{"title": "Accounts in Asset Hub Smart Contracts", "slug": "polkadot-protocol-smart-contract-basics-accounts", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-smart-contract-basics-accounts.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/smart-contract-basics/accounts/", "categories": ["Basics", "Polkadot Protocol"], "description": "Bridges Ethereum's 20-byte addresses with Polkadot's 32-byte accounts, enabling seamless interaction while maintaining compatibility with Ethereum tooling.", "estimated_token_count": 1862, "token_estimator": "heuristic-v1", "content": "# Accounts on Asset Hub Smart Contracts\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nAsset Hub natively utilizes Polkadot's 32-byte account system while providing interoperability with Ethereum's 20-byte addresses through an automatic conversion system. When interacting with smart contracts:\n\n- Ethereum-compatible wallets (like MetaMask) can use their familiar 20-byte addresses.\n- Polkadot accounts continue using their native 32-byte format.\n- The Asset Hub chain automatically handles conversion between the two formats behind the scenes:\n\n    - 20-byte Ethereum addresses are padded with `0xEE` bytes to create valid 32-byte Polkadot accounts.\n    - 32-byte Polkadot accounts can optionally register a mapping to a 20-byte address for Ethereum compatibility.\n\nThis dual-format approach enables Asset Hub to maintain compatibility with Ethereum tooling while fully integrating with the Polkadot ecosystem.\n\n## Address Types and Mappings\n\nThe platform handles two distinct address formats:\n\n- [Ethereum-style addresses (20 bytes)](https://ethereum.org/en/developers/docs/accounts/#account-creation){target=\\_blank}\n- [Polkadot native account IDs (32 bytes)](/polkadot-protocol/parachain-basics/accounts/){target=\\_blank}\n\n### Ethereum to Polkadot Mapping\n\nThe [`AccountId32Mapper`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/struct.AccountId32Mapper.html){target=\\_blank} implementation in [`pallet_revive`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/index.html){target=\\_blank} handles the core address conversion logic. For converting a 20-byte Ethereum address to a 32-byte Polkadot address, the pallet uses a simple concatenation approach:\n\n- [**Core mechanism**](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_fallback_account_id){target=\\_blank}: Takes a 20-byte Ethereum address and extends it to 32 bytes by adding twelve `0xEE` bytes at the end. The key benefits of this approach are:\n    - Able to fully revert, allowing a smooth transition back to the Ethereum format.\n    - Provides clear identification of Ethereum-controlled accounts through the `0xEE` suffix pattern.\n    - Maintains cryptographic security with a `2^96` difficulty for pattern reproduction.\n\n### Polkadot to Ethereum Mapping\n\nThe conversion from 32-byte Polkadot accounts to 20-byte Ethereum addresses is more complex than the reverse direction due to the lossy nature of the conversion. The [`AccountId32Mapper`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/struct.AccountId32Mapper.html){target=\\_blank} handles this through two distinct approaches:\n\n- **For Ethereum-derived accounts**: The system uses the [`is_eth_derived`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/fn.is_eth_derived.html){target=\\_blank} function to detect accounts that were originally Ethereum addresses (identified by the `0xEE` suffix pattern). For these accounts, the conversion strips the last 12 bytes to recover the original 20-byte Ethereum address.\n\n- **For native Polkadot accounts**: Since these accounts utilize the whole 32-byte space and weren't derived from Ethereum addresses, direct truncation would result in lost information. Instead, the system:\n\n    1. Hashes the entire 32-byte account using Keccak-256.\n    2. Takes the last 20 bytes of the hash to create the Ethereum address.\n    3. This ensures a deterministic mapping while avoiding simple truncation.\n\nThe conversion process is implemented through the [`to_address`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_address){target=\\_blank} function, which automatically detects the account type and applies the appropriate conversion method.\n\n**Stateful Mapping for Reversibility** : Since the conversion from 32-byte to 20-byte addresses is inherently lossy, the system provides an optional stateful mapping through the [`OriginalAccount`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/storage_types/struct.OriginalAccount.html){target=\\_blank} storage. When a Polkadot account registers a mapping (via the [`map`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.map){target=\\_blank} function), the system stores the original 32-byte account ID, enabling the [`to_account_id`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_account_id){target=\\_blank} function to recover the exact original account rather than falling back to a default conversion.\n\n\n### Account Mapping for Native Polkadot Accounts\n\nIf you have a native Polkadot account (32-byte format) that was created with a Polkadot/Substrate keypair (Ed25519/Sr25519) rather than an Ethereum-compatible keypair (secp256k1), you'll need to map your account to enable Ethereum compatibility.\n\nTo map your account, call the [`map_account`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/dispatchables/fn.map_account.html){target=\\_blank} extrinsic of the [`pallet_revive`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/index.html){target=\\_blank} pallet using your original Substrate account. This creates a stateful mapping that allows your 32-byte account to interact with the Ethereum-compatible smart contract system.\n\nOnce mapped, you'll be able to:\n\n- Transfer funds between 20-byte format addresses.\n- Interact with smart contracts using Ethereum-compatible tools like MetaMask.\n- Maintain full reversibility to your original 32-byte account format.\n\n!!! warning \"Mapping Requirement\"\n    Without this mapping, native Polkadot accounts cannot transfer funds or interact with the Ethereum-compatible layer on the Hub.\n\n## Account Registration\n\nThe registration process is implemented through the [`map`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.map){target=\\_blank} function. This process involves:\n\n- Checking if the account is already mapped.\n- Calculating and collecting required deposits based on data size.\n- Storing the address suffix for future reference.\n- Managing the currency holds for security.\n\n## Fallback Accounts\n\nThe fallback mechanism is integrated into the [`to_account_id`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_account_id){target=\\_blank} function. It provides a safety net for address conversion by:\n\n- First, attempting to retrieve stored mapping data.\n- Falling back to the default conversion method if no mapping exists.\n- Maintaining consistency in address representation.\n\n## Contract Address Generation\n\nThe system supports two methods for generating contract addresses:\n\n- [CREATE1 method](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/fn.create1.html){target=\\_blank}:\n\n    - Uses the deployer address and nonce.\n    - Generates deterministic addresses for standard contract deployment.\n\n- [CREATE2 method](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/fn.create2.html){target=\\_blank}:\n\n    - Uses the deployer address, initialization code, input data, and salt.\n    - Enables predictable address generation for advanced use cases.\n\n## Security Considerations\n\nThe address mapping system maintains security through several design choices evident in the implementation:\n\n- The stateless mapping requires no privileged operations, as shown in the [`to_fallback_account_id`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_fallback_account_id){target=\\_blank} implementation.\n- The stateful mapping requires a deposit managed through the [`Currency`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/trait.Config.html#associatedtype.Currency){target=\\_blank} trait.\n- Mapping operations are protected against common errors through explicit checks.\n- The system prevents double-mapping through the [`ensure!(!Self::is_mapped(account_id))`](https://github.com/paritytech/polkadot-sdk/blob/stable2412/substrate/frame/revive/src/address.rs#L125){target=\\_blank} check.\n\nAll source code references are from the [`address.rs`](https://github.com/paritytech/polkadot-sdk/blob/stable2412/substrate/frame/revive/src/address.rs){target=\\_blank} file in the Revive pallet of the Polkadot SDK repository.\n"}
{"title": "Add Pallets to the Runtime", "slug": "tutorials-polkadot-sdk-parachains-zero-to-hero-add-pallets-to-runtime", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-polkadot-sdk-parachains-zero-to-hero-add-pallets-to-runtime.md", "html_url": "https://docs.polkadot.com/tutorials/polkadot-sdk/parachains/zero-to-hero/add-pallets-to-runtime/", "categories": ["Basics", "Parachains"], "description": "Add pallets to your runtime for custom functionality. Learn to configure and integrate pallets in Polkadot SDK-based blockchains.", "estimated_token_count": 3121, "token_estimator": "heuristic-v1", "content": "# Add Pallets to the Runtime\n\n## Introduction\n\nIn previous tutorials, you learned how to [create a custom pallet](/tutorials/polkadot-sdk/parachains/zero-to-hero/build-custom-pallet/){target=\\_blank} and [test it](/tutorials/polkadot-sdk/parachains/zero-to-hero/pallet-unit-testing/){target=\\_blank}. The next step is to include this pallet in your runtime, integrating it into the core logic of your blockchain.\n\nThis tutorial will guide you through adding two pallets to your runtime: the custom pallet you previously developed and the [utility pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_utility/index.html){target=\\_blank}. This standard Polkadot SDK pallet provides powerful dispatch functionality. The utility pallet offers, for example, batch dispatch, a stateless operation that enables executing multiple calls in a single transaction.\n\n## Add the Pallets as Dependencies\n\nFirst, you'll update the runtime's `Cargo.toml` file to include the Utility pallet and your custom pallets as dependencies for the runtime. Follow these steps:\n\n1. Open the `runtime/Cargo.toml` file and locate the `[dependencies]` section. Add pallet-utility as one of the features for the `polkadot-sdk` dependency with the following line:\n\n    ```toml hl_lines=\"4\" title=\"runtime/Cargo.toml\"\n    -[dependencies]\n    ...\n    -polkadot-sdk = { workspace = true, features = [\n  \"pallet-utility\",\n        ...\n    -], default-features = false }\n    ```\n\n2. In the same `[dependencies]` section, add the custom pallet that you built from scratch with the following line:\n\n    ```toml hl_lines=\"3\" title=\"Cargo.toml\"\n    -[dependencies]\n    ...\n    -custom-pallet = { path = \"../pallets/custom-pallet\", default-features = false }\n    ```\n\n3. In the `[features]` section, add the custom pallet to the `std` feature list:\n\n    ```toml hl_lines=\"5\" title=\"Cargo.toml\"\n    -[features]\ndefault = [\"std\"]\nstd = [\n      ...\n      -\"custom-pallet/std\",\n      ...\n    ]\n    ```\n\n3. Save the changes and close the `Cargo.toml` file.\n\n    Once you have saved your file, it should look like the following:\n\n    ???- code \"runtime/Cargo.toml\"\n        \n        ```rust title=\"runtime/Cargo.toml\"\n        -[package]\nname = \"parachain-template-runtime\"\ndescription = \"A parachain runtime template built with Substrate and Cumulus, part of Polkadot Sdk.\"\nversion = \"0.1.0\"\nlicense = \"Unlicense\"\nauthors.workspace = true\nhomepage.workspace = true\nrepository.workspace = true\nedition.workspace = true\npublish = false\n\n[package.metadata.docs.rs]\ntargets = [\"x86_64-unknown-linux-gnu\"]\n\n[build-dependencies]\ndocify = { workspace = true }\nsubstrate-wasm-builder = { optional = true, workspace = true, default-features = true }\n\n[dependencies]\ncodec = { features = [\"derive\"], workspace = true }\ncumulus-pallet-parachain-system.workspace = true\ndocify = { workspace = true }\nhex-literal = { optional = true, workspace = true, default-features = true }\nlog = { workspace = true }\npallet-parachain-template = { path = \"../pallets/template\", default-features = false }\npolkadot-sdk = { workspace = true, features = [\n  \"pallet-utility\",\n  \"cumulus-pallet-aura-ext\",\n  \"cumulus-pallet-session-benchmarking\",\n  \"cumulus-pallet-weight-reclaim\",\n  \"cumulus-pallet-xcm\",\n  \"cumulus-pallet-xcmp-queue\",\n  \"cumulus-primitives-aura\",\n  \"cumulus-primitives-core\",\n  \"cumulus-primitives-utility\",\n  \"pallet-aura\",\n  \"pallet-authorship\",\n  \"pallet-balances\",\n  \"pallet-collator-selection\",\n  \"pallet-message-queue\",\n  \"pallet-session\",\n  \"pallet-sudo\",\n  \"pallet-timestamp\",\n  \"pallet-transaction-payment\",\n  \"pallet-transaction-payment-rpc-runtime-api\",\n  \"pallet-xcm\",\n  \"parachains-common\",\n  \"polkadot-parachain-primitives\",\n  \"polkadot-runtime-common\",\n  \"runtime\",\n  \"staging-parachain-info\",\n  \"staging-xcm\",\n  \"staging-xcm-builder\",\n  \"staging-xcm-executor\",\n], default-features = false }\nscale-info = { features = [\"derive\"], workspace = true }\nserde_json = { workspace = true, default-features = false, features = [\n  \"alloc\",\n] }\nsmallvec = { workspace = true, default-features = true }\n\ncustom-pallet = { path = \"../pallets/custom-pallet\", default-features = false }\n\n[features]\ndefault = [\"std\"]\nstd = [\n  \"codec/std\",\n  \"cumulus-pallet-parachain-system/std\",\n  \"log/std\",\n  \"pallet-parachain-template/std\",\n  \"polkadot-sdk/std\",\n  \"scale-info/std\",\n  \"serde_json/std\",\n  \"substrate-wasm-builder\",\n  \"custom-pallet/std\",\n]\n\nruntime-benchmarks = [\n  \"cumulus-pallet-parachain-system/runtime-benchmarks\",\n  \"hex-literal\",\n  \"pallet-parachain-template/runtime-benchmarks\",\n  \"polkadot-sdk/runtime-benchmarks\",\n]\n\ntry-runtime = [\n  \"cumulus-pallet-parachain-system/try-runtime\",\n  \"pallet-parachain-template/try-runtime\",\n  \"polkadot-sdk/try-runtime\",\n]\n\n# Enable the metadata hash generation.\n#\n# This is hidden behind a feature because it increases the compile time.\n# The wasm binary needs to be compiled twice, once to fetch the metadata,\n# generate the metadata hash and then a second time with the\n# `RUNTIME_METADATA_HASH` environment variable set for the `CheckMetadataHash`\n# extension.\nmetadata-hash = [\"substrate-wasm-builder/metadata-hash\"]\n\n# A convenience feature for enabling things when doing a build\n# for an on-chain release.\non-chain-release-build = [\"metadata-hash\"]\n\n        ```\n\nUpdate your root parachain template's `Cargo.toml` file to include your custom pallet as a dependency. Follow these steps:\n\n1. Open the `./Cargo.toml` file and locate the `[workspace]` section. \n    \n    Make sure the `custom-pallet` is a member of the workspace:\n\n    ```toml hl_lines=\"4\" title=\"Cargo.toml\"\n     -[workspace]\ndefault-members = [\"pallets/template\", \"runtime\"]\nmembers = [\n    \"node\", \"pallets/custom-pallet\",\n    \"pallets/template\",\n    \"runtime\",\n]\n    ```\n\n???- code \"./Cargo.toml\"\n\n    ```rust title=\"./Cargo.toml\"\n    -[workspace.package]\nlicense = \"MIT-0\"\nauthors = [\"Parity Technologies <admin@parity.io>\"]\nhomepage = \"https://paritytech.github.io/polkadot-sdk/\"\nrepository = \"https://github.com/paritytech/polkadot-sdk-parachain-template.git\"\nedition = \"2021\"\n\n[workspace]\ndefault-members = [\"pallets/template\", \"runtime\"]\nmembers = [\n    \"node\", \"pallets/custom-pallet\",\n    \"pallets/template\",\n    \"runtime\",\n]\nresolver = \"2\"\n\n[workspace.dependencies]\nparachain-template-runtime = { path = \"./runtime\", default-features = false }\npallet-parachain-template = { path = \"./pallets/template\", default-features = false }\nclap = { version = \"4.5.13\" }\ncolor-print = { version = \"0.3.4\" }\ndocify = { version = \"0.2.9\" }\nfutures = { version = \"0.3.31\" }\njsonrpsee = { version = \"0.24.3\" }\nlog = { version = \"0.4.22\", default-features = false }\npolkadot-sdk = { version = \"2503.0.1\", default-features = false }\nprometheus-endpoint = { version = \"0.17.2\", default-features = false, package = \"substrate-prometheus-endpoint\" }\nserde = { version = \"1.0.214\", default-features = false }\ncodec = { version = \"3.7.4\", default-features = false, package = \"parity-scale-codec\" }\ncumulus-pallet-parachain-system = { version = \"0.20.0\", default-features = false }\nhex-literal = { version = \"0.4.1\", default-features = false }\nscale-info = { version = \"2.11.6\", default-features = false }\nserde_json = { version = \"1.0.132\", default-features = false }\nsmallvec = { version = \"1.11.0\", default-features = false }\nsubstrate-wasm-builder = { version = \"26.0.1\", default-features = false }\nframe = { version = \"0.9.1\", default-features = false, package = \"polkadot-sdk-frame\" }\n\n[profile.release]\nopt-level = 3\npanic = \"unwind\"\n\n[profile.production]\ncodegen-units = 1\ninherits = \"release\"\nlto = true\n    ```\n\n\n### Update the Runtime Configuration\n\nConfigure the pallets by implementing their `Config` trait and update the runtime macro to include the new pallets:\n\n1. Add the `OriginCaller` import:\n\n    ```rust title=\"mod.rs\" hl_lines=\"8\"\n    -// Local module imports\nuse super::OriginCaller;\n    ...\n    ```\n\n2. Implement the [`Config`](https://paritytech.github.io/polkadot-sdk/master/pallet_utility/pallet/trait.Config.html){target=\\_blank} trait for both pallets at the end of the `runtime/src/config/mod.rs` file:\n\n    ```rust title=\"mod.rs\" hl_lines=\"8-25\"\n    ...\n    -/// Configure the pallet template in pallets/template.\nimpl pallet_parachain_template::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type WeightInfo = pallet_parachain_template::weights::SubstrateWeight<Runtime>;\n}\n\n// Configure utility pallet.\nimpl pallet_utility::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type RuntimeCall = RuntimeCall;\n    type PalletsOrigin = OriginCaller;\n    type WeightInfo = pallet_utility::weights::SubstrateWeight<Runtime>;\n}\n    -// Define counter max value runtime constant.\nparameter_types! {\n    pub const CounterMaxValue: u32 = 500;\n}\n\n// Configure custom pallet.\nimpl custom_pallet::Config for Runtime {\n    type RuntimeEvent = RuntimeEvent;\n    type CounterMaxValue = CounterMaxValue;\n    }\n    ```\n\n3. Locate the `#[frame_support::runtime]` macro in the `runtime/src/lib.rs` file and add the pallets:\n\n    ```rust hl_lines=\"9-14\" title=\"lib.rs\"\n    -#[frame_support::runtime]\nmod runtime {\n    #[runtime::runtime]\n    #[runtime::derive(\n            ...\n        -    )]\n    pub struct Runtime;\n\n    -    #[runtime::pallet_index(51)]\n    pub type Utility = pallet_utility;\n\n    #[runtime::pallet_index(52)]\n    pub type CustomPallet = custom_pallet;\n    }\n    ```\n\n## Recompile the Runtime\n\nAfter adding and configuring your pallets in the runtime, the next step is to ensure everything is set up correctly. To do this, recompile the runtime with the following command (make sure you're in the project's root directory):\n\n```bash\ncargo build --release\n```\n\nThis command ensures the runtime compiles without errors, validates the pallet configurations, and prepares the build for subsequent testing or deployment.\n\n## Run Your Chain Locally\n\nLaunch your parachain locally and start producing blocks:\n\n!!!tip\n    Generated chain TestNet specifications include development accounts \"Alice\" and \"Bob.\" These accounts are pre-funded with native parachain currency, allowing you to sign and send TestNet transactions. Take a look at the [Polkadot.js Accounts section](https://polkadot.js.org/apps/#/accounts){target=\\_blank} to view the development accounts for your chain.\n\n1. Create a new chain specification file with the updated runtime:\n\n    ```bash\n    chain-spec-builder create -t development \\\n    --relay-chain paseo \\\n    --para-id 1000 \\\n    --runtime ./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm \\\n    named-preset development\n    ```\n\n2. Start the omni node with the generated chain specification:\n\n    ```bash\n    polkadot-omni-node --chain ./chain_spec.json --dev\n    ```\n\n3. Verify you can interact with the new pallets using the [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/extrinsics){target=\\_blank} interface. Navigate to the **Extrinsics** tab and check that you can see both pallets:\n\n    - Utility pallet\n\n        ![](/images/tutorials/polkadot-sdk/parachains/zero-to-hero/add-pallets-to-runtime/add-pallets-to-runtime-1.webp)\n    \n\n    - Custom pallet\n\n        ![](/images/tutorials/polkadot-sdk/parachains/zero-to-hero/add-pallets-to-runtime/add-pallets-to-runtime-2.webp)\n\n## Where to Go Next\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Deploy on Paseo TestNet__\n\n    ---\n\n    Deploy your Polkadot SDK blockchain on Paseo! Follow this step-by-step guide for a seamless journey to a successful TestNet deployment.\n\n    [:octicons-arrow-right-24: Get Started](/tutorials/polkadot-sdk/parachains/zero-to-hero/deploy-to-testnet/)\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Pallet Benchmarking (Optional)__\n\n    ---\n\n    Discover how to measure extrinsic costs and assign precise weights to optimize your pallet for accurate fees and runtime performance.\n\n    [:octicons-arrow-right-24: Get Started](/tutorials/polkadot-sdk/parachains/zero-to-hero/pallet-benchmarking/)\n\n</div>\n"}
{"title": "Asset Transfer API", "slug": "develop-toolkit-interoperability-asset-transfer-api-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-toolkit-interoperability-asset-transfer-api-overview.md", "html_url": "https://docs.polkadot.com/develop/toolkit/interoperability/asset-transfer-api/overview/", "categories": ["Basics", "Tooling", "Dapps"], "description": "Asset Transfer API is a library that simplifies the transfer of assets for Polkadot SDK-based chains. It provides methods for cross-chain and local transfers.", "estimated_token_count": 4322, "token_estimator": "heuristic-v1", "content": "# Asset Transfer API\n\n## Introduction\n\n[Asset Transfer API](https://github.com/paritytech/asset-transfer-api){target=\\_blank}, a tool developed and maintained by [Parity](https://www.parity.io/){target=\\_blank}, is a specialized library designed to streamline asset transfers for Polkadot SDK-based blockchains. This API provides a simplified set of methods for users to:\n\n- Execute asset transfers to other parachains or locally within the same chain.\n- Facilitate transactions involving system parachains like Asset Hub (Polkadot and Kusama).\n\nUsing this API, developers can manage asset transfers more efficiently, reducing the complexity of cross-chain transactions and enabling smoother operations within the ecosystem.\n\nFor additional support and information, please reach out through [GitHub Issues](https://github.com/paritytech/asset-transfer-api/issues){target=\\_blank}.\n\n## Prerequisites\n\nBefore you begin, ensure you have the following installed:\n\n- [Node.js](https://nodejs.org/en/){target=\\_blank} (recommended version 21 or greater).\n- A package manager like [npm](https://www.npmjs.com/){target=\\_blank} should be installed with Node.js by default. Alternatively, you can use other package managers like [Yarn](https://yarnpkg.com/){target=\\_blank}.\n\nThis documentation covers version `1.0.0` of Asset Transfer API. \n\n## Install Asset Transfer API\n\nTo use `asset-transfer-api`, you need a TypeScript project. If you don't have one, you can create a new one:\n\n1. Create a new directory for your project:\n\n    ```bash\n    mkdir my-asset-transfer-project \\\n    && cd my-asset-transfer-project\n    ```\n\n2. Initialize a new TypeScript project:\n\n    ```bash\n    npm init -y \\\n    && npm install typescript ts-node @types/node --save-dev \\\n    && npx tsc --init\n    ```\n\nOnce you have a project set up, you can install the `asset-transfer-api` package. Run the following command to install the package:\n\n```bash\nnpm install @substrate/asset-transfer-api@1.0.0\n```\n\n## Set Up Asset Transfer API\n\nTo initialize the Asset Transfer API, you need three key components:\n\n- A Polkadot.js API instance\n- The `specName` of the chain\n- The XCM version to use\n\n### Using Helper Function from Library\n\nLeverage the `constructApiPromise` helper function provided by the library for the simplest setup process. It not only constructs a Polkadot.js `ApiPromise` but also automatically retrieves the chain's `specName` and fetches a safe XCM version. By using this function, developers can significantly reduce boilerplate code and potential configuration errors, making the initial setup both quicker and more robust.\n\n```ts\n-import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'INSERT_WEBSOCKET_URL',\n  );\n\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  // Your code using assetsApi goes here\n}\n\nmain();\n\n```\n\n!!!warning\n    The code example is enclosed in an async main function to provide the necessary asynchronous context. However, you can use the code directly if you're already working within an async environment. The key is to ensure you're in an async context when working with these asynchronous operations, regardless of your specific setup.\n\n## Asset Transfer API Reference\n\nFor detailed information on the Asset Transfer API, including available methods, data types, and functionalities, refer to the [Asset Transfer API Reference](/develop/toolkit/interoperability/asset-transfer-api/reference){target=\\_blank} section. This resource provides in-depth explanations and technical specifications to help you integrate and utilize the API effectively.\n\n## Examples\n\n### Relay to System Parachain Transfer\n\nThis example demonstrates how to initiate a cross-chain token transfer from a relay chain to a system parachain. Specifically, 1 WND will be transferred from a Westend (relay chain) account to a Westmint (system parachain) account.\n\n```ts\n-import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://westend-rpc.polkadot.io',\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      '1000',\n      '5EWNeodpcQ6iYibJ3jmWVe85nsok1EDG8Kk3aFg8ZzpfY1qX',\n      ['WND'],\n      ['1000000000000'],\n      {\n        format: 'call',\n        xcmVersion: safeXcmVersion,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, 'call');\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n```\n\nAfter running the script, you'll see the following output in the terminal, which shows the call data for the cross-chain transfer and its decoded extrinsic details:\n\n-<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\"><span class=\"file-path\"></span>ts-node relayToSystem.ts</span>\n    <br>\n\t<span data-ty>Call data:</span>\n\t<span data-ty>{</span>\n\t<span data-ty>    \"origin\": \"westend\",</span>\n\t<span data-ty>    \"dest\": \"westmint\",</span>\n\t<span data-ty>    \"direction\": \"RelayToSystem\",</span>\n\t<span data-ty>    \"xcmVersion\": 3,</span>\n\t<span data-ty>    \"method\": \"transferAssets\",</span>\n\t<span data-ty>    \"format\": \"call\",</span>\n\t<span data-ty>    \"tx\": \"0x630b03000100a10f03000101006c0c32faf970eacb2d4d8e538ac0dab3642492561a1be6f241c645876c056c1d030400000000070010a5d4e80000000000\"</span>\n\t<span data-ty>}</span>\n\t<span data-ty></span>\n\t<span data-ty>Decoded tx:</span>\n\t<span data-ty>{</span>\n\t<span data-ty>    \"args\": {</span>\n\t<span data-ty>        \"dest\": {</span>\n\t<span data-ty>            \"V3\": {</span>\n\t<span data-ty>                \"parents\": \"0\",</span>\n\t<span data-ty>                \"interior\": {</span>\n\t<span data-ty>                    \"X1\": {</span>\n\t<span data-ty>                        \"Parachain\": \"1,000\"</span>\n\t<span data-ty>                    }</span>\n\t<span data-ty>                }</span>\n\t<span data-ty>            }</span>\n\t<span data-ty>        },</span>\n\t<span data-ty>        \"beneficiary\": {</span>\n\t<span data-ty>            \"V3\": {</span>\n\t<span data-ty>                \"parents\": \"0\",</span>\n\t<span data-ty>                \"interior\": {</span>\n\t<span data-ty>                    \"X1\": {</span>\n\t<span data-ty>                        \"AccountId32\": {</span>\n\t<span data-ty>                            \"network\": null,</span>\n\t<span data-ty>                            \"id\": \"0x6c0c32faf970eacb2d4d8e538ac0dab3642492561a1be6f241c645876c056c1d\"</span>\n\t<span data-ty>                        }</span>\n\t<span data-ty>                    }</span>\n\t<span data-ty>                }</span>\n\t<span data-ty>            }</span>\n\t<span data-ty>        },</span>\n\t<span data-ty>        \"assets\": {</span>\n\t<span data-ty>            \"V3\": [</span>\n\t<span data-ty>                {</span>\n\t<span data-ty>                    \"id\": {</span>\n\t<span data-ty>                        \"Concrete\": {</span>\n\t<span data-ty>                            \"parents\": \"0\",</span>\n\t<span data-ty>                            \"interior\": \"Here\"</span>\n\t<span data-ty>                        }</span>\n\t<span data-ty>                    },</span>\n\t<span data-ty>                    \"fun\": {</span>\n\t<span data-ty>                        \"Fungible\": \"1,000,000,000,000\"</span>\n\t<span data-ty>                    }</span>\n\t<span data-ty>                }</span>\n\t<span data-ty>            ]</span>\n\t<span data-ty>        },</span>\n\t<span data-ty>        \"fee_asset_item\": \"0\",</span>\n\t<span data-ty>        \"weight_limit\": \"Unlimited\"</span>\n\t<span data-ty>    },</span>\n\t<span data-ty>    \"method\": \"transferAssets\",</span>\n\t<span data-ty>    \"section\": \"xcmPallet\"</span>\n\t<span data-ty>}</span>\n</div>\n\n### Local Parachain Transfer\n\nThe following example demonstrates a local GLMR transfer within Moonbeam, using the `balances` pallet. It transfers 1 GLMR token from one account to another account, where both the sender and recipient accounts are located on the same parachain.\n\n```ts\n-import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      '2004',\n      '0xF977814e90dA44bFA03b6295A0616a897441aceC',\n      [],\n      ['1000000000000000000'],\n      {\n        format: 'call',\n        keepAlive: true,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, 'call');\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n```\n\nUpon executing this script, the terminal will display the following output, illustrating the encoded extrinsic for the cross-chain message and its corresponding decoded format:\n\n-<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\"><span class=\"file-path\"></span>ts-node localParachainTx.ts</span>\n    <br>\n\t<span data-ty>Call data:</span>\n\t<span data-ty>{</span>\n\t<span data-ty>    \"origin\": \"moonbeam\",</span>\n\t<span data-ty>    \"dest\": \"moonbeam\",</span>\n\t<span data-ty>    \"direction\": \"local\",</span>\n\t<span data-ty>    \"xcmVersion\": null,</span>\n\t<span data-ty>    \"method\": \"balances::transferKeepAlive\",</span>\n\t<span data-ty>    \"format\": \"call\",</span>\n\t<span data-ty>    \"tx\": \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\"</span>\n\t<span data-ty>}</span>\n\t<span data-ty></span>\n\t<span data-ty>Decoded tx:</span>\n\t<span data-ty>{</span>\n\t<span data-ty>    \"args\": {</span>\n\t<span data-ty>        \"dest\": \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",</span>\n\t<span data-ty>        \"value\": \"1,000,000,000,000,000,000\"</span>\n\t<span data-ty>    },</span>\n\t<span data-ty>    \"method\": \"transferKeepAlive\",</span>\n\t<span data-ty>    \"section\": \"balances\"</span>\n\t<span data-ty>}</span>\n</div>\n\n### Parachain to Parachain Transfer\n\nThis example demonstrates creating a cross-chain asset transfer between two parachains. It shows how to send vMOVR and vBNC from a Moonriver account to a Bifrost Kusama account using the safe XCM version. It connects to Moonriver, initializes the API, and uses the `createTransferTransaction` method to prepare a transaction.\n\n```ts\n-import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://moonriver.public.blastapi.io',\n  );\n  const assetApi = new AssetTransferApi(api, specName, safeXcmVersion);\n  let callInfo;\n  try {\n    callInfo = await assetApi.createTransferTransaction(\n      '2001',\n      '0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063',\n      ['vMOVR', '72145018963825376852137222787619937732'],\n      ['1000000', '10000000000'],\n      {\n        format: 'call',\n        xcmVersion: safeXcmVersion,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n\n  const decoded = assetApi.decodeExtrinsic(callInfo.tx, 'call');\n  console.log(`\\nDecoded tx:\\n${JSON.stringify(JSON.parse(decoded), null, 4)}`);\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n```\n\nAfter running this script, you'll see the following output in your terminal. This output presents the encoded extrinsic for the cross-chain message, along with its decoded format, providing a clear view of the transaction details.\n\n-<div id='termynal' data-termynal>\n    <span data-ty='input'><span class='file-path'></span>ts-node paraToPara.ts</span>\n\n    <br>\n    <span data-ty>Call data:</span>\n    <span data-ty>{</span>\n    <span data-ty>    \"origin\": \"moonriver\",</span>\n    <span data-ty>    \"dest\": \"bifrost\",</span>\n    <span data-ty>    \"direction\": \"ParaToPara\",</span>\n    <span data-ty>    \"xcmVersion\": 2,</span>\n    <span data-ty>    \"method\": \"transferMultiassets\",</span>\n    <span data-ty>    \"format\": \"call\",</span>\n    <span data-ty>    \"tx\": \"0x6a05010800010200451f06080101000700e40b540200010200451f0608010a0002093d000000000001010200451f0100c4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a06300\"</span>\n    <span data-ty>}</span>\n    <span data-ty></span>\n    <span data-ty>Decoded tx:</span>\n    <span data-ty>{</span>\n    <span data-ty>    \"args\": {</span>\n    <span data-ty>        \"assets\": {</span>\n    <span data-ty>            \"V2\": [</span>\n    <span data-ty>                {</span>\n    <span data-ty>                    \"id\": {</span>\n    <span data-ty>                        \"Concrete\": {</span>\n    <span data-ty>                            \"parents\": \"1\",</span>\n    <span data-ty>                            \"interior\": {</span>\n    <span data-ty>                                \"X2\": [</span>\n    <span data-ty>                                    {</span>\n    <span data-ty>                                        \"Parachain\": \"2,001\"</span>\n    <span data-ty>                                    },</span>\n    <span data-ty>                                    {</span>\n    <span data-ty>                                        \"GeneralKey\": \"0x0101\"</span>\n    <span data-ty>                                    }</span>\n    <span data-ty>                                ]</span>\n    <span data-ty>                            }</span>\n    <span data-ty>                        }</span>\n    <span data-ty>                    },</span>\n    <span data-ty>                    \"fun\": {</span>\n    <span data-ty>                        \"Fungible\": \"10,000,000,000\"</span>\n    <span data-ty>                    }</span>\n    <span data-ty>                },</span>\n    <span data-ty>                {</span>\n    <span data-ty>                    \"id\": {</span>\n    <span data-ty>                        \"Concrete\": {</span>\n    <span data-ty>                            \"parents\": \"1\",</span>\n    <span data-ty>                            \"interior\": {</span>\n    <span data-ty>                                \"X2\": [</span>\n    <span data-ty>                                    {</span>\n    <span data-ty>                                        \"Parachain\": \"2,001\"</span>\n    <span data-ty>                                    },</span>\n    <span data-ty>                                    {</span>\n    <span data-ty>                                        \"GeneralKey\": \"0x010a\"</span>\n    <span data-ty>                                    }</span>\n    <span data-ty>                                ]</span>\n    <span data-ty>                            }</span>\n    <span data-ty>                        }</span>\n    <span data-ty>                    },</span>\n    <span data-ty>                    \"fun\": {</span>\n    <span data-ty>                        \"Fungible\": \"1,000,000\"</span>\n    <span data-ty>                    }</span>\n    <span data-ty>                }</span>\n    <span data-ty>            ]</span>\n    <span data-ty>        },</span>\n    <span data-ty>        \"fee_item\": \"0\",</span>\n    <span data-ty>        \"dest\": {</span>\n    <span data-ty>            \"V2\": {</span>\n    <span data-ty>                \"parents\": \"1\",</span>\n    <span data-ty>                \"interior\": {</span>\n    <span data-ty>                    \"X2\": [</span>\n    <span data-ty>                        {</span>\n    <span data-ty>                            \"Parachain\": \"2,001\"</span>\n    <span data-ty>                        },</span>\n    <span data-ty>                        {</span>\n    <span data-ty>                            \"AccountId32\": {</span>\n    <span data-ty>                                \"network\": \"Any\",</span>\n    <span data-ty>                                \"id\": \"0xc4db7bcb733e117c0b34ac96354b10d47e84a006b9e7e66a229d174e8ff2a063\"</span>\n    <span data-ty>                            }</span>\n    <span data-ty>                        }</span>\n    <span data-ty>                    ]</span>\n    <span data-ty>                }</span>\n    <span data-ty>            }</span>\n    <span data-ty>        },</span>\n    <span data-ty>        \"dest_weight_limit\": \"Unlimited\"</span>\n    <span data-ty>    },</span>\n    <span data-ty>    \"method\": \"transferMultiassets\",</span>\n    <span data-ty>    \"section\": \"xTokens\"</span>\n    <span data-ty>}</span>\n</div>\n"}
{"title": "Asset Transfer API Reference", "slug": "develop-toolkit-interoperability-asset-transfer-api-reference", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-toolkit-interoperability-asset-transfer-api-reference.md", "html_url": "https://docs.polkadot.com/develop/toolkit/interoperability/asset-transfer-api/reference/", "categories": ["Reference", "Dapps"], "description": "Explore the Asset Transfer API Reference for comprehensive details on methods, data types, and functionalities. Essential for cross-chain asset transfers.", "estimated_token_count": 6558, "token_estimator": "heuristic-v1", "content": "# Asset Transfer API Reference\n\n<br>\n<div class=\"grid cards\" markdown>\n-   :octicons-download-16:{ .lg .middle } __Install the Asset Transfer API__\n\n    ---\n\n    Learn how to install [`asset-transfer-api`](https://github.com/paritytech/asset-transfer-api){target=\\_blank} into a new or existing project.\n\n    <br>\n    [:octicons-arrow-right-24: Get started](/develop/toolkit/interoperability/asset-transfer-api/overview/#install-asset-transfer-api){target=\\_blank}\n\n-   :octicons-code-16:{ .lg .middle } __Dive in with a tutorial__\n\n    ---\n\n    Ready to start coding? Follow along with a step-by-step tutorial.\n\n    <br>\n    [:octicons-arrow-right-24: How to use the Asset Transfer API](/develop/toolkit/interoperability/asset-transfer-api/overview/#examples)\n</div>\n<br>\n\n\n## Asset Transfer API Class\n\nHolds open an API connection to a specified chain within the `ApiPromise` to help construct transactions for assets and estimate fees.\n\nFor a more in-depth explanation of the Asset Transfer API class structure, check the [source code](https://github.com/paritytech/asset-transfer-api/blob/v1.0.0/src/AssetTransferApi.ts#L128){target=\\_blank}.\n\n### Methods\n\n#### Create Transfer Transaction\n\nGenerates an XCM transaction for transferring assets between chains. It simplifies the process by inferring what type of transaction is required given the inputs, ensuring that the assets are valid, and that the transaction details are correctly formatted.\n\nAfter obtaining the transaction, you must handle the signing and submission process separately.\n\n```ts\n-public async createTransferTransaction<T extends Format>(\n\t\tdestChainId: string,\n\t\tdestAddr: string,\n\t\tassetIds: string[],\n\t\tamounts: string[],\n\t\topts: TransferArgsOpts<T> = {},\n\t): Promise<TxResult<T>> {\n```\n\n??? interface \"Request parameters\"\n\n    `destChainId` ++\"string\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    ID of the destination chain (`'0'` for relay chain, other values for parachains).\n\n    ---\n\n    `destAddr` ++\"string\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Address of the recipient account on the destination chain.\n\n    ---\n\n    `assetIds` ++\"string[]\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Array of asset IDs to be transferred.\n\n    When asset IDs are provided, the API dynamically selects the appropriate pallet for the current chain to handle these specific assets. If the array is empty, the API defaults to using the `balances` pallet.\n\n    ---\n\n    `amounts` ++\"string[]\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Array of amounts corresponding to each asset in `assetIds`.\n\n    ---\n\n    `opts` ++\"TransferArgsOpts<T>\"++\n\n    -Options for customizing the claim assets transaction. These options allow you to specify the transaction format, fee payment details, weight limits, XCM versions, and more.\n\n??? child \"Show more\"\n\n    `format` ++\"T extends Format\"++ \n        \n    Specifies the format for returning a transaction.\n\n    ??? child \"Type `Format`\"\n\n        ```ts\n        -export type Format = 'payload' | 'call' | 'submittable';\n        ```\n\n    ---\n\n    `paysWithFeeOrigin` ++\"string\"++\n    \n    The Asset ID to pay fees on the current common good parachain. The defaults are as follows:\n\n    - **Polkadot Asset Hub**: `'DOT'`\n    - **Kusama Asset Hub**: `'KSM'`\n\n    ---\n\n    `paysWithFeeDest` ++\"string\"++\n    \n    Asset ID to pay fees on the destination parachain.\n\n    ---\n\n    `weightLimit` ++\"{ refTime?: string, proofSize?: string }\"++\n    \n    Custom weight limit option. If not provided, it will default to unlimited.\n\n    ---\n\n    `xcmVersion` ++\"number\"++\n    \n    Sets the XCM version for message construction. If this is not present a supported version will be queried, and if there is no supported version a safe version will be queried.\n\n    ---\n\n    `keepAlive` ++\"boolean\"++\n    \n    Enables `transferKeepAlive` for local asset transfers. For creating local asset transfers, if `true` this will allow for a `transferKeepAlive` as opposed to a `transfer`.\n\n    ---\n\n    `transferLiquidToken` ++\"boolean\"++\n    \n    Declares if this will transfer liquidity tokens. Default is `false`.\n\n    ---\n\n    `assetTransferType` ++\"string\"++\n    \n    The XCM transfer type used to transfer assets. The `AssetTransferType` type defines the possible values for this parameter.\n\n    ??? child \"Type `AssetTransferType`\"\n\n        ```ts\n        -export type AssetTransferType = LocalReserve | DestinationReserve | Teleport | RemoteReserve;\n        ```\n        \n        !!! note\n            To use the `assetTransferType` parameter, which is a string, you should use the `AssetTransferType` type as if each of its variants are strings. For example: `assetTransferType = 'LocalReserve'`.\n\n\n    ---\n\n    `remoteReserveAssetTransferTypeLocation` ++\"string\"++\n    \n    The remove reserve location for the XCM transfer. Should be provided when specifying an `assetTransferType` of `RemoteReserve`.\n\n    ---\n\n    `feesTransferType` ++\"string\"++\n    \n    XCM TransferType used to pay fees for XCM transfer. The `AssetTransferType` type defines the possible values for this parameter.\n\n    ??? child \"Type `AssetTransferType`\"\n\n        ```ts\n        -export type AssetTransferType = LocalReserve | DestinationReserve | Teleport | RemoteReserve;\n        ```\n        \n        !!! note\n            To use the `feesTransferType` parameter, which is a string, you should use the `AssetTransferType` type as if each of its variants are strings. For example: `feesTransferType = 'LocalReserve'`.\n\n    ---\n\n    `remoteReserveFeesTransferTypeLocation` ++\"string\"++\n    \n    The remote reserve location for the XCM transfer fees. Should be provided when specifying a `feesTransferType` of `RemoteReserve`.\n\n    ---\n\n    `customXcmOnDest` ++\"string\"++\n    \n    A custom XCM message to be executed on the destination chain. Should be provided if a custom XCM message is needed after transferring assets. Defaults to:\n\n    ```bash\n    Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])\n    ```\n\n\n??? interface \"Response parameters\"\n\n    ++\"Promise<TxResult<T>\"++\n\n    -A promise containing the result of constructing the transaction.\n\n??? child \"Show more\"\n\n    `dest` ++\"string\"++\n\n    The destination `specName` of the transaction.\n\n    ---\n\n    `origin` ++\"string\"++\n\n    The origin `specName` of the transaction.\n\n    ---\n\n    `format` ++\"Format | 'local'\"++\n\n    The format type the transaction is outputted in.\n\n    ??? child \"Type `Format`\"\n\n        ```ts\n        -export type Format = 'payload' | 'call' | 'submittable';\n        ```\n\n    ---\n\n    `xcmVersion` ++\"number | null\"++\n\n    The XCM version that was used to construct the transaction.\n\n    ---\n\n    `direction` ++\"Direction | 'local'\"++\n\n    The direction of the cross-chain transfer.\n\n    ??? child \"Enum `Direction` values\"\n\n        `Local`\n\n        Local transaction.\n\n        ---\n\n        `SystemToPara`\n\n        System parachain to parachain.\n\n        ---\n\n        `SystemToRelay`\n\n        System paracahin to system relay chain.\n\n        ---\n\n        `SystemToSystem`\n\n        System parachain to System parachain chain.\n\n        ---\n\n        `SystemToBridge`\n\n        System parachain to an external `GlobalConsensus` chain.\n        \n        ---\n\n        `ParaToPara`\n\n        Parachain to Parachain.\n\n        ---\n\n        `ParaToRelay`\n\n        Parachain to Relay chain.\n\n        ---\n        \n        `ParaToSystem`\n\n        Parachain to System parachain.\n\n        ---\n\n        `RelayToSystem`\n\n        Relay to System Parachain.\n\n        ---\n\n        `RelayToPara`\n\n        Relay chain to Parachain.\n\n        ---\n\n        `RelayToBridge`\n\n        Relay chain to an external `GlobalConsensus` chain.\n\n    `method` ++\"Methods\"++\n\n    The method used in the transaction.\n\n    ??? child \"Type `Methods`\"\n\n        ```ts\n        -export type Methods =\n\t| LocalTransferTypes\n\t| 'transferAssets'\n\t| 'transferAssetsUsingTypeAndThen'\n\t| 'limitedReserveTransferAssets'\n\t| 'limitedTeleportAssets'\n\t| 'transferMultiasset'\n\t| 'transferMultiassets'\n\t| 'transferMultiassetWithFee'\n\t| 'claimAssets';\n        ```\n\n        ??? child \"Type `LocalTransferTypes`\"\n\n\n            ```ts\n            -export type LocalTransferTypes =\n\t| 'assets::transfer'\n\t| 'assets::transferKeepAlive'\n\t| 'assets::transferAll'\n\t| 'foreignAssets::transfer'\n\t| 'foreignAssets::transferKeepAlive'\n\t| 'foreignAssets::transferAll'\n\t| 'balances::transfer'\n\t| 'balances::transferKeepAlive'\n\t| 'balances::transferAll'\n\t| 'poolAssets::transfer'\n\t| 'poolAssets::transferKeepAlive'\n\t| 'poolAssets::transferAll'\n\t| 'tokens::transfer'\n\t| 'tokens::transferKeepAlive'\n\t| 'tokens::transferAll';\n            ```\n\n    ---\n\n    `tx` ++\"ConstructedFormat<T>\"++\n\n    The constructed transaction.\n\n    ??? child \"Type `ConstructedFormat<T>`\"\n\n        ```ts\n        -export type ConstructedFormat<T> = T extends 'payload'\n\t? GenericExtrinsicPayload\n\t: T extends 'call'\n\t\t? `0x${string}`\n\t\t: T extends 'submittable'\n\t\t\t? SubmittableExtrinsic<'promise', ISubmittableResult>\n\t\t\t: never;\n        ```\n\n        The `ConstructedFormat` type is a conditional type that returns a specific type based on the value of the TxResult `format` field.\n\n        - **Payload format**: If the format field is set to `'payload'`, the `ConstructedFormat` type will return a [`GenericExtrinsicPayload`](https://github.com/polkadot-js/api/blob/v15.8.1/packages/types/src/extrinsic/ExtrinsicPayload.ts#L87){target=\\_blank}.\n        - **Call format**: If the format field is set to `'call'`, the `ConstructedFormat` type will return a hexadecimal string (`0x${string}`). This is the encoded representation of the extrinsic call.\n        - **Submittable format**: If the format field is set to `'submittable'`, the `ConstructedFormat` type will return a [`SubmittableExtrinsic`](https://github.com/polkadot-js/api/blob/v15.8.1/packages/api-base/src/types/submittable.ts#L56){target=\\_blank}. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain.\n\n\n??? interface \"Example\"\n\n    ***Request***\n\n    ```ts\n    -import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetsApi.createTransferTransaction(\n      '2004',\n      '0xF977814e90dA44bFA03b6295A0616a897441aceC',\n      [],\n      ['1000000000000000000'],\n      {\n        format: 'call',\n        keepAlive: true,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n    ```\n\n    ***Response***\n\n    -<div id=\"termynal\" data-termynal>\n    <span data-ty>Call data:</span>\n    <span data-ty>{</span>\n    <span data-ty>    \"origin\": \"moonbeam\",</span>\n    <span data-ty>    \"dest\": \"moonbeam\",</span>\n    <span data-ty>    \"direction\": \"local\",</span>\n    <span data-ty>    \"xcmVersion\": null,</span>\n    <span data-ty>    \"method\": \"balances::transferKeepAlive\",</span>\n    <span data-ty>    \"format\": \"call\",</span>\n    <span data-ty>    \"tx\": \"0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600\"</span>\n    <span data-ty>}</span>\n<div>\n\n#### Claim Assets\n\nCreates a local XCM transaction to retrieve trapped assets. This function can be used to claim assets either locally on a system parachain, on the relay chain, or on any chain that supports the `claimAssets` runtime call.\n\n\n```ts\n-public async claimAssets<T extends Format>(\n\t\tassetIds: string[],\n\t\tamounts: string[],\n\t\tbeneficiary: string,\n\t\topts: TransferArgsOpts<T>,\n\t): Promise<TxResult<T>> {\n```\n\n??? interface \"Request parameters\"\n\n    `assetIds` ++\"string[]\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Array of asset IDs to be claimed from the `AssetTrap`.\n\n    ---\n\n    `amounts` ++\"string[]\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Array of amounts corresponding to each asset in `assetIds`.\n\n    ---\n\n    `beneficiary` ++\"string\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Address of the account to receive the trapped assets.\n\n    ---\n\n    `opts` ++\"TransferArgsOpts<T>\"++\n\n    -Options for customizing the claim assets transaction. These options allow you to specify the transaction format, fee payment details, weight limits, XCM versions, and more.\n\n??? child \"Show more\"\n\n    `format` ++\"T extends Format\"++ \n        \n    Specifies the format for returning a transaction.\n\n    ??? child \"Type `Format`\"\n\n        ```ts\n        -export type Format = 'payload' | 'call' | 'submittable';\n        ```\n\n    ---\n\n    `paysWithFeeOrigin` ++\"string\"++\n    \n    The Asset ID to pay fees on the current common good parachain. The defaults are as follows:\n\n    - **Polkadot Asset Hub**: `'DOT'`\n    - **Kusama Asset Hub**: `'KSM'`\n\n    ---\n\n    `paysWithFeeDest` ++\"string\"++\n    \n    Asset ID to pay fees on the destination parachain.\n\n    ---\n\n    `weightLimit` ++\"{ refTime?: string, proofSize?: string }\"++\n    \n    Custom weight limit option. If not provided, it will default to unlimited.\n\n    ---\n\n    `xcmVersion` ++\"number\"++\n    \n    Sets the XCM version for message construction. If this is not present a supported version will be queried, and if there is no supported version a safe version will be queried.\n\n    ---\n\n    `keepAlive` ++\"boolean\"++\n    \n    Enables `transferKeepAlive` for local asset transfers. For creating local asset transfers, if `true` this will allow for a `transferKeepAlive` as opposed to a `transfer`.\n\n    ---\n\n    `transferLiquidToken` ++\"boolean\"++\n    \n    Declares if this will transfer liquidity tokens. Default is `false`.\n\n    ---\n\n    `assetTransferType` ++\"string\"++\n    \n    The XCM transfer type used to transfer assets. The `AssetTransferType` type defines the possible values for this parameter.\n\n    ??? child \"Type `AssetTransferType`\"\n\n        ```ts\n        -export type AssetTransferType = LocalReserve | DestinationReserve | Teleport | RemoteReserve;\n        ```\n        \n        !!! note\n            To use the `assetTransferType` parameter, which is a string, you should use the `AssetTransferType` type as if each of its variants are strings. For example: `assetTransferType = 'LocalReserve'`.\n\n\n    ---\n\n    `remoteReserveAssetTransferTypeLocation` ++\"string\"++\n    \n    The remove reserve location for the XCM transfer. Should be provided when specifying an `assetTransferType` of `RemoteReserve`.\n\n    ---\n\n    `feesTransferType` ++\"string\"++\n    \n    XCM TransferType used to pay fees for XCM transfer. The `AssetTransferType` type defines the possible values for this parameter.\n\n    ??? child \"Type `AssetTransferType`\"\n\n        ```ts\n        -export type AssetTransferType = LocalReserve | DestinationReserve | Teleport | RemoteReserve;\n        ```\n        \n        !!! note\n            To use the `feesTransferType` parameter, which is a string, you should use the `AssetTransferType` type as if each of its variants are strings. For example: `feesTransferType = 'LocalReserve'`.\n\n    ---\n\n    `remoteReserveFeesTransferTypeLocation` ++\"string\"++\n    \n    The remote reserve location for the XCM transfer fees. Should be provided when specifying a `feesTransferType` of `RemoteReserve`.\n\n    ---\n\n    `customXcmOnDest` ++\"string\"++\n    \n    A custom XCM message to be executed on the destination chain. Should be provided if a custom XCM message is needed after transferring assets. Defaults to:\n\n    ```bash\n    Xcm(vec![DepositAsset { assets: Wild(AllCounted(assets.len())), beneficiary }])\n    ```\n\n\n??? interface \"Response parameters\"\n\n    ++\"Promise<TxResult<T>>\"++\n\n    -A promise containing the result of constructing the transaction.\n\n??? child \"Show more\"\n\n    `dest` ++\"string\"++\n\n    The destination `specName` of the transaction.\n\n    ---\n\n    `origin` ++\"string\"++\n\n    The origin `specName` of the transaction.\n\n    ---\n\n    `format` ++\"Format | 'local'\"++\n\n    The format type the transaction is outputted in.\n\n    ??? child \"Type `Format`\"\n\n        ```ts\n        -export type Format = 'payload' | 'call' | 'submittable';\n        ```\n\n    ---\n\n    `xcmVersion` ++\"number | null\"++\n\n    The XCM version that was used to construct the transaction.\n\n    ---\n\n    `direction` ++\"Direction | 'local'\"++\n\n    The direction of the cross-chain transfer.\n\n    ??? child \"Enum `Direction` values\"\n\n        `Local`\n\n        Local transaction.\n\n        ---\n\n        `SystemToPara`\n\n        System parachain to parachain.\n\n        ---\n\n        `SystemToRelay`\n\n        System paracahin to system relay chain.\n\n        ---\n\n        `SystemToSystem`\n\n        System parachain to System parachain chain.\n\n        ---\n\n        `SystemToBridge`\n\n        System parachain to an external `GlobalConsensus` chain.\n        \n        ---\n\n        `ParaToPara`\n\n        Parachain to Parachain.\n\n        ---\n\n        `ParaToRelay`\n\n        Parachain to Relay chain.\n\n        ---\n        \n        `ParaToSystem`\n\n        Parachain to System parachain.\n\n        ---\n\n        `RelayToSystem`\n\n        Relay to System Parachain.\n\n        ---\n\n        `RelayToPara`\n\n        Relay chain to Parachain.\n\n        ---\n\n        `RelayToBridge`\n\n        Relay chain to an external `GlobalConsensus` chain.\n\n    `method` ++\"Methods\"++\n\n    The method used in the transaction.\n\n    ??? child \"Type `Methods`\"\n\n        ```ts\n        -export type Methods =\n\t| LocalTransferTypes\n\t| 'transferAssets'\n\t| 'transferAssetsUsingTypeAndThen'\n\t| 'limitedReserveTransferAssets'\n\t| 'limitedTeleportAssets'\n\t| 'transferMultiasset'\n\t| 'transferMultiassets'\n\t| 'transferMultiassetWithFee'\n\t| 'claimAssets';\n        ```\n\n        ??? child \"Type `LocalTransferTypes`\"\n\n\n            ```ts\n            -export type LocalTransferTypes =\n\t| 'assets::transfer'\n\t| 'assets::transferKeepAlive'\n\t| 'assets::transferAll'\n\t| 'foreignAssets::transfer'\n\t| 'foreignAssets::transferKeepAlive'\n\t| 'foreignAssets::transferAll'\n\t| 'balances::transfer'\n\t| 'balances::transferKeepAlive'\n\t| 'balances::transferAll'\n\t| 'poolAssets::transfer'\n\t| 'poolAssets::transferKeepAlive'\n\t| 'poolAssets::transferAll'\n\t| 'tokens::transfer'\n\t| 'tokens::transferKeepAlive'\n\t| 'tokens::transferAll';\n            ```\n\n    ---\n\n    `tx` ++\"ConstructedFormat<T>\"++\n\n    The constructed transaction.\n\n    ??? child \"Type `ConstructedFormat<T>`\"\n\n        ```ts\n        -export type ConstructedFormat<T> = T extends 'payload'\n\t? GenericExtrinsicPayload\n\t: T extends 'call'\n\t\t? `0x${string}`\n\t\t: T extends 'submittable'\n\t\t\t? SubmittableExtrinsic<'promise', ISubmittableResult>\n\t\t\t: never;\n        ```\n\n        The `ConstructedFormat` type is a conditional type that returns a specific type based on the value of the TxResult `format` field.\n\n        - **Payload format**: If the format field is set to `'payload'`, the `ConstructedFormat` type will return a [`GenericExtrinsicPayload`](https://github.com/polkadot-js/api/blob/v15.8.1/packages/types/src/extrinsic/ExtrinsicPayload.ts#L87){target=\\_blank}.\n        - **Call format**: If the format field is set to `'call'`, the `ConstructedFormat` type will return a hexadecimal string (`0x${string}`). This is the encoded representation of the extrinsic call.\n        - **Submittable format**: If the format field is set to `'submittable'`, the `ConstructedFormat` type will return a [`SubmittableExtrinsic`](https://github.com/polkadot-js/api/blob/v15.8.1/packages/api-base/src/types/submittable.ts#L56){target=\\_blank}. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain.\n\n\n??? interface \"Example\"\n\n    ***Request***\n\n    ```ts\n    -import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://westend-rpc.polkadot.io',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  let callInfo;\n  try {\n    callInfo = await assetsApi.claimAssets(\n      [\n        `{\"parents\":\"0\",\"interior\":{\"X2\":[{\"PalletInstance\":\"50\"},{\"GeneralIndex\":\"1984\"}]}}`,\n      ],\n      ['1000000000000'],\n      '0xf5d5714c084c112843aca74f8c498da06cc5a2d63153b825189baa51043b1f0b',\n      {\n        format: 'call',\n        xcmVersion: 2,\n      },\n    );\n\n    console.log(`Call data:\\n${JSON.stringify(callInfo, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n    ```\n\n    ***Response***\n\n    -<div id=\"termynal\" data-termynal>\n    <span data-ty>Call data:</span>\n    <span data-ty>{</span>\n    <span data-ty>    \"origin\": \"0\",</span>\n    <span data-ty>    \"dest\": \"westend\",</span>\n    <span data-ty>    \"direction\": \"local\",</span>\n    <span data-ty>    \"xcmVersion\": 2,</span>\n    <span data-ty>    \"method\": \"claimAssets\",</span>\n    <span data-ty>    \"format\": \"call\",</span>\n    <span data-ty>    \"tx\": \"0x630c0104000002043205011f00070010a5d4e80100010100f5d5714c084c112843aca74f8c498da06cc5a2d63153b825189baa51043b1f0b\"</span>\n    <span data-ty>}</span>\n<div>\n\n\n#### Decode Extrinsic\n\nDecodes the hex of an extrinsic into a string readable format.\n\n```ts\n-public decodeExtrinsic<T extends Format>(encodedTransaction: string, format: T): string {\n```\n\n??? interface \"Request parameters\"\n\n    `encodedTransaction` ++\"string\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    A hex encoded extrinsic.\n\n    ---\n\n    `format` ++\"T extends Format\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    Specifies the format for returning a transaction.\n\n    ??? child \"Type `Format`\"\n\n        ```ts\n        -export type Format = 'payload' | 'call' | 'submittable';\n        ```\n\n??? interface \"Response parameters\"\n\n    ++\"string\"++\n\n    Decoded extrinsic in string readable format.\n\n??? interface \"Example\"\n\n    ***Request***\n\n    ```ts\n    -import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  const encodedExt = '0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600';\n\n  try {\n    const decodedExt = assetsApi.decodeExtrinsic(encodedExt, 'call');\n    console.log(\n      `Decoded tx:\\n ${JSON.stringify(JSON.parse(decodedExt), null, 4)}`,\n    );\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n    ```\n\n    ***Response***\n\n    -<div id='termynal' data-termynal>\n\t<span data-ty>Decoded tx:</span>\n\t<span data-ty> {</span>\n\t<span data-ty>    \"args\": {</span>\n\t<span data-ty>        \"dest\": \"0xF977814e90dA44bFA03b6295A0616a897441aceC\",</span>\n\t<span data-ty>        \"value\": \"100,000\"</span>\n\t<span data-ty>    },</span>\n\t<span data-ty>    \"method\": \"transferKeepAlive\",</span>\n\t<span data-ty>    \"section\": \"balances\"</span>\n\t<span data-ty>}</span>\n</div>\n\n#### Fetch Fee Info\n\nFetch estimated fee information for an extrinsic.\n\n```ts\n-public async fetchFeeInfo<T extends Format>(\n\t\ttx: ConstructedFormat<T>,\n\t\tformat: T,\n\t): Promise<RuntimeDispatchInfo | RuntimeDispatchInfoV1 | null> {\n```\n\n??? interface \"Request parameters\"\n\n    `tx` ++\"ConstructedFormat<T>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    The constructed transaction.\n\n    ??? child \"Type `ConstructedFormat<T>`\"\n\n        ```ts\n        -export type ConstructedFormat<T> = T extends 'payload'\n\t? GenericExtrinsicPayload\n\t: T extends 'call'\n\t\t? `0x${string}`\n\t\t: T extends 'submittable'\n\t\t\t? SubmittableExtrinsic<'promise', ISubmittableResult>\n\t\t\t: never;\n        ```\n\n        The `ConstructedFormat` type is a conditional type that returns a specific type based on the value of the TxResult `format` field.\n\n        - **Payload format**: If the format field is set to `'payload'`, the `ConstructedFormat` type will return a [`GenericExtrinsicPayload`](https://github.com/polkadot-js/api/blob/v16.2.2/packages/types/src/extrinsic/ExtrinsicPayload.ts#L87){target=\\_blank}.\n        - **Call format**: If the format field is set to `'call'`, the `ConstructedFormat` type will return a hexadecimal string (`0x${string}`). This is the encoded representation of the extrinsic call.\n        - **Submittable format**: If the format field is set to `'submittable'`, the `ConstructedFormat` type will return a [`SubmittableExtrinsic`](https://github.com/polkadot-js/api/blob/v16.2.2/packages/api-base/src/types/submittable.ts#L56){target=\\_blank}. This is a Polkadot.js type that represents a transaction that can be submitted to the blockchain.\n\n    ---\n\n    `format` ++\"T extends Format\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Specifies the format for returning a transaction.\n\n    ??? child \"Type `Format`\"\n\n        ```ts\n        -export type Format = 'payload' | 'call' | 'submittable';\n        ```\n\n??? interface \"Response parameters\"\n\n    ++\"Promise<RuntimeDispatchInfo | RuntimeDispatchInfoV1 | null>\"++\n\n    A promise containing the estimated fee information for the provided extrinsic.\n\n    ??? child \"Type `RuntimeDispatchInfo`\"\n\n        ```ts\n        export interface RuntimeDispatchInfo extends Struct {\n          readonly weight: Weight;\n          readonly class: DispatchClass;\n          readonly partialFee: Balance;\n        }\n        ```\n\n        For more information on the underlying types and fields of `RuntimeDispatchInfo`, check the [`RuntimeDispatchInfo`](https://github.com/polkadot-js/api/blob/v16.2.2/packages/types/src/interfaces/payment/types.ts#L21){target=\\_blank} source code.\n\n    ??? child \"Type `RuntimeDispatchInfoV1`\"\n\n        ```ts\n        export interface RuntimeDispatchInfoV1 extends Struct {\n          readonly weight: WeightV1;\n          readonly class: DispatchClass;\n          readonly partialFee: Balance;\n        }\n        ```\n\n        For more information on the underlying types and fields of `RuntimeDispatchInfoV1`, check the [`RuntimeDispatchInfoV1`](https://github.com/polkadot-js/api/blob/v16.2.2/packages/types/src/interfaces/payment/types.ts#L28){target=\\_blank} source code.\n\n??? interface \"Example\"\n\n    ***Request***\n\n    ```ts\n    -import {\n  AssetTransferApi,\n  constructApiPromise,\n} from '@substrate/asset-transfer-api';\n\nasync function main() {\n  const { api, specName, safeXcmVersion } = await constructApiPromise(\n    'wss://wss.api.moonbeam.network',\n  );\n  const assetsApi = new AssetTransferApi(api, specName, safeXcmVersion);\n\n  const encodedExt = '0x0a03f977814e90da44bfa03b6295a0616a897441acec821a0600';\n\n  try {\n    const decodedExt = await assetsApi.fetchFeeInfo(encodedExt, 'call');\n    console.log(`Fee info:\\n${JSON.stringify(decodedExt, null, 4)}`);\n  } catch (e) {\n    console.error(e);\n    throw Error(e as string);\n  }\n}\n\nmain()\n  .catch((err) => console.error(err))\n  .finally(() => process.exit());\n\n    ```\n\n    ***Response***\n\n    -<div id='termynal' data-termynal>\n    <span data-ty>Fee info:</span>\n    <span data-ty>{</span>\n    <span data-ty>    \"weight\": {</span>\n    <span data-ty>        \"refTime\": 163777000,</span>\n    <span data-ty>        \"proofSize\": 3581</span>\n    <span data-ty>    },</span>\n    <span data-ty>    \"class\": \"Normal\",</span>\n    <span data-ty>    \"partialFee\": 0</span>\n    <span data-ty>}</span>\n</div>\n"}
{"title": "Blocks", "slug": "polkadot-protocol-parachain-basics-blocks-transactions-fees-blocks", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-blocks-transactions-fees-blocks.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/blocks/", "categories": ["Basics", "Polkadot Protocol"], "description": "Understand how blocks are produced, validated, and imported in Polkadot SDK-based blockchains, covering initialization, finalization, and authoring processes.", "estimated_token_count": 1401, "token_estimator": "heuristic-v1", "content": "# Blocks\n\n## Introduction\n\nIn the Polkadot SDK, blocks are fundamental to the functioning of the blockchain, serving as containers for [transactions](/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/){target=\\_blank} and changes to the chain's state. Blocks consist of headers and an array of transactions, ensuring the integrity and validity of operations on the network. This guide explores the essential components of a block, the process of block production, and how blocks are validated and imported across the network. By understanding these concepts, developers can better grasp how blockchains maintain security, consistency, and performance within the Polkadot ecosystem.\n\n## What is a Block?\n\nIn the Polkadot SDK, a block is a fundamental unit that encapsulates both the header and an array of transactions. The block header includes critical metadata to ensure the integrity and sequence of the blockchain. Here's a breakdown of its components:\n\n- **Block height**: Indicates the number of blocks created in the chain so far.\n- **Parent hash**: The hash of the previous block, providing a link to maintain the blockchain's immutability.\n- **Transaction root**: Cryptographic digest summarizing all transactions in the block.\n- **State root**: A cryptographic digest representing the post-execution state.\n- **Digest**: Additional information that can be attached to a block, such as consensus-related messages.\n\nEach transaction is part of a series that is executed according to the runtime's rules. The transaction root is a cryptographic digest of this series, which prevents alterations and enables succinct verification by light clients. This verification process allows light clients to confirm whether a transaction exists in a block with only the block header, avoiding downloading the entire block.\n\n## Block Production\n\nWhen an authoring node is authorized to create a new block, it selects transactions from the transaction queue based on priority. This step, known as block production, relies heavily on the executive module to manage the initialization and finalization of blocks. The process is summarized as follows:\n\n### Initialize Block\n\nThe block initialization process begins with a series of function calls that prepare the block for transaction execution:\n\n1. **Call `on_initialize`**: The executive module calls the [`on_initialize`](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/trait.Hooks.html#method.on_initialize){target=\\_blank} hook from the system pallet and other runtime pallets to prepare for the block's transactions.\n2. **Coordinate runtime calls**: Coordinates function calls in the order defined by the transaction queue.\n3. **Verify information**: Once [`on_initialize`](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/trait.Hooks.html#method.on_initialize){target=\\_blank} functions are executed, the executive module checks the parent hash in the block header and the trie root to verify information is consistent.\n\n### Finalize Block\n\nOnce transactions are processed, the block must be finalized before being broadcast to the network. The finalization steps are as follows:\n\n1. **Call `on_finalize`**: The executive module calls the [`on_finalize`](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/trait.Hooks.html#method.on_finalize){target=\\_blank} hooks in each pallet to ensure any remaining state updates or checks are completed before the block is sealed and published.\n2. **Verify information**: The block's digest and storage root in the header are checked against the initialized block to ensure consistency.\n3. **Call `on_idle`**: The [`on_idle`](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/trait.Hooks.html#method.on_idle){target=\\_blank} hook is triggered to process any remaining tasks using the leftover weight from the block.\n\n## Block Authoring and Import\n\nOnce the block is finalized, it is gossiped to other nodes in the network. Nodes follow this procedure:\n\n1. **Receive transactions**: The authoring node collects transactions from the network.\n2. **Validate**: Transactions are checked for validity.\n3. **Queue**: Valid transactions are placed in the transaction pool for execution.\n4. **Execute**: State changes are made as the transactions are executed.\n5. **Publish**: The finalized block is broadcast to the network.\n\n### Block Import Queue\n\nAfter a block is published, other nodes on the network can import it into their chain state. The block import queue is part of the outer node in every Polkadot SDK-based node and ensures incoming blocks are valid before adding them to the node's state.\n\nIn most cases, you don't need to know details about how transactions are gossiped or how other nodes on the network import blocks. The following traits are relevant, however, if you plan to write any custom consensus logic or want a deeper dive into the block import queue:\n\n- **[`ImportQueue`](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/import_queue/trait.ImportQueue.html){target=\\_blank}**: The trait that defines the block import queue.\n- **[`Link`](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/import_queue/trait.Link.html){target=\\_blank}**: The trait that defines the link between the block import queue and the network.\n- **[`BasicQueue`](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/import_queue/struct.BasicQueue.html){target=\\_blank}**: A basic implementation of the block import queue.\n- **[`Verifier`](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/import_queue/trait.Verifier.html){target=\\_blank}**: The trait that defines the block verifier.\n- **[`BlockImport`](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/block_import/trait.BlockImport.html){target=\\_blank}**: The trait that defines the block import process.\n\nThese traits govern how blocks are validated and imported across the network, ensuring consistency and security.\n\n## Additional Resources\n\nTo learn more about the block structure in the Polkadot SDK runtime, see the [`Block` reference](https://paritytech.github.io/polkadot-sdk/master/sp_runtime/traits/trait.Block.html){target=\\_blank} entry in the Rust Docs.\n"}
{"title": "Build a Custom Pallet", "slug": "tutorials-polkadot-sdk-parachains-zero-to-hero-build-custom-pallet", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-polkadot-sdk-parachains-zero-to-hero-build-custom-pallet.md", "html_url": "https://docs.polkadot.com/tutorials/polkadot-sdk/parachains/zero-to-hero/build-custom-pallet/", "categories": ["Basics", "Parachains"], "description": "Learn how to build a custom pallet for Polkadot SDK-based blockchains with this step-by-step guide. Create and configure a simple counter pallet from scratch.", "estimated_token_count": 6767, "token_estimator": "heuristic-v1", "content": "# Build a Custom Pallet\n\n## Introduction\n\nIn Polkadot SDK-based blockchains, runtime functionality is built through modular components called [pallets](/polkadot-protocol/glossary#pallet){target=\\_blank}. These pallets are Rust-based runtime modules created using [FRAME (Framework for Runtime Aggregation of Modular Entities)](/develop/parachains/customize-parachain/overview/){target=\\_blank}, a powerful library that simplifies blockchain development by providing specialized macros and standardized patterns for building blockchain logic.\nA pallet encapsulates a specific set of blockchain functionalities, such as managing token balances, implementing governance mechanisms, or creating custom state transitions.\n\nIn this tutorial, you'll learn how to create a custom pallet from scratch. You will develop a simple counter pallet with the following features:\n\n- Users can increment and decrement a counter.\n- Only a [root origin](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/type.Origin.html#variant.Root){target=\\_blank} can set an arbitrary counter value.\n\n## Prerequisites\n\nYou'll use the [Polkadot SDK Parachain Template](https://github.com/paritytech/polkadot-sdk/tree/master/templates/parachain){target=\\_blank} created in the [Set Up a Template](/tutorials/polkadot-sdk/parachains/zero-to-hero/set-up-a-template/){target=\\_blank} tutorial. \n\n## Create a New Project\n\nIn this tutorial, you'll build a custom pallet from scratch to demonstrate the complete workflow, rather than starting with the pre-built `pallet-template`. The first step is to create a new Rust package for your pallet:\n\n1. Navigate to the `pallets` directory in your workspace:\n\n    ```bash\n    cd pallets\n    ```\n\n2. Create a new Rust library project for your custom pallet by running the following command:\n\n    ```bash\n    cargo new --lib custom-pallet\n    ```\n\n3. Enter the new project directory:\n\n    ```bash\n    cd custom-pallet\n    ```\n\n4. Ensure the project was created successfully by checking its structure. The file layout should resemble the following:\n\n    ```\n    custom-pallet \n    ├── Cargo.toml\n    └── src\n        └── lib.rs\n    ```\n\n    If the files are in place, your project setup is complete, and you're ready to start building your custom pallet.\n\n## Add Dependencies\n\nTo build and integrate your custom pallet into a Polkadot SDK-based runtime, you must add specific dependencies to the `Cargo.toml` file of your pallet's project. These dependencies provide essential modules and features required for pallet development. Since your custom pallet is part of a workspace that includes other components, such as the runtime, the configuration must align with the workspace structure. Follow the steps below to set up your `Cargo.toml` file properly:\n\n1. Open your `Cargo.toml` file.\n\n2. Add the required dependencies in the `[dependencies]` section:\n\n    ```toml\n    -[dependencies]\ncodec = { features = [\"derive\"], workspace = true }\nscale-info = { features = [\"derive\"], workspace = true }\nframe = { features = [\"experimental\", \"runtime\"], workspace = true }\n    ```\n\n3. Enable `std` features:\n\n    ```toml\n    -[features]\ndefault = [\"std\"]\nstd = [\"codec/std\", \"frame/std\", \"scale-info/std\"]\n    ```\n\nThe final `Cargo.toml` file should resemble the following:\n\n??? code \"Cargo.toml\"\n\n    ```toml\n    -[package]\nname = \"custom-pallet\"\nversion = \"0.1.0\"\nlicense.workspace = true\nauthors.workspace = true\nhomepage.workspace = true\nrepository.workspace = true\nedition.workspace = true\n\n[dependencies]\ncodec = { features = [\"derive\"], workspace = true }\nscale-info = { features = [\"derive\"], workspace = true }\nframe = { features = [\"experimental\", \"runtime\"], workspace = true }\n\n[features]\ndefault = [\"std\"]\nstd = [\"codec/std\", \"frame/std\", \"scale-info/std\"]\nruntime-benchmarks = [\"frame/runtime-benchmarks\"]\n\n    ```\n\n## Implement the Pallet Logic\n\nIn this section, you will construct the core structure of your custom pallet, starting with setting up its basic scaffold. This scaffold acts as the foundation, enabling you to later add functionality such as storage items, events, errors, and dispatchable calls.\n\n### Add Scaffold Pallet Structure\n\nYou now have the bare minimum of package dependencies that your pallet requires specified in the `Cargo.toml` file. The next step is to prepare the scaffolding for your new pallet.\n\n1. Open `src/lib.rs` in a text editor and delete all the content.\n   \n2. Prepare the scaffolding for the pallet by adding the following:\n\n    ```rust title=\"lib.rs\"\n    -#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\n    -#[frame::pallet]\npub mod pallet {\n    use super::*;\n    use frame::prelude::*;\n    #[pallet::pallet]\n    pub struct Pallet<T>(_);\n\n    // Configuration trait for the pallet.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        // Defines the event type for the pallet.\n        -    }\n    -}\n    ```\n\n3. Verify that it compiles by running the following command:\n\n    ```bash\n    cargo build --package custom-pallet\n    ```\n\n### Pallet Configuration\n\nImplementing the `#[pallet::config]` macro is mandatory and sets the module's dependency on other modules and the types and values specified by the runtime-specific settings.\n\nIn this step, you will configure two essential components that are critical for the pallet's functionality:\n\n- **`RuntimeEvent`**: Since this pallet emits events, the [`RuntimeEvent`](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/trait.Config.html#associatedtype.RuntimeEvent){target=\\_blank} type is required to handle them. This ensures that events generated by the pallet can be correctly processed and interpreted by the runtime.\n\n- **`CounterMaxValue`**: A constant that sets an upper limit on the value of the counter, ensuring that the counter remains within a predefined range.\n\nAdd the following `Config` trait definition to your pallet:\n\n```rust title=\"lib.rs\"\n-    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        // Defines the event type for the pallet.\n        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n        // Defines the maximum value the counter can hold.\n        #[pallet::constant]\n        type CounterMaxValue: Get<u32>;\n-    }\n```\n\n### Add Events\n\nEvents allow the pallet to communicate with the outside world by emitting signals when specific actions occur. These events are critical for transparency, debugging, and integration with external systems such as UIs or monitoring tools.\n\nBelow are the events defined for this pallet:\n\n- **`CounterValueSet`**: Is emitted when the counter is explicitly set to a new value. This event includes the counter's updated value.\n\n- **`CounterIncremented`**: Is emitted after a successful increment operation. It includes.\n\n    - The new counter value.\n    - The account responsible for the increment.\n    - The amount by which the counter was incremented.\n\n- **`CounterDecremented`**: Is emitted after a successful decrement operation. It includes.\n\n    - The new counter value.\n    - The account responsible for the decrement.\n    - The amount by which the counter was decremented.\n\nDefine the events in the pallet as follows:\n\n```rust title=\"lib.rs\"\n-    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event<T: Config> {\n        /// The counter value has been set to a new value by Root.\n        CounterValueSet {\n            /// The new value set.\n            counter_value: u32,\n        },\n        /// A user has successfully incremented the counter.\n        CounterIncremented {\n            /// The new value set.\n            counter_value: u32,\n            /// The account who incremented the counter.\n            who: T::AccountId,\n            /// The amount by which the counter was incremented.\n            incremented_amount: u32,\n        },\n        /// A user has successfully decremented the counter.\n        CounterDecremented {\n            /// The new value set.\n            counter_value: u32,\n            /// The account who decremented the counter.\n            who: T::AccountId,\n            /// The amount by which the counter was decremented.\n            decremented_amount: u32,\n        },\n    }\n\n```\n\n### Add Storage Items\n\nStorage items are used to manage the pallet's state. This pallet defines two items to handle the counter's state and user interactions:\n\n- **`CounterValue`**: A single storage value that keeps track of the current value of the counter. This value is the core state variable manipulated by the pallet's functions.\n\n- **`UserInteractions`**: A storage map that tracks the number of times each account interacts with the counter.\n  \nDefine the storage items as follows:\n\n```rust title=\"lib.rs\"\n-    #[pallet::storage]\n    pub type CounterValue<T> = StorageValue<_, u32>;\n\n    /// Storage map to track the number of interactions performed by each account.\n    #[pallet::storage]\n    pub type UserInteractions<T: Config> = StorageMap<_, Twox64Concat, T::AccountId, u32>;\n\n```\n\n### Implement Custom Errors\n\nThe `#[pallet::error]` macro defines a custom `Error` enum to handle specific failure conditions within the pallet. Errors help provide meaningful feedback to users and external systems when an extrinsic cannot be completed successfully. They are critical for maintaining the pallet's clarity and robustness.\n\nTo add custom errors, use the `#[pallet::error]` macro to define the `Error` enum. Each variant represents a unique error that the pallet can emit, and these errors should align with the logic and constraints of the pallet. \n\nAdd the following errors to the pallet:\n\n```rust title=\"lib.rs\"\n-    #[pallet::error]\n    pub enum Error<T> {\n        /// The counter value exceeds the maximum allowed value.\n        CounterValueExceedsMax,\n        /// The counter value cannot be decremented below zero.\n        CounterValueBelowZero,\n        /// Overflow occurred in the counter.\n        CounterOverflow,\n        /// Overflow occurred in user interactions.\n        UserInteractionOverflow,\n    }\n\n```\n\n### Implement Calls\n\nThe `#[pallet::call]` macro defines the dispatchable functions (or calls) the pallet exposes. These functions allow users or the runtime to interact with the pallet's logic and state. Each call includes comprehensive validations, modifies the state, and optionally emits events to signal successful execution.\n\nThe structure of the dispatchable calls in this pallet is as follows:\n\n```rust title=\"lib.rs\"\n-    #[pallet::call]\n    impl<T: Config> Pallet<T> {\n        /// Set the value of the counter.\n        ///\n        /// The dispatch origin of this call must be _Root_.\n        ///\n        /// - `new_value`: The new value to set for the counter.\n        ///\n        /// Emits `CounterValueSet` event when successful.\n        #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    -        pub fn set_counter_value(origin: OriginFor<T>, new_value: u32) -> DispatchResult {\n    -        }\n\n    -        /// Increment the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_increment`: The amount by which to increment the counter.\n        ///\n        /// Emits `CounterIncremented` event when successful.\n        #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    -        pub fn increment(origin: OriginFor<T>, amount_to_increment: u32) -> DispatchResult {\n    -        }\n\n    -        /// Decrement the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_decrement`: The amount by which to decrement the counter.\n        ///\n        /// Emits `CounterDecremented` event when successful.\n        #[pallet::call_index(2)]\n    #[pallet::weight(0)]\n    -        pub fn decrement(origin: OriginFor<T>, amount_to_decrement: u32) -> DispatchResult {\n    -    }\n-}\n```\n\nExpand the following items to view the implementations of each dispatchable call in this pallet.\n\n???- code \"set_counter_value(origin: OriginFor<T>, new_value: u32) -> DispatchResult\"\n    This call sets the counter to a specific value. It is restricted to the Root origin, meaning it can only be invoked by privileged users or entities.\n\n    - Parameters:\n        - **`new_value`**: The value to set the counter to.\n    - Validations:\n        - The new value must not exceed the maximum allowed counter value (`CounterMaxValue`).\n    - Behavior:\n        - Updates the `CounterValue` storage item.\n        - Emits a `CounterValueSet` event on success.\n\n    ```rust title=\"lib.rs\"\n    -        /// Set the value of the counter.\n        ///\n        /// The dispatch origin of this call must be _Root_.\n        ///\n        /// - `new_value`: The new value to set for the counter.\n        ///\n        /// Emits `CounterValueSet` event when successful.\n        #[pallet::call_index(0)]\n    #[pallet::weight(0)]\n    -        pub fn set_counter_value(origin: OriginFor<T>, new_value: u32) -> DispatchResult {\n            ensure_root(origin)?;\n\n            ensure!(\n                new_value <= T::CounterMaxValue::get(),\n                Error::<T>::CounterValueExceedsMax\n            );\n\n            CounterValue::<T>::put(new_value);\n\n            Self::deposit_event(Event::<T>::CounterValueSet {\n                counter_value: new_value,\n            });\n\n            Ok(())\n        }\n    ```\n\n???- code \"increment(origin: OriginFor<T>, amount_to_increment: u32) -> DispatchResult\"\n    This call increments the counter by a specified amount. It is accessible to any signed account.\n\n    - Parameters:\n        - **`amount_to_increment`**: The amount to add to the counter.\n    - Validations:\n        - Prevents overflow during the addition.\n        - Ensures the resulting counter value does not exceed `CounterMaxValue`.\n    - Behavior:\n        - Updates the `CounterValue` storage item.\n        - Tracks the number of interactions by the user in the `UserInteractions` storage map.\n        - Emits a `CounterIncremented` event on success.\n\n    ```rust title=\"lib.rs\"\n    -        /// Increment the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_increment`: The amount by which to increment the counter.\n        ///\n        /// Emits `CounterIncremented` event when successful.\n        #[pallet::call_index(1)]\n    #[pallet::weight(0)]\n    -        pub fn increment(origin: OriginFor<T>, amount_to_increment: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let current_value = CounterValue::<T>::get().unwrap_or(0);\n\n            let new_value = current_value\n                .checked_add(amount_to_increment)\n                .ok_or(Error::<T>::CounterOverflow)?;\n\n            ensure!(\n                new_value <= T::CounterMaxValue::get(),\n                Error::<T>::CounterValueExceedsMax\n            );\n\n            CounterValue::<T>::put(new_value);\n\n            UserInteractions::<T>::try_mutate(&who, |interactions| -> Result<_, Error<T>> {\n                let new_interactions = interactions\n                    .unwrap_or(0)\n                    .checked_add(1)\n                    .ok_or(Error::<T>::UserInteractionOverflow)?;\n                *interactions = Some(new_interactions); // Store the new value.\n\n                Ok(())\n            })?;\n\n            Self::deposit_event(Event::<T>::CounterIncremented {\n                counter_value: new_value,\n                who,\n                incremented_amount: amount_to_increment,\n            });\n\n            Ok(())\n        }\n    ```\n\n???- code \"decrement(origin: OriginFor<T>, amount_to_decrement: u32) -> DispatchResult\"\n    This call decrements the counter by a specified amount. It is accessible to any signed account.\n\n    - Parameters:\n        - **`amount_to_decrement`**: The amount to subtract from the counter.\n    - Validations:\n        - Prevents underflow during the subtraction.\n        - Ensures the counter does not drop below zero.\n    - Behavior:\n        - Updates the `CounterValue` storage item.\n        - Tracks the number of interactions by the user in the `UserInteractions` storage map.\n        - Emits a `CounterDecremented` event on success.\n\n    ```rust title=\"lib.rs\"\n    -        /// Decrement the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_decrement`: The amount by which to decrement the counter.\n        ///\n        /// Emits `CounterDecremented` event when successful.\n        #[pallet::call_index(2)]\n    #[pallet::weight(0)]\n    -        pub fn decrement(origin: OriginFor<T>, amount_to_decrement: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let current_value = CounterValue::<T>::get().unwrap_or(0);\n\n            let new_value = current_value\n                .checked_sub(amount_to_decrement)\n                .ok_or(Error::<T>::CounterValueBelowZero)?;\n\n            CounterValue::<T>::put(new_value);\n\n            UserInteractions::<T>::try_mutate(&who, |interactions| -> Result<_, Error<T>> {\n                let new_interactions = interactions\n                    .unwrap_or(0)\n                    .checked_add(1)\n                    .ok_or(Error::<T>::UserInteractionOverflow)?;\n                *interactions = Some(new_interactions); // Store the new value.\n\n                Ok(())\n            })?;\n\n            Self::deposit_event(Event::<T>::CounterDecremented {\n                counter_value: new_value,\n                who,\n                decremented_amount: amount_to_decrement,\n            });\n\n            Ok(())\n        }\n    ```\n\n## Verify Compilation\n\nAfter implementing all the pallet components, verifying that the code still compiles successfully is crucial. Run the following command in your terminal to ensure there are no errors:\n\n```bash\ncargo build --package custom-pallet\n```\n\nIf you encounter any errors or warnings, carefully review your code to resolve the issues. Once the build is complete without errors, your pallet implementation is ready.\n\n## Key Takeaways\n\nIn this tutorial, you learned how to create a custom pallet by defining storage, implementing errors, adding dispatchable calls, and emitting events. These are the foundational building blocks for developing robust Polkadot SDK-based blockchain logic.\n\nExpand the following item to review this implementation and the complete pallet code.\n\n???- code \"src/lib.rs\"\n\n    ```rust title=\"lib.rs\"\n    -#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\n    -#[frame::pallet]\npub mod pallet {\n    use super::*;\n    use frame::prelude::*;\n    #[pallet::pallet]\n    pub struct Pallet<T>(_);\n\n    // Configuration trait for the pallet.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        // Defines the event type for the pallet.\n        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n        // Defines the maximum value the counter can hold.\n        #[pallet::constant]\n        type CounterMaxValue: Get<u32>;\n        -    }\n\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event<T: Config> {\n        /// The counter value has been set to a new value by Root.\n        CounterValueSet {\n            /// The new value set.\n            counter_value: u32,\n        },\n        /// A user has successfully incremented the counter.\n        CounterIncremented {\n            /// The new value set.\n            counter_value: u32,\n            /// The account who incremented the counter.\n            who: T::AccountId,\n            /// The amount by which the counter was incremented.\n            incremented_amount: u32,\n        },\n        /// A user has successfully decremented the counter.\n        CounterDecremented {\n            /// The new value set.\n            counter_value: u32,\n            /// The account who decremented the counter.\n            who: T::AccountId,\n            /// The amount by which the counter was decremented.\n            decremented_amount: u32,\n        },\n    }\n\n    /// Storage for the current value of the counter.\n    #[pallet::storage]\n    pub type CounterValue<T> = StorageValue<_, u32>;\n\n    /// Storage map to track the number of interactions performed by each account.\n    #[pallet::storage]\n    pub type UserInteractions<T: Config> = StorageMap<_, Twox64Concat, T::AccountId, u32>;\n\n    #[pallet::error]\n    pub enum Error<T> {\n        /// The counter value exceeds the maximum allowed value.\n        CounterValueExceedsMax,\n        /// The counter value cannot be decremented below zero.\n        CounterValueBelowZero,\n        /// Overflow occurred in the counter.\n        CounterOverflow,\n        /// Overflow occurred in user interactions.\n        UserInteractionOverflow,\n    }\n\n    #[pallet::call]\n    impl<T: Config> Pallet<T> {\n        /// Set the value of the counter.\n        ///\n        /// The dispatch origin of this call must be _Root_.\n        ///\n        /// - `new_value`: The new value to set for the counter.\n        ///\n        /// Emits `CounterValueSet` event when successful.\n        #[pallet::call_index(0)]\n            #[pallet::weight(0)]\n            -        pub fn set_counter_value(origin: OriginFor<T>, new_value: u32) -> DispatchResult {\n            ensure_root(origin)?;\n\n            ensure!(\n                new_value <= T::CounterMaxValue::get(),\n                Error::<T>::CounterValueExceedsMax\n            );\n\n            CounterValue::<T>::put(new_value);\n\n            Self::deposit_event(Event::<T>::CounterValueSet {\n                counter_value: new_value,\n            });\n\n            Ok(())\n        }\n\n        /// Increment the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_increment`: The amount by which to increment the counter.\n        ///\n        /// Emits `CounterIncremented` event when successful.\n        #[pallet::call_index(1)]\n            #[pallet::weight(0)]\n            -        pub fn increment(origin: OriginFor<T>, amount_to_increment: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let current_value = CounterValue::<T>::get().unwrap_or(0);\n\n            let new_value = current_value\n                .checked_add(amount_to_increment)\n                .ok_or(Error::<T>::CounterOverflow)?;\n\n            ensure!(\n                new_value <= T::CounterMaxValue::get(),\n                Error::<T>::CounterValueExceedsMax\n            );\n\n            CounterValue::<T>::put(new_value);\n\n            UserInteractions::<T>::try_mutate(&who, |interactions| -> Result<_, Error<T>> {\n                let new_interactions = interactions\n                    .unwrap_or(0)\n                    .checked_add(1)\n                    .ok_or(Error::<T>::UserInteractionOverflow)?;\n                *interactions = Some(new_interactions); // Store the new value.\n\n                Ok(())\n            })?;\n\n            Self::deposit_event(Event::<T>::CounterIncremented {\n                counter_value: new_value,\n                who,\n                incremented_amount: amount_to_increment,\n            });\n\n            Ok(())\n        }\n\n        /// Decrement the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_decrement`: The amount by which to decrement the counter.\n        ///\n        /// Emits `CounterDecremented` event when successful.\n        #[pallet::call_index(2)]\n            #[pallet::weight(0)]\n    -// This file is part of 'custom-pallet'.\n\n// SPDX-License-Identifier: MIT-0\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\npub use pallet::*;\n\n#[cfg(test)]\nmod mock;\n\n#[cfg(test)]\nmod tests;\n\n#[cfg(feature = \"runtime-benchmarks\")]\nmod benchmarking;\n\npub mod weights;\nuse crate::weights::WeightInfo;\n\n#[frame::pallet]\npub mod pallet {\n    use super::*;\n    use frame::prelude::*;\n    #[pallet::pallet]\n    pub struct Pallet<T>(_);\n\n    // Configuration trait for the pallet.\n    #[pallet::config]\n    pub trait Config: frame_system::Config {\n        // Defines the event type for the pallet.\n        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;\n\n        // Defines the maximum value the counter can hold.\n        #[pallet::constant]\n        type CounterMaxValue: Get<u32>;\n\n        /// A type representing the weights required by the dispatchables of this pallet.\n        type WeightInfo: WeightInfo;\n    }\n\n    #[pallet::event]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event<T: Config> {\n        /// The counter value has been set to a new value by Root.\n        CounterValueSet {\n            /// The new value set.\n            counter_value: u32,\n        },\n        /// A user has successfully incremented the counter.\n        CounterIncremented {\n            /// The new value set.\n            counter_value: u32,\n            /// The account who incremented the counter.\n            who: T::AccountId,\n            /// The amount by which the counter was incremented.\n            incremented_amount: u32,\n        },\n        /// A user has successfully decremented the counter.\n        CounterDecremented {\n            /// The new value set.\n            counter_value: u32,\n            /// The account who decremented the counter.\n            who: T::AccountId,\n            /// The amount by which the counter was decremented.\n            decremented_amount: u32,\n        },\n    }\n\n    /// Storage for the current value of the counter.\n    #[pallet::storage]\n    pub type CounterValue<T> = StorageValue<_, u32>;\n\n    /// Storage map to track the number of interactions performed by each account.\n    #[pallet::storage]\n    pub type UserInteractions<T: Config> = StorageMap<_, Twox64Concat, T::AccountId, u32>;\n\n    #[pallet::error]\n    pub enum Error<T> {\n        /// The counter value exceeds the maximum allowed value.\n        CounterValueExceedsMax,\n        /// The counter value cannot be decremented below zero.\n        CounterValueBelowZero,\n        /// Overflow occurred in the counter.\n        CounterOverflow,\n        /// Overflow occurred in user interactions.\n        UserInteractionOverflow,\n    }\n\n    #[pallet::call]\n    impl<T: Config> Pallet<T> {\n        /// Set the value of the counter.\n        ///\n        /// The dispatch origin of this call must be _Root_.\n        ///\n        /// - `new_value`: The new value to set for the counter.\n        ///\n        /// Emits `CounterValueSet` event when successful.\n        #[pallet::call_index(0)]\n        #[pallet::weight(T::WeightInfo::set_counter_value())]\n        pub fn set_counter_value(origin: OriginFor<T>, new_value: u32) -> DispatchResult {\n            ensure_root(origin)?;\n\n            ensure!(\n                new_value <= T::CounterMaxValue::get(),\n                Error::<T>::CounterValueExceedsMax\n            );\n\n            CounterValue::<T>::put(new_value);\n\n            Self::deposit_event(Event::<T>::CounterValueSet {\n                counter_value: new_value,\n            });\n\n            Ok(())\n        }\n\n        /// Increment the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_increment`: The amount by which to increment the counter.\n        ///\n        /// Emits `CounterIncremented` event when successful.\n        #[pallet::call_index(1)]\n        #[pallet::weight(T::WeightInfo::increment())]\n        pub fn increment(origin: OriginFor<T>, amount_to_increment: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let current_value = CounterValue::<T>::get().unwrap_or(0);\n\n            let new_value = current_value\n                .checked_add(amount_to_increment)\n                .ok_or(Error::<T>::CounterOverflow)?;\n\n            ensure!(\n                new_value <= T::CounterMaxValue::get(),\n                Error::<T>::CounterValueExceedsMax\n            );\n\n            CounterValue::<T>::put(new_value);\n\n            UserInteractions::<T>::try_mutate(&who, |interactions| -> Result<_, Error<T>> {\n                let new_interactions = interactions\n                    .unwrap_or(0)\n                    .checked_add(1)\n                    .ok_or(Error::<T>::UserInteractionOverflow)?;\n                *interactions = Some(new_interactions); // Store the new value.\n\n                Ok(())\n            })?;\n\n            Self::deposit_event(Event::<T>::CounterIncremented {\n                counter_value: new_value,\n                who,\n                incremented_amount: amount_to_increment,\n            });\n\n            Ok(())\n        }\n\n        /// Decrement the counter by a specified amount.\n        ///\n        /// This function can be called by any signed account.\n        ///\n        /// - `amount_to_decrement`: The amount by which to decrement the counter.\n        ///\n        /// Emits `CounterDecremented` event when successful.\n        #[pallet::call_index(2)]\n        #[pallet::weight(T::WeightInfo::decrement())]\n        pub fn decrement(origin: OriginFor<T>, amount_to_decrement: u32) -> DispatchResult {\n            let who = ensure_signed(origin)?;\n\n            let current_value = CounterValue::<T>::get().unwrap_or(0);\n\n            let new_value = current_value\n                .checked_sub(amount_to_decrement)\n                .ok_or(Error::<T>::CounterValueBelowZero)?;\n\n            CounterValue::<T>::put(new_value);\n\n            UserInteractions::<T>::try_mutate(&who, |interactions| -> Result<_, Error<T>> {\n                let new_interactions = interactions\n                    .unwrap_or(0)\n                    .checked_add(1)\n                    .ok_or(Error::<T>::UserInteractionOverflow)?;\n                *interactions = Some(new_interactions); // Store the new value.\n\n                Ok(())\n            })?;\n\n            Self::deposit_event(Event::<T>::CounterDecremented {\n                counter_value: new_value,\n                who,\n                decremented_amount: amount_to_decrement,\n            });\n\n            Ok(())\n        }\n    }\n}\n\n    ```\n\n## Where to Go Next\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Pallet Unit Testing__\n\n    ---\n\n    Learn to write effective unit tests for Polkadot SDK pallets! Use a custom pallet as a practical example in this comprehensive guide.\n\n    [:octicons-arrow-right-24: Get Started](/tutorials/polkadot-sdk/parachains/zero-to-hero/pallet-unit-testing/)\n\n</div>\n"}
{"title": "Chain Data", "slug": "polkadot-protocol-parachain-basics-chain-data", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-chain-data.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/chain-data/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn how to expose and utilize chain data for blockchain applications. Discover runtime metadata, RPC APIs, and tools for efficient development.", "estimated_token_count": 3789, "token_estimator": "heuristic-v1", "content": "# Chain Data\n\n## Introduction\n\nUnderstanding and leveraging on-chain data is a fundamental aspect of blockchain development. Whether you're building frontend applications or backend systems, accessing and decoding runtime metadata is vital to interacting with the blockchain. This guide introduces you to the tools and processes for generating and retrieving metadata, explains its role in application development, and outlines the additional APIs available for interacting with a Polkadot node. By mastering these components, you can ensure seamless communication between your applications and the blockchain.\n\n## Application Development\n\nYou might not be directly involved in building frontend applications as a blockchain developer. However, most applications that run on a blockchain require some form of frontend or user-facing client to enable users or other programs to access and modify the data that the blockchain stores. For example, you might develop a browser-based, mobile, or desktop application that allows users to submit transactions, post articles, view their assets, or track previous activity. The backend for that application is configured in the runtime logic for your blockchain, but the frontend client makes the runtime features accessible to your users.\n\nFor your custom chain to be useful to others, you'll need to provide a client application that allows users to view, interact with, or update information that the blockchain keeps track of. In this article, you'll learn how to expose information about your runtime so that client applications can use it, see examples of the information exposed, and explore tools and libraries that use it.\n\n## Understand Metadata\n\nPolkadot SDK-based blockchain networks are designed to expose their runtime information, allowing developers to learn granular details regarding pallets, RPC calls, and runtime APIs. The metadata also exposes their related documentation. The chain's metadata is [SCALE-encoded](/polkadot-protocol/parachain-basics/data-encoding/){target=\\_blank}, allowing for the development of browser-based, mobile, or desktop applications to support the chain's runtime upgrades seamlessly. It is also possible to develop applications compatible with multiple Polkadot SDK-based chains simultaneously.\n\n## Expose Runtime Information as Metadata\n\nTo interact with a node or the state of the blockchain, you need to know how to connect to the chain and access the exposed runtime features. This interaction involves a Remote Procedure Call (RPC) through a node endpoint address, commonly through a secure web socket connection.\n\nAn application developer typically needs to know the contents of the runtime logic, including the following details:\n\n- Version of the runtime the application is connecting to.\n- Supported APIs.\n- Implemented pallets.\n- Defined functions and corresponding type signatures.\n- Defined custom types.\n- Exposed parameters users can set.\n\nAs the Polkadot SDK is modular and provides a composable framework for building blockchains, there are limitless opportunities to customize the schema of properties. Each runtime can be configured with its properties, including function calls and types, which can be changed over time with runtime upgrades.\n\nThe Polkadot SDK enables you to generate the runtime metadata schema to capture information unique to a runtime. The metadata for a runtime describes the pallets in use and types defined for a specific runtime version. The metadata includes information about each pallet's storage items, functions, events, errors, and constants. The metadata also provides type definitions for any custom types included in the runtime.\n\nMetadata provides a complete inventory of a chain's runtime. It is key to enabling client applications to interact with the node, parse responses, and correctly format message payloads sent back to that chain.\n\n## Generate Metadata\n\nTo efficiently use the blockchain's networking resources and minimize the data transmitted over the network, the metadata schema is encoded using the [Parity SCALE Codec](https://github.com/paritytech/parity-scale-codec?tab=readme-ov-file#parity-scale-codec){target=\\_blank}. This encoding is done automatically through the [`scale-info`](https://docs.rs/scale-info/latest/scale_info/){target=\\_blank}crate.\n\nAt a high level, generating the metadata involves the following steps:\n\n1. The pallets in the runtime logic expose callable functions, types, parameters, and documentation that need to be encoded in the metadata.\n2. The `scale-info` crate collects type information for the pallets in the runtime, builds a registry of the pallets that exist in a particular runtime, and the relevant types for each pallet in the registry. The type information is detailed enough to enable encoding and decoding for every type.\n3. The [`frame-metadata`](https://github.com/paritytech/frame-metadata){target=\\_blank} crate describes the structure of the runtime based on the registry provided by the `scale-info` crate.\n4. Nodes provide the RPC method `state_getMetadata` to return a complete description of all the types in the current runtime as a hex-encoded vector of SCALE-encoded bytes.\n\n## Retrieve Runtime Metadata\n\nThe type information provided by the metadata enables applications to communicate with nodes using different runtime versions and across chains that expose different calls, events, types, and storage items. The metadata also allows libraries to generate a substantial portion of the code needed to communicate with a given node, enabling libraries like [`subxt`](https://github.com/paritytech/subxt){target=\\_blank} to generate frontend interfaces that are specific to a target chain.\n\n### Use Polkadot.js\n\nVisit the [Polkadot.js Portal](https://polkadot.js.org/apps/#/rpc){target=\\_blank} and select the **Developer** dropdown in the top banner. Select **RPC Calls** to make the call to request metadata. Follow these steps to make the RPC call:\n\n1. Select **state** as the endpoint to call.\n2. Select **`getMetadata(at)`** as the method to call.\n3. Click **Submit RPC call** to submit the call and return the metadata in JSON format.\n\n### Use Curl \n\nYou can fetch the metadata for the network by calling the node's RPC endpoint. This request returns the metadata in bytes rather than human-readable JSON:\n\n```sh\ncurl -H \"Content-Type: application/json\" \\\n-d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"state_getMetadata\"}' \\\nhttps://rpc.polkadot.io\n\n```\n\n### Use Subxt\n\n[`subxt`](https://github.com/paritytech/subxt){target=\\_blank} may also be used to fetch the metadata of any data in a human-readable JSON format: \n\n```sh\nsubxt metadata  --url wss://rpc.polkadot.io --format json > spec.json\n```\n\nAnother option is to use the [`subxt` explorer web UI](https://paritytech.github.io/subxt-explorer/#/){target=\\_blank}.\n\n## Client Applications and Metadata\n\nThe metadata exposes the expected way to decode each type, meaning applications can send, retrieve, and process application information without manual encoding and decoding. Client applications must use the [SCALE codec library](https://github.com/paritytech/parity-scale-codec?tab=readme-ov-file#parity-scale-codec){target=\\_blank} to encode and decode RPC payloads to use the metadata. Client applications use the metadata to interact with the node, parse responses, and format message payloads sent to the node.\n\n## Metadata Format\n\nAlthough the SCALE-encoded bytes can be decoded using the `frame-metadata` and [`parity-scale-codec`](https://github.com/paritytech/parity-scale-codec){target=\\_blank} libraries, there are other tools, such as `subxt` and the Polkadot-JS API, that can convert the raw data to human-readable JSON format.\n\nThe types and type definitions included in the metadata returned by the `state_getMetadata` RPC call depend on the runtime's metadata version.\n\nIn general, the metadata includes the following information:\n\n- A constant identifying the file as containing metadata.\n- The version of the metadata format used in the runtime.\n- Type definitions for all types used in the runtime and generated by the `scale-info` crate.\n- Pallet information for the pallets included in the runtime in the order that they are defined in the `construct_runtime` macro.\n\n!!!tip \n    Depending on the frontend library used (such as the [Polkadot API](https://papi.how/){target=\\_blank}), they may format the metadata differently than the raw format shown.\n\nThe following example illustrates a condensed and annotated section of metadata decoded and converted to JSON:\n\n```json\n-[\n    1635018093,\n    {\n        \"V14\": {\n            \"types\": {\n                \"types\": [{}]\n            },\n            \"pallets\": [{}],\n            \"extrinsic\": {\n                \"ty\": 126,\n                \"version\": 4,\n                \"signed_extensions\": [{}]\n            },\n            \"ty\": 141\n        }\n    }\n]\n\n```\n\nThe constant `1635018093` is a magic number that identifies the file as a metadata file. The rest of the metadata is divided into the `types`, `pallets`, and `extrinsic` sections:\n\n- The `types` section contains an index of the types and information about each type's type signature.\n- The `pallets` section contains information about each pallet in the runtime.\n- The `extrinsic` section describes the type identifier and transaction format version that the runtime uses.\n\nDifferent extrinsic versions can have varying formats, especially when considering [signed transactions](/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/#signed-transactions){target=\\_blank}. \n\n### Pallets\n\nThe following is a condensed and annotated example of metadata for a single element in the `pallets` array (the [`sudo`](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/index.html){target=\\_blank} pallet):\n\n```json\n-{\n    \"name\": \"Sudo\",\n    \"storage\": {\n        \"prefix\": \"Sudo\",\n        \"entries\": [\n            {\n                \"name\": \"Key\",\n                \"modifier\": \"Optional\",\n                \"ty\": {\n                    \"Plain\": 0\n                },\n                \"default\": [0],\n                \"docs\": [\"The `AccountId` of the sudo key.\"]\n            }\n        ]\n    },\n    \"calls\": {\n        \"ty\": 117\n    },\n    \"event\": {\n        \"ty\": 42\n    },\n    \"constants\": [],\n    \"error\": {\n        \"ty\": 124\n    },\n    \"index\": 8\n}\n\n```\n\nEvery element metadata contains the name of the pallet it represents and information about its storage, calls, events, and errors. You can look up details about the definition of the calls, events, and errors by viewing the type index identifier. The type index identifier is the `u32` integer used to access the type information for that item. For example, the type index identifier for calls in the Sudo pallet is 117. If you view information for that type identifier in the `types` section of the metadata, it provides information about the available calls, including the documentation for each call.\n\nFor example, the following is a condensed excerpt of the calls for the Sudo pallet:\n\n```json\n-{\n    \"id\": 117,\n    \"type\": {\n        \"path\": [\"pallet_sudo\", \"pallet\", \"Call\"],\n        \"params\": [\n            {\n                \"name\": \"T\",\n                \"type\": null\n            }\n        ],\n        \"def\": {\n            \"variant\": {\n                \"variants\": [\n                    {\n                        \"name\": \"sudo\",\n                        \"fields\": [\n                            {\n                                \"name\": \"call\",\n                                \"type\": 114,\n                                \"typeName\": \"Box<<T as Config>::RuntimeCall>\"\n                            }\n                        ],\n                        \"index\": 0,\n                        \"docs\": [\n                            \"Authenticates sudo key, dispatches a function call with `Root` origin\"\n                        ]\n                    },\n                    {\n                        \"name\": \"sudo_unchecked_weight\",\n                        \"fields\": [\n                            {\n                                \"name\": \"call\",\n                                \"type\": 114,\n                                \"typeName\": \"Box<<T as Config>::RuntimeCall>\"\n                            },\n                            {\n                                \"name\": \"weight\",\n                                \"type\": 8,\n                                \"typeName\": \"Weight\"\n                            }\n                        ],\n                        \"index\": 1,\n                        \"docs\": [\n                            \"Authenticates sudo key, dispatches a function call with `Root` origin\"\n                        ]\n                    },\n                    {\n                        \"name\": \"set_key\",\n                        \"fields\": [\n                            {\n                                \"name\": \"new\",\n                                \"type\": 103,\n                                \"typeName\": \"AccountIdLookupOf<T>\"\n                            }\n                        ],\n                        \"index\": 2,\n                        \"docs\": [\n                            \"Authenticates current sudo key, sets the given AccountId (`new`) as the new sudo\"\n                        ]\n                    },\n                    {\n                        \"name\": \"sudo_as\",\n                        \"fields\": [\n                            {\n                                \"name\": \"who\",\n                                \"type\": 103,\n                                \"typeName\": \"AccountIdLookupOf<T>\"\n                            },\n                            {\n                                \"name\": \"call\",\n                                \"type\": 114,\n                                \"typeName\": \"Box<<T as Config>::RuntimeCall>\"\n                            }\n                        ],\n                        \"index\": 3,\n                        \"docs\": [\n                            \"Authenticates sudo key, dispatches a function call with `Signed` origin from a given account\"\n                        ]\n                    }\n                ]\n            }\n        }\n    }\n}\n\n```\n\nFor each field, you can access type information and metadata for the following:\n\n- **Storage metadata**: Provides the information required to enable applications to get information for specific storage items.\n- **Call metadata**: Includes information about the runtime calls defined by the `#[pallet]` macro including call names, arguments and documentation.\n- **Event metadata**: Provides the metadata generated by the `#[pallet::event]` macro, including the name, arguments, and documentation for each pallet event.\n- **Constants metadata**: Provides metadata generated by the `#[pallet::constant]` macro, including the name, type, and hex-encoded value of the constant.\n- **Error metadata**: Provides metadata generated by the `#[pallet::error]` macro, including the name and documentation for each pallet error.\n\n!!!tip\n    Type identifiers change from time to time, so you should avoid relying on specific type identifiers in your applications.\n\n### Extrinsic\n\nThe runtime generates extrinsic metadata and provides useful information about transaction format. When decoded, the metadata contains the transaction version and the list of signed extensions.\n\nFor example:\n\n```json\n-{\n    \"extrinsic\": {\n        \"ty\": 126,\n        \"version\": 4,\n        \"signed_extensions\": [\n            {\n                \"identifier\": \"CheckNonZeroSender\",\n                \"ty\": 132,\n                \"additional_signed\": 41\n            },\n            {\n                \"identifier\": \"CheckSpecVersion\",\n                \"ty\": 133,\n                \"additional_signed\": 4\n            },\n            {\n                \"identifier\": \"CheckTxVersion\",\n                \"ty\": 134,\n                \"additional_signed\": 4\n            },\n            {\n                \"identifier\": \"CheckGenesis\",\n                \"ty\": 135,\n                \"additional_signed\": 11\n            },\n            {\n                \"identifier\": \"CheckMortality\",\n                \"ty\": 136,\n                \"additional_signed\": 11\n            },\n            {\n                \"identifier\": \"CheckNonce\",\n                \"ty\": 138,\n                \"additional_signed\": 41\n            },\n            {\n                \"identifier\": \"CheckWeight\",\n                \"ty\": 139,\n                \"additional_signed\": 41\n            },\n            {\n                \"identifier\": \"ChargeTransactionPayment\",\n                \"ty\": 140,\n                \"additional_signed\": 41\n            }\n        ]\n    },\n    \"ty\": 141\n}\n\n```\n\nThe type system is [composite](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/frame_runtime_types/index.html){target=\\_blank}, meaning each type identifier contains a reference to a specific type or to another type identifier that provides information about the associated primitive types.\n\nFor example, you can encode the `BitVec<Order, Store>` type, but to decode it properly, you must know the types used for the `Order` and `Store` types. To find type information for `Order` and `Store`, you can use the path in the decoded JSON to locate their type identifiers.\n\n## Included RPC APIs\n\nA standard node comes with the following APIs to interact with a node:\n\n- **[`AuthorApiServer`](https://paritytech.github.io/polkadot-sdk/master/sc_rpc/author/trait.AuthorApiServer.html){target=\\_blank}**: Make calls into a full node, including authoring extrinsics and verifying session keys.\n- **[`ChainApiServer`](https://paritytech.github.io/polkadot-sdk/master/sc_rpc/chain/trait.ChainApiServer.html){target=\\_blank}**: Retrieve block header and finality information.\n- **[`OffchainApiServer`](https://paritytech.github.io/polkadot-sdk/master/sc_rpc/offchain/trait.OffchainApiServer.html){target=\\_blank}**: Make RPC calls for off-chain workers.\n- **[`StateApiServer`](https://paritytech.github.io/polkadot-sdk/master/sc_rpc/state/trait.StateApiServer.html){target=\\_blank}**: Query information about on-chain state such as runtime version, storage items, and proofs.\n- **[`SystemApiServer`](https://paritytech.github.io/polkadot-sdk/master/sc_rpc/system/trait.SystemApiServer.html){target=\\_blank}**: Retrieve information about network state, such as connected peers and node roles.\n\n## Additional Resources\n\nThe following tools can help you locate and decode metadata:\n\n- [Subxt Explorer](https://paritytech.github.io/subxt-explorer/#/){target=\\_blank}\n- [Metadata Portal 🌗](https://github.com/paritytech/metadata-portal){target=\\_blank}\n- [De[code] Sub[strate]](https://github.com/paritytech/desub){target=\\_blank}\n"}
{"title": "Create a Smart Contract", "slug": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-smart-contracts-launch-your-first-project-create-contracts.md", "html_url": "https://docs.polkadot.com/tutorials/smart-contracts/launch-your-first-project/create-contracts/", "categories": ["Basics", "Smart Contracts"], "description": "Learn how to write a basic smart contract using just a text editor. This guide covers creating and preparing a contract for deployment on Polkadot Hub.", "estimated_token_count": 1800, "token_estimator": "heuristic-v1", "content": "# Create a Smart Contract\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nCreating [smart contracts](/develop/smart-contracts/overview/){target=\\_blank} is fundamental to blockchain development. While many frameworks and tools are available, understanding how to write a contract from scratch with just a text editor is essential knowledge.\n\nThis tutorial will guide you through creating a basic smart contract that can be used with other tutorials for deployment and integration on Polkadot Hub. To understand how smart contracts work in Polkadot Hub, check the [Smart Contract Basics](/polkadot-protocol/smart-contract-basics/){target=\\_blank} guide for more information.\n\n## Prerequisites\n\nBefore starting, make sure you have:\n\n- A text editor of your choice ([VS Code](https://code.visualstudio.com/){target=\\_blank}, [Sublime Text](https://www.sublimetext.com/){target=\\_blank}, etc.).\n- Basic understanding of programming concepts.\n- Familiarity with the Solidity programming language syntax. For further references, check the official [Solidity documentation](https://docs.soliditylang.org/en/latest/){target=\\_blank}.\n\n## Understanding Smart Contract Structure\n\nLet's explore these components before building the contract:\n\n- **[SPDX license identifier](https://docs.soliditylang.org/en/v0.6.8/layout-of-source-files.html){target=\\_blank}**: A standardized way to declare the license under which your code is released. This helps with legal compliance and is required by the Solidity compiler to avoid warnings.\n- **Pragma directive**: Specifies which version of Solidity compiler should be used for your contract.\n- **Contract declaration**: Similar to a class in object-oriented programming, it defines the boundaries of your smart contract.\n- **State variables**: Data stored directly in the contract that persists between function calls. These represent the contract's \"state\" on the blockchain.\n- **Functions**: Executable code that can read or modify the contract's state variables.\n- **Events**: Notification mechanisms that applications can subscribe to in order to track blockchain changes.\n\n## Create the Smart Contract\n\nIn this section, you'll build a simple storage contract step by step. This basic Storage contract is a great starting point for beginners. It introduces key concepts like state variables, functions, and events in a simple way, demonstrating how data is stored and updated on the blockchain. Later, you'll explore each component in more detail to understand what's happening behind the scenes.\n\nThis contract will:\n\n- Store a number.\n- Allow updating the stored number.\n- Emit an event when the number changes.\n\nTo build the smart contract, follow the steps below:\n\n1. Create a new file named `Storage.sol`.\n\n2. Add the SPDX license identifier at the top of the file:\n\n    ```solidity\n    // SPDX-License-Identifier: MIT\n    ```\n\n    This line tells users and tools which license governs your code. The [MIT license](https://opensource.org/license/mit){target=\\_blank} is commonly used for open-source projects. The Solidity compiler requires this line to avoid licensing-related warnings.\n\n3. Specify the Solidity version:\n\n    ```solidity\n    pragma solidity ^0.8.28;\n    ```\n\n    The caret `^` means \"this version or any compatible newer version.\" This helps ensure your contract compiles correctly with the intended compiler features.\n\n4. Create the contract structure:\n\n    ```solidity\n    contract Storage {\n        // Contract code will go here\n    }\n    ```\n\n    This defines a contract named \"Storage\", similar to how you would define a class in other programming languages.\n\n5. Add the state variables and event:\n\n    ```solidity\n    contract Storage {\n        // State variable to store a number\n        uint256 private number;\n        \n        // Event to notify when the number changes\n        event NumberChanged(uint256 newNumber);\n    }\n    ```\n\n    Here, you're defining:\n\n    - A state variable named `number` of type `uint256` (unsigned integer with 256 bits), which is marked as `private` so it can only be accessed via functions within this contract.\n    - An event named `NumberChanged` that will be triggered whenever the number changes. The event includes the new value as data.\n\n6. Add the getter and setter functions:\n\n    ```solidity\n    -// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract Storage {\n    // State variable to store our number\n    uint256 private number;\n\n    // Event to notify when the number changes\n    event NumberChanged(uint256 newNumber);\n\n    // Function to store a new number\n    function store(uint256 newNumber) public {\n        number = newNumber;\n        emit NumberChanged(newNumber);\n    }\n\n    // Function to retrieve the stored number\n    function retrieve() public view returns (uint256) {\n        return number;\n    }\n}\n    ```\n\n??? code \"Complete Storage.sol contract\"\n\n    ```solidity title=\"Storage.sol\"\n    -// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract Storage {\n    // State variable to store our number\n    uint256 private number;\n\n    // Event to notify when the number changes\n    event NumberChanged(uint256 newNumber);\n\n    // Function to store a new number\n    function store(uint256 newNumber) public {\n        number = newNumber;\n        emit NumberChanged(newNumber);\n    }\n\n    // Function to retrieve the stored number\n    function retrieve() public view returns (uint256) {\n        return number;\n    }\n}\n    ```\n\n## Understanding the Code\n\nLet's break down the key components of the contract:\n\n- **State Variable**\n\n    - **`uint256 private number`**: A private variable that can only be accessed through the contract's functions.\n    - The `private` keyword prevents direct access from other contracts, but it's important to note that while other contracts cannot read this variable directly, the data itself is still visible on the blockchain and can be read by external tools or applications that interact with the blockchain. \"Private\" in Solidity doesn't mean the data is encrypted or truly hidden.\n    - State variables in Solidity are permanent storage on the blockchain, making them different from variables in traditional programming. Every change to a state variable requires a transaction and costs gas (the fee paid for blockchain operations).\n\n- **Event**\n\n    - **`event NumberChanged(uint256 newNumber)`**: Emitted when the stored number changes.\n    - When triggered, events write data to the blockchain's log, which can be efficiently queried by applications.\n    - Unlike state variables, events cannot be read by smart contracts, only by external applications.\n    - Events are much more gas-efficient than storing data when you only need to notify external systems of changes.\n\n- **Functions**\n\n    - **`store(uint256 newNumber)`**: Updates the stored number and emits an event.\n        - This function changes the state of the contract and requires a transaction to execute.\n        - The `emit` keyword is used to trigger the defined event.\n\n    - **`retrieve()`**: Returns the current stored number.\n        - The `view` keyword indicates that this function only reads data and doesn't modify the contract's state.\n        - View functions don't require a transaction and don't cost gas when called externally.\n\n    For those new to Solidity, this naming pattern (getter/setter functions) is a common design pattern. Instead of directly accessing state variables, the convention is to use functions to control access and add additional logic if needed.\n\nThis basic contract serves as a foundation for learning smart contract development. Real-world contracts often require additional security considerations, more complex logic, and thorough testing before deployment.\n\nFor more detailed information about Solidity types, functions, and best practices, refer to the [Solidity documentation](https://docs.soliditylang.org/en/latest/){target=\\_blank} or this [beginner's guide to Solidity](https://www.tutorialspoint.com/solidity/index.htm){target=\\_blank}.\n\n## Where to Go Next\n\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Test and Deploy with Hardhat__\n\n    ---\n\n    Learn how to test and deploy the smart contract you created by using Hardhat.\n\n    [:octicons-arrow-right-24: Get Started](/tutorials/smart-contracts/launch-your-first-project/test-and-deploy-with-hardhat/)\n\n</div>\n"}
{"title": "Cryptography", "slug": "polkadot-protocol-parachain-basics-cryptography", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-cryptography.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/cryptography/", "categories": ["Basics", "Polkadot Protocol"], "description": "A concise guide to cryptography in blockchain, covering hash functions, encryption types, digital signatures, and elliptic curve applications.", "estimated_token_count": 1799, "token_estimator": "heuristic-v1", "content": "# Cryptography\n\n## Introduction\n\nCryptography forms the backbone of blockchain technology, providing the mathematical verifiability crucial for consensus systems, data integrity, and user security. While a deep understanding of the underlying mathematical processes isn't necessary for most blockchain developers, grasping the fundamental applications of cryptography is essential. This page comprehensively overviews cryptographic implementations used across Polkadot SDK-based chains and the broader blockchain ecosystem.\n\n## Hash Functions\n\nHash functions are fundamental to blockchain technology, creating a unique digital fingerprint for any piece of data, including simple text, images, or any other form of file. They map input data of any size to a fixed-size output (typically 32 bytes) using complex mathematical operations. Hashing is used to verify data integrity, create digital signatures, and provide a secure way to store passwords. This form of mapping is known as the [\"pigeonhole principle,\"](https://en.wikipedia.org/wiki/Pigeonhole_principle){target=\\_blank} it is primarily implemented to efficiently and verifiably identify data from large sets.\n\n### Key Properties of Hash Functions\n\n- **Deterministic**: The same input always produces the same output.\n- **Quick computation**: It's easy to calculate the hash value for any given input.\n- **Pre-image resistance**: It's infeasible to generate the input data from its hash.\n- **Small changes in input yield large changes in output**: Known as the [\"avalanche effect\"](https://en.wikipedia.org/wiki/Avalanche_effect){target=\\_blank}.\n- **Collision resistance**: The probabilities are extremely low to find two different inputs with the same hash.\n\n### Blake2\n\nThe Polkadot SDK utilizes Blake2, a state-of-the-art hashing method that offers:\n\n- Equal or greater security compared to [SHA-2](https://en.wikipedia.org/wiki/SHA-2){target=\\_blank}.\n- Significantly faster performance than other algorithms.\n\nThese properties make Blake2 ideal for blockchain systems, reducing sync times for new nodes and lowering the resources required for validation. For detailed technical specifications about Blake2, see the [official Blake2 paper](https://www.blake2.net/blake2.pdf){target=\\_blank}.\n\n## Types of Cryptography\n\nThere are two different ways that cryptographic algorithms are implemented: symmetric cryptography and asymmetric cryptography.\n\n### Symmetric Cryptography\n\nSymmetric encryption is a branch of cryptography that isn't based on one-way functions, unlike asymmetric cryptography. It uses the same cryptographic key to encrypt plain text and decrypt the resulting ciphertext.\n\nSymmetric cryptography is a type of encryption that has been used throughout history, such as the Enigma Cipher and the Caesar Cipher. It is still widely used today and can be found in Web2 and Web3 applications alike. There is only one single key, and a recipient must also have access to it to access the contained information.\n\n#### Advantages {: #symmetric-advantages }\n\n- Fast and efficient for large amounts of data.\n- Requires less computational power.\n\n#### Disadvantages {: #symmetric-disadvantages }\n\n- Key distribution can be challenging.\n- Scalability issues in systems with many users.\n\n### Asymmetric Cryptography\n\nAsymmetric encryption is a type of cryptography that uses two different keys, known as a keypair: a public key, used to encrypt plain text, and a private counterpart, used to decrypt the ciphertext.\n\nThe public key encrypts a fixed-length message that can only be decrypted with the recipient's private key and, sometimes, a set password. The public key can be used to cryptographically verify that the corresponding private key was used to create a piece of data without compromising the private key, such as with digital signatures. This has obvious implications for identity, ownership, and properties and is used in many different protocols across Web2 and Web3.\n\n#### Advantages {: #asymmetric-advantages }\n\n- Solves the key distribution problem.\n- Enables digital signatures and secure key exchange.\n\n#### Disadvantages {: #asymmetric-disadvantages }\n\n- Slower than symmetric encryption.\n- Requires more computational resources.\n\n### Trade-offs and Compromises\n\nSymmetric cryptography is faster and requires fewer bits in the key to achieve the same level of security that asymmetric cryptography provides. However, it requires a shared secret before communication can occur, which poses issues to its integrity and a potential compromise point. On the other hand, asymmetric cryptography doesn't require the secret to be shared ahead of time, allowing for far better end-user security.\n\nHybrid symmetric and asymmetric cryptography is often used to overcome the engineering issues of asymmetric cryptography, as it is slower and requires more bits in the key to achieve the same level of security. It encrypts a key and then uses the comparatively lightweight symmetric cipher to do the \"heavy lifting\" with the message.\n\n## Digital Signatures\n\nDigital signatures are a way of verifying the authenticity of a document or message using asymmetric keypairs. They are used to ensure that a sender or signer's document or message hasn't been tampered with in transit, and for recipients to verify that the data is accurate and from the expected sender.\n\nSigning digital signatures only requires a low-level understanding of mathematics and cryptography. For a conceptual example -- when signing a check, it is expected that it cannot be cashed multiple times. This isn't a feature of the signature system but rather the check serialization system. The bank will check that the serial number on the check hasn't already been used. Digital signatures essentially combine these two concepts, allowing the signature to provide the serialization via a unique cryptographic fingerprint that cannot be reproduced.\n\nUnlike pen-and-paper signatures, knowledge of a digital signature cannot be used to create other signatures. Digital signatures are often used in bureaucratic processes, as they are more secure than simply scanning in a signature and pasting it onto a document.\n\nPolkadot SDK provides multiple different cryptographic schemes and is generic so that it can support anything that implements the [`Pair` trait](https://paritytech.github.io/polkadot-sdk/master/sp_core/crypto/trait.Pair.html){target=\\_blank}.\n\n### Example of Creating a Digital Signature\n\nThe process of creating and verifying a digital signature involves several steps:\n\n1. The sender creates a hash of the message.\n2. The hash is encrypted using the sender's private key, creating the signature.\n3. The message and signature are sent to the recipient.\n4. The recipient decrypts the signature using the sender's public key.\n5. The recipient hashes the received message and compares it to the decrypted hash.\n\nIf the hashes match, the signature is valid, confirming the message's integrity and the sender's identity.\n\n## Elliptic Curve\n\nBlockchain technology requires the ability to have multiple keys creating a signature for block proposal and validation. To this end, Elliptic Curve Digital Signature Algorithm (ECDSA) and Schnorr signatures are two of the most commonly used methods. While ECDSA is a far simpler implementation, Schnorr signatures are more efficient when it comes to multi-signatures.\n\nSchnorr signatures bring some noticeable features over the ECDSA/EdDSA schemes:\n\n- It is better for hierarchical deterministic key derivations.\n- It allows for native multi-signature through [signature aggregation](https://bitcoincore.org/en/2017/03/23/schnorr-signature-aggregation/){target=\\_blank}.\n- It is generally more resistant to misuse.\n\nOne sacrifice that is made when using Schnorr signatures over ECDSA is that both require 64 bytes, but only ECDSA signatures communicate their public key.\n\n### Various Implementations\n\n- **[ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm){target=\\_blank}**: Polkadot SDK provides an ECDSA signature scheme using the [secp256k1](https://en.bitcoin.it/wiki/Secp256k1){target=\\_blank} curve. This is the same cryptographic algorithm used to secure [Bitcoin](https://en.wikipedia.org/wiki/Bitcoin){target=\\_blank} and [Ethereum](https://en.wikipedia.org/wiki/Ethereum){target=\\_blank}.\n\n- **[Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519){target=\\_blank}**: An EdDSA signature scheme using [Curve25519](https://en.wikipedia.org/wiki/Curve25519){target=\\_blank}. It is carefully engineered at several levels of design and implementation to achieve very high speeds without compromising security.\n\n- **[SR25519](https://research.web3.foundation/Polkadot/security/keys/accounts-more){target=\\_blank}**: Based on the same underlying curve as Ed25519. However, it uses Schnorr signatures instead of the EdDSA scheme.\n"}
{"title": "Data Encoding", "slug": "polkadot-protocol-parachain-basics-data-encoding", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-data-encoding.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/data-encoding/", "categories": ["Basics", "Polkadot Protocol"], "description": "SCALE codec enables fast, efficient data encoding, ideal for resource-constrained environments like Wasm, supporting custom types and compact encoding.", "estimated_token_count": 3217, "token_estimator": "heuristic-v1", "content": "# Data Encoding\n\n## Introduction\n\nThe Polkadot SDK uses a lightweight and efficient encoding/decoding mechanism to optimize data transmission across the network. This mechanism, known as the _SCALE_ codec, is used for serializing and deserializing data.\n\nThe SCALE codec enables communication between the runtime and the outer node. This mechanism is designed for high-performance, copy-free data encoding and decoding in resource-constrained environments like the Polkadot SDK [Wasm runtime](/develop/parachains/deployment/build-deterministic-runtime/#introduction){target=\\_blank}.\n\nIt is not self-describing, meaning the decoding context must fully know the encoded data types. \n\nParity's libraries utilize the [`parity-scale-codec`](https://github.com/paritytech/parity-scale-codec){target=\\_blank} crate (a Rust implementation of the SCALE codec) to handle encoding and decoding for interactions between RPCs and the runtime.\n\nThe `codec` mechanism is ideal for Polkadot SDK-based chains because:\n\n- It is lightweight compared to generic serialization frameworks like [`serde`](https://serde.rs/){target=\\_blank}, which add unnecessary bulk to binaries.\n- It doesn’t rely on Rust’s `libstd`, making it compatible with `no_std` environments like Wasm runtime.\n- It integrates seamlessly with Rust, allowing easy derivation of encoding and decoding logic for new types using `#[derive(Encode, Decode)]`.\n\nDefining a custom encoding scheme in the Polkadot SDK-based chains, rather than using an existing Rust codec library, is crucial for enabling cross-platform and multi-language support. \n\n## SCALE Codec\n\nThe codec is implemented using the following traits:\n\n- [`Encode`](#encode)\n- [`Decode`](#decode)\n- [`CompactAs`](#compactas)\n- [`HasCompact`](#hascompact)\n- [`EncodeLike`](#encodelike)\n\n### Encode\n\nThe [`Encode`](https://docs.rs/parity-scale-codec/latest/parity_scale_codec/trait.Encode.html){target=\\_blank} trait handles data encoding into SCALE format and includes the following key functions:\n\n- **`size_hint(&self) -> usize`**: Estimates the number of bytes required for encoding to prevent multiple memory allocations. This should be inexpensive and avoid complex operations. Optional if the size isn’t known.\n- **`encode_to<T: Output>(&self, dest: &mut T)`**: Encodes the data, appending it to a destination buffer.\n- **`encode(&self) -> Vec<u8>`**: Encodes the data and returns it as a byte vector.\n- **`using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R`**: Encodes the data and passes it to a closure, returning the result.\n- **`encoded_size(&self) -> usize`**: Calculates the encoded size. Should be used when the encoded data isn’t required.\n\n!!!tip\n    For best performance, value types should override `using_encoded`, and allocating types should override `encode_to`. It's recommended to implement `size_hint` for all types where possible.\n\n### Decode\n\nThe [`Decode`](https://docs.rs/parity-scale-codec/latest/parity_scale_codec/trait.Decode.html){target=\\_blank} trait handles decoding SCALE-encoded data back into the appropriate types:\n\n- **`fn decode<I: Input>(value: &mut I) -> Result<Self, Error>`**: Decodes data from the SCALE format, returning an error if decoding fails.\n\n### CompactAs\n\nThe [`CompactAs`](https://docs.rs/parity-scale-codec/latest/parity_scale_codec/trait.CompactAs.html){target=\\_blank} trait wraps custom types for compact encoding:\n\n- **`encode_as(&self) -> &Self::As`**: Encodes the type as a compact type.\n- **`decode_from(_: Self::As) -> Result<Self, Error>`**: decodes from a compact encoded type.\n\n### HasCompact\n\nThe [`HasCompact`](https://docs.rs/parity-scale-codec/latest/parity_scale_codec/trait.HasCompact.html){target=\\_blank} trait indicates a type supports compact encoding.\n\n### EncodeLike\n\nThe [`EncodeLike`](https://docs.rs/parity-scale-codec/latest/parity_scale_codec/trait.EncodeLike.html){target=\\_blank} trait is used to ensure multiple types that encode similarly are accepted by the same function. When using `derive`, it is automatically implemented.\n\n### Data Types\n\nThe table below outlines how the Rust implementation of the Parity SCALE codec encodes different data types.\n\n| Type                          | Description                                                                                                                                                                                                                                                                                                                | Example SCALE Decoded Value                                                                                                                        | SCALE Encoded Value                                                     |\n|-------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------|\n| Boolean                       | Boolean values are encoded using the least significant bit of a single byte.                                                                                                                                                                                                                                               | `false` / `true`                                                                                                                                   | `0x00` / `0x01`                                                         |\n| Compact/general integers      | A \"compact\" or general integer encoding is sufficient for encoding large integers (up to 2^536) and is more efficient at encoding most values than the fixed-width version.                                                                                                                                                | `unsigned integer 0` / `unsigned integer 1` / `unsigned integer 42` / `unsigned integer 69` / `unsigned integer 65535` / `BigInt(100000000000000)` | `0x00` / `0x04` / `0xa8` / `0x1501` / `0xfeff0300` / `0x0b00407a10f35a` |\n| Enumerations (tagged-unions)  | A fixed number of variants, each mutually exclusive and potentially implying a further value or series of values. Encoded as the first byte identifying the index of the variant that the value is. Any further bytes are used to encode any data that the variant implies. Thus, no more than 256 variants are supported. | `Int(42)` and `Bool(true)` where `enum IntOrBool { Int(u8), Bool(bool) }`                                                                          | `0x002a` and `0x0101`                                                   |\n| Fixed-width integers          | Basic integers are encoded using a fixed-width little-endian (LE) format.                                                                                                                                                                                                                                                  | `signed 8-bit integer 69` / `unsigned 16-bit integer 42` / `unsigned 32-bit integer 16777215`                                                      | `0x45` / `0x2a00` / `0xffffff00`                                        |\n| Options                       | One or zero values of a particular type.                                                                                                                                                                                                                                                                                   | `Some` / `None`                                                                                                                                    | `0x01` followed by the encoded value / `0x00`                           |\n| Results                       | Results are commonly used enumerations which indicate whether certain operations were successful or unsuccessful.                                                                                                                                                                                                          | `Ok(42)` / `Err(false)`                                                                                                                            | `0x002a` / `0x0100`                                                     |\n| Strings                       | Strings are Vectors of bytes (Vec<u8>) containing a valid UTF8 sequence.                                                                                                                                                                                                                                                   |                                                                                                                                                    |                                                                         |\n| Structs                       | For structures, the values are named, but that is irrelevant for the encoding (names are ignored - only order matters).                                                                                                                                                                                                    | `SortedVecAsc::from([3, 5, 2, 8])`                                                                                                                 | `[3, 2, 5, 8] `                                                         |\n| Tuples                        | A fixed-size series of values, each with a possibly different but predetermined and fixed type. This is simply the concatenation of each encoded value.                                                                                                                                                                    | Tuple of compact unsigned integer and boolean: `(3, false)`                                                                                        | `0x0c00`                                                                |\n| Vectors (lists, series, sets) | A collection of same-typed values is encoded, prefixed with a compact encoding of the number of items, followed by each item's encoding concatenated in turn.                                                                                                                                                              | Vector of unsigned `16`-bit integers: `[4, 8, 15, 16, 23, 42]`                                                                                     | `0x18040008000f00100017002a00`                                          |\n\n## Encode and Decode Rust Trait Implementations\n\nHere's how the `Encode` and `Decode` traits are implemented:\n\n\n```rust\n-use parity_scale_codec::{Encode, Decode};\n\n[derive(Debug, PartialEq, Encode, Decode)]\nenum EnumType {\n    #[codec(index = 15)]\n    A,\n    B(u32, u64),\n    C {\n        a: u32,\n        b: u64,\n    },\n}\n\nlet a = EnumType::A;\nlet b = EnumType::B(1, 2);\nlet c = EnumType::C { a: 1, b: 2 };\n\na.using_encoded(|ref slice| {\n    assert_eq!(slice, &b\"\\x0f\");\n});\n\nb.using_encoded(|ref slice| {\n    assert_eq!(slice, &b\"\\x01\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\");\n});\n\nc.using_encoded(|ref slice| {\n    assert_eq!(slice, &b\"\\x02\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\");\n});\n\nlet mut da: &[u8] = b\"\\x0f\";\nassert_eq!(EnumType::decode(&mut da).ok(), Some(a));\n\nlet mut db: &[u8] = b\"\\x01\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\";\nassert_eq!(EnumType::decode(&mut db).ok(), Some(b));\n\nlet mut dc: &[u8] = b\"\\x02\\x01\\0\\0\\0\\x02\\0\\0\\0\\0\\0\\0\\0\";\nassert_eq!(EnumType::decode(&mut dc).ok(), Some(c));\n\nlet mut dz: &[u8] = &[0];\nassert_eq!(EnumType::decode(&mut dz).ok(), None);\n```\n\n## SCALE Codec Libraries\n\nSeveral SCALE codec implementations are available in various languages. Here's a list of them:\n\n- **AssemblyScript**: [`LimeChain/as-scale-codec`](https://github.com/LimeChain/as-scale-codec){target=\\_blank}\n- **C**: [`MatthewDarnell/cScale`](https://github.com/MatthewDarnell/cScale){target=\\_blank}\n- **C++**: [`qdrvm/scale-codec-cpp`](https://github.com/qdrvm/scale-codec-cpp){target=\\_blank}\n- **JavaScript**: [`polkadot-js/api`](https://github.com/polkadot-js/api){target=\\_blank}\n- **Dart**: [`leonardocustodio/polkadart`](https://github.com/leonardocustodio/polkadart){target=\\_blank}\n- **Haskell**: [`airalab/hs-web3`](https://github.com/airalab/hs-web3/tree/master/packages/scale){target=\\_blank}\n- **Golang**: [`itering/scale.go`](https://github.com/itering/scale.go){target=\\_blank}\n- **Java**: [`splix/polkaj`](https://github.com/splix/polkaj){target=\\_blank}\n- **Python**: [`polkascan/py-scale-codec`](https://github.com/polkascan/py-scale-codec){target=\\_blank}\n- **Ruby**: [` wuminzhe/scale_rb`](https://github.com/wuminzhe/scale_rb){target=\\_blank}\n- **TypeScript**: [`parity-scale-codec-ts`](https://github.com/tjjfvi/subshape){target=\\_blank}, [`scale-ts`](https://github.com/unstoppablejs/unstoppablejs/tree/main/packages/scale-ts#scale-ts){target=\\_blank}, [`soramitsu/scale-codec-js-library`](https://github.com/soramitsu/scale-codec-js-library){target=\\_blank}, [`subsquid/scale-codec`](https://github.com/subsquid/squid-sdk/tree/master/substrate/scale-codec){target=\\_blank}\n"}
{"title": "Deploy an ERC-20 to Polkadot Hub", "slug": "tutorials-smart-contracts-deploy-erc20", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-smart-contracts-deploy-erc20.md", "html_url": "https://docs.polkadot.com/tutorials/smart-contracts/deploy-erc20/", "categories": ["Basics", "dApps", "Smart Contracts", "Tutorial"], "description": "Deploy an ERC-20 token on Polkadot Hub using PolkaVM. This guide covers contract creation, compilation, deployment, and interaction via Polkadot Remix IDE.", "estimated_token_count": 2099, "token_estimator": "heuristic-v1", "content": "# Deploy an ERC-20 to Polkadot Hub\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\n[ERC-20](https://eips.ethereum.org/EIPS/eip-20){target=\\_blank} tokens are fungible tokens commonly used for creating cryptocurrencies, governance tokens, and staking mechanisms. Polkadot Hub enables easy token deployment with Ethereum-compatible smart contracts via PolkaVM.\n\nThis tutorial covers deploying an ERC-20 contract on the Polkadot Hub TestNet using [Polkadot Remix IDE](https://remix.polkadot.io){target=\\_blank}, a web-based development tool. [OpenZeppelin's ERC-20 contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0/contracts/token/ERC20){target=\\_blank} are used for security and compliance.\n\n## Prerequisites\n\nBefore starting, make sure you have:\n\n- [MetaMask](https://metamask.io/){target=\\_blank} installed and connected to Polkadot Hub. For detailed instructions, see the [Connect Your Wallet](/develop/smart-contracts/wallets){target=\\_blank} section.\n- A funded account with some PAS tokens (you can get them from the [Polkadot Faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}). To learn how to get test tokens, check out the [Test Tokens](/develop/smart-contracts/connect-to-polkadot#test-tokens){target=\\_blank} section.\n- Basic understanding of Solidity and fungible tokens.\n\n## Create the ERC-20 Contract\n\nTo create the ERC-20 contract, you can follow the steps below:\n\n1. Navigate to the [Polkadot Remix IDE](https://remix.polkadot.io){target=\\_blank}.\n2. Click in the **Create new file** button under the **contracts** folder, and name your contract as `MyToken.sol`.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-1.webp)\n\n3. Now, paste the following ERC-20 contract code into the editor:\n\n    ```solidity title=\"MyToken.sol\"\n    -// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.22;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyToken is ERC20, Ownable {\n    constructor(address initialOwner)\n        ERC20(\"MyToken\", \"MTK\")\n        Ownable(initialOwner)\n    {}\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n    ```\n\n    The key components of the code above are:\n\n    - Contract imports:\n\n        - **[`ERC20.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0/contracts/token/ERC20/ERC20.sol){target=\\_blank}**: The base contract for fungible tokens, implementing core functionality like transfers, approvals, and balance tracking.\n        - **[`Ownable.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0/contracts/access/Ownable.sol){target=\\_blank}**: Provides basic authorization control, ensuring only the contract owner can mint new tokens.\n    \n    - Constructor parameters:\n\n        - **`initialOwner`**: Sets the address that will have administrative rights over the contract.\n        - **`\"MyToken\"`**: The full name of your token.\n        - **`\"MTK\"`**: The symbol representing your token in wallets and exchanges.\n\n    - Key functions:\n\n        - **`mint(address to, uint256 amount)`**: Allows the contract owner to create new tokens for any address. The amount should include 18 decimals (e.g., 1 token = 1000000000000000000).\n        - Inherited [Standard ERC-20](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/){target=\\_blank} functions:\n            - **`transfer(address recipient, uint256 amount)`**: Sends a specified amount of tokens to another address.\n            - **`approve(address spender, uint256 amount)`**: Grants permission for another address to spend a specific number of tokens on behalf of the token owner.\n            - **`transferFrom(address sender, address recipient, uint256 amount)`**: Transfers tokens from one address to another, if previously approved.\n            - **`balanceOf(address account)`**: Returns the token balance of a specific address.\n            - **`allowance(address owner, address spender)`**: Checks how many tokens an address is allowed to spend on behalf of another address.\n\n    !!! tip\n        Use the [OpenZeppelin Contracts Wizard](https://wizard.openzeppelin.com/){target=\\_blank} to quickly generate customized smart contracts. Simply configure your contract, copy the generated code, and paste it into Polkadot Remix IDE for deployment. Below is an example of an ERC-20 token contract created with it:\n\n        ![Screenshot of the OpenZeppelin Contracts Wizard showing an ERC-20 contract configuration.](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-2.webp)\n        \n\n## Compile the Contract\n\nThe compilation transforms your Solidity source code into bytecode that can be deployed on the blockchain. During this process, the compiler checks your contract for syntax errors, ensures type safety, and generates the machine-readable instructions needed for blockchain execution. To compile your contract, follow the instructions below:\n\n1. Select the **Solidity Compiler** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-3.webp)\n\n2. Click the **Compile MyToken.sol** button.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-4.webp)\n\n3. If the compilation succeeded, you'll see a green checkmark indicating success in the **Solidity Compiler** icon.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-5.webp)\n\n## Deploy the Contract\n\nDeployment is the process of publishing your compiled smart contract to the blockchain, making it permanently available for interaction. During deployment, you'll create a new instance of your contract on the blockchain, which involves:\n\n1. Select the **Deploy & Run Transactions** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-6.webp)\n\n2. Configure the deployment settings.\n    1. From the **ENVIRONMENT** dropdown, select **Injected Provider - Talisman** (check the [Deploying Contracts](/develop/smart-contracts/dev-environments/remix/#deploying-contracts){target=\\_blank} section of the Remix IDE guide for more details).\n    2. From the **ACCOUNT** dropdown, select the account you want to use for the deploy.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-7.webp)\n\n3. Configure the contract parameters:\n\n    1. Enter the address that will own the deployed token contract.\n    2. Click the **Deploy** button to initiate the deployment.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-8.webp)\n\n4. **Talisman will pop up**: Review the transaction details. Click **Approve** to deploy your contract.\n\n     ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-9.webp){: .browser-extension}\n\n    If the deployment process succeeded, you will see the transaction details in the terminal, including the contract address and deployment transaction hash:\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-10.webp)\n\n## Interact with Your ERC-20 Contract\n\nOnce deployed, you can interact with your contract through Remix:\n\n1. Find your contract under **Deployed/Unpinned Contracts**, and click it to expand the available methods.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-11.webp)\n\n2. To mint new tokens:\n\n    1. Click in the contract to expand its associated methods.\n    2. Expand the **mint** function.\n    3. Enter:\n        - The recipient address.\n        - The amount (remember to add 18 zeros for 1 whole token).\n    4. Click **Transact**.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-12.webp)\n\n3. Click **Approve** to confirm the transaction in the Talisman popup.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-13.webp){: .browser-extension}\n\n    If the transaction succeeds, you will see the following output in the terminal:\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-14.webp)\n\nOther common functions you can use:\n\n- **`balanceOf(address)`**: Check token balance of any address.\n- **`transfer(address to, uint256 amount)`**: Send tokens to another address.\n- **`approve(address spender, uint256 amount)`**: Allow another address to spend your tokens.\n\nFeel free to explore and interact with the contract's other functions using the same approach - selecting the method, providing any required parameters, and confirming the transaction through Talisman when needed.\n"}
{"title": "Deploy an NFT to Polkadot Hub", "slug": "tutorials-smart-contracts-deploy-nft", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-smart-contracts-deploy-nft.md", "html_url": "https://docs.polkadot.com/tutorials/smart-contracts/deploy-nft/", "categories": ["Basics", "dApps", "Smart Contracts", "Tutorial"], "description": "Deploy an NFT on Polkadot Hub using PolkaVM and OpenZeppelin. Learn how to compile, deploy, and interact with your contract using Polkadot Remix IDE.", "estimated_token_count": 2261, "token_estimator": "heuristic-v1", "content": "# Deploy an NFT to Polkadot Hub\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nNon-Fungible Tokens (NFTs) represent unique digital assets commonly used for digital art, collectibles, gaming, and identity verification. Polkadot Hub supports Ethereum-compatible smart contracts through PolkaVM, enabling straightforward NFT deployment.\n\nThis tutorial guides you through deploying an [ERC-721](https://eips.ethereum.org/EIPS/eip-721){target=\\_blank} NFT contract on the Polkadot Hub TestNet using the [Polkadot Remix IDE](https://remix.polkadot.io){target=\\_blank}, a web-based development environment. To ensure security and standard compliance, it uses [OpenZeppelin's NFT contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0){target=\\_blank} implementation.\n\n## Prerequisites\n\nBefore starting, make sure you have:\n\n- [Talisman](https://talisman.xyz/){target=\\_blank} installed and connected to the Polkadot Hub TestNet. Check the [Connect to Polkadot](/develop/smart-contracts/connect-to-polkadot/){target=\\_blank} guide for more information.\n- A funded account with some PAS tokens (you can get them from the [Faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}, noting that the faucet imposes a daily token limit, which may require multiple requests to obtain sufficient funds for testing).\n- Basic understanding of Solidity and NFTs, see the [Solidity Basics](https://soliditylang.org/){target=\\_blank} and the [NFT Overview](https://ethereum.org/en/nft/){target=\\_blank} guides for more details.\n\n## Create the NFT Contract\n\nTo create the NFT contract, you can follow the steps below:\n\n1. Navigate to the [Polkadot Remix IDE](https://remix.polkadot.io/){target=\\_blank}.\n2. Click in the **Create new file** button under the **contracts** folder, and name your contract as `MyNFT.sol`.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-1.webp)\n\n3. Now, paste the following NFT contract code into the editor.\n\n    ```solidity title=\"MyNFT.sol\"\n    -// SPDX-License-Identifier: MIT\n// Compatible with OpenZeppelin Contracts ^5.0.0\npragma solidity ^0.8.22;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MyToken is ERC721, Ownable {\n    uint256 private _nextTokenId;\n\n    constructor(address initialOwner)\n        ERC721(\"MyToken\", \"MTK\")\n        Ownable(initialOwner)\n    {}\n\n    function safeMint(address to) public onlyOwner {\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n    }\n}\n    ```\n\n    The key components of the code above are:\n\n    - Contract imports:\n\n        - **[`ERC721.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/token/ERC721/ERC721.sol){target=\\_blank}**: The base contract for non-fungible tokens, implementing core NFT functionality like transfers and approvals.\n        - **[`Ownable.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/access/Ownable.sol){target=\\_blank}**: Provides basic authorization control, ensuring only the contract owner can mint new tokens.\n    \n    - Constructor parameters:\n\n        - **`initialOwner`**: Sets the address that will have administrative rights over the contract.\n        - **`\"MyToken\"`**: The full name of your NFT collection.\n        - **`\"MTK\"`**: The symbol representing your token in wallets and marketplaces.\n\n    - Key functions:\n\n        - **[`_safeMint(to, tokenId)`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/token/ERC721/ERC721.sol#L304){target=\\_blank}**: An internal function from `ERC721` that safely mints new tokens. It includes checks to ensure the recipient can handle `ERC721` tokens, with the `_nextTokenId` mechanism automatically generating unique sequential token IDs and the `onlyOwner` modifier restricting minting rights to the contract owner.\n        - Inherited [Standard ERC721](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/){target=\\_blank} functions provide a standardized set of methods that enable interoperability across different platforms, wallets, and marketplaces, ensuring that your NFT can be easily transferred, traded, and managed by any system that supports the `ERC721` standard:\n            - **`transferFrom(address from, address to, uint256 tokenId)`**: Transfers a specific NFT from one address to another.\n            - **`safeTransferFrom(address from, address to, uint256 tokenId)`**: Safely transfers an NFT, including additional checks to prevent loss.\n            - **`approve(address to, uint256 tokenId)`**: Grants permission for another address to transfer a specific NFT.\n            - **`setApprovalForAll(address operator, bool approved)`**: Allows an address to manage all of the owner's NFTs.\n            - **`balanceOf(address owner)`**: Returns the number of NFTs owned by a specific address.\n            - **`ownerOf(uint256 tokenId)`**: Returns the current owner of a specific NFT.\n\n    !!! tip\n        Use the [OpenZeppelin Contracts Wizard](https://wizard.openzeppelin.com/){target=\\_blank} to generate customized smart contracts quickly. Simply configure your contract, copy the generated code, and paste it into Polkadot Remix IDE for deployment. Below is an example of an ERC-721 token contract created with it:\n\n        ![Screenshot of the OpenZeppelin Contracts Wizard showing an ERC-721 contract configuration.](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-2.webp)\n\n\n## Compile the Contract\n\nCompilation is a stage that converts your Solidity source code into bytecode suitable for deployment on the blockchain. Throughout this process, the compiler examines your contract for syntax errors, verifies type safety, and produces machine-readable instructions for execution on the blockchain.\n\n1. Select the **Solidity Compiler** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-3.webp)\n\n2. Click in the **Compile MyNFT.sol** button.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-4.webp)\n\n3. If the compilation succeeded, you can see a green checkmark indicating success in the **Solidity Compiler** icon.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-5.webp)\n\n## Deploy the Contract\n\nDeployment is the process of uploading your compiled smart contract to the blockchain, allowing for interaction. During deployment, you will instantiate your contract on the blockchain, which involves:\n\n1. Select the **Deploy & Run Transactions** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-6.webp)\n\n2. Configure the deployment settings:\n\n    1. From the **ENVIRONMENT** dropdown, select **Injected Provider - Talisman** (check the [Deploying Contracts](/develop/smart-contracts/dev-environments/remix/#deploying-contracts){target=\\_blank} section of the Remix IDE guide for more details).\n    2. From the **ACCOUNT** dropdown, select the account you want to use for the deploy.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-7.webp)\n\n3. Configure the contract parameters:\n\n    1. Enter the address that will own the deployed NFT.\n    2. Click the **Deploy** button to initiate the deployment.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-8.webp)\n\n4. **Talisman will pop up**: Review the transaction details. Click **Approve** to deploy your contract.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-9.webp){: .browser-extension}\n\n    Deploying this contract requires paying gas fees in PAS tokens on the Polkadot Hub TestNet. Ensure your Talisman account is funded with sufficient PAS tokens from the faucet before confirming the transaction, check the [Test Tokens](/develop/smart-contracts/connect-to-polkadot/#test-tokens){target=\\_blank} section for more information. Gas fees cover the computational resources needed to deploy and execute the smart contract on the blockchain.\n\n    If the deployment process succeeded, you will see the following output in the terminal:\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-10.webp)\n\n## Interact with Your NFT Contract\n\nOnce deployed, you can interact with your contract through Remix:\n\n1. Find your contract under **Deployed/Unpinned Contracts**, and click it to expand the available methods for the contract.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-11.webp)\n\n2. To mint an NFT:\n\n    1. Click on the contract to expand its associated methods.\n    2. Expand the **safeMint** function.\n    3. Enter the recipient address.\n    4. Click **Transact**.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-12.webp)\n\n3. Click **Approve** to confirm the transaction in the Talisman popup.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-13.webp){: .browser-extension}\n\n    If the transaction is successful, the terminal will display the following output, which details the information about the transaction, including the transaction hash, the block number, the associated logs, and so on.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-14.webp)\n\nFeel free to explore and interact with the contract's other functions using the same approach - selecting the method, providing any required parameters, and confirming the transaction through Talisman when needed.\n"}
{"title": "EVM vs PolkaVM", "slug": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-smart-contract-basics-evm-vs-polkavm.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/smart-contract-basics/evm-vs-polkavm/", "categories": ["Basics", "Polkadot Protocol"], "description": "Compares EVM and PolkaVM, highlighting key architectural differences, gas models, memory management, and account handling while ensuring Solidity compatibility.", "estimated_token_count": 5340, "token_estimator": "heuristic-v1", "content": "# EVM vs PolkaVM\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nWhile [PolkaVM](/polkadot-protocol/smart-contract-basics/polkavm-design/){target=\\_blank} strives for maximum Ethereum compatibility, several fundamental design decisions create necessary divergences from the [EVM](https://ethereum.org/en/developers/docs/evm/){target=\\_blank}. These differences represent trade-offs that enhance performance and resource management while maintaining accessibility for Solidity developers.\n\n## Core Virtual Machine Architecture\n\nThe most significant departure from Ethereum comes from PolkaVM's foundation itself. Rather than implementing the EVM, PolkaVM utilizes a RISC-V instruction set. For most Solidity developers, this architectural change remains transparent thanks to the [Revive compiler's](https://github.com/paritytech/revive){target=\\_blank} complete Solidity support, including inline assembler functionality.\n\n```mermaid\ngraph TD\n    subgraph \"Ethereum Path\"\n        EthCompile[\"Standard Solidity Compiler\"] --> EVM_Bytecode[\"EVM Bytecode\"]\n        EVM_Bytecode --> EVM[\"Stack-based EVM\"]\n        EVM --> EthExecution[\"Contract Execution\"]\n    end\n\n    subgraph \"PolkaVM Path\"\n        ReviveCompile[\"Revive Compiler\"] --> RISCV_Bytecode[\"RISC-V Format Bytecode\"]\n        RISCV_Bytecode --> PolkaVM[\"RISC-V Based PolkaVM\"]\n        PolkaVM --> PolkaExecution[\"Contract Execution\"]\n    end\n\n    EthExecution -.-> DifferencesNote[\"Key Differences:\n    - Instruction Set Architecture\n    - Bytecode Format\n    - Runtime Behavior\"]\n    PolkaExecution -.-> DifferencesNote\n```\n\nHowever, this architectural difference becomes relevant in specific scenarios. Tools that attempt to download and inspect contract bytecode will fail, as they expect EVM bytecode rather than PolkaVM's RISC-V format. Most applications typically pass bytecode as an opaque blob, making this a non-issue for standard use cases.\n\nThis primarily affects contracts using [`EXTCODECOPY`](https://www.evm.codes/?fork=cancun#3c){target=\\_blank} to manipulate code at runtime. A contract encounters problems specifically when it uses `EXTCODECOPY` to copy contract code into memory and then attempts to mutate it. This pattern is not possible in standard Solidity and requires dropping down to YUL assembly. An example would be a factory contract written in assembly that constructs and instantiates new contracts by generating code at runtime. Such contracts are rare in practice.\n\nPolkaVM offers an elegant alternative through its [on-chain constructors](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/struct.Pallet.html#method.bare_instantiate){target=\\_blank}, enabling contract instantiation without runtime code modification, making this pattern unnecessary. This architectural difference also impacts how contract deployment works more broadly, as discussed in the [Contract Deployment](#contract-deployment) section.\n\n### High-Level Architecture Comparison\n\n|            Feature            |                            Ethereum Virtual Machine (EVM)                            |                        PolkaVM                         |\n|:-----------------------------:|:------------------------------------------------------------------------------------:|:------------------------------------------------------:|\n|      **Instruction Set**      |                               Stack-based architecture                               |                 RISC-V instruction set                 |\n|      **Bytecode Format**      |                                     EVM bytecode                                     |                     RISC-V format                      |\n|    **Contract Size Limit**    |                                 24KB code size limit                                 |            Contract-specific memory limits             |\n|         **Compiler**          |                                  Solidity Compiler                                   |                    Revive Compiler                     |\n|      **Inline Assembly**      |                                      Supported                                       |         Supported with the compatibility layer         |\n|    **Code Introspection**     | Supported via [`EXTCODECOPY`](https://www.evm.codes/?fork=cancun#3c){target=\\_blank} | Limited support, alternative via on-chain constructors |\n|     **Resource Metering**     |                                  Single gas metric                                   |                   Multi-dimensional                    |\n| **Runtime Code Modification** |                                      Supported                                       |               Limited, with alternatives               |\n|  **Contract Instantiation**   |                                 Standard deployment                                  |    On-chain constructors for flexible instantiation    |\n\n## Gas Model\n\nEthereum's resource model relies on a single metric: [gas](https://ethereum.org/en/developers/docs/gas/#what-is-gas){target=\\_blank}, which serves as the universal unit for measuring computational costs. Each operation on the network consumes a specific amount of gas. Most platforms aiming for Ethereum compatibility typically adopt identical gas values to ensure seamless integration.\n\nThe significant changes to Ethereum's gas model will be outlined in the following sections.\n\n### Dynamic Gas Value Scaling\n\nInstead of adhering to Ethereum's fixed gas values, PolkaVM implements benchmark-based pricing that better reflects its improved execution performance. This makes instructions cheaper relative to I/O-bound operations but requires developers to avoid hardcoding gas values, particularly in cross-contract calls.\n\n### Multi-Dimensional Resource Metering\n\nMoving beyond Ethereum's single gas metric, PolkaVM meters three distinct resources:\n\n- **`ref_time`**: Equivalent to traditional gas, measuring computation time.\n- **`proof_size`**: Tracks state proof size for validator verification.\n- **`storage_deposit`**: Manages state bloat through a deposit system.\n\nAll three resources can be limited at the transaction level, just like gas on Ethereum. The [Ethereum RPC proxy](https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/revive/rpc){target=\\_blank} maps all three dimensions into the single gas dimension, ensuring everything behaves as expected for users.\n\nThese resources can also be limited when making cross-contract calls, which is essential for security when interacting with untrusted contracts. However, Solidity only allows specifying `gas_limit` for cross-contract calls. The `gas_limit` is most similar to Polkadots `ref_time_limit`, but the Revive compiler doesn't supply any imposed `gas_limit` for cross-contract calls for two key reasons:\n\n- **Semantic differences**: `gas_limit` and `ref_time_limit` are not semantically identical; blindly passing EVM gas as `ref_time_limit` can lead to unexpected behavior.\n- **Incomplete protection**: The other two resources (`proof_size` and `storage_deposit`) would remain uncapped anyway, making it insufficient to prevent malicious callees from performing DOS attacks.\n\nWhen resources are \"uncapped\" in cross-contract calls, they remain constrained by transaction-specified limits, preventing abuse of the transaction signer.\n\n!!! note\n    The runtime will provide a special precompile, allowing cross-contract calls with limits specified for all weight dimensions in the future.\n\nAll gas-related opcodes like [`GAS`](https://www.evm.codes/?fork=cancun#5a){target=\\_blank} or [`GAS_LIMIT`](https://www.evm.codes/?fork=cancun#45){target=\\_blank} return only the `ref_time` value as it's the closest match to traditional gas. Extended APIs will be provided through precompiles to make full use of all resources, including cross-contract calls with all three resources specified.\n\n## Memory Management\n\nThe EVM and the PolkaVM take fundamentally different approaches to memory constraints:\n\n|         Feature          |      Ethereum Virtual Machine (EVM)       |                    PolkaVM                     |\n|:------------------------:|:-----------------------------------------:|:----------------------------------------------:|\n|  **Memory Constraints**  |      Indirect control via gas costs       |        Hard memory limits per contract         |\n|      **Cost Model**      | Increasing gas curve with allocation size |    Fixed costs separated from execution gas    |\n|    **Memory Limits**     | Soft limits through prohibitive gas costs |         Hard fixed limits per contract         |\n|  **Pricing Efficiency**  |     Potential overcharging for memory     | More efficient through separation of concerns  |\n|   **Contract Nesting**   |         Limited by available gas          |    Limited by constant memory per contract     |\n|   **Memory Metering**    |     Dynamic based on total allocation     |      Static limits per contract instance       |\n| **Future Improvements**  |       Incremental gas cost updates        | Potential dynamic metering for deeper nesting  |\n| **Cross-Contract Calls** |      Handled through gas forwarding       | Requires careful boundary limit implementation |\n\nThe architecture establishes a constant memory limit per contract, which is the basis for calculating maximum contract nesting depth. This calculation assumes worst-case memory usage for each nested contract, resulting in a straightforward but conservative limit that operates independently of actual memory consumption. Future iterations may introduce dynamic memory metering, allowing deeper nesting depths for contracts with smaller memory footprints. However, such an enhancement would require careful implementation of cross-contract boundary limits before API stabilization, as it would introduce an additional resource metric to the system.\n\n### Current Memory Limits\n\nThe following table depicts memory-related limits at the time of writing:\n\n|                   Limit                    |     Maximum     |\n|:------------------------------------------:|:---------------:|\n|              Call stack depth              |        5        |\n|                Event topics                |        4        |\n| Event data payload size (including topics) |    416 bytes    |\n|             Storage value size             |    416 bytes    |\n|        Transient storage variables         | 128 uint values |\n|            Immutable variables             | 16 uint values  |\n|          Contract code blob size           | ~100 kilobytes  |\n\n!!! note\n    Limits might be increased in the future. To guarantee existing contracts work as expected, limits will never be decreased.\n\n## Account Management - Existential Deposit\n\nEthereum and Polkadot handle account persistence differently, affecting state management and contract interactions:\n\n### Account Management Comparison\n\n|          Feature          |                   Ethereum Approach                   |               PolkaVM/Polkadot Approach                |\n|:-------------------------:|:-----------------------------------------------------:|:------------------------------------------------------:|\n|  **Account Persistence**  | Accounts persist indefinitely, even with zero balance | Requires existential deposit (ED) to maintain account  |\n|    **Minimum Balance**    |                         None                          |                      ED required                       |\n|   **Account Deletion**    |               Accounts remain in state                |      Accounts below ED are automatically deleted       |\n|   **Contract Accounts**   |                  Exist indefinitely                   |                    Must maintain ED                    |\n|   **Balance Reporting**   |                 Reports full balance                  |      Reports ED-adjusted balance via Ethereum RPC      |\n| **New Account Transfers** |                   Standard transfer                   |     Includes ED automatically with extra fee cost      |\n| **Contract-to-Contract**  |                   Direct transfers                    | ED drawn from transaction signer, not sending contract |\n|   **State Management**    |      Potential bloat from zero-balance accounts       |     Optimized with auto-deletion of dust accounts      |\n\nThis difference introduces potential compatibility challenges for Ethereum-based contracts and tools, particularly wallets. To mitigate this, PolkaVM implements several transparent adjustments:\n\n- Balance queries via Ethereum RPC automatically deduct the ED, ensuring reported balances match spendable amounts.\n- Account balance checks through EVM opcodes reflect the ED-adjusted balance.\n- Transfers to new accounts automatically include the ED (`x + ED`), with the extra cost incorporated into transaction fees.\n- Contract-to-contract transfers handle ED requirements by:\n    - Drawing ED from the transaction signer instead of the sending contract.\n    - Keeping transfer amounts transparent for contract logic.\n    - Treating ED like other storage deposit costs.\n\nThis approach ensures that Ethereum contracts work without modifications while maintaining Polkadot's optimized state management.\n\n## Contract Deployment\n\nFor most users deploying contracts (like ERC-20 tokens), contract deployment works seamlessly without requiring special steps. However, when using advanced patterns like factory contracts that dynamically create other contracts at runtime, you'll need to understand PolkaVM's unique deployment model.\n\nIn the PolkaVM, contract deployment follows a fundamentally different model from EVM. The EVM allows contracts to be deployed with a single transaction, where the contract code is bundled with the deployment transaction. In contrast, PolkaVM has a different process for contract instantiation.\n\n- **Code must be pre-uploaded**: Unlike EVM, where contract code is bundled within the deploying contract, PolkaVM requires all contract bytecode to be uploaded to the chain before instantiation.\n- **Factory pattern limitations**: The common EVM pattern, where contracts dynamically create other contracts, will fail with a `CodeNotFound` error unless the dependent contract code was previously uploaded.\n- **Separate upload and instantiation**: This creates a two-step process where developers must first upload all contract code, then instantiate relationships between contracts.\n\nThis architecture impacts several common EVM patterns and requires developers to adapt their deployment strategies accordingly. _Factory contracts must be modified to work with pre-uploaded code rather than embedding bytecode_, and runtime code generation is not supported due to PolkaVM's RISC-V bytecode format. The specific behavior of contract creation opcodes is detailed in the [YUL IR Translation](#yul-function-translation-differences) section.\n\nWhen migrating EVM projects to PolkaVM, developers should identify all contracts that will be instantiated at runtime and ensure they are pre-uploaded to the chain before any instantiation attempts.\n\n## Solidity and YUL IR Translation Incompatibilities\n\nWhile PolkaVM maintains high-level compatibility with Solidity, several low-level differences exist in the translation of YUL IR and specific Solidity constructs. These differences are particularly relevant for developers working with assembly code or utilizing advanced contract patterns.\n\n### Contract Code Structure\n\nPolkaVM's contract runtime does not differentiate between runtime code and deploy (constructor) code. Instead, both are emitted into a single PolkaVM contract code blob and live on-chain. Therefore, in EVM terminology, the deploy code equals the runtime code. For most standard Solidity contracts, this is transparent. However, if you are analyzing raw bytecode or building tools that expect separate deploy and runtime sections, you'll need to adjust for this unified structure.\n\nIn the constructor code, the `codesize` instruction returns the call data size instead of the actual code blob size, which differs from standard EVM behavior. Developers might consider that the constructor logic uses `codesize` to inspect the deployed contract's size (e.g., for self-validation or specific deployment patterns); this will return an incorrect value on PolkaVM. Re-evaluate such logic or use alternative methods to achieve your goal.\n\n### Solidity-Specific Differences\n\nSolidity constructs behave differently under PolkaVM:\n\n- **`address.creationCode`**: Returns the bytecode keccak256 hash instead of the actual creation code, reflecting PolkaVM's hash-based code referencing system.\n    - If your contract relies on `address.creationCode` to verify or interact with the full raw bytecode of a newly deployed contract, this will not work as expected. You will receive a hash, not the code itself. This typically affects highly specialized factory contracts or introspection tools.\n\n### YUL Function Translation Differences\n\nThe following YUL functions exhibit notable behavioral differences in PolkaVM:\n\n- Memory operations:\n\n    - **`mload`, `mstore`, `msize`, `mcopy`**: PolkaVM preserves memory layout but implements several constraints.\n\n        - EVM linear heap memory is emulated using a fixed 64KB byte buffer, limiting maximum contract memory usage.\n        - Accessing memory offsets larger than the buffer size traps the contract with an `OutOfBound` error.\n        - Compiler optimizations may eliminate unused memory operations, potentially causing `msize` to differ from EVM behavior.\n\n        For Solidity developers, the compiler generally handles memory efficiently within this 64KB limit. However, if you are writing low-level YUL assembly and perform direct memory manipulations, you must respect the 64KB buffer limit. Attempting to access memory outside this range will cause your transaction to revert. Be aware that `msize` might not always reflect the exact EVM behavior if compiler optimizations occur.\n\n- Call data operations:\n\n    - **`calldataload`, `calldatacopy`**: In constructor code, the offset parameter is ignored and these functions always return `0`, diverging from EVM behavior where call data represents constructor arguments.\n\n        - If your constructor logic in YUL assembly attempts to read constructor arguments using `calldataload` or `calldatacopy` with specific offsets, this will not yield the expected constructor arguments. Instead, these functions will return `zeroed` values. Standard Solidity constructors are handled correctly by the compiler, but manual YUL assembly for constructor argument parsing will need adjustment.\n\n- Code operations:\n\n    - **`codecopy`**: Only supported within constructor code, reflecting PolkaVM's different approach to code handling and the unified code blob structure.\n\n        - If your contracts use `codecopy` (e.g., for self-modifying code or inspecting other contract's runtime bytecode) outside of the constructor, this will not be supported and will likely result in a compile-time error or runtime trap. This implies that patterns like dynamically generating or modifying contract code at runtime are not directly feasible with `codecopy` on PolkaVM.\n\n- Control flow:\n\n    - **`invalid`**: Traps the contract execution but does not consume remaining gas, unlike EVM where it consumes all available gas.\n\n        - While `invalid` still reverts the transaction, the difference in gas consumption could subtly affect very specific error handling or gas accounting patterns that rely on `invalid` to consume all remaining gas. For most error scenarios, `revert()` is the standard and recommended practice.\n\n- Cross-contract calls:\n\n    - **`call`, `delegatecall`, `staticall`**: These functions ignore supplied gas limits and forward all remaining resources due to PolkaVM's multi-dimensional resource model. This creates important security implications:\n\n        - Contract authors must implement reentrancy protection since gas stipends don't provide protection.\n        - The compiler detects `address payable.{send,transfer}` patterns and disables call reentrancy as a protective heuristic.\n        - Using `address payable.{send,transfer}` is already deprecated; PolkaVM will provide dedicated precompiles for safe balance transfers.\n\n        The traditional EVM pattern of limiting gas in cross-contract calls (especially with the 2300 gas stipend for send/transfer) does not provide reentrancy protection on PolkaVM. Developers must explicitly implement reentrancy guards (e.g., using a reentrancy lock mutex) in their Solidity code when making external calls to untrusted contracts. Relying on gas limits alone for reentrancy prevention is unsafe and will lead to vulnerabilities on PolkaVM.\n\n        !!! warning\n            The 2300 gas stipend that is provided by solc for address payable.{send, transfer} calls offers no reentrancy protection in PolkaVM. While the compiler attempts to detect and mitigate this pattern, developers should avoid these deprecated functions.\n\n- Contract creation:\n\n    - **`create`, `create2`**: Contract instantiation works fundamentally differently in PolkaVM. Instead of supplying deploy code concatenated with constructor arguments, the runtime expects:\n\n        1. A buffer containing the code hash to deploy.\n        2. The constructor arguments buffer.\n\n        PolkaVM translates `dataoffset` and `datasize` instructions to handle contract hashes instead of contract code, enabling seamless use of the `new` keyword in Solidity. However, this translation may fail for contracts creating other contracts within `assembly` blocks.\n\n        If you use the Solidity `new` keyword to deploy contracts, the Revive compiler handles this transparently. However, if you are creating contracts manually in YUL assembly using `create` or `create2` opcodes, you must provide the code hash of the contract to be deployed, not its raw bytecode. Attempting to pass raw bytecode will fail. This fundamentally changes how manual contract creation is performed in assembly.\n\n        !!! warning\n            Avoid using `create` family opcodes for manual deployment crafting in `assembly` blocks. This pattern is discouraged due to translation complexity and offers no gas savings benefits in PolkaVM.\n\n- Data operations:\n\n    - **`dataoffset`**: Returns the contract hash instead of code offset, aligning with PolkaVM's hash-based code referencing.\n    - **`datasize`**: Returns the constant contract hash size (32 bytes) rather than variable code size.\n\n    These changes are primarily relevant for low-level YUL assembly developers who are trying to inspect or manipulate contract code directly. `dataoffset` will provide a hash, not a memory offset to the code, and `datasize` will always be 32 bytes (the size of a hash). This reinforces that direct manipulation of contract bytecode at runtime, as might be done in some EVM patterns, is not supported.\n\n- Resource queries:\n\n    - **`gas`, `gaslimit`**: Return only the `ref_time` component of PolkaVM's multi-dimensional weight system, providing the closest analog to traditional gas measurements.\n\n        - While `gas` and `gaslimit` still provide a useful metric, consider that they represent `ref_time` (computation time) only. If your contract logic depends on precise knowledge of other resource costs (like `proof_size` or `storage_deposit`), you won't get that information from these opcodes. You'll need to use future precompiles for full multi-dimensional resource queries.\n\n- Blockchain state:\n\n    - **`prevrandao`, `difficulty`**: Both translate to a constant value of `2500000000000000`, as PolkaVM doesn't implement Ethereum's difficulty adjustment or randomness mechanisms.\n\n        - If your Solidity contract relies on `block.difficulty` (or its equivalent YUL opcode `difficulty`) for randomness generation or any logic tied to Ethereum's proof-of-work difficulty, this will not provide true randomness on PolkaVM. The value will always be constant. Developers needing on-chain randomness should utilize Polkadot's native randomness sources or dedicated VRF (Verifiable Random Function) solutions if available. \n\n### Unsupported Operations\n\nSeveral EVM operations are not supported in PolkaVM and produce compile-time errors:\n\n- **`pc`, `extcodecopy`**: These operations are EVM-specific and have no equivalent functionality in PolkaVM's RISC-V architecture.\n\n    - Any Solidity contracts that utilize inline assembly to interact with `pc` (program counter) or `extcodecopy` will fail to compile or behave unexpectedly. This means patterns involving introspection of the current execution location or copying external contract bytecode at runtime are not supported.\n\n- **`blobhash`, `blobbasefee`**: Related to Ethereum's rollup model and blob data handling, these operations are unnecessary given Polkadot's superior rollup architecture.\n\n    - If you are porting contracts designed for Ethereum's EIP-4844 (proto-danksharding) and rely on these blob-related opcodes, they will not be available on PolkaVM.\n\n- **`extcodecopy`, `selfdestruct`**: These deprecated operations are not supported and generate compile-time errors.\n\n    - The `selfdestruct` opcode, which allowed contracts to remove themselves from the blockchain, is not supported. Contracts cannot be self-destroyed on PolkaVM. This affects contract upgradeability patterns that rely on self-destruction and redeployment. Similarly, `extcodecopy` is unsupported, impacting contracts that intend to inspect or copy the bytecode of other deployed contracts.\n\n### Compilation Pipeline Considerations\n\nPolkaVM processes YUL IR exclusively, meaning all contracts exhibit behavior consistent with Solidity's `via-ir` compilation mode. Developers familiar with the legacy compilation pipeline should expect [IR-based codegen behavior](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html){target=\\_blank} when working with PolkaVM contracts.\n\nIf you've previously worked with older Solidity compilers that did not use the `via-ir` pipeline by default, you might observe subtle differences in compiled bytecode size or gas usage. It's recommended to familiarize yourself with Solidity's IR-based codegen behavior, as this is the standard for PolkaVM.\n\n### Memory Pointer Limitations\n\nYUL functions accepting memory buffer offset pointers or size arguments are limited by PolkaVM's 32-bit pointer size. Supplying values above `2^32-1` will trap the contract immediately. The Solidity compiler typically generates valid memory references, making this primarily a concern for low-level assembly code.\n\nFor standard Solidity development, this limitation is unlikely to be hit as the compiler handles memory addresses correctly within typical contract sizes. However, if you are writing extremely large contracts using YUL assembly that manually and extensively manipulate memory addresses, ensure that your memory offsets and sizes do not exceed PolkaVM's **fixed 64KB memory limit per contract**. While the YUL functions might accept 32-bit pointers (up to 2^32-1), attempting to access memory beyond the allocated 64KB buffer will trap the contract immediately.\n\nThese incompatibilities reflect the fundamental architectural differences between EVM and PolkaVM while maintaining high-level Solidity compatibility. Most developers using standard Solidity patterns will encounter no issues, but those working with assembly code or advanced contract patterns should carefully review these differences during migration.\n"}
{"title": "Fork a Chain with Chopsticks", "slug": "tutorials-polkadot-sdk-testing-fork-live-chains", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-polkadot-sdk-testing-fork-live-chains.md", "html_url": "https://docs.polkadot.com/tutorials/polkadot-sdk/testing/fork-live-chains/", "categories": ["Basics", "dApps", "Tooling"], "description": "Learn how to fork live Polkadot SDK chains with Chopsticks. Configure forks, replay blocks, test XCM, and interact programmatically or via UI.", "estimated_token_count": 2747, "token_estimator": "heuristic-v1", "content": "# Fork a Chain with Chopsticks\n\n## Introduction\n\nChopsticks is an innovative tool that simplifies the process of forking live Polkadot SDK chains. This guide provides step-by-step instructions to configure and fork chains, enabling developers to:\n\n- Replay blocks for state analysis.\n- Test cross-chain messaging (XCM).\n- Simulate blockchain environments for debugging and experimentation.\n\nWith support for both configuration files and CLI commands, Chopsticks offers flexibility for diverse development workflows. Whether you're testing locally or exploring complex blockchain scenarios, Chopsticks empowers developers to gain deeper insights and accelerate application development.\n\nChopsticks uses the [Smoldot](https://github.com/smol-dot/smoldot){target=\\_blank} light client, which does not support calls made through the Ethereum JSON-RPC. As a result, you can't fork your chain using Chopsticks and then interact with it using tools like MetaMask.\n\nFor additional support and information, please reach out through [GitHub Issues](https://github.com/AcalaNetwork/chopsticks/issues){target=\\_blank}.\n\n## Prerequisites\n\nTo follow this tutorial, ensure you have completed the following:\n\n- **Installed Chopsticks**: If you still need to do so, see the [Install Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/#install-chopsticks){target=\\_blank} guide for assistance.\n- **Reviewed** [Configure Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/#configure-chopsticks){target=\\_blank}: And understand how forked chains are configured.\n\n## Configuration File \n\nTo run Chopsticks using a configuration file, utilize the `--config` flag. You can use a raw GitHub URL, a path to a local file, or simply the chain's name. The following commands all look different but they use the `polkadot` configuration in the same way:\n\n=== \"GitHub URL\"\n\n    ```bash\n    npx @acala-network/chopsticks \\\n    --config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml\n    ```\n\n=== \"Local File Path\"\n\n    ```bash\n    npx @acala-network/chopsticks --config=configs/polkadot.yml\n    ```\n\n=== \"Chain Name\"\n\n    ```bash\n    npx @acala-network/chopsticks --config=polkadot\n    ```\n\nRegardless of which method you choose from the preceding examples, you'll see an output similar to the following:\n\n-<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx @acala-network/chopsticks --config=polkadot</span>\n  <br />\n  <span data-ty>[18:38:26.155] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty> chopsticks::executor TRACE: Calling Metadata_metadata</span>\n  <span data-ty> chopsticks::executor TRACE: Completed Metadata_metadata</span>\n  <span data-ty>[18:38:28.186] INFO: Polkadot RPC listening on port 8000</span>\n  <span data-ty> app: \"chopsticks\"</span>\n</div>\n\n\nIf using a file path, make sure you've downloaded the [Polkadot configuration file](https://github.com/AcalaNetwork/chopsticks/blob/master/configs/polkadot.yml){target=\\_blank}, or have created your own.\n\n## Create a Fork\n\nOnce you've configured Chopsticks, use the following command to fork Polkadot at block 100:\n\n```bash\nnpx @acala-network/chopsticks \\\n--endpoint wss://polkadot-rpc.dwellir.com \\\n--block 100\n```\n\nIf the fork is successful, you will see output similar to the following:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx @acala-network/chopsticks \\ --endpoint wss://polkadot-rpc.dwellir.com \\ --block 100</span>\n  <br />\n  <span data-ty>[19:12:21.023] INFO: Polkadot RPC listening on port 8000</span>\n  <span data-ty> app: \"chopsticks\"</span>\n</div>\n\n\nAccess the running Chopsticks fork using the default address.\n\n```bash\nws://localhost:8000\n```\n\n## Interact with a Fork\n\nYou can interact with the forked chain using various [libraries](/develop/toolkit/#libraries){target=\\_blank} such as [Polkadot.js](https://polkadot.js.org/docs/){target=\\_blank} and its user interface, [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank}.\n\n### Use Polkadot.js Apps\n\nTo interact with Chopsticks via the hosted user interface, visit [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank} and follow these steps:\n\n1. Select the network icon in the top left corner.\n\n    ![](/images/tutorials/polkadot-sdk/testing/fork-live-chains/chopsticks-1.webp)\n\n2. Scroll to the bottom and select **Development**.\n3. Choose **Custom**.\n4. Enter `ws://localhost:8000` in the input field.\n5. Select the **Switch** button.\n\n    ![](/images/tutorials/polkadot-sdk/testing/fork-live-chains/chopsticks-2.webp)\n\nYou should now be connected to your local fork and can interact with it as you would with a real chain.\n\n### Use Polkadot.js Library\n\nFor programmatic interaction, you can use the Polkadot.js library. The following is a basic example:\n\n```js\n-import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function connectToFork() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n\n  // Now you can use 'api' to interact with your fork\n  console.log(`Connected to chain: ${await api.rpc.system.chain()}`);\n}\n\nconnectToFork();\n\n```\n\n## Replay Blocks\n\nChopsticks allows you to replay specific blocks from a chain, which is useful for debugging and analyzing state changes. You can use the parameters in the [Configuration](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/#configure-chopsticks){target=\\_blank} section to set up the chain configuration, and then use the run-block subcommand with the following additional options:\n\n- **`output-path`**: Path to print output.\n- **`html`**: Generate HTML with storage diff.\n- **`open`**: Open generated HTML.\n\nFor example, the command to replay block 1000 from Polkadot and save the output to a JSON file would be as follows:\n\n```bash\nnpx @acala-network/chopsticks run-block  \\\n--endpoint wss://polkadot-rpc.dwellir.com  \\\n--output-path ./polkadot-output.json  \\\n--block 1000\n```\n\n??? code \"polkadot-output.json\"\n\n    ```json\n    -{\n    \"Call\": {\n        \"result\": \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44a10f6fc59a4d90c3b78e38fac100fc6adc6f9e69a07565ec8abce6165bd0d24078cc7bf34f450a2cc7faacc1fa1e244b959f0ed65437f44208876e1e5eefbf8dd34c040642414245b501030100000083e2cc0f00000000d889565422338aa58c0fd8ebac32234149c7ce1f22ac2447a02ef059b58d4430ca96ba18fbf27d06fe92ec86d8b348ef42f6d34435c791b952018d0a82cae40decfe5faf56203d88fdedee7b25f04b63f41f23da88c76c876db5c264dad2f70c\",\n        \"storageDiff\": [\n            [\n                \"0x0b76934f4cc08dee01012d059e1b83eebbd108c4899964f707fdaffb82636065\",\n                \"0x00\"\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087f0323475657e0890fbdbf66fb24b4649e\",\n                null\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087f06155b3cd9a8c9e5e9a23fd5dc13a5ed\",\n                \"0x83e2cc0f00000000\"\n            ],\n            [\n                \"0x1cb6f36e027abb2091cfb5110ab5087ffa92de910a7ce2bd58e99729c69727c1\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\",\n                \"0x02000000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef734abf5cb34d6244378cddbf18e849d96\",\n                \"0xc03b86ae010000000000000000000000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\",\n                \"0x080000000000000080e36a09000000000200000001000000000000ca9a3b00000000020000\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef78a42f33323cb5ced3b44dd825fda9fcc\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef799e7f93fc6a98f0874fd057f111c4d2d\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7a44704b568d21667356a5a050c118746d366e7fe86e06375e7030000\",\n                \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44\"\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7a86da5a932684f199539836fcb8c886f\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7b06c3320c6ac196d813442e270868d63\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7bdc0bd303e9855813aa8a30d4efc5112\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d15153cb1f00942ff401000000\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d1b4def25cfda6ef3a00000000\",\n                null\n            ],\n            [\n                \"0x26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\",\n                null\n            ],\n            [\n                \"0x2b06af9719ac64d755623cda8ddd9b94b1c371ded9e9c565e89ba783c4d5f5f9b4def25cfda6ef3a000000006f3d6b177c8acbd8dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e7201\",\n                \"0x9b000000\"\n            ],\n            [\"0x3a65787472696e7369635f696e646578\", null],\n            [\n                \"0x3f1467a096bcd71a5b6a0c8155e208103f2edf3bdf381debe331ab7446addfdc\",\n                \"0x550057381efedcffffffffffffffffff\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790ab0f41321f75df7ea5127be2db4983c8b2\",\n                \"0x00\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790ab21a5051453bd3ae7ed269190f4653f3b\",\n                \"0x080000\"\n            ],\n            [\n                \"0x3fba98689ebed1138735e0e7a5a790abb984cfb497221deefcefb70073dcaac1\",\n                \"0x00\"\n            ],\n            [\n                \"0x5f3e4907f716ac89b6347d15ececedca80cc6574281671b299c1727d7ac68cabb4def25cfda6ef3a00000000\",\n                \"0x204e0000183887050ecff59f58658b3df63a16d03a00f92890f1517f48c2f6ccd215e5450e380e00005809fd84af6483070acbb92378e3498dbc02fb47f8e97f006bb83f60d7b2b15d980d000082104c22c383925323bf209d771dec6e1388285abe22c22d50de968467e0bb6ce00b000088ee494d719d68a18aade04903839ea37b6be99552ceceb530674b237afa9166480d0000dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e72011c0c0000e240d12c7ad07bb0e7785ee6837095ddeebb7aef84d6ed7ea87da197805b343a0c0d0000\"\n            ],\n            [\n                \"0xae394d879ddf7f99595bc0dd36e355b5bbd108c4899964f707fdaffb82636065\",\n                null\n            ],\n            [\n                \"0xbd2a529379475088d3e29a918cd478721a39ec767bd5269111e6492a1675702a\",\n                \"0x4501407565175cfbb5dca18a71e2433f838a3d946ef532c7bff041685db1a7c13d74252fffe343a960ef84b15187ea0276687d8cb3168aeea5202ea6d651cb646517102b81ff629ee6122430db98f2cadf09db7f298b49589b265dae833900f24baa8fb358d87e12f3e9f7986a9bf920c2fb48ce29886199646d2d12c6472952519463e80b411adef7e422a1595f1c1af4b5dd9b30996fba31fa6a30bd94d2022d6b35c8bc5a8a51161d47980bf4873e01d15afc364f8939a6ce5a09454ab7f2dd53bf4ee59f2c418e85aa6eb764ad218d0097fb656900c3bdd859771858f87bf7f06fc9b6db154e65d50d28e8b2374898f4f519517cd0bedc05814e0f5297dc04beb307b296a93cc14d53afb122769dfd402166568d8912a4dff9c2b1d4b6b34d811b40e5f3763e5f3ab5cd1da60d75c0ff3c12bcef3639f5f792a85709a29b752ffd1233c2ccae88ed3364843e2fa92bdb49021ee36b36c7cdc91b3e9ad32b9216082b6a2728fccd191a5cd43896f7e98460859ca59afbf7c7d93cd48da96866f983f5ff8e9ace6f47ee3e6c6edb074f578efbfb0907673ebca82a7e1805bc5c01cd2fa5a563777feeb84181654b7b738847c8e48d4f575c435ad798aec01631e03cf30fe94016752b5f087f05adf1713910767b7b0e6521013be5370776471191641c282fdfe7b7ccf3b2b100a83085cd3af2b0ad4ab3479448e71fc44ff987ec3a26be48161974b507fb3bc8ad23838f2d0c54c9685de67dc6256e71e739e9802d0e6e3b456f6dca75600bc04a19b3cc1605784f46595bfb10d5e077ce9602ae3820436166aa1905a7686b31a32d6809686462bc9591c0bc82d9e49825e5c68352d76f1ac6e527d8ac02db3213815080afad4c2ecb95b0386e3e9ab13d4f538771dac70d3059bd75a33d0b9b581ec33bb16d0e944355d4718daccb35553012adfcdacb1c5200a2aec3756f6ad5a2beffd30018c439c1b0c4c0f86dbf19d0ad59b1c9efb7fe90906febdb9001af1e7e15101089c1ab648b199a40794d30fe387894db25e614b23e833291a604d07eec2ade461b9b139d51f9b7e88475f16d6d23de6fe7831cc1dbba0da5efb22e3b26cd2732f45a2f9a5d52b6d6eaa38782357d9ae374132d647ef60816d5c98e6959f8858cfa674c8b0d340a8f607a68398a91b3a965585cc91e46d600b1310b8f59c65b7c19e9d14864a83c4ad6fa4ba1f75bba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44c7736fc3ab2969878810153aa3c93fc08c99c478ed1bb57f647d3eb02f25cee122c70424643f4b106a7643acaa630a5c4ac39364c3cb14453055170c01b44e8b1ef007c7727494411958932ae8b3e0f80d67eec8e94dd2ff7bbe8c9e51ba7e27d50bd9f52cbaf9742edecb6c8af1aaf3e7c31542f7d946b52e0c37d194b3dd13c3fddd39db0749755c7044b3db1143a027ad428345d930afcefc0d03c3a0217147900bdea1f5830d826f7e75ecd1c4e2bc8fd7de3b35c6409acae1b2215e9e4fd7e360d6825dc712cbf9d87ae0fd4b349b624d19254e74331d66a39657da81e73d7b13adc1e5efa8efd65aa32c1a0a0315913166a590ae551c395c476116156cf9d872fd863893edb41774f33438161f9b973e3043f819d087ba18a0f1965e189012496b691f342f7618fa9db74e8089d4486c8bd1993efd30ff119976f5cc0558e29b417115f60fd8897e13b6de1a48fbeee38ed812fd267ae25bffea0caa71c09309899b34235676d5573a8c3cf994a3d7f0a5dbd57ab614c6caf2afa2e1a860c6307d6d9341884f1b16ef22945863335bb4af56e5ef5e239a55dbd449a4d4d3555c8a3ec5bd3260f88cabca88385fe57920d2d2dfc5d70812a8934af5691da5b91206e29df60065a94a0a8178d118f1f7baf768d934337f570f5ec68427506391f51ab4802c666cc1749a84b5773b948fcbe460534ed0e8d48a15c149d27d67deb8ea637c4cc28240ee829c386366a0b1d6a275763100da95374e46528a0adefd4510c38c77871e66aeda6b6bfd629d32af9b2fad36d392a1de23a683b7afd13d1e3d45dad97c740106a71ee308d8d0f94f6771164158c6cd3715e72ccfbc49a9cc49f21ead8a3c5795d64e95c15348c6bf8571478650192e52e96dd58f95ec2c0fb4f2ccc05b0ab749197db8d6d1c6de07d6e8cb2620d5c308881d1059b50ffef3947c273eaed7e56c73848e0809c4bd93619edd9fd08c8c5c88d5f230a55d2c6a354e5dd94440e7b5bf99326cf4a112fe843e7efdea56e97af845761d98f40ed2447bd04a424976fcf0fe0a0c72b97619f85cf431fe4c3aa6b3a4f61df8bc1179c11e77783bfedb7d374bd1668d0969333cb518bd20add8329462f2c9a9f04d150d60413fdd27271586405fd85048481fc2ae25b6826cb2c947e4231dc7b9a0d02a9a03f88460bced3fef5d78f732684bd218a1954a4acfc237d79ccf397913ab6864cd8a07e275b82a8a72520624738368d1c5f7e0eaa2b445cf6159f2081d3483618f7fc7b16ec4e6e4d67ab5541bcda0ca1af40efd77ef8653e223191448631a8108c5e50e340cd405767ecf932c1015aa8856b834143dc81fa0e8b9d1d8c32278fca390f2ff08181df0b74e2d13c9b7b1d85543416a0dae3a77530b9cd1366213fcf3cd12a9cd3ae0a006d6b29b5ffc5cdc1ab24343e2ab882abfd719892fca5bf2134731332c5d3bef6c6e4013d84a853cb03d972146b655f0f8541bcd36c3c0c8a775bb606edfe50d07a5047fd0fe01eb125e83673930bc89e91609fd6dfe97132679374d3de4a0b3db8d3f76f31bed53e247da591401d508d65f9ee01d3511ee70e3644f3ab5d333ca7dbf737fe75217b4582d50d98b5d59098ea11627b7ed3e3e6ee3012eadd326cf74ec77192e98619427eb0591e949bf314db0fb932ed8be58258fb4f08e0ccd2cd18b997fb5cf50c90d5df66a9f3bb203bd22061956128b800e0157528d45c7f7208c65d0592ad846a711fa3c5601d81bb318a45cc1313b122d4361a7d7a954645b04667ff3f81d3366109772a41f66ece09eb93130abe04f2a51bb30e767dd37ec6ee6a342a4969b8b342f841193f4f6a9f0fac4611bc31b6cab1d25262feb31db0b8889b6f8d78be23f033994f2d3e18e00f3b0218101e1a7082782aa3680efc8502e1536c30c8c336b06ae936e2bcf9bbfb20dd514ed2867c03d4f44954867c97db35677d30760f37622b85089cc5d182a89e29ab0c6b9ef18138b16ab91d59c2312884172afa4874e6989172014168d3ed8db3d9522d6cbd631d581d166787c93209bec845d112e0cbd825f6df8b64363411270921837cfb2f9e7f2e74cdb9cd0d2b02058e5efd9583e2651239654b887ea36ce9537c392fc5dfca8c5a0facbe95b87dfc4232f229bd12e67937d32b7ffae2e837687d2d292c08ff6194a2256b17254748857c7e3c871c3fff380115e6f7faf435a430edf9f8a589f6711720cfc5cec6c8d0d94886a39bb9ac6c50b2e8ef6cf860415192ca4c1c3aaa97d36394021a62164d5a63975bcd84b8e6d74f361c17101e3808b4d8c31d1ee1a5cf3a2feda1ca2c0fd5a50edc9d95e09fb5158c9f9b0eb5e2c90a47deb0459cea593201ae7597e2e9245aa5848680f546256f3\"\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5e326d21bc67a4b34023d577585d72bfd7\",\n                null\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5ea36180b5cfb9f6541f8849df92a6ec93\",\n                \"0x00\"\n            ],\n            [\n                \"0xd57bce545fb382c34570e5dfbf338f5ebddf84c5eb23e6f53af725880d8ffe90\",\n                null\n            ],\n            [\n                \"0xd5c41b52a371aa36c9254ce34324f2a53b996bb988ea8ee15bad3ffd2f68dbda\",\n                \"0x00\"\n            ],\n            [\n                \"0xf0c365c3cf59d671eb72da0e7a4113c49f1f0515f462cdcf84e0f1d6045dfcbb\",\n                \"0x50defc5172010000\"\n            ],\n            [\n                \"0xf0c365c3cf59d671eb72da0e7a4113c4bbd108c4899964f707fdaffb82636065\",\n                null\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed90420d49a14a763e1cbc887acd097f92014\",\n                \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed9049b58374218f48eaf5bc23b7b3e7cf08a\",\n                \"0xb3030000\"\n            ],\n            [\n                \"0xf68f425cf5645aacb2ae59b51baed904b97380ce5f4e70fbf9d6b5866eb59527\",\n                \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n            ]\n        ],\n        \"offchainStorageDiff\": [],\n        \"runtimeLogs\": []\n    }\n}\n\n    ```\n\n## XCM Testing\n\nTo test XCM (Cross-Consensus Messaging) messages between networks, you can fork multiple parachains and a relay chain locally using Chopsticks.\n\n- **`relaychain`**: Relay chain config file.\n- **`parachain`**: Parachain config file.\n\nFor example, to fork Moonbeam, Astar, and Polkadot enabling XCM between them, you can use the following command:\n\n```bash\nnpx @acala-network/chopsticks xcm \\\n--r polkadot \\\n--p moonbeam \\\n--p astar\n```\n\nAfter running it, you should see output similar to the following:\n\n-<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx @acala-network/chopsticks xcm \\</span>\n  <span data-ty>--r polkadot \\</span>\n  <span data-ty>--p moonbeam \\</span>\n  <span data-ty>--p astar</span>\n  <br />\n  <span data-ty>[13:46:07.901] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:12.631] INFO: Moonbeam RPC listening on port 8000</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:12.632] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/astar.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty> chopsticks::executor TRACE: Calling Metadata_metadata</span>\n  <span data-ty> chopsticks::executor TRACE: Completed Metadata_metadata</span>\n  <span data-ty>[13:46:23.669] INFO: Astar RPC listening on port 8001</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:25.144] INFO (xcm): Connected parachains [2004,2006]</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:25.144] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty> chopsticks::executor TRACE: Calling Metadata_metadata</span>\n  <span data-ty> chopsticks::executor TRACE: Completed Metadata_metadata</span>\n  <span data-ty>[13:46:53.320] INFO: Polkadot RPC listening on port 8002</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:54.038] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Moonbeam'</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:55.028] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Astar'</span>\n  <span data-ty> app: \"chopsticks\"</span>\n</div>\n\n\nNow you can interact with your forked chains using the ports specified in the output.\n"}
{"title": "Glossary", "slug": "polkadot-protocol-glossary", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-glossary.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/glossary/", "categories": ["Reference"], "description": "Glossary of terms used within the Polkadot ecosystem, Polkadot SDK, its subsequent libraries, and other relevant Web3 terminology.", "estimated_token_count": 5364, "token_estimator": "heuristic-v1", "content": "# Glossary\n\nKey definitions, concepts, and terminology specific to the Polkadot ecosystem are included here.\n\nAdditional glossaries from around the ecosystem you might find helpful:\n\n- [Polkadot Wiki Glossary](https://wiki.polkadot.com/general/glossary){target=\\_blank}\n- [Polkadot SDK Glossary](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/glossary/index.html){target=\\_blank}\n\n## Authority\n\nThe role in a blockchain that can participate in consensus mechanisms. \n\n- **[GRANDPA](#grandpa)**: The authorities vote on chains they consider final.\n- **[Blind Assignment of Blockchain Extension](#blind-assignment-of-blockchain-extension-babe) (BABE)**: The authorities are also [block authors](#block-author).\n\nAuthority sets can be used as a basis for consensus mechanisms such as the [Nominated Proof of Stake (NPoS)](#nominated-proof-of-stake-npos) protocol.\n\n## Authority Round (Aura)\n\nA deterministic [consensus](#consensus) protocol where block production is limited to a rotating list of [authorities](#authority) that take turns creating blocks. In authority round (Aura) consensus, most online authorities are assumed to be honest. It is often used in combination with [GRANDPA](#grandpa) as a [hybrid consensus](#hybrid-consensus) protocol.\n\nLearn more by reading the official [Aura consensus algorithm](https://openethereum.github.io/Aura){target=\\_blank} wiki article.\n\n## Blind Assignment of Blockchain Extension (BABE)\n\nA [block authoring](#block-author) protocol similar to [Aura](#authority-round-aura), except [authorities](#authority) win [slots](#slot) based on a Verifiable Random Function (VRF) instead of the round-robin selection method. The winning authority can select a chain and submit a new block.\n\nLearn more by reading the official Web3 Foundation [BABE research document](https://research.web3.foundation/Polkadot/protocols/block-production/Babe){target=\\_blank}.\n\n## Block Author\n\nThe node responsible for the creation of a block, also called _block producers_. In a Proof of Work (PoW) blockchain, these nodes are called _miners_.\n\n## Byzantine Fault Tolerance (BFT)\n\nThe ability of a distributed computer network to remain operational if a certain proportion of its nodes or [authorities](#authority) are defective or behaving maliciously. A distributed network is typically considered Byzantine fault tolerant if it can remain functional, with up to one-third of nodes assumed to be defective, offline, actively malicious, and part of a coordinated attack.\n\n### Byzantine Failure\n\nThe loss of a network service due to node failures that exceed the proportion of nodes required to reach consensus.\n\n### Practical Byzantine Fault Tolerance (pBFT)\n\nAn early approach to Byzantine fault tolerance (BFT), practical Byzantine fault tolerance (pBFT) systems tolerate Byzantine behavior from up to one-third of participants.\n\nThe communication overhead for such systems is `O(n²)`, where `n` is the number of nodes (participants) in the system.\n\n### Preimage\n\nA preimage is the data that is input into a hash function to calculate a hash. Since a hash function is a [one-way function](https://en.wikipedia.org/wiki/One-way_function){target=\\_blank}, the output, the hash, cannot be used to reveal the input, the preimage.\n\n## Call\n\nIn the context of pallets containing functions to be dispatched to the runtime, `Call` is an enumeration data type that describes the functions that can be dispatched with one variant per pallet. A `Call` represents a [dispatch](#dispatchable) data structure object.\n\n## Chain Specification \n\nA chain specification file defines the properties required to run a node in an active or new Polkadot SDK-built network. It often contains the initial genesis runtime code, network properties (such as the network's name), the initial state for some pallets, and the boot node list. The chain specification file makes it easy to use a single Polkadot SDK codebase as the foundation for multiple independently configured chains.\n\n## Collator\n\nAn [author](#block-author) of a [parachain](#parachain) network.\nThey aren't [authorities](#authority) in themselves, as they require a [relay chain](#relay-chain) to coordinate [consensus](#consensus).\n\nMore details are found on the [Polkadot Collator Wiki](https://wiki.polkadot.com/learn/learn-collator/){target=\\_blank}.\n\n## Collective\n\nMost often used to refer to an instance of the Collective pallet on Polkadot SDK-based networks such as [Kusama](#kusama) or [Polkadot](#polkadot) if the Collective pallet is part of the FRAME-based runtime for the network.\n\n## Consensus\n\nConsensus is the process blockchain nodes use to agree on a chain's canonical fork. It is composed of [authorship](#block-author), finality, and [fork-choice rule](#fork-choice-rulestrategy). In the Polkadot ecosystem, these three components are usually separate and the term consensus often refers specifically to authorship.\n\nSee also [hybrid consensus](#hybrid-consensus).\n\n## Consensus Algorithm\n\nEnsures a set of [actors](#authority)—who don't necessarily trust each other—can reach an agreement about the state as the result of some computation. Most consensus algorithms assume that up to one-third of the actors or nodes can be [Byzantine fault tolerant](#byzantine-fault-tolerance-bft).\n\nConsensus algorithms are generally concerned with ensuring two properties:\n\n- **Safety**: Indicating that all honest nodes eventually agreed on the state of the chain.\n- **Liveness**: Indicating the ability of the chain to keep progressing.\n\n## Consensus Engine\n\nThe node subsystem responsible for consensus tasks.\n\nFor detailed information about the consensus strategies of the [Polkadot](#polkadot) network, see the [Polkadot Consensus](/polkadot-protocol/architecture/polkadot-chain/pos-consensus/){target=\\_blank} blog series.\n\nSee also [hybrid consensus](#hybrid-consensus).\n\n## Coretime\n\nThe time allocated for utilizing a core, measured in relay chain blocks. There are two types of coretime: *on-demand* and *bulk*.\n\nOn-demand coretime refers to coretime acquired through bidding in near real-time for the validation of a single parachain block on one of the cores reserved specifically for on-demand orders. They are available as an on-demand coretime pool. Set of cores that are available on-demand. Cores reserved through bulk coretime could also be made available in the on-demand coretime pool, in parts or in entirety.\n\nBulk coretime is a fixed duration of continuous coretime represented by an NFT that can be split, shared, or resold. It is managed by the [Broker pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_broker/index.html){target=\\_blank}.\n\n## Development Phrase\n\nA [mnemonic phrase](https://en.wikipedia.org/wiki/Mnemonic#For_numerical_sequences_and_mathematical_operations){target=\\_blank} that is intentionally made public.\n\nWell-known development accounts, such as Alice, Bob, Charlie, Dave, Eve, and Ferdie, are generated from the same secret phrase:\n\n```\nbottom drive obey lake curtain smoke basket hold race lonely fit walk\n```\n\nMany tools in the Polkadot SDK ecosystem, such as [`subkey`](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/substrate/bin/utils/subkey){target=\\_blank}, allow you to implicitly specify an account using a derivation path such as `//Alice`.\n\n## Digest\n\nAn extensible field of the [block header](#header) that encodes information needed by several actors in a blockchain network, including:\n\n- [Light clients](#light-client) for chain synchronization.\n- Consensus engines for block verification.\n- The runtime itself, in the case of pre-runtime digests.\n\n## Dispatchable\n\nFunction objects that act as the entry points in FRAME [pallets](#pallet). Internal or external entities can call them to interact with the blockchain’s state. They are a core aspect of the runtime logic, handling [transactions](#transaction) and other state-changing operations.\n\n## Events\n\nA means of recording that some particular [state](#state) transition happened.\n\nIn the context of [FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities), events are composable data types that each [pallet](#pallet) can individually define. Events in FRAME are implemented as a set of transient storage items inspected immediately after a block has been executed and reset during block initialization.\n\n## Executor\n\nA means of executing a function call in a given [runtime](#runtime) with a set of dependencies.\nThere are two orchestration engines in Polkadot SDK, _WebAssembly_ and _native_.\n\n- The _native executor_ uses a natively compiled runtime embedded in the node to execute calls. This is a performance optimization available to up-to-date nodes.\n\n- The _WebAssembly executor_ uses a [Wasm](#webassembly-wasm) binary and a Wasm interpreter to execute calls. The binary is guaranteed to be up-to-date regardless of the version of the blockchain node because it is persisted in the [state](#state) of the Polkadot SDK-based chain.\n\n## Existential Deposit\n\nThe minimum balance an account is allowed to have in the [Balances pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_balances/index.html){target=\\_blank}. Accounts cannot be created with a balance less than the existential deposit amount. \n\nIf an account balance drops below this amount, the Balances pallet uses [a FRAME System API](https://paritytech.github.io/substrate/master/frame_system/pallet/struct.Pallet.html#method.dec_ref){target=\\_blank} to drop its references to that account.\n\nIf the Balances pallet reference to an account is dropped, the account can be [reaped](https://paritytech.github.io/substrate/master/frame_system/pallet/struct.Pallet.html#method.allow_death){target=\\_blank}.\n\n## Extrinsic\n\nA general term for data that originates outside the runtime, is included in a block, and leads to some action. This includes user-initiated transactions and inherent transactions placed into the block by the block builder.\n\nIt is a SCALE-encoded array typically consisting of a version number, signature, and varying data types indicating the resulting runtime function to be called. Extrinsics can take two forms: [inherents](#inherent-transactions) and [transactions](#transaction). \n\nFor more technical details, see the [Polkadot spec](https://spec.polkadot.network/id-extrinsics){target=\\_blank}.\n\n## Fork Choice Rule/Strategy\n\nA fork choice rule or strategy helps determine which chain is valid when reconciling several network forks. A common fork choice rule is the [longest chain](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/struct.LongestChain.html){target=\\_blank}, in which the chain with the most blocks is selected.\n\n## FRAME (Framework for Runtime Aggregation of Modularized Entities)\n\nEnables developers to create blockchain [runtime](#runtime) environments from a modular set of components called [pallets](#pallet). It utilizes a set of procedural macros to construct runtimes.\n\n[Visit the Polkadot SDK docs for more details on FRAME.](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/frame_runtime/index.html){target=\\_blank}\n\n## Full Node\n\nA node that prunes historical states, keeping only recently finalized block states to reduce storage needs. Full nodes provide current chain state access and allow direct submission and validation of [extrinsics](#extrinsic), maintaining network decentralization.\n\n## Genesis Configuration\n\nA mechanism for specifying the initial state of a blockchain. By convention, this initial state or first block is commonly referred to as the genesis state or genesis block. The genesis configuration for Polkadot SDK-based chains is accomplished by way of a [chain specification](#chain-specification) file.\n\n## GRANDPA\n\nA deterministic finality mechanism for blockchains that is implemented in the [Rust](https://www.rust-lang.org/){target=\\_blank} programming language.\n\nThe [formal specification](https://github.com/w3f/consensus/blob/master/pdf/grandpa-old.pdf){target=\\_blank} is maintained by the [Web3 Foundation](https://web3.foundation/){target=\\_blank}.\n\n## Header\n\nA structure that aggregates the information used to summarize a block. Primarily, it consists of cryptographic information used by [light clients](#light-client) to get minimally secure but very efficient chain synchronization.\n\n## Hybrid Consensus\n\nA blockchain consensus protocol that consists of independent or loosely coupled mechanisms for [block production](#block-author) and finality.\n\nHybrid consensus allows the chain to grow as fast as probabilistic consensus protocols, such as [Aura](#authority-round-aura), while maintaining the same level of security as deterministic finality consensus protocols, such as [GRANDPA](#grandpa).\n\n## Inherent Transactions\n\nA special type of unsigned transaction, referred to as _inherents_, that enables a block authoring node to insert information that doesn't require validation directly into a block.\n\nOnly the block-authoring node that calls the inherent transaction function can insert data into its block. In general, validators assume the data inserted using an inherent transaction is valid and reasonable even if it can't be deterministically verified.\n\n## JSON-RPC\n\nA stateless, lightweight remote procedure call protocol encoded in JavaScript Object Notation (JSON). JSON-RPC provides a standard way to call functions on a remote system by using JSON.\n\nFor Polkadot SDK, this protocol is implemented through the [Parity JSON-RPC](https://github.com/paritytech/jsonrpc){target=\\_blank} crate.\n\n## Keystore\n\nA subsystem for managing keys for the purpose of producing new blocks.\n\n## Kusama\n\n[Kusama](https://kusama.network/){target=\\_blank} is a Polkadot SDK-based blockchain that implements a design similar to the [Polkadot](#polkadot) network.\n\nKusama is a [canary](https://en.wiktionary.org/wiki/canary_in_a_coal_mine){target=\\_blank} network and is referred to as [Polkadot's \"wild cousin.\"](https://wiki.polkadot.com/learn/learn-comparisons-kusama/){target=\\_blank}.\n\nAs a canary network, Kusama is expected to be more stable than a test network like [Westend](#westend) but less stable than a production network like [Polkadot](#polkadot). Kusama is controlled by its network participants and is intended to be stable enough to encourage meaningful experimentation.\n\n## libp2p\n\nA peer-to-peer networking stack that allows the use of many transport mechanisms, including WebSockets (usable in a web browser).\n\nPolkadot SDK uses the [Rust implementation](https://github.com/libp2p/rust-libp2p){target=\\_blank} of the `libp2p` networking stack.\n\n## Light Client\n\nA type of blockchain node that doesn't store the [chain state](#state) or produce blocks.\n\nA light client can verify cryptographic primitives and provides a [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call){target=\\_blank} server, enabling blockchain users to interact with the network.\n\n## Metadata\n\nData that provides information about one or more aspects of a system.\nThe metadata that exposes information about a Polkadot SDK blockchain enables you to interact with that system.\n\n## Nominated Proof of Stake (NPoS)\n\nA method for determining [validators](#validator) or _[authorities](#authority)_ based on a willingness to commit their stake to the proper functioning of one or more block-producing nodes.\n\n## Oracle\n\nAn entity that connects a blockchain to a non-blockchain data source. Oracles enable the blockchain to access and act upon information from existing data sources and incorporate data from non-blockchain systems and services.\n\n## Origin\n\nA [FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities) primitive that identifies the source of a [dispatched](#dispatchable) function call into the [runtime](#runtime). The FRAME System pallet defines three built-in [origins](#origin). As a [pallet](#pallet) developer, you can also define custom origins, such as those defined by the [Collective pallet](https://paritytech.github.io/substrate/master/pallet_collective/enum.RawOrigin.html){target=\\_blank}.\n\n## Pallet\n\nA module that can be used to extend the capabilities of a [FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities)-based [runtime](#runtime).\nPallets bundle domain-specific logic with runtime primitives like [events](#events) and [storage items](#storage-item).\n\n## Parachain\n\nA parachain is a blockchain that derives shared infrastructure and security from a _[relay chain](#relay-chain)_.\nYou can learn more about parachains on the [Polkadot Wiki](https://wiki.polkadot.com/learn/learn-parachains/){target=\\_blank}.\n\n## Paseo\n\nPaseo TestNet provisions testing on Polkadot's \"production\" runtime, which means less chance of feature or code mismatch when developing parachain apps. Specifically, after the [Polkadot Technical fellowship](https://wiki.polkadot.com/learn/learn-polkadot-technical-fellowship/){target=\\_blank} proposes a runtime upgrade for Polkadot, this TestNet is updated, giving a period where the TestNet will be ahead of Polkadot to allow for testing.\n\n## Polkadot\n\nThe [Polkadot network](https://polkadot.com/){target=\\_blank} is a blockchain that serves as the central hub of a heterogeneous blockchain network. It serves the role of the [relay chain](#relay-chain) and provides shared infrastructure and security to support [parachains](#parachain).\n\n## Polkadot Cloud\n\nPolkadot Cloud is a platform for deploying resilient, customizable and scalable Web3 applications through Polkadot's functionality. It encompasses the wider Polkadot network infrastructure and security layer where parachains operate. The platform enables users to launch Ethereum-compatible chains, build specialized blockchains, and flexibly manage computing resources through on-demand or bulk coretime purchases. Initially launched with basic parachain functionality, Polkadot Cloud has evolved to offer enhanced flexibility with features like coretime, elastic scaling, and async backing for improved performance.\n\n## Polkadot Hub\n\nPolkadot Hub is a Layer 1 platform that serves as the primary entry point to the Polkadot ecosystem, providing essential functionality without requiring parachain deployment. It offers core services including smart contracts, identity management, staking, governance, and interoperability with other ecosystems, making it simple and fast for both builders and users to get started in Web3.\n\n## PolkaVM\n\nPolkaVM is a custom virtual machine optimized for performance, leveraging a RISC-V-based architecture to support Solidity and any language that compiles to RISC-V. It is specifically designed for the Polkadot ecosystem, enabling smart contract deployment and execution.\n\n## Relay Chain\n\nRelay chains are blockchains that provide shared infrastructure and security to the [parachains](#parachain) in the network. In addition to providing [consensus](#consensus) capabilities, relay chains allow parachains to communicate and exchange digital assets without needing to trust one another.\n\n## Rococo\n\nA [parachain](#parachain) test network for the Polkadot network. The [Rococo](#rococo) network is a Polkadot SDK-based blockchain with an October 14, 2024 deprecation date. Development teams are encouraged to use the Paseo TestNet instead.\n\n## Runtime\n\nThe runtime represents the [state transition function](#state-transition-function-stf) for a blockchain. In Polkadot SDK, the runtime is stored as a [Wasm](#webassembly-wasm) binary in the chain state. The Runtime is stored under a unique state key and can be modified during the execution of the state transition function.\n\n## Slot\n\nA fixed, equal interval of time used by consensus engines such as [Aura](#authority-round-aura) and [BABE](#blind-assignment-of-blockchain-extension-babe). In each slot, a subset of [authorities](#authority) is permitted, or obliged, to [author](#block-author) a block.\n\n## Sovereign Account\n\nThe unique account identifier for each chain in the relay chain ecosystem. It is often used in cross-consensus (XCM) interactions to sign XCM messages sent to the relay chain or other chains in the ecosystem.\n\nThe sovereign account for each chain is a root-level account that can only be accessed using the Sudo pallet or through governance. The account identifier is calculated by concatenating the Blake2 hash of a specific text string and the registered parachain identifier.\n\n## SS58 Address Format\n\nA public key address based on the Bitcoin [`Base-58-check`](https://en.bitcoin.it/wiki/Base58Check_encoding){target=\\_blank} encoding. Each Polkadot SDK SS58 address uses a `base-58` encoded value to identify a specific account on a specific Polkadot SDK-based chain\n\nThe [canonical `ss58-registry`](https://github.com/paritytech/ss58-registry){target=\\_blank} provides additional details about the address format used by different Polkadot SDK-based chains, including the network prefix and website used for different networks\n\n## State Transition Function (STF)\n\nThe logic of a blockchain that determines how the state changes when a block is processed. In Polkadot SDK, the state transition function is effectively equivalent to the [runtime](#runtime).\n\n## Storage Item\n\n[FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities) primitives that provide type-safe data persistence capabilities to the [runtime](#runtime).\nLearn more in the [storage items](https://paritytech.github.io/polkadot-sdk/master/frame_support/storage/types/index.html){target=\\_blank} reference document in the Polkadot SDK.\n\n## Substrate\n\nA flexible framework for building modular, efficient, and upgradeable blockchains. Substrate is written in the [Rust](https://www.rust-lang.org/){target=\\_blank} programming language and is maintained by [Parity Technologies](https://www.parity.io/){target=\\_blank}.\n\n## Transaction\n\nAn [extrinsic](#extrinsic) that includes a signature that can be used to verify the account authorizing it inherently or via [signed extensions](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/signed_extensions/index.html){target=\\_blank}.\n\n## Transaction Era\n\nA definable period expressed as a range of block numbers during which a transaction can be included in a block.\nTransaction eras are used to protect against transaction replay attacks if an account is reaped and its replay-protecting nonce is reset to zero.\n\n## Trie (Patricia Merkle Tree)\n\nA data structure used to represent sets of key-value pairs and enables the items in the data set to be stored and retrieved using a cryptographic hash. Because incremental changes to the data set result in a new hash, retrieving data is efficient even if the data set is very large. With this data structure, you can also prove whether the data set includes any particular key-value pair without access to the entire data set.\n\nIn Polkadot SDK-based blockchains, state is stored in a trie data structure that supports the efficient creation of incremental digests. This trie is exposed to the [runtime](#runtime) as [a simple key/value map](#storage-item) where both keys and values can be arbitrary byte arrays.\n\n## Validator\n\nA validator is a node that participates in the consensus mechanism of the network. Its roles include block production, transaction validation, network integrity, and security maintenance.\n\n## WebAssembly (Wasm)\n\nAn execution architecture that allows for the efficient, platform-neutral expression of\ndeterministic, machine-executable logic.\n\n[Wasm](https://webassembly.org/){target=\\_blank} can be compiled from many languages, including\nthe [Rust](https://www.rust-lang.org/){target=\\_blank} programming language. Polkadot SDK-based chains use a Wasm binary to provide portable [runtimes](#runtime) that can be included as part of the chain's state.\n\n## Weight\n\nA convention used in Polkadot SDK-based blockchains to measure and manage the time it takes to validate a block.\nPolkadot SDK defines one unit of weight as one picosecond of execution time on reference hardware.\n\nThe maximum block weight should be equivalent to one-third of the target block time with an allocation of one-third each for:\n\n- Block construction\n- Network propagation\n- Import and verification\n\nBy defining weights, you can trade-off the number of transactions per second and the hardware required to maintain the target block time appropriate for your use case. Weights are defined in the runtime, meaning you can tune them using runtime updates to keep up with hardware and software improvements.\n\n## Westend\n\nWestend is a Parity-maintained, Polkadot SDK-based blockchain that serves as a test network for the [Polkadot](#polkadot) network.\n"}
{"title": "Install Polkadot SDK Dependencies", "slug": "develop-parachains-install-polkadot-sdk", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-parachains-install-polkadot-sdk.md", "html_url": "https://docs.polkadot.com/develop/parachains/install-polkadot-sdk/", "categories": ["Basics", "Tooling"], "description": "Install everything you need to begin working with Substrated-based blockchains and the Polkadot SDK, the framework for building blockchains.", "estimated_token_count": 2767, "token_estimator": "heuristic-v1", "content": "# Install Polkadot SDK Dependencies\n\nThis guide provides step-by-step instructions for installing the dependencies you need to work with the Polkadot SDK-based chains on macOS, Linux, and Windows. Follow the appropriate section for your operating system to ensure all necessary tools are installed and configured properly.\n\n## macOS\n\nYou can install Rust and set up a Substrate development environment on Apple macOS computers with Intel or Apple M1 processors.\n\n### Before You Begin\n\nBefore you install Rust and set up your development environment on macOS, verify that your computer meets the following basic requirements:\n\n- Operating system version is 10.7 Lion or later.\n- Processor speed of at least 2 GHz. Note that 3 GHz is recommended.\n- Memory of at least 8 GB RAM. Note that 16 GB is recommended.\n- Storage of at least 10 GB of available space.\n- Broadband Internet connection.\n\n#### Install Homebrew\n\nIn most cases, you should use Homebrew to install and manage packages on macOS computers. If you don't already have Homebrew installed on your local computer, you should download and install it before continuing.\n\nTo install Homebrew:\n\n1. Open the Terminal application.\n2. Download and install Homebrew by running the following command:\n\n    ```bash\n    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n    ```\n\n3. Verify Homebrew has been successfully installed by running the following command:\n\n    ```bash\n    brew --version\n    ```\n\n    The command displays output similar to the following:\n\n    -<div id=\"termynal\" data-termynal markdown>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>brew --version</span>\n  <span data-ty>Homebrew 4.3.15</span>\n</div>\n\n\n#### Support for Apple Silicon\n\nProtobuf must be installed before the build process can begin. To install it, run the following command:\n\n```bash\nbrew install protobuf\n```\n\n### Install Required Packages and Rust\n\nBecause the blockchain requires standard cryptography to support the generation of public/private key pairs and the validation of transaction signatures, you must also have a package that provides cryptography, such as `openssl`.\n\nTo install `openssl` and the Rust toolchain on macOS:\n\n1. Open the Terminal application.\n2. Ensure you have an updated version of Homebrew by running the following command:\n\n    ```bash\n    brew update\n    ```\n\n3. Install the `openssl` package by running the following command:\n\n    ```bash\n    brew install openssl\n    ```\n\n4. Download the `rustup` installation program and use it to install Rust by running the following command:\n\n    ```bash\n    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n    ```\n\n5. Follow the prompts displayed to proceed with a default installation.\n6. Update your current shell to include Cargo by running the following command:\n\n    ```bash\n    source ~/.cargo/env\n    ```\n\n7. Configure the Rust toolchain to default to the latest stable version by running the following commands:\n\n    ```bash\n    rustup default stable\n    rustup update\n    rustup target add wasm32-unknown-unknown\n    rustup component add rust-src\n    ```\n\n8. [Verify your installation](#verifying-installation).\n9. Install `cmake` using the following command:\n\n    ```bash\n    brew install cmake\n    ```\n\n## Linux\n\nRust supports most Linux distributions. Depending on the specific distribution and version of the operating system you use, you might need to add some software dependencies to your environment. In general, your development environment should include a linker or C-compatible compiler, such as `clang` and an appropriate integrated development environment (IDE).\n\n### Before You Begin {: #before-you-begin-linux }\n\nCheck the documentation for your operating system for information about the installed packages and how to download and install any additional packages you might need. For example, if you use Ubuntu, you can use the Ubuntu Advanced Packaging Tool (`apt`) to install the `build-essential` package:\n\n```bash\nsudo apt install build-essential\n```\n\nAt a minimum, you need the following packages before you install Rust:\n\n```text\nclang curl git make\n```\n\nBecause the blockchain requires standard cryptography to support the generation of public/private key pairs and the validation of transaction signatures, you must also have a package that provides cryptography, such as `libssl-dev` or `openssl-devel`.\n\n### Install Required Packages and Rust {: #install-required-packages-and-rust-linux }\n\nTo install the Rust toolchain on Linux:\n\n1. Open a terminal shell.\n2. Check the packages you have installed on the local computer by running an appropriate package management command for your Linux distribution.\n3. Add any package dependencies you are missing to your local development environment by running the appropriate package management command for your Linux distribution:\n\n    === \"Ubuntu\"\n\n        ```bash\n        sudo apt install --assume-yes git clang curl libssl-dev protobuf-compiler\n        ```\n\n    === \"Debian\"\n\n        ```sh\n        sudo apt install --assume-yes git clang curl libssl-dev llvm libudev-dev make protobuf-compiler\n        ```\n\n    === \"Arch\"\n\n        ```sh\n        pacman -Syu --needed --noconfirm curl git clang make protobuf\n        ```\n\n    === \"Fedora\"\n\n        ```sh\n        sudo dnf update\n        sudo dnf install clang curl git openssl-devel make protobuf-compiler\n        ```\n\n    === \"OpenSUSE\"\n\n        ```sh\n        sudo zypper install clang curl git openssl-devel llvm-devel libudev-devel make protobuf\n        ```\n\n    Remember that different distributions might use different package managers and bundle packages in different ways. For example, depending on your installation selections, Ubuntu Desktop and Ubuntu Server might have different packages and different requirements. However, the packages listed in the command-line examples are applicable for many common Linux distributions, including Debian, Linux Mint, MX Linux, and Elementary OS.\n\n4. Download the `rustup` installation program and use it to install Rust by running the following command:\n\n    ```bash\n    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n    ```\n\n5. Follow the prompts displayed to proceed with a default installation.\n6. Update your current shell to include Cargo by running the following command:\n\n    ```bash\n    source $HOME/.cargo/env\n    ```\n\n7. Verify your installation by running the following command:\n\n    ```bash\n    rustc --version\n    ```\n\n8. Configure the Rust toolchain to default to the latest stable version by running the following commands:\n\n    ```bash\n    rustup default stable\n    rustup update\n    rustup target add wasm32-unknown-unknown\n    rustup component add rust-src\n    ```\n\n9. [Verify your installation](#verifying-installation).\n\n## Windows (WSL)\n\nIn general, UNIX-based operating systems—like macOS or Linux—provide a better development environment for building Substrate-based blockchains.\n\nHowever, suppose your local computer uses Microsoft Windows instead of a UNIX-based operating system. In that case, you can configure it with additional software to make it a suitable development environment for building Substrate-based blockchains. To prepare a development environment on a Microsoft Windows computer, you can use Windows Subsystem for Linux (WSL) to emulate a UNIX operating environment.\n\n### Before You Begin {: #before-you-begin-windows }\n\nBefore installing on Microsoft Windows, verify the following basic requirements:\n\n- You have a computer running a supported Microsoft Windows operating system:\n    - **For Windows desktop**: You must be running Microsoft Windows 10, version 2004 or later, or Microsoft Windows 11 to install WSL.\n    - **For Windows server**: You must be running Microsoft Windows Server 2019, or later, to install WSL on a server operating system.\n- You have good internet connection and access to a shell terminal on your local computer.\n\n### Set Up Windows Subsystem for Linux\n\nWSL enables you to emulate a Linux environment on a computer that uses the Windows operating system. The primary advantage of this approach for Substrate development is that you can use all of the code and command-line examples as described in the Substrate documentation. For example, you can run common commands—such as `ls` and `ps`—unmodified. By using WSL, you can avoid configuring a virtual machine image or a dual-boot operating system.\n\nTo prepare a development environment using WSL:\n\n1. Check your Windows version and build number to see if WSL is enabled by default.\n\n    If you have Microsoft Windows 10, version 2004 (Build 19041 and higher), or Microsoft Windows 11, WSL is available by default and you can continue to the next step.\n\n    If you have an older version of Microsoft Windows installed, see the [WSL manual installation steps for older versions](https://learn.microsoft.com/en-us/windows/wsl/install-manual){target=\\_blank}. If you are installing on an older version of Microsoft Windows, you can download and install WLS 2 if your computer has Windows 10, version 1903 or higher.\n\n2. Select **Windows PowerShell** or **Command Prompt** from the **Start** menu, right-click, then **Run as administrator**.\n\n3. In the PowerShell or Command Prompt terminal, run the following command:\n\n    ```bash\n    wsl --install\n    ```\n\n    This command enables the required WSL 2 components that are part of the Windows operating system, downloads the latest Linux kernel, and installs the Ubuntu Linux distribution by default.\n\n    If you want to review the other Linux distributions available, run the following command:\n\n    ```bash\n    wsl --list --online\n    ```\n\n4. After the distribution is downloaded, close the terminal.\n\n5. Click the **Start** menu, select **Shut down or sign out**, then click **Restart** to restart the computer.\n\n    Restarting the computer is required to start the installation of the Linux distribution. It can take a few minutes for the installation to complete after you restart.\n\n    For more information about setting up WSL as a development environment, see the [Set up a WSL development environment](https://learn.microsoft.com/en-us/windows/wsl/setup/environment){target=\\_blank} docs.\n\n### Install Required Packages and Rust {: #install-required-packages-and-rust-windows }\n\nTo install the Rust toolchain on WSL:\n\n1. Click the **Start** menu, then select **Ubuntu**.\n2. Type a UNIX user name to create user account.\n3. Type a password for your UNIX user, then retype the password to confirm it.\n4. Download the latest updates for the Ubuntu distribution using the Ubuntu Advanced Packaging Tool (`apt`) by running the following command:\n\n    ```bash\n    sudo apt update\n    ```\n\n5. Add the required packages for the Ubuntu distribution by running the following command:\n\n    ```bash\n    sudo apt install --assume-yes git clang curl libssl-dev llvm libudev-dev make protobuf-compiler\n    ```\n\n6. Download the `rustup` installation program and use it to install Rust for the Ubuntu distribution by running the following command:\n\n    ```bash\n    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n    ```\n\n7. Follow the prompts displayed to proceed with a default installation.\n\n8. Update your current shell to include Cargo by running the following command:\n\n    ```bash\n    source ~/.cargo/env\n    ```\n\n9. Verify your installation by running the following command:\n\n    ```bash\n    rustc --version\n    ```\n\n10. Configure the Rust toolchain to use the latest stable version as the default toolchain by running the following commands:\n\n    ```bash\n    rustup default stable\n    rustup update\n    rustup target add wasm32-unknown-unknown\n    rustup component add rust-src\n    ```\n\n11. [Verify your installation](#verifying-installation).\n\n## Verifying Installation\n\nVerify the configuration of your development environment by running the following command:\n\n```bash\nrustup show\n```\n\nThe command displays output similar to the following:\n\n-<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>rustup show</span>\n  <span data-ty>...</span>\n  <br />\n  <span data-ty>active toolchain</span>\n  <span data-ty>----------------</span>\n  <span data-ty>name: stable-aarch64-apple-darwin</span>\n  <span data-ty>active because: it's the default toolchain</span>\n  <span data-ty>installed targets:</span>\n  <span data-ty>  aarch64-apple-darwin</span>\n  <span data-ty>  wasm32-unknown-unknown</span>\n</div>\n\n\n## Where to Go Next\n\n- **[Parachain Zero to Hero Tutorials](/tutorials/polkadot-sdk/parachains/zero-to-hero/){target=\\_blank}**: A series of step-by-step guides to building, testing, and deploying custom pallets and runtimes using the Polkadot SDK.\n"}
{"title": "Interoperability", "slug": "polkadot-protocol-parachain-basics-interoperability", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-interoperability.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/interoperability/", "categories": ["Basics", "Polkadot Protocol"], "description": "Explore the importance of interoperability in the Polkadot ecosystem, covering XCM, bridges, and cross-chain communication.", "estimated_token_count": 782, "token_estimator": "heuristic-v1", "content": "# Interoperability\n\n## Introduction\n\nInteroperability lies at the heart of the Polkadot ecosystem, enabling communication and collaboration across a diverse range of blockchains. By bridging the gaps between parachains, relay chains, and even external networks, Polkadot unlocks the potential for truly decentralized applications, efficient resource sharing, and scalable solutions.\n\nPolkadot’s design ensures that blockchains can transcend their individual limitations by working together as part of a unified system. This cooperative architecture is what sets Polkadot apart in the blockchain landscape.\n\n## Why Interoperability Matters\n\nThe blockchain ecosystem is inherently fragmented. Different blockchains excel in specialized domains such as finance, gaming, or supply chain management, but these chains function in isolation without interoperability. This lack of connectivity stifles the broader utility of blockchain technology.\n\nInteroperability solves this problem by enabling blockchains to:\n\n- **Collaborate across networks**: Chains can interact to share assets, functionality, and data, creating synergies that amplify their individual strengths.\n- **Achieve greater scalability**: Specialized chains can offload tasks to others, optimizing performance and resource utilization.\n- **Expand use-case potential**: Cross-chain applications can leverage features from multiple blockchains, unlocking novel user experiences and solutions.\n\nIn the Polkadot ecosystem, interoperability transforms a collection of isolated chains into a cohesive, efficient network, pushing the boundaries of what blockchains can achieve together.\n\n## Key Mechanisms for Interoperability\n\nAt the core of Polkadot's cross-chain collaboration are foundational technologies designed to break down barriers between networks. These mechanisms empower blockchains to communicate, share resources, and operate as a cohesive ecosystem.\n\n### Cross-Consensus Messaging (XCM): The Backbone of Communication\n\nPolkadot's Cross-Consensus Messaging (XCM) is the standard framework for interaction between parachains, relay chains, and, eventually, external blockchains. XCM provides a trustless, secure messaging format for exchanging assets, sharing data, and executing cross-chain operations.\n\nThrough XCM, decentralized applications can:\n\n- Transfer tokens and other assets across chains.\n- Coordinate complex workflows that span multiple blockchains.\n- Enable seamless user experiences where underlying blockchain differences are invisible.\n- XCM exemplifies Polkadot’s commitment to creating a robust and interoperable ecosystem.\n\nFor further information about XCM, check the [Introduction to XCM](/develop/interoperability/intro-to-xcm/){target=\\_blank} article.\n\n### Bridges: Connecting External Networks\n\nWhile XCM enables interoperability within the Polkadot ecosystem, bridges extend this functionality to external blockchains such as Ethereum and Bitcoin. By connecting these networks, bridges allow Polkadot-based chains to access external liquidity, additional functionalities, and broader user bases.\n\nWith bridges, developers and users gain the ability to:\n\n- Integrate external assets into Polkadot-based applications.\n- Combine the strengths of Polkadot’s scalability with the liquidity of other networks.\n- Facilitate accurate multi-chain applications that transcend ecosystem boundaries.\n\nFor more information about bridges in the Polkadot ecosystem, see the [Bridge Hub](/polkadot-protocol/architecture/system-chains/bridge-hub/){target=\\_blank} guide.\n\n## The Polkadot Advantage\n\nPolkadot was purpose-built for interoperability. Unlike networks that add interoperability as an afterthought, Polkadot integrates it as a fundamental design principle. This approach offers several distinct advantages:\n\n- **Developer empowerment**: Polkadot’s interoperability tools allow developers to build applications that leverage multiple chains’ capabilities without added complexity.\n- **Enhanced ecosystem collaboration**: Chains in Polkadot can focus on their unique strengths while contributing to the ecosystem’s overall growth.\n- **Future-proofing blockchain**: By enabling seamless communication, Polkadot ensures its ecosystem can adapt to evolving demands and technologies.\n\n## Looking Ahead\n\nPolkadot’s vision of interoperability extends beyond technical functionality, representing a shift towards a more collaborative blockchain landscape. By enabling chains to work together, Polkadot fosters innovation, efficiency, and accessibility, paving the way for a decentralized future where blockchains are not isolated competitors but interconnected collaborators.\n"}
{"title": "Introduction to Polkadot SDK", "slug": "develop-parachains-intro-polkadot-sdk", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-parachains-intro-polkadot-sdk.md", "html_url": "https://docs.polkadot.com/develop/parachains/intro-polkadot-sdk/", "categories": ["Basics", "Tooling"], "description": "Learn about the Polkadot SDK, a robust developer toolkit for building custom blockchains. Explore its components and how it powers the Polkadot protocol.", "estimated_token_count": 1895, "token_estimator": "heuristic-v1", "content": "# Introduction to Polkadot SDK\n\n## Introduction\n\nThe [Polkadot SDK](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506){target=\\_blank} is a powerful and versatile developer kit designed to facilitate building on the Polkadot network. It provides the necessary components for creating custom blockchains, parachains, generalized rollups, and more. Written in the Rust programming language, it puts security and robustness at the forefront of its design.\n\nWhether you're building a standalone chain or deploying a parachain on Polkadot, this SDK equips developers with the libraries and tools needed to manage runtime logic, compile the codebase, and utilize core features like staking, governance, and Cross-Consensus Messaging (XCM). It also provides a means for building generalized peer-to-peer systems beyond blockchains. The Polkadot SDK houses the following overall functionality:\n\n- Networking and peer-to-peer communication (powered by [Libp2p](/polkadot-protocol/glossary#libp2p){target=\\_blank}).\n- Consensus protocols, such as [BABE](/polkadot-protocol/glossary#blind-assignment-of-blockchain-extension-babe){target=\\_blank}, [GRANDPA](/polkadot-protocol/glossary#grandpa){target=\\_blank}, or [Aura](/polkadot-protocol/glossary#authority-round-aura){target=\\_blank}.\n- Cryptography.\n- The ability to create portable Wasm runtimes.\n- A selection of pre-built modules, called [pallets](/polkadot-protocol/glossary#pallet){target=\\_blank}.\n- Benchmarking and testing suites.\n\nFor an in-depth look at the monorepo, see the [Polkadot SDK Rust documentation](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/index.html){target=\\_blank}.\n\n## Polkadot SDK Overview\n\nThe Polkadot SDK is composed of five major components:\n\n![](/images/develop/parachains/intro-polkadot-sdk/intro-polkadot-sdk-1.webp)\n\n- **[Substrate](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/substrate/index.html){target=\\_blank}**: A set of libraries and primitives for building blockchains.\n- **[FRAME](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/frame_runtime/index.html){target=\\_blank}**: A blockchain development framework built on top of Substrate.\n- **[Cumulus](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/cumulus/index.html){target=\\_blank}**: A set of libraries and pallets to add parachain capabilities to a Substrate/FRAME runtime.\n- **[XCM (Cross Consensus Messaging)](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/xcm/index.html){target=\\_blank}**: The primary format for conveying messages between parachains.\n- **[Polkadot](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/polkadot/index.html){target=\\_blank}**: The node implementation for the Polkadot protocol.\n\n### Substrate\n\nSubstrate is a Software Development Kit (SDK) that uses Rust-based libraries and tools to enable you to build application-specific blockchains from modular and extensible components. Application-specific blockchains built with Substrate can run as standalone services or in parallel with other chains to take advantage of the shared security provided by the Polkadot ecosystem. Substrate includes default implementations of the core components of the blockchain infrastructure to allow you to focus on the application logic.\n\nEvery blockchain platform relies on a decentralized network of computers—called nodes—that communicate with each other about transactions and blocks. In general, a node in this context is the software running on the connected devices rather than the physical or virtual machine in the network. As software, Substrate-based nodes consist of two main parts with separate responsibilities:\n\n- **Client**: Services to handle network and blockchain infrastructure activity.\n\n    - Native binary.\n    - Executes the Wasm runtime.\n    - Manages components like database, networking, mempool, consensus, and others.\n    - Also known as \"Host\".\n\n- **Runtime**: Business logic for state transitions.\n\n    - Application logic.\n    - Compiled to [Wasm](https://webassembly.org/){target=\\_blank}.\n    - Stored as a part of the chain state.\n    - Also known as State Transition Function (STF).\n\n```mermaid\n%%{init: {'flowchart': {'padding': 5, 'nodeSpacing': 50, 'rankSpacing': 10}}}%%\ngraph TB\n    classDef title font-size:20px,font-weight:bold,stroke-width:0px\n    classDef clientStyle font-size:16px,font-weight:bold\n    classDef clientSubNodeStyle margin-top:10px\n    classDef runtimeCallExecutorStyle padding-top:10px\n\n    subgraph sg1[Substrate<br /> Node]\n        direction TB\n\n        I[RuntimeCall Executor]\n        B[Wasm Runtime - STF]\n\n        subgraph sg2[Client]\n            direction TB\n            C[Network and Blockchain<br/>Infrastructure Services]\n        end\n\n        I --> B\n    end\n\n    class sg1 title\n    class sg2 clientStyle\n    class C clientSubNodeStyle\n    class I runtimeCallExecutorStyle\n\n```\n\n### FRAME\n\nFRAME provides the core modular and extensible components that make the Substrate SDK flexible and adaptable to different use cases. FRAME includes Rust-based libraries that simplify the development of application-specific logic. Most of the functionality that FRAME provides takes the form of plug-in modules called [pallets](/polkadot-protocol/glossary#pallet){target=\\_blank} that you can add and configure to suit your requirements for a custom runtime.\n\n```mermaid\ngraph LR\n    subgraph SP[\"<b style='font-size:18px;'>Runtime</b>\"]\n        direction LR\n        Timestamp ~~~ Aura ~~~ GRANDPA\n        Balances ~~~ TransactionPayment ~~~ Sudo\n        subgraph Timestamp[\"Timestamp\"]\n            SS1[Custom Config]\n        end\n        subgraph Aura[\"Aura\"]\n            SS2[Custom Config]\n        end\n        subgraph GRANDPA[\"GRANDPA\"]\n            SS3[Custom Config]\n        end\n        subgraph Balances[\"Balances\"]\n            SS4[Custom Config]\n        end\n        subgraph TransactionPayment[\"Transaction Payment\"]\n            SS5[Custom Config]\n        end\n        subgraph Sudo[\"Sudo\"]\n            SS6[Custom Config]\n        end\n        style Timestamp stroke:#FF69B4\n        style Aura stroke:#FF69B4\n        style GRANDPA stroke:#FF69B4\n        style Balances stroke:#FF69B4\n        style TransactionPayment stroke:#FF69B4\n        style Sudo stroke:#FF69B4\n        style SS1 stroke-dasharray: 5\n        style SS2 stroke-dasharray: 5\n        style SS3 stroke-dasharray: 5\n        style SS4 stroke-dasharray: 5\n        style SS5 stroke-dasharray: 5\n        style SS6 stroke-dasharray: 5\n\n    end\n    subgraph AP[\"<b style='font-size:18px;'>FRAME Pallets</b>\"]\n        direction LR\n        A1[Aura]~~~A2[BABE]~~~A3[GRANDPA]~~~A4[Transaction<br>Payment]\n        B1[Identity]~~~B2[Balances]~~~B3[Sudo]~~~B4[EVM]\n        C1[Timestamp]~~~C2[Assets]~~~C3[Contracts]~~~C4[and more...]\n    end\n    AP --> SP\n```\n\n### Cumulus\n\nCumulus provides utilities and libraries to turn FRAME-based runtimes into runtimes that can be a parachain on Polkadot. Cumulus runtimes are still FRAME runtimes but contain the necessary functionality that allows that runtime to become a parachain on a relay chain.\n\n## Why Use Polkadot SDK?\n\nUsing the Polkadot SDK, you can build application-specific blockchains without the complexity of building a blockchain from scratch or the limitations of building on a general-purpose blockchain. You can focus on crafting the business logic that makes your chain unique and innovative with the additional benefits of flexibility, upgradeability, open-source licensing, and cross-consensus interoperability.\n\n## Create a Custom Blockchain Using the SDK\n\nBefore starting your blockchain development journey, you'll need to decide whether you want to build a standalone chain or a parachain that connects to the Polkadot network. Each path has its considerations and requirements. Once you've made this decision, follow these development stages:\n\n```mermaid\ngraph LR\n    A[Install the Polkadot SDK] --> B[Build the Chain]\n    B --> C[Deploy the Chain]\n```\n\n1. **[Install the Polkadot SDK](/develop/parachains/install-polkadot-sdk/)**: Set up your development environment with all necessary dependencies and tools.\n2. **[Build the chain](/develop/parachains/customize-parachain)**: Learn how to create and customize your blockchain's runtime, configure pallets, and implement your chain's unique features.\n3. **[Deploy the chain](/develop/parachains/deployment)**: Follow the steps to launch your blockchain, whether as a standalone network or as a parachain on Polkadot.\n\nEach stage is covered in detail in its respective guide, walking you through the process from initial setup to final deployment.\n"}
{"title": "Introduction to XCM", "slug": "develop-interoperability-intro-to-xcm", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-interoperability-intro-to-xcm.md", "html_url": "https://docs.polkadot.com/develop/interoperability/intro-to-xcm/", "categories": ["Basics", "Polkadot Protocol"], "description": "Unlock blockchain interoperability with XCM — Polkadot's Cross-Consensus Messaging format for cross-chain interactions.", "estimated_token_count": 1513, "token_estimator": "heuristic-v1", "content": "# Introduction to XCM\n\n## Introduction\n\nPolkadot’s unique value lies in its ability to enable interoperability between parachains and other blockchain systems. At the core of this capability is XCM (Cross-Consensus Messaging)—a flexible messaging format that facilitates communication and collaboration between independent consensus systems.\n\nWith XCM, one chain can send intents to another one, fostering a more interconnected ecosystem. Although it was developed specifically for Polkadot, XCM is a universal format, usable in any blockchain environment. This guide provides an overview of XCM’s core principles, design, and functionality, alongside practical examples of its implementation.\n\n## Messaging Format\n\nXCM is not a protocol but a standardized [messaging format](https://github.com/polkadot-fellows/xcm-format){target=\\_blank}. It defines the structure and behavior of messages but does not handle their delivery. This separation allows developers to focus on crafting instructions for target systems without worrying about transmission mechanics.\n\nXCM messages are intent-driven, outlining desired actions for the receiving blockchain to consider and potentially alter its state. These messages do not directly execute changes; instead, they rely on the host chain's environment to interpret and implement them. By utilizing asynchronous composability, XCM facilitates efficient execution where messages can be processed independently of their original order, similar to how RESTful services handle HTTP requests without requiring sequential processing.\n\n## The Four Principles of XCM\n\nXCM adheres to four guiding principles that ensure robust and reliable communication across consensus systems:\n\n- **Asynchronous**: XCM messages operate independently of sender acknowledgment, avoiding delays due to blocked processes.\n- **Absolute**: XCM messages are guaranteed to be delivered and interpreted accurately, in order, and timely. Once a message is sent, one can be sure it will be processed as intended.\n- **Asymmetric**: XCM messages follow the 'fire and forget' paradigm meaning no automatic feedback is provided to the sender. Any results must be communicated separately to the sender with an additional message back to the origin.\n- **Agnostic**: XCM operates independently of the specific consensus mechanisms, making it compatible across diverse systems.\n\nThese principles guarantee that XCM provides a reliable framework for cross-chain communication, even in complex environments.\n\n## The XCM Tech Stack\n\n![Diagram of the XCM tech stack](/images/develop/interoperability/intro-to-xcm/intro-to-xcm-01.webp)\n\nThe XCM tech stack is designed to facilitate seamless interoperable communication between chains that reside within the Polkadot ecosystem. XCM can be used to express the meaning of the messages over each of the communication channels.\n\n## Core Functionalities of XCM\n\nXCM enhances cross-consensus communication by introducing several powerful features:\n\n- **Programmability**: Supports dynamic message handling, allowing for more comprehensive use cases. Includes branching logic, safe dispatches for version checks, and asset operations like NFT management.\n- **Functional Multichain Decomposition**: Enables mechanisms such as remote asset locking, asset namespacing, and inter-chain state referencing, with contextual message identification.\n- **Bridging**: Establishes a universal reference framework for multi-hop setups, connecting disparate systems like Ethereum and Bitcoin with the Polkadot relay chain acting as a universal location.\n\nThe standardized format for messages allows parachains to handle tasks like user balances, governance, and staking, freeing the Polkadot relay chain to focus on shared security. These features make XCM indispensable for implementing scalable and interoperable blockchain applications. \n\n## XCM Example\n\nThe following is a simplified XCM message demonstrating a token transfer from Alice to Bob on the same chain (ParaA).\n\n```rust\n-let message = Xcm(vec![\n    WithdrawAsset((Here, amount).into()),\n    BuyExecution { \n        fees: (Here, amount).into(), \n        weight_limit: WeightLimit::Unlimited \n    },\n    DepositAsset {\n        assets: All.into(),\n        beneficiary: MultiLocation {\n            parents: 0,\n            interior: Junction::AccountId32 {\n                network: None,\n                id: BOB.clone().into()\n            }.into(),\n        }.into()\n    }\n]);\n```\n\nThe message consists of three instructions described as follows:\n\n- **[WithdrawAsset](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#withdrawasset){target=\\_blank}**: Transfers a specified number of tokens from Alice's account to a holding register.\n\n    ```rust\n    -    WithdrawAsset((Here, amount).into()),\n    ```\n\n    - **`Here`**: The native parachain token.\n    - **`amount`**: The number of tokens that are transferred.\n\n    The first instruction takes as an input the MultiAsset that should be withdrawn. The MultiAsset describes the native parachain token with the `Here` keyword. The `amount` parameter is the number of tokens that are transferred. The withdrawal account depends on the origin of the message. In this example the origin of the message is Alice. The `WithdrawAsset` instruction moves `amount` number of native tokens from Alice's account into the holding register.\n\n- **[BuyExecution](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#buyexecution){target=\\_blank}**: Allocates fees to cover the execution [weight](/polkadot-protocol/glossary/#weight){target=\\_blank} of the XCM instructions.\n\n    ```rust\n    -    BuyExecution { \n        fees: (Here, amount).into(), \n        weight_limit: WeightLimit::Unlimited \n    },\n    ```\n\n    - **`fees`**: Describes the asset in the holding register that should be used to pay for the weight.\n    - **`weight_limit`**: Defines the maximum fees that can be used to buy weight.\n\n- **[DepositAsset](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#depositasset){target=\\_blank}**: Moves the remaining tokens from the holding register to Bob’s account.\n\n    ```rust\n    -    DepositAsset {\n        assets: All.into(),\n        beneficiary: MultiLocation {\n            parents: 0,\n            interior: Junction::AccountId32 {\n                network: None,\n                id: BOB.clone().into()\n            }.into(),\n        }.into()\n    }\n    ```\n\n    - **`All`**: The wildcard for the asset(s) to be deposited. In this case, all assets in the holding register should be deposited.\n    \nThis step-by-step process showcases how XCM enables precise state changes within a blockchain system. You can find a complete XCM message example in the [XCM repository](https://github.com/paritytech/xcm-docs/blob/main/examples/src/0_first_look/mod.rs){target=\\_blank}.\n\n## Overview\n\nXCM revolutionizes cross-chain communication by enabling use cases such as:\n\n- Token transfers between blockchains.\n- Asset locking for cross-chain smart contract interactions.\n- Remote execution of functions on other blockchains.\n\nThese functionalities empower developers to build innovative, multi-chain applications, leveraging the strengths of various blockchain networks. To stay updated on XCM’s evolving format or contribute, visit the [XCM repository](https://github.com/paritytech/xcm-docs/blob/main/examples/src/0_first_look/mod.rs){target=\\_blank}.\n"}
{"title": "JSON-RPC APIs", "slug": "develop-smart-contracts-json-rpc-apis", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-smart-contracts-json-rpc-apis.md", "html_url": "https://docs.polkadot.com/develop/smart-contracts/json-rpc-apis/", "categories": ["Reference"], "description": "JSON-RPC APIs guide for Polkadot Hub, covering supported methods, parameters, and examples for interacting with the chain.", "estimated_token_count": 9788, "token_estimator": "heuristic-v1", "content": "# JSON-RPC APIs\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nPolkadot Hub provides Ethereum compatibility through its JSON-RPC interface, allowing developers to interact with the chain using familiar Ethereum tooling and methods. This document outlines the supported [Ethereum JSON-RPC methods](https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods){target=\\_blank} and provides examples of how to use them.\n\nThis guide uses the Polkadot Hub TestNet endpoint:\n\n```text\nhttps://testnet-passet-hub-eth-rpc.polkadot.io\n```\n\n## Available Methods\n\n### eth_accounts\n\nReturns a list of addresses owned by the client. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_accounts\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_accounts\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### eth_blockNumber\n\nReturns the number of the most recent block. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_blockNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_blockNumber\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### eth_call\n\nExecutes a new message call immediately without creating a transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call){target=\\_blank}.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction call object.\n    - **`to` ++\"string\"++**: Recipient address of the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: Hash of the method signature and encoded parameters. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`from` ++\"string\"++**: (Optional) Sender's address for the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (Optional) Gas limit to execute the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit of gas. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Value in wei to send with the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) Block tag or block number to execute the call at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_call\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_call\",\n    \"params\":[{\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"data\": \"INSERT_ENCODED_CALL\"\n    }, \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_RECIPIENT_ADDRESS`, `INSERT_ENCODED_CALL`, and `INSERT_BLOCK_VALUE` with the proper values.\n\n---\n\n### eth_chainId\n\nReturns the chain ID used for signing transactions. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_chainId\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_chainId\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### eth_estimateGas\n\nEstimates gas required for a transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas){target=\\_blank}.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction call object.\n    - **`to` ++\"string\"++**: Recipient address of the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: Hash of the method signature and encoded parameters. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`from` ++\"string\"++**: (Optional) Sender's address for the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (Optional) Gas limit to execute the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit of gas. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Value in wei to send with the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) Block tag or block number to execute the call at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_estimateGas\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"data\": \"INSERT_ENCODED_FUNCTION_CALL\"\n    }],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_RECIPIENT_ADDRESS` and `INSERT_ENCODED_CALL` with the proper values.\n\n---\n\n### eth_gasPrice\n\nReturns the current gas price in Wei. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_gasPrice\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_gasPrice\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### eth_getBalance\n\nReturns the balance of a given address. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Address to query balance. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_getBalance\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBalance\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS` and `INSERT_BLOCK_VALUE` with the proper values.\n\n---\n\n### eth_getBlockByHash\n\nReturns information about a block by its hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockHash` ++\"string\"++**: The hash of the block to retrieve. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`fullTransactions` ++\"boolean\"++**: If `true`, returns full transaction details; if `false`, returns only transaction hashes.\n\n**Example**:\n\n```bash title=\"eth_getBlockByHash\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockByHash\",\n    \"params\":[\"INSERT_BLOCK_HASH\", INSERT_BOOLEAN],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_HASH` and `INSERT_BOOLEAN` with the proper values.\n\n---\n\n### eth_getBlockByNumber\n\nReturns information about a block by its number. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`fullTransactions` ++\"boolean\"++**: If `true`, returns full transaction details; if `false`, returns only transaction hashes.\n\n**Example**:\n\n```bash title=\"eth_getBlockByNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockByNumber\",\n    \"params\":[\"INSERT_BLOCK_VALUE\", INSERT_BOOLEAN],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_VALUE` and `INSERT_BOOLEAN` with the proper values.\n\n---\n\n### eth_getBlockTransactionCountByNumber\n\nReturns the number of transactions in a block from a block number. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_getBlockTransactionCountByNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockTransactionCountByNumber\",\n    \"params\":[\"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_VALUE` with the proper values.\n\n---\n\n### eth_getBlockTransactionCountByHash\n\nReturns the number of transactions in a block from a block hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockHash` ++\"string\"++**: The hash of the block to retrieve. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getBlockTransactionCountByHash\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockTransactionCountByHash\",\n    \"params\":[\"INSERT_BLOCK_HASH\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_HASH` with the proper values.\n\n---\n\n### eth_getCode\n\nReturns the code at a given address. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Contract or account address to query code. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block).\n\n**Example**:\n\n```bash title=\"eth_getCode\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getCode\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS` and `INSERT_BLOCK_VALUE` with the proper values.\n\n---\n\n### eth_getLogs\n\nReturns an array of all logs matching a given filter object. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs){target=\\_blank}.\n\n**Parameters**:\n\n- **`filter` ++\"object\"++**: The filter object.\n    - **`fromBlock` ++\"string\"++**: (Optional) Block number or tag to start from. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n    - **`toBlock` ++\"string\"++**: (Optional) Block number or tag to end at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n    - **`address` ++\"string\" or \"array of strings\"++**: (Optional) Contract address or a list of addresses from which to get logs. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`topics` ++\"array of strings\"++**: (Optional) Array of topics for filtering logs. Each topic can be a single [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string or an array of such strings (meaning OR).\n    - **`blockhash` ++\"string\"++**: (Optional) Hash of a specific block. Cannot be used with `fromBlock` or `toBlock`. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getLogs\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getLogs\",\n    \"params\":[{\n        \"fromBlock\": \"latest\",\n        \"toBlock\": \"latest\"\n    }],\n    \"id\":1\n}'\n```\n\n---\n\n### eth_getStorageAt\n\nReturns the value from a storage position at a given address. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Contract or account address to query code. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`storageKey` ++\"string\"++**: Position in storage to retrieve data from. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block).\n\n**Example**:\n\n```bash title=\"eth_getStorageAt\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getStorageAt\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_STORAGE_KEY\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS`, `INSERT_STORAGE_KEY`, and `INSERT_BLOCK_VALUE` with the proper values.\n\n---\n\n### eth_getTransactionCount\n\nReturns the number of transactions sent from an address (nonce). [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Address to query balance. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block).\n\n**Example**:\n\n```bash title=\"eth_getTransactionCount\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionCount\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS` and `INSERT_BLOCK_VALUE` with the proper values.\n\n---\n\n### eth_getTransactionByHash\n\nReturns information about a transaction by its hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash){target=\\_blank}.\n\n**Parameters**:\n\n- **`transactionHash` ++\"string\"++**: The hash of the transaction. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionByHash\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionByHash\",\n    \"params\":[\"INSERT_TRANSACTION_HASH\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_TRANSACTION_HASH` with the proper values.\n\n---\n\n### eth_getTransactionByBlockNumberAndIndex\n\nReturns information about a transaction by block number and transaction index. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyblocknumberandindex){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`transactionIndex` ++\"string\"++**: The index of the transaction in the block. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionByBlockNumberAndIndex\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionByBlockNumberAndIndex\",\n    \"params\":[\"INSERT_BLOCK_VALUE\", \"INSERT_TRANSACTION_INDEX\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_VALUE` and `INSERT_TRANSACTION_INDEX` with the proper values.\n\n---\n\n### eth_getTransactionByBlockHashAndIndex\n\nReturns information about a transaction by block hash and transaction index. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyblockhashandindex){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockHash` ++\"string\"++**: The hash of the block. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`transactionIndex` ++\"string\"++**: The index of the transaction in the block. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionByBlockHashAndIndex\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionByBlockHashAndIndex\",\n    \"params\":[\"INSERT_BLOCK_HASH\", \"INSERT_TRANSACTION_INDEX\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_HASH` and `INSERT_TRANSACTION_INDEX` with the proper values.\n\n---\n\n### eth_getTransactionReceipt\n\nReturns the receipt of a transaction by transaction hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt){target=\\_blank}.\n\n**Parameters**:\n\n- **`transactionHash` ++\"string\"++**: The hash of the transaction. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionReceipt\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionReceipt\",\n    \"params\":[\"INSERT_TRANSACTION_HASH\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_TRANSACTION_HASH` with the proper values.\n\n---\n\n### eth_maxPriorityFeePerGas\n\nReturns an estimate of the current priority fee per gas, in Wei, to be included in a block.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_maxPriorityFeePerGas\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_maxPriorityFeePerGas\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### eth_sendRawTransaction\n\nSubmits a raw transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction){target=\\_blank}.\n\n**Parameters**:\n\n- **`callData` ++\"string\"++**: Signed transaction data. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_sendRawTransaction\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_sendRawTransaction\",\n    \"params\":[\"INSERT_CALL_DATA\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_CALL_DATA` with the proper values.\n\n---\n\n### eth_sendTransaction\n\nCreates and sends a new transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction){target=\\_blank}.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction object.\n    - **`from` ++\"string\"++**: Address sending the transaction. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`to` ++\"string\"++**: (Optional) Recipient address. No need to provide this value when deploying a contract. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (optional, default: `90000`) gas limit for execution. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Amount of Ether to send. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: (Optional) Contract bytecode or encoded method call. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`nonce` ++\"string\"++**: (Optional) Transaction nonce. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_sendTransaction\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_sendTransaction\",\n    \"params\":[{\n        \"from\": \"INSERT_SENDER_ADDRESS\",\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"gas\": \"INSERT_GAS_LIMIT\",\n        \"gasPrice\": \"INSERT_GAS_PRICE\",\n        \"value\": \"INSERT_VALUE\",\n        \"input\": \"INSERT_INPUT_DATA\",\n        \"nonce\": \"INSERT_NONCE\"\n    }],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_SENDER_ADDRESS`, `INSERT_RECIPIENT_ADDRESS`, `INSERT_GAS_LIMIT`, `INSERT_GAS_PRICE`, `INSERT_VALUE`, `INSERT_INPUT_DATA`, and `INSERT_NONCE` with the proper values.\n\n---\n\n### eth_syncing\n\nReturns an object with syncing data or `false` if not syncing. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_syncing){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_syncing\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_syncing\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### net_listening\n\nReturns `true` if the client is currently listening for network connections, otherwise `false`. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#net_listening){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"net_listening\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"net_listening\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### net_peerCount\n\nReturns the number of peers currently connected to the client.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"net_peerCount\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"net_peerCount\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### net_version\n\nReturns the current network ID as a string. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#net_version){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"net_version\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"net_version\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### system_health\n\nReturns information about the health of the system.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"system_health\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"system_health\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### web3_clientVersion\n\nReturns the current client version. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#web3_clientversion){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"web3_clientVersion\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"web3_clientVersion\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---\n\n### debug_traceBlockByNumber \n\nTraces a block's execution by its number and returns a detailed execution trace for each transaction.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: The block number or tag to trace. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`options` ++\"object\"++**: (Optional) An object containing tracer options.\n    - **`tracer` ++\"string\"++**: The name of the tracer to use (e.g., `\"callTracer\"`, `\"opTracer\"`).\n    - Other tracer-specific options may be supported.\n\n**Example**:\n\n```bash title=\"debug_traceBlockByNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"debug_traceBlockByNumber\",\n    \"params\":[\"INSERT_BLOCK_VALUE\", {\"tracer\": \"callTracer\"}],\n    \"id\":1\n}'\n```\n\nEnsure to replace `INSERT_BLOCK_VALUE` with a proper block number if needed.\n\n---\n\n### debug_traceTransaction\n\nTraces the execution of a single transaction by its hash and returns a detailed execution trace.\n\n**Parameters**:\n\n- **`transactionHash` ++\"string\"++**: The hash of the transaction to trace. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`options` ++\"object\"++**: (Optional) An object containing tracer options (e.g., `tracer: \"callTracer\"`).\n\n**Example**:\n\n```bash title=\"debug_traceTransaction\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"debug_traceTransaction\",\n    \"params\":[\"INSERT_TRANSACTION_HASH\", {\"tracer\": \"callTracer\"}],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_TRANSACTION_HASH` with the proper value.\n\n---\n\n### debug_traceCall\n\nExecutes a new message call and returns a detailed execution trace without creating a transaction on the blockchain.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction call object, similar to `eth_call` parameters.\n    - **`to` ++\"string\"++**: Recipient address of the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: Hash of the method signature and encoded parameters. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`from` ++\"string\"++**: (Optional) Sender's address for the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (Optional) Gas limit to execute the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit of gas. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Value in wei to send with the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) Block tag or block number to execute the call at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`options` ++\"object\"++**: (Optional) An object containing tracer options (e.g., `tracer: \"callTracer\"`).\n\n**Example**:\n\n```bash title=\"debug_traceCall\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"debug_traceCall\",\n    \"params\":[{\n        \"from\": \"INSERT_SENDER_ADDRESS\",\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"data\": \"INSERT_ENCODED_CALL\"\n    }, \"INSERT_BLOCK_VALUE\", {\"tracer\": \"callTracer\"}],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_SENDER_ADDRESS`, `INSERT_RECIPIENT_ADDRESS`, `INSERT_ENCODED_CALL`, and `INSERT_BLOCK_VALUE` with the proper value.\n\n---\n\n## Response Format\n\nAll responses follow the standard JSON-RPC 2.0 format:\n\n```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": ... // The return value varies by method\n}\n```\n\n## Error Handling\n\nIf an error occurs, the response will include an error object:\n\n```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"error\": {\n        \"code\": -32000,\n        \"message\": \"Error message here\"\n    }\n}\n```\n"}
{"title": "Networks", "slug": "develop-networks", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-networks.md", "html_url": "https://docs.polkadot.com/develop/networks/", "categories": ["Basics", "Networks"], "description": "Explore the Polkadot ecosystem networks and learn the unique purposes of each, tailored for blockchain innovation, testing, and enterprise-grade solutions.", "estimated_token_count": 1522, "token_estimator": "heuristic-v1", "content": "# Networks\n\n## Introduction\n\nThe Polkadot ecosystem consists of multiple networks designed to support different stages of blockchain development, from main networks to test networks. Each network serves a unique purpose, providing developers with flexible environments for building, testing, and deploying blockchain applications.\n\nThis section includes essential network information such as RPC endpoints, currency symbols and decimals, and how to acquire TestNet tokens for the Polkadot ecosystem of networks.\n\n## Production Networks\n\n### Polkadot\n\nPolkadot is the primary production blockchain network for high-stakes, enterprise-grade applications. Polkadot MainNet has been running since May 2020 and has implementations in various programming languages ranging from Rust to JavaScript.\n\n=== \"Network Details\"\n\n    **Currency symbol**: `DOT`\n\n    ---\n    \n    **Currency decimals**: 10\n\n    ---\n\n    **Block explorer**: [Polkadot Subscan](https://polkadot.subscan.io/){target=\\_blank}\n\n=== \"RPC Endpoints\"\n\n    Blockops\n\n    ```\n    wss://polkadot-public-rpc.blockops.network/ws\n    ```\n\n    ---\n\n    Dwellir\n\n    ```\n    wss://polkadot-rpc.dwellir.com\n    ```\n\n    ---\n\n    Dwellir Tunisia\n\n    ```\n    wss://polkadot-rpc-tn.dwellir.com\n    ```\n\n    ---\n\n    IBP1\n\n    ```\n    wss://rpc.ibp.network/polkadot\n    ```\n\n    ---\n\n    IBP2\n\n    ```\n    wss://polkadot.dotters.network\n    ```\n\n    ---\n\n    LuckyFriday\n\n    ```\n    wss://rpc-polkadot.luckyfriday.io\n    ```\n\n    ---\n\n    OnFinality\n\n    ```\n    wss://polkadot.api.onfinality.io/public-ws\n    ```\n\n    ---\n\n    RadiumBlock\n\n    ```\n    wss://polkadot.public.curie.radiumblock.co/ws\n    ```\n\n    ---\n\n    RockX\n\n    ```\n    wss://rockx-dot.w3node.com/polka-public-dot/ws\n    ```\n\n    ---\n\n    Stakeworld\n\n    ```\n    wss://dot-rpc.stakeworld.io\n    ```\n\n    ---\n\n    SubQuery\n\n    ```\n    wss://polkadot.rpc.subquery.network/public/ws\n    ```\n\n    ---\n\n    Light client\n\n    ```\n    light://substrate-connect/polkadot\n    ```\n\n### Kusama\n\nKusama is a network built as a risk-taking, fast-moving \"canary in the coal mine\" for its cousin Polkadot. As it is built on top of the same infrastructure, Kusama often acts as a final testing ground for new features before they are launched on Polkadot. Unlike true TestNets, however, the Kusama KSM native token does have economic value. This incentive encourages participants to maintain this robust and performant structure for the benefit of the community.\n\n=== \"Network Details\"\n\n    **Currency symbol**: `KSM`\n\n    ---\n\n    **Currency decimals**: 12\n\n    ---\n    \n    **Block explorer**: [Kusama Subscan](https://kusama.subscan.io/){target=\\_blank}\n\n=== \"RPC Endpoints\"\n\n    Dwellir\n\n    ```\n    wss://kusama-rpc.dwellir.com\n    ```\n\n    ---\n\n    Dwellir Tunisia\n\n    ```\n    wss://kusama-rpc-tn.dwellir.com\n    ```\n\n    ---\n\n    IBP1\n\n    ```\n    wss://rpc.ibp.network/kusama\n    ```\n\n    ---\n\n    IBP2\n\n    ```\n    wss://kusama.dotters.network\n    ```\n\n    ---\n\n    LuckyFriday\n\n    ```\n    wss://rpc-kusama.luckyfriday.io\n    ```\n\n    ---\n\n    OnFinality\n\n    ```\n    wss://kusama.api.onfinality.io/public-ws\n    ```\n\n    ---\n\n    RadiumBlock\n\n    ```\n    wss://kusama.public.curie.radiumblock.co/ws\n    ```\n\n    ---\n\n    RockX\n\n    ```\n    wss://rockx-ksm.w3node.com/polka-public-ksm/ws\n    ```\n\n    ---\n\n    Stakeworld\n\n    ```\n    wss://rockx-ksm.w3node.com/polka-public-ksm/ws\n    ```\n\n    ---\n\n    Light client\n\n    ```\n    light://substrate-connect/kusama\n    ```\n\n## Test Networks\n\n### Westend\n\nWestend is the primary test network that mirrors Polkadot's functionality for protocol-level feature development. As a true TestNet, the WND native token intentionally does not have any economic value. Use the faucet information in the following section to obtain WND tokens.\n\n=== \"Network Information\"\n\n    **Currency symbol**: `WND`\n\n    ---\n\n    **Currency decimals**: 12\n\n    ---\n    \n    **Block explorer**: [Westend Subscan](https://westend.subscan.io/){target=\\_blank}\n\n    ---\n\n    **Faucet**: [Official Westend faucet](https://faucet.polkadot.io/westend){target=\\_blank}\n\n\n=== \"RPC Endpoints\"\n\n    Dwellir\n\n    ```\n    wss://westend-rpc.dwellir.com\n    ```\n\n    ---\n\n    Dwellir Tunisia\n\n    ```\n    wss://westend-rpc-tn.dwellir.com\n    ```\n\n    ---\n\n    IBP1\n\n    ```\n    wss://rpc.ibp.network/westend\n    ```\n\n    ---\n\n    IBP2\n\n    ```\n    wss://westend.dotters.network\n    ```\n\n    ---\n\n    OnFinality\n\n    ```\n    wss://westend.api.onfinality.io/public-ws\n    ```\n\n    ---\n\n    Parity\n\n    ```\n    wss://westend-rpc.polkadot.io\n    ```\n\n    ---\n\n    Light client\n\n    ```\n    light://substrate-connect/westend\n    ```\n\n### Paseo\n\nPaseo is a decentralised, community run, stable testnet for parachain and dapp developers to build and test their applications. Unlike Westend, Paseo is not intended for protocol-level testing. As a true TestNet, the PAS native token intentionally does not have any economic value. Use the faucet information in the following section to obtain PAS tokens.\n\n=== \"Network Information\"\n\n    **Currency symbol**: `PAS`\n\n    ---\n\n    **Currency decimals**: 10\n\n    ---\n    \n    **Block explorer**: [Paseo Subscan](https://paseo.subscan.io/){target=\\_blank}\n\n    ---\n\n    **Faucet**: [Official Paseo faucet](https://faucet.polkadot.io/){target=\\_blank}\n\n=== \"RPC Endpoints\"\n\n    Amforc\n    \n    ```\n    wss://paseo.rpc.amforc.com\n    ```\n    \n    ---\n    \n    Dwellir\n    \n    ```\n    wss://paseo-rpc.dwellir.com\n    ```\n    \n    ---\n    \n    IBP1\n    \n    ```\n    wss://rpc.ibp.network/paseo\n    ```\n    \n    ---\n    \n    IBP2\n    \n    ```\n    wss://paseo.dotters.network\n    ```\n    \n    ---\n    \n    StakeWorld\n    \n    ```\n    wss://pas-rpc.stakeworld.io\n    ```\n\n## Additional Resources\n\n- [**Polkadot Fellowship runtimes repository**](https://github.com/polkadot-fellows/runtimes){target=\\_blank}: Find a collection of runtimes for Polkadot, Kusama, and their system-parachains as maintained by the community via the [Polkadot Technical Fellowship](https://wiki.polkadot.com/learn/learn-polkadot-technical-fellowship/){target=\\_blank}.\n"}
{"title": "Networks", "slug": "polkadot-protocol-parachain-basics-networks", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-networks.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/networks/", "categories": ["Basics", "Polkadot Protocol", "Networks"], "description": "Explore Polkadot's testing and production networks, including Westend, Kusama, and Paseo, for efficient development, deployment, and testing.", "estimated_token_count": 1476, "token_estimator": "heuristic-v1", "content": "# Networks\n\n## Introduction\n\nThe Polkadot ecosystem is built on a robust set of networks designed to enable secure and scalable development. Whether you are testing new features or deploying to live production, Polkadot offers several layers of networks tailored for each stage of the development process. From local environments to experimental networks like Kusama and community-run TestNets such as Paseo, developers can thoroughly test, iterate, and validate their applications. This guide will introduce you to Polkadot's various networks and explain how they fit into the development workflow.\n\n## Network Overview \n\nPolkadot's development process is structured to ensure new features and upgrades are rigorously tested before being deployed on live production networks. The progression follows a well-defined path, starting from local environments and advancing through TestNets, ultimately reaching the Polkadot MainNet. The diagram below outlines the typical progression of the Polkadot development cycle:\n\n``` mermaid\n\nflowchart LR\n    id1[Local] --> id2[Westend] --> id4[Kusama] --> id5[Polkadot]  \n    id1[Local] --> id3[Paseo] --> id5[Polkadot] \n```\nThis flow ensures developers can thoroughly test and iterate without risking real tokens or affecting production networks. Testing tools like [Chopsticks](#chopsticks) and various TestNets make it easier to experiment safely before releasing to production.\n\nA typical journey through the Polkadot core protocol development process might look like this:\n\n1. **Local development node**: Development starts in a local environment, where developers can create, test, and iterate on upgrades or new features using a local development node. This stage allows rapid experimentation in an isolated setup without any external dependencies.\n\n2. **Westend**: After testing locally, upgrades are deployed to [Westend](#westend), Polkadot's primary TestNet. Westend simulates real-world conditions without using real tokens, making it the ideal place for rigorous feature testing before moving on to production networks.\n\n3. **Kusama**: Once features have passed extensive testing on Westend, they move to Kusama, Polkadot's experimental and fast-moving \"canary\" network. Kusama operates as a high-fidelity testing ground with actual economic incentives, giving developers insights into how their features will perform in a real-world environment.\n\n4. **Polkadot**: After passing tests on Westend and Kusama, features are considered ready for deployment to Polkadot, the live production network.\n\n    In addition, parachain developers can leverage local TestNets like [Zombienet](#zombienet) and deploy upgrades on parachain TestNets.\n\n5. **Paseo**: For parachain and dApp developers, Paseo serves as a community-run TestNet that mirrors Polkadot's runtime. Like Westend for core protocol development, Paseo provides a testing ground for parachain development without affecting live networks.\n\n!!!note\n    The Rococo TestNet deprecation date was October 14, 2024. Teams should use Westend for Polkadot protocol and feature testing and Paseo for chain development-related testing.\n\n## Polkadot Development Networks\n\nDevelopment and testing are crucial to building robust dApps and parachains and performing network upgrades within the Polkadot ecosystem. To achieve this, developers can leverage various networks and tools that provide a risk-free environment for experimentation and validation before deploying features to live networks. These networks help avoid the costs and risks associated with real tokens, enabling testing for functionalities like governance, cross-chain messaging, and runtime upgrades.\n\n## Kusama Network\n\nKusama is the experimental version of Polkadot, designed for developers who want to move quickly and test their applications in a real-world environment with economic incentives. Kusama serves as a production-grade testing ground where developers can deploy features and upgrades with the pressure of game theory and economics in mind. It mirrors Polkadot but operates as a more flexible space for innovation.\n\nThe native token for Kusama is KSM. For more information about KSM, visit the [Native Assets](https://guide.kusama.network/docs/learn-DOT#kusama-tokens){target=\\_blank} page.\n\n## Test Networks\n\nThe following test networks provide controlled environments for testing upgrades and new features. TestNet tokens are available from the [Polkadot faucet](https://faucet.polkadot.io/){target=\\_blank}.\n\n### Westend\n\nWestend is Polkadot's primary permanent TestNet. Unlike temporary test networks, Westend is not reset to the genesis block, making it an ongoing environment for testing Polkadot core features. Managed by Parity Technologies, Westend ensures that developers can test features in a real-world simulation without using actual tokens.\n\nThe native token for Westend is WND. More details about WND can be found on the [Native Assets](https://wiki.polkadot.com/learn/learn-dot/#__tabbed_2_2){target=\\_blank} page.\n\n### Paseo\n\n[Paseo](https://github.com/paseo-network){target=\\_blank} is a community-managed TestNet designed for parachain and dApp developers. It mirrors Polkadot's runtime and is maintained by Polkadot community members. Paseo provides a dedicated space for parachain developers to test their applications in a Polkadot-like environment without the risks associated with live networks.\n\nThe native token for Paseo is PAS. Additional information on PAS is available on the [Native Assets](https://wiki.polkadot.com/learn/learn-dot/#__tabbed_2_1){target=\\_blank} page.\n\n## Local Test Networks\n\nLocal test networks are an essential part of the development cycle for blockchain developers using the Polkadot SDK. They allow for fast, iterative testing in controlled, private environments without connecting to public TestNets. Developers can quickly spin up local instances to experiment, debug, and validate their code before deploying to larger TestNets like Westend or Paseo. Two key tools for local network testing are Zombienet and Chopsticks.\n\n### Zombienet\n\n[Zombienet](https://github.com/paritytech/zombienet){target=\\_blank} is a flexible testing framework for Polkadot SDK-based blockchains. It enables developers to create and manage ephemeral, short-lived networks. This feature makes Zombienet particularly useful for quick iterations, as it allows you to run multiple local networks concurrently, mimicking different runtime conditions. Whether you're developing a parachain or testing your custom blockchain logic, Zombienet gives you the tools to automate local testing.\n\nKey features of Zombienet include:\n\n- Creating dynamic, local networks with different configurations.\n- Running parachains and relay chains in a simulated environment.\n- Efficient testing of network components like cross-chain messaging and governance.\n\nZombienet is ideal for developers looking to test quickly and thoroughly before moving to more resource-intensive public TestNets.\n\n### Chopsticks\n\n[Chopsticks](https://github.com/AcalaNetwork/chopsticks){target=\\_blank} is a tool designed to create forks of Polkadot SDK-based blockchains, allowing developers to interact with network forks as part of their testing process. This capability makes Chopsticks a powerful option for testing upgrades, runtime changes, or cross-chain applications in a forked network environment.\n\nKey features of Chopsticks include:\n\n- Forking live Polkadot SDK-based blockchains for isolated testing.\n- Simulating cross-chain messages in a private, controlled setup.\n- Debugging network behavior by interacting with the fork in real-time.\n\nChopsticks provides a controlled environment for developers to safely explore the effects of runtime changes. It ensures that network behavior is tested and verified before upgrades are deployed to live networks.\n"}
{"title": "Networks for Polkadot Hub Smart Contracts", "slug": "polkadot-protocol-smart-contract-basics-networks", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-smart-contract-basics-networks.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/smart-contract-basics/networks/", "categories": ["Basics", "Polkadot Protocol"], "description": "Explore the available networks for smart contract development on Polkadot Hub, including Westend Hub, Kusama Hub, and Polkadot Hub.", "estimated_token_count": 926, "token_estimator": "heuristic-v1", "content": "# Networks\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nPolkadot Hub provides smart contract functionality across multiple networks to facilitate smart contract development in the Polkadot ecosystem. Whether you're testing new contracts or deploying to production, Polkadot Hub offers several network environments tailored for each stage of development. Developers can thoroughly test, iterate, and validate their smart contracts from local testing environments to production networks like Polkadot Hub.\n\nThis guide will introduce you to the current and upcoming networks available for smart contract development and explain how they fit into the development workflow.\n\n## Network Overview\n\nSmart contract development on Polkadot Hub follows a structured process to ensure rigorous testing of new contracts and upgrades before deployment on production networks. Development progresses through a well-defined path, beginning with local environments, advancing through TestNets, and ultimately reaching MainNets. The diagram below illustrates this progression:\n\n``` mermaid\nflowchart LR\n    id1[Local Polkadot Hub] --> id2[TestNet Polkadot Hub] --> id4[MainNet Polkadot Hub]\n```\n\nThis progression ensures developers can thoroughly test and iterate their smart contracts without risking real tokens or affecting production networks. A typical development journey consists of three main stages:\n\n1. Local development:\n\n    - Developers start in a local environment to create, test, and iterate on smart contracts.\n    - Provides rapid experimentation in an isolated setup without external dependencies.\n\n2. TestNet development:\n\n    - Contracts move to TestNets like Westend Hub and Passet Hub.\n    - Enables testing in simulated real-world conditions without using real tokens.\n\n3. Production deployment:\n\n    - Final deployment to MainNets like Kusama Hub and Polkadot Hub.\n    - Represents the live environment where contracts interact with real economic value.\n\n## Local Development\n\nThe local development environment is crucial for smart contract development on Polkadot Hub. It provides developers a controlled space for rapid testing and iteration before moving to public networks. The local setup consists of several key components:\n\n- **[Kitchensink node](https://paritytech.github.io/polkadot-sdk/master/kitchensink_runtime/index.html){target=\\_blank}**: A local node that can be run for development and testing. It includes logging capabilities for debugging contract execution and provides a pre-configured development environment with pre-funded accounts for testing purposes.\n- **[Ethereum RPC proxy](https://paritytech.github.io/polkadot-sdk/master/pallet_revive_eth_rpc/index.html){target=\\_blank}**: Bridges Ethereum-compatible tools with the Polkadot SDK-based network. It enables seamless integration with popular development tools like MetaMask and Remix IDE. The purpose of this component is to translate Ethereum RPC calls into Substrate format.\n\n## Test Networks\n\nThe following test networks provide controlled environments for testing smart contracts. TestNet tokens are available from the [Polkadot faucet](https://faucet.polkadot.io/){target=\\_blank}. They provide a stable environment for testing your contracts without using real tokens.\n\n``` mermaid\nflowchart TB\n    id1[Polkadot Hub TestNets] --> id2[Passet Hub]\n    id1[Polkadot Hub TestNets] --> id3[Westend Hub]\n```\n\n### Passet Hub\n\nThe Passet Hub will be a community-managed TestNet designed specifically for smart contract development. It will mirror Asset Hub's runtime and provide developers with an additional environment for testing their contracts before deployment to production networks.\n\n### Westend Hub\n\nWestend Hub is the TestNet for smart contract development and its cutting-edge features. The network maintains the same features and capabilities as the production Polkadot Hub, and also incorporates the latest features developed by core developers.\n\n## Production Networks\n\nThe MainNet environments represent the final destination for thoroughly tested and validated smart contracts, where they operate with real economic value and serve actual users.\n\n``` mermaid\nflowchart TB\n    id1[Polkadot Hub MainNets] --> id2[Polkadot Hub]\n    id1[Polkadot Hub MainNets] --> id3[Kusama Hub]\n```\n\n### Polkadot Hub\n\nPolkadot Hub is the primary production network for deploying smart contracts in the Polkadot ecosystem. It provides a secure and stable environment for running smart contracts with real economic value. The network supports PolkaVM-compatible contracts written in Solidity or Rust, maintaining compatibility with Ethereum-based development tools.\n\n### Kusama Hub\n\nKusama Hub is the canary version of Polkadot Hub. It is designed for developers who want to move quickly and test their smart contracts in a real-world environment with economic incentives. It provides a more flexible space for innovation while maintaining the same core functionality as Polkadot Hub.\n"}
{"title": "Node and Runtime", "slug": "polkadot-protocol-parachain-basics-node-and-runtime", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-node-and-runtime.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/node-and-runtime/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn how Polkadot SDK-based nodes function, how the client and runtime are separated, and how they communicate using SCALE-encoded data.", "estimated_token_count": 918, "token_estimator": "heuristic-v1", "content": "# Node and Runtime\n\n## Introduction\n\nEvery blockchain platform relies on a decentralized network of computers, called nodes, that communicate with each other about transactions and blocks. In this context, a node refers to the software running on the connected devices rather than the physical or virtual machines in the network.\n\nPolkadot SDK-based nodes consist of two main components, each with distinct responsibilities: the client (also called node) and the runtime.\n\nIf the system were a monolithic protocol, any modification would require updating the entire system. Instead, Polkadot achieves true upgradeability by defining an immutable meta-protocol (the client) and a protocol (the runtime) that can be upgraded independently.\n\nThis separation gives the [Polkadot Relay Chain](/polkadot-protocol/architecture/polkadot-chain){target=\\_blank} and all connected [parachains](/polkadot-protocol/architecture/parachains){target=\\_blank} an evolutionary advantage over other blockchain platforms.\n\n## Architectural Principles\n\nThe Polkadot SDK-based blockchain architecture is fundamentally built on two distinct yet interconnected components:\n\n- Client (Meta-protocol):\n    - Handles the foundational infrastructure of the blockchain.\n    - Manages runtime execution, networking, consensus, and other off-chain components.\n    - Provides an immutable base layer that ensures network stability.\n    - Upgradable only through hard forks.\n\n- Runtime (Protocol):\n    - Defines the blockchain's state transition logic.\n    - Determines the specific rules and behaviors of the blockchain.\n    - Compiled to WebAssembly (Wasm) for platform-independent execution.\n    - Capable of being upgraded without network-wide forking.\n\n### Advantages of this Architecture\n\n- **Forkless upgrades**: Runtime can be updated without disrupting the entire network.\n- **Modularity**: Clear separation allows independent development of client and runtime.\n- **Flexibility**: Enables rapid iteration and evolution of blockchain logic.\n- **Performance**: WebAssembly compilation provides efficient, cross-platform execution.\n\n## Node (Client)\n\nThe node, also known as the client, is the core component responsible for executing the Wasm runtime and orchestrating various essential blockchain components. It ensures the correct execution of the state transition function and manages multiple critical subsystems, including:\n\n- **Wasm execution**: Runs the blockchain runtime, which defines the state transition rules.\n- **Database management**: Stores blockchain data.\n- **Networking**: Facilitates peer-to-peer communication, block propagation, and transaction gossiping.\n- **Transaction pool (Mempool)**: Manages pending transactions before they are included in a block.\n- **Consensus mechanism**: Ensures agreement on the blockchain state across nodes.\n- **RPC services**: Provides external interfaces for applications and users to interact with the node.\n\n## Runtime\n\nThe runtime is more than just a set of rules. It's the fundamental logic engine that defines a blockchain's entire behavior. In Polkadot SDK-based blockchains, the runtime represents a complete, self-contained description of the blockchain's state transition function.\n\n### Characteristics\n\nThe runtime is distinguished by three key characteristics:\n\n- **Business logic**: Defines the complete application-specific blockchain behavior.\n- **WebAssembly compilation**: Ensures platform-independent, secure execution.\n- **On-chain storage**: Stored within the blockchain's state, allowing dynamic updates.\n\n### Key Functions\n\nThe runtime performs several critical functions, such as:\n\n- Define state transition rules.\n- Implement blockchain-specific logic.\n- Manage account interactions.\n- Control transaction processing.\n- Define governance mechanisms.\n- Handle custom pallets and modules.\n\n## Communication Between Node and Runtime\n\nThe client and runtime communicate exclusively using [SCALE-encoded](/polkadot-protocol/parachain-basics/data-encoding){target=\\_blank} communication. This ensures efficient and compact data exchange between the two components.\n\n### Runtime APIs\n\nThe Runtime API consists of well-defined functions and constants a client assumes are implemented in the Runtime Wasm blob. These APIs enable the client to interact with the runtime to execute blockchain operations and retrieve information. The client invokes these APIs to:\n\n- Build, execute, and finalize blocks.\n- Access metadata.\n- Access consensus related information.\n- Handle transaction execution.\n\n### Host Functions\n\nDuring execution, the runtime can access certain external client functionalities via host functions. The specific functions the client exposes allow the runtime to perform operations outside the WebAssembly domain. Host functions enable the runtime to:\n\n- Perform cryptographic operations.\n- Access the current blockchain state.\n- Handle storage modifications.\n- Allocate memory.\n"}
{"title": "On-Chain Governance Overview", "slug": "polkadot-protocol-onchain-governance-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-onchain-governance-overview.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/onchain-governance/overview/", "categories": ["Basics", "Polkadot Protocol"], "description": "Discover Polkadot’s cutting-edge OpenGov system, enabling transparent, decentralized decision-making through direct democracy and flexible governance tracks.", "estimated_token_count": 1614, "token_estimator": "heuristic-v1", "content": "# On-Chain Governance \n\n## Introduction\n\nPolkadot’s governance system exemplifies decentralized decision-making, empowering its community of stakeholders to shape the network’s future through active participation. The latest evolution, OpenGov, builds on Polkadot’s foundation by providing a more inclusive and efficient governance model.\n\nThis guide will explain the principles and structure of OpenGov and walk you through its key components, such as Origins, Tracks, and Delegation. You will learn about improvements over earlier governance systems, including streamlined voting processes and enhanced stakeholder participation.\n\nWith OpenGov, Polkadot achieves a flexible, scalable, and democratic governance framework that allows multiple proposals to proceed simultaneously, ensuring the network evolves in alignment with its community's needs.\n\n## Governance Evolution\n\nPolkadot’s governance journey began with [Governance V1](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#governance-summary){target=\\_blank}, a system that proved effective in managing treasury funds and protocol upgrades. However, it faced limitations, such as:\n\n- Slow voting cycles, causing delays in decision-making.\n- Inflexibility in handling multiple referendums, restricting scalability.\n\nTo address these challenges, Polkadot introduced OpenGov, a governance model designed for greater inclusivity, efficiency, and scalability. OpenGov replaces the centralized structures of Governance V1, such as the Council and Technical Committee, with a fully decentralized and dynamic framework.\n\nFor a full comparison of the historic and current governance models, visit the [Gov1 vs. Polkadot OpenGov](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#gov1-vs-polkadot-opengov){target=\\_blank} section of the Polkadot Wiki.\n\n## OpenGov Key Features\n\nOpenGov transforms Polkadot’s governance into a decentralized, stakeholder-driven model, eliminating centralized decision-making bodies like the Council. Key enhancements include:\n\n- **Decentralization**: Shifts all decision-making power to the public, ensuring a more democratic process.\n- **Enhanced delegation**: Allows users to delegate their votes to trusted experts across specific governance tracks.\n- **Simultaneous referendums**: Multiple proposals can progress at once, enabling faster decision-making.\n- **Polkadot Technical Fellowship**: A broad, community-driven group replacing the centralized Technical Committee.\n\nThis new system ensures Polkadot governance remains agile and inclusive, even as the ecosystem grows.\n\n## Origins and Tracks\n\nIn OpenGov, origins and tracks are central to managing proposals and votes.\n\n- **Origin**: Determines the authority level of a proposal (e.g., Treasury, Root) which decides the track of all referendums from that origin.\n- **Track**: Define the procedural flow of a proposal, such as voting duration, approval thresholds, and enactment timelines.\n\nDevelopers must be aware that referendums from different origins and tracks will take varying amounts of time to reach approval and enactment. The [Polkadot Technical Fellowship](https://wiki.polkadot.com/learn/learn-polkadot-technical-fellowship/){target=\\_blank} has the option to shorten this timeline by whitelisting a proposal and allowing it to be enacted through the [Whitelist Caller](https://wiki.polkadot.com/learn/learn-polkadot-opengov-origins/#whitelisted-caller){target=\\_blank} origin.\n\nVisit [Origins and Tracks Info](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#origins-and-tracks){target=\\_blank} for details on current origins and tracks, associated terminology, and parameters.\n\n## Referendums\n\nIn OpenGov, anyone can submit a referendum, fostering an open and participatory system. The timeline for a referendum depends on the privilege level of the origin with more significant changes offering more time for community voting and participation before enactment. \n\nThe timeline for an individual referendum includes four distinct periods:\n\n- **Lead-in**: A minimum amount of time to allow for community participation, available room in the origin, and payment of the decision deposit. Voting is open during this period.\n- **Decision**: Voting continues.\n- **Confirmation**: Referendum must meet [approval and support](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#approval-and-support){target=\\_blank} criteria during entire period to avoid rejection.\n- **Enactment**: Changes approved by the referendum are executed.\n\n### Vote on Referendums\n\nVoters can vote with their tokens on each referendum. Polkadot uses a voluntary token locking mechanism, called conviction voting, as a way for voters to increase their voting power. A token holder signals they have a stronger preference for approving a proposal based upon their willingness to lock up tokens. Longer voluntary token locks are seen as a signal of continual approval and translate to increased voting weight.\n\nSee [Voting on a Referendum](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#voting-on-a-referendum){target=\\_blank} for a deeper look at conviction voting and related token locks.\n\n### Delegate Voting Power\n\nThe OpenGov system also supports multi-role delegations, allowing token holders to assign their voting power on different tracks to entities with expertise in those areas. \n\nFor example, if a token holder lacks the technical knowledge to evaluate proposals on the [Root track](https://wiki.polkadot.com/learn/learn-polkadot-opengov-origins/#root){target=\\_blank}, they can delegate their voting power for that track to an expert they trust to vote in the best interest of the network. This ensures informed decision-making across tracks while maintaining flexibility for token holders.\n\nVisit [Multirole Delegation](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#multirole-delegation){target=\\_blank} for more details on delegating voting power.\n\n### Cancel a Referendum\n\nPolkadot OpenGov has two origins for rejecting ongoing referendums: \n\n- [**Referendum Canceller**](https://wiki.polkadot.com/learn/learn-polkadot-opengov-origins/#referendum-canceller){target=\\_blank}: Cancels an active referendum when non-malicious errors occur and refunds the deposits to the originators.\n- [**Referendum Killer**](https://wiki.polkadot.com/learn/learn-polkadot-opengov-origins/#referendum-killer){target=\\_blank}: Used for urgent, malicious cases this origin instantly terminates an active referendum and slashes deposits.\n\nSee [Cancelling, Killing, and Blacklisting](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#cancelling-killing--blacklisting){target=\\_blank} for additional information on rejecting referendums.\n\n## Additional Resources\n\n- **[Democracy pallet](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/substrate/frame/democracy/src){target=\\_blank}**: Handles administration of general stakeholder voting.\n- **[Gov2: Polkadot’s Next Generation of Decentralised Governance](https://medium.com/polkadot-network/gov2-polkadots-next-generation-of-decentralised-governance-4d9ef657d11b){target=\\_blank}**: Medium article by Gavin Wood.\n- **[Polkadot Direction](https://matrix.to/#/#Polkadot-Direction:parity.io){target=\\_blank}**: Matrix Element client.\n- **[Polkassembly](https://polkadot.polkassembly.io/){target=\\_blank}**: OpenGov dashboard and UI.\n- **[Polkadot.js Apps Governance](https://polkadot.js.org/apps/#/referenda){target=\\_blank}**: Overview of active referendums.\n"}
{"title": "Overview", "slug": "polkadot-protocol-architecture-parachains-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-architecture-parachains-overview.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/architecture/parachains/overview/", "categories": ["Basics", "Polkadot Protocol", "Parachains"], "description": "Learn about the role, functionality, and implementation of parachains as a developer in the wider Polkadot architecture.", "estimated_token_count": 1867, "token_estimator": "heuristic-v1", "content": "## Introduction \n\nA [_parachain_](/polkadot-protocol/glossary#parachain){target=\\_blank} is a coherent, application-specific blockchain that derives security from its respective relay chain. Parachains on Polkadot are each their own separate, fully functioning blockchain. The primary difference between a parachain and a regular, \"solo\" blockchain is that the relay chain verifies the state of all parachains that are connected to it.  In many ways, parachains can be thought of as a [\"cynical\" rollup](#cryptoeconomic-security-elves-protocol), as the crypto-economic protocol used (ELVES) assumes the worst-case scenario, rather than the typical optimistic approach that many roll-up mechanisms take. Once enough validators attest that a block is valid, then the probability of that block being valid is high.\n\nAs each parachain’s state is validated by the relay chain, the relay chain represents the collective state of all parachains.\n\n```mermaid\nflowchart TB\n    subgraph \"Relay Chain\"\n        RC[Relay Chain Validators]\n        State[Collective State Validation]\n    end\n\n    PA[Parachain A]\n    PB[Parachain B]\n    PC[Parachain C]\n\n    RC -->|Validate State| PA\n    RC -->|Validate State| PB\n    RC -->|Validate State| PC\n\n    State -->|Represents Collective<br>Parachain State| RC\n\n    note[\"ELVES Protocol:<br>- Crypto-economic security<br>- Assumes worst-case scenario<br>- High probability validation\"]\n```\n\n## Coherent Systems\n    \nCoherency refers to the degree of synchronization, consistency, and interoperability between different components or chains within a system. It encompasses the internal coherence of individual chains and the external coherence between chains regarding how they interact.\n    \nA single-state machine like Ethereum is very coherent, as all of its components (smart contracts, dApps/applications, staking, consensus) operate within a single environment with the downside of less scalability. Multi-protocol state machines, such as Polkadot, offer less coherency due to their sharded nature but more scalability due to the parallelization of their architecture.\n\nParachains are coherent, as they are self-contained environments with domain-specific functionality.\n\n## Flexible Ecosystem\n\nParachains enable parallelization of different services within the same network. However, unlike most layer two rollups, parachains don't suffer the same interoperability pitfalls that most rollups suffer. [Cross-Consensus Messaging (XCM)](/develop/interoperability/intro-to-xcm/){target=\\_blank} provides a common communication format for each parachain and can be configured to allow a parachain to communicate with just the relay chain or certain parachains. \n\nThe diagram below highlights the flexibility of the Polkadot ecosystem, where each parachain specializes in a distinct domain. This example illustrates how parachains, like DeFi and GameFi, leverage XCM for cross-chain operations such as asset transfers and credential verification.\n\n```mermaid\nflowchart TB\n    subgraph \"Polkadot Relay Chain\"\n        RC[Relay Chain<br>Cross-Consensus<br>Routing]\n    end\n\n    subgraph \"Parachain Ecosystem\"\n        direction TB\n        DeFi[DeFi Parachain<br>Financial Services]\n        GameFi[GameFi Parachain<br>Gaming Ecosystem]\n        NFT[NFT Parachain<br>Digital Collectibles]\n        Identity[Identity Parachain<br>User Verification]\n    end\n\n    DeFi <-->|XCM: Asset Transfer| GameFi\n    GameFi <-->|XCM: Token Exchange| NFT\n    Identity <-->|XCM: Credential Verification| DeFi\n\n    RC -->|Validate & Route XCM| DeFi\n    RC -->|Validate & Route XCM| GameFi\n    RC -->|Validate & Route XCM| NFT\n    RC -->|Validate & Route XCM| Identity\n\n    note[\"XCM Features:<br>- Standardized Messaging<br>- Cross-Chain Interactions<br>- Secure Asset/Data Transfer\"]\n```\n\nMost parachains are built using the Polkadot SDK, which provides all the tools to create a fully functioning parachain. However, it is possible to construct a parachain that can inherit the security of the relay chain as long as it implements the correct mechanisms expected by the relay chain.\n\n## State Transition Functions (Runtimes)\n\nDeterminism is a fundamental property where given the same input, a system will consistently produce identical outputs. In blockchain systems, this predictable behavior is essential for state machines, which are algorithms that transition between different states based on specific inputs to generate a new state.\n\nAt their core, parachains, like most blockchains, are deterministic, finite-state machines that are often backed by game theory and economics. The previous state of the parachain, combined with external input in the form of [extrinsics](/polkadot-protocol/glossary#extrinsic){target=\\_blank}, allows the state machine to progress forward, one block at a time.\n\n```mermaid\nstateDiagram-v2\n    direction LR\n    [*] --> StateA : Initial State\n    \n    StateA --> STF : Extrinsics/Transactions\n    STF --> StateB : Deterministic Transformation\n    StateB --> [*] : New State\n```\n\nThe primary driver of this progression is the state transition function (STF), commonly referred to as a runtime. Each time a block is submitted, it represents the next proposed state for a parachain. By applying the state transition function to the previous state and including a new block that contains the proposed changes in the form of a list of extrinsics/transactions, the runtime defines just exactly how the parachain is to advance from state A to state B.\n\nThe STF in a Polkadot SDK-based chain is compiled to Wasm and uploaded on the relay chain. This STF is crucial for the relay chain to validate the state changes coming from the parachain, as it is used to ensure that all proposed state transitions are happening correctly as part of the validation process.\n\nFor more information on the Wasm meta protocol that powers runtimes, see the [WASM Meta Protocol](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/wasm_meta_protocol/index.html){target=\\blank} in the Polkadot SDK Rust Docs.\n\n## Shared Security: Validated by the Relay Chain\n\nThe relay chain provides a layer of economic security for its parachains. Parachains submit proof of validation (PoV) data to the relay chain for validation through [collators](/polkadot-protocol/glossary/#collator), upon which the relay chains' validators ensure the validity of this data in accordance with the STF for that particular parachain. In other words, the consensus for a parachain follows the relay chain. While parachains choose how a block is authored, what it contains, and who authors it, the relay chain ultimately provides finality and consensus for those blocks.\n\nFor more information about the parachain and relay chain validation process, see the [Parachains' Protocol Overview: Protocols' Summary](https://wiki.polkadot.com/learn/learn-parachains-protocol/#protocols-summary){target=\\blank} entry in the Polkadot Wiki.\n\nParachains need at least one honest collator to submit PoV data to the relay chain. Without this, the parachain can't progress. The mechanisms that facilitate this are found in the Cumulus portion of the Polkadot SDK, some of which are found in the [`cumulus_pallet_parachain_system`](https://paritytech.github.io/polkadot-sdk/master/cumulus_pallet_parachain_system/index.html){target=\\blank}\n\n### Cryptoeconomic Security: ELVES Protocol\n\nThe [ELVES (Economic Last Validation Enforcement System)](https://eprint.iacr.org/2024/961){target=\\_blank} protocol forms the foundation of Polkadot's cryptoeconomic security model. ELVES assumes a worst-case scenario by enforcing strict validation rules before any state transitions are finalized. Unlike optimistic approaches that rely on post-facto dispute resolution, ELVES ensures that validators collectively confirm the validity of a block before it becomes part of the parachain's state.\n\nValidators are incentivized through staking and penalized for malicious or erroneous actions, ensuring adherence to the protocol. This approach minimizes the probability of invalid states being propagated across the network, providing robust security for parachains.\n\n## Interoperability\n\nPolkadot's interoperability framework allows parachains to communicate with each other, fostering a diverse ecosystem of interconnected blockchains. Through [Cross-Consensus Messaging (XCM)](/develop/interoperability/intro-to-xcm/){target=_blank}, parachains can transfer assets, share data, and invoke functionalities on other chains securely. This standardized messaging protocol ensures that parachains can interact with the relay chain and each other, supporting efficient cross-chain operations.\n\nThe XCM protocol mitigates common interoperability challenges in isolated blockchain networks, such as fragmented ecosystems and limited collaboration. By enabling decentralized applications to leverage resources and functionality across parachains, Polkadot promotes a scalable, cooperative blockchain environment that benefits all participants.\n\n## Where to Go Next\n\nFor further information about the consensus protocol used by parachains, see the [Consensus](/polkadot-protocol/architecture/parachains/consensus/) page.\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge learn\">Learn</span> __Consensus__\n\n    ---\n\n    Understand how the blocks authored by parachain collators are secured by the relay chain validators and how the parachain transactions achieve finality.\n\n    [:octicons-arrow-right-24: Reference](/polkadot-protocol/architecture/parachains/consensus/)\n\n</div>\n"}
{"title": "Overview of FRAME", "slug": "develop-parachains-customize-parachain-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-parachains-customize-parachain-overview.md", "html_url": "https://docs.polkadot.com/develop/parachains/customize-parachain/overview/", "categories": ["Basics", "Parachains"], "description": "Learn how Polkadot SDK’s FRAME framework simplifies blockchain development with modular pallets and support libraries for efficient runtime design.", "estimated_token_count": 2008, "token_estimator": "heuristic-v1", "content": "# Overview\n\n## Introduction\n\nThe runtime is the heart of any Polkadot SDK-based blockchain, handling the essential logic that governs state changes and transaction processing. With Polkadot SDK’s [FRAME (Framework for Runtime Aggregation of Modularized Entities)](/polkadot-protocol/glossary/#frame-framework-for-runtime-aggregation-of-modularized-entities){target=\\_bank}, developers gain access to a powerful suite of tools for building custom blockchain runtimes. FRAME offers a modular architecture, featuring reusable pallets and support libraries, to streamline development.\n\nThis guide provides an overview of FRAME, its core components like pallets and system libraries, and demonstrates how to compose a runtime tailored to your specific blockchain use case. Whether you’re integrating pre-built modules or designing custom logic, FRAME equips you with the tools to create scalable, feature-rich blockchains.\n\n## FRAME Runtime Architecture\n\nThe following diagram illustrates how FRAME components integrate into the runtime:\n\n![](/images/develop/parachains/customize-parachain/overview/frame-overview-1.webp)\n\nAll transactions sent to the runtime are handled by the `frame_executive` pallet, which dispatches them to the appropriate pallet for execution. These runtime modules contain the logic for specific blockchain features. The `frame_system` module provides core functions, while `frame_support` libraries offer useful tools to simplify pallet development. Together, these components form the backbone of a FRAME-based blockchain's runtime.\n\n### Pallets\n\nPallets are modular components within the FRAME ecosystem that encapsulate specific blockchain functionalities. These modules offer customizable business logic for various use cases and features that can be integrated into a runtime.\n\nDevelopers have the flexibility to implement any desired behavior in the core logic of the blockchain, such as:\n\n- Exposing new transactions.\n- Storing information.\n- Enforcing business rules.\n\nPallets also include necessary wiring code to ensure proper integration and functionality within the runtime. FRAME provides a range of [pre-built pallets](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/substrate/frame){target=\\_blank} for standard and common blockchain functionalities, including consensus algorithms, staking mechanisms, governance systems, and more. These pre-existing pallets serve as building blocks or templates, which developers can use as-is, modify, or reference when creating custom functionalities. \n\n#### Pallet Structure\n\nPolkadot SDK heavily utilizes Rust macros, allowing developers to focus on specific functional requirements when writing pallets instead of dealing with technicalities and scaffolding code.\n\nA typical pallet skeleton looks like this:\n\n```rust\n-pub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n  use frame_support::pallet_prelude::*;\n  use frame_system::pallet_prelude::*;\n\n  #[pallet::pallet]\n  #[pallet::generate_store(pub(super) trait Store)]\n  pub struct Pallet<T>(_);\n\n  #[pallet::config]  // snip\n  #[pallet::event]   // snip\n  #[pallet::error]   // snip\n  #[pallet::storage] // snip\n  #[pallet::call]    // snip\n}\n```\n\nAll pallets, including custom ones, can implement these attribute macros:\n\n- **`#[frame_support::pallet]`**: Marks the module as usable in the runtime.\n- **`#[pallet::pallet]`**: Applied to a structure used to retrieve module information easily.\n- **`#[pallet::config]`**: Defines the configuration for the pallets's data types.\n- **`#[pallet::event]`**: Defines events to provide additional information to users.\n- **`#[pallet::error]`**: Lists possible errors in an enum to be returned upon unsuccessful execution.\n- **`#[pallet::storage]`**: Defines elements to be persisted in storage.\n- **`#[pallet::call]`**: Defines functions exposed as transactions, allowing dispatch to the runtime.\n\nThese macros are applied as attributes to Rust modules, functions, structures, enums, and types and serve as the core components of a pallet. They enable the pallet to be built and added to the runtime, exposing the custom logic to the outer world.\n\nFor a comprehensive guide on these and additional macros, see the [`pallet_macros`](https://paritytech.github.io/polkadot-sdk/master/frame_support/pallet_macros/index.html){target=\\_blank} section in the Polkadot SDK documentation.\n\n### Support Libraries\n\nIn addition to purpose-specific pallets, FRAME offers services and core libraries that facilitate composing and interacting with the runtime:\n\n- **[`frame_system` pallet](https://paritytech.github.io/polkadot-sdk/master/frame_system/index.html){target=\\_blank}**: Provides low-level types, storage, and functions for the runtime.\n- **[`frame_executive` pallet](https://paritytech.github.io/polkadot-sdk/master/frame_executive/index.html){target=\\_blank}**: Orchestrates the execution of incoming function calls to the respective pallets in the runtime.\n- **[`frame_support` crate](https://paritytech.github.io/polkadot-sdk/master/frame_support/index.html){target=\\_blank}**: Is a collection of Rust macros, types, traits, and modules that simplify the development of Substrate pallets.\n- **[`frame_benchmarking` crate](https://paritytech.github.io/polkadot-sdk/master/frame_benchmarking/trait.Benchmark.html){target=\\_blank}**: Contains common runtime patterns for benchmarking and testing purposes.\n\n## Compose a Runtime with Pallets\n\nThe Polkadot SDK allows developers to construct a runtime by combining various pallets, both built-in and custom-made. This modular approach enables the creation of unique blockchain behaviors tailored to specific requirements.\n\nThe following diagram illustrates the process of selecting and combining FRAME pallets to compose a runtime:\n\n![](/images/develop/parachains/customize-parachain/overview/frame-overview-2.webp)\n\nThis modular design allows developers to:\n\n- Rapidly prototype blockchain systems.\n- Easily add or remove features by including or excluding pallets.\n- Customize blockchain behavior without rebuilding core components.\n- Leverage tested and optimized code from built-in pallets.\n\n## Starting from Templates\n\nUsing pre-built templates is an efficient way to begin building a custom blockchain. Templates provide a foundational setup with pre-configured modules, letting developers avoid starting from scratch and instead focus on customization. Depending on your project’s goals—whether you want a simple test chain, a standalone chain, or a parachain that integrates with Polkadot’s relay chains—there are templates designed to suit different levels of complexity and scalability.\n\n### Solochain Templates\n\nSolochain templates are designed for developers who want to create standalone blockchains that operate independently without connecting to a relay chain:\n\n- **[`minimal-template`](https://github.com/paritytech/polkadot-sdk/tree/master/templates/minimal){target=\\_blank}**: Includes only the essential components necessary for a functioning blockchain. It’s ideal for developers who want to gain familiarity with blockchain basics and test simple customizations before scaling up.\n\n- **[`solochain-template`](https://github.com/paritytech/polkadot-sdk/tree/master/templates/solochain){target=\\_blank}**: Provides a foundation for creating standalone blockchains with moderate features, including a simple consensus mechanism and several core FRAME pallets. It’s a solid starting point for developers who want a fully functional chain that doesn’t depend on a relay chain.\n\n### Parachain Templates\n\nParachain templates are specifically designed for chains that will connect to and interact with relay chains in the Polkadot ecosystem:\n\n- **[`parachain-template`](https://github.com/paritytech/polkadot-sdk/tree/master/templates/parachain){target=\\_blank}**: Designed for connecting to relay chains like Polkadot, Kusama, or Paseo, this template enables a chain to operate as a parachain. For projects aiming to integrate with Polkadot’s ecosystem, this template offers a great starting point.\n\n- **[`OpenZeppelin`](https://github.com/OpenZeppelin/polkadot-runtime-templates/tree/main){target=\\_blank}**: Offers two flexible starting points.\n    - The [`generic-runtime-template`](https://github.com/OpenZeppelin/polkadot-runtime-templates/tree/main/generic-template){target=\\_blank} provides a minimal setup with essential pallets and secure defaults, creating a reliable foundation for custom blockchain development.\n    - The [`evm-runtime-template`](https://github.com/OpenZeppelin/polkadot-runtime-templates/tree/main/evm-template){target=\\_blank} enables EVM compatibility, allowing developers to migrate Solidity contracts and EVM-based dApps. This template is ideal for Ethereum developers looking to leverage Substrate's capabilities.\n\nChoosing a suitable template depends on your project’s unique requirements, level of customization, and integration needs. Starting from a template speeds up development and lets you focus on implementing your chain’s unique features rather than the foundational blockchain setup.\n\n## Where to Go Next\n\nFor more detailed information on implementing this process, refer to the following sections:\n\n- [Add a Pallet to Your Runtime](/develop/parachains/customize-parachain/add-existing-pallets/)\n- [Create a Custom Pallet](/develop/parachains/customize-parachain/make-custom-pallet/)\n"}
{"title": "Overview of Polkadot's System Chains", "slug": "polkadot-protocol-architecture-system-chains-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-architecture-system-chains-overview.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/architecture/system-chains/overview/", "categories": ["Basics", "Polkadot Protocol"], "description": "Discover how system parachains enhance Polkadot's scalability and performance by offloading tasks like governance, asset management, and bridging from the relay chain.", "estimated_token_count": 1655, "token_estimator": "heuristic-v1", "content": "## Introduction\n\nPolkadot's relay chain is designed to secure parachains and facilitate seamless inter-chain communication. However, resource-intensive—tasks like governance, asset management, and bridging are more efficiently handled by system parachains. These specialized chains offload functionality from the relay chain, leveraging Polkadot's parallel execution model to improve performance and scalability. By distributing key functionalities across system parachains, Polkadot can maximize its relay chain's blockspace for its core purpose of securing and validating parachains.\n\nThis guide will explore how system parachains operate within Polkadot and Kusama, detailing their critical roles in network governance, asset management, and bridging. You'll learn about the currently deployed system parachains, their unique functions, and how they enhance Polkadot's decentralized ecosystem.\n\n## System Chains\n\nSystem parachains contain core Polkadot protocol features, but in parachains rather than the relay chain. Execution cores for system chains are allocated via network [governance](/polkadot-protocol/onchain-governance/overview/){target=\\_blank} rather than purchasing coretime on a marketplace.\n\nSystem parachains defer to on-chain governance to manage their upgrades and other sensitive actions as they do not have native tokens or governance systems separate from DOT or KSM. It is not uncommon to see a system parachain implemented specifically to manage network governance.\n\n!!!note\n    You may see system parachains called common good parachains in articles and discussions. This nomenclature caused confusion as the network evolved, so system parachains is preferred. \n    \n    For more details on this evolution, review this [parachains forum discussion](https://forum.polkadot.network/t/polkadot-protocol-and-common-good-parachains/866){target=\\_blank}.\n\n## Existing System Chains\n\n```mermaid\n---\ntitle: System Parachains at a Glance\n---\nflowchart TB\n    subgraph POLKADOT[\"Polkadot\"]\n        direction LR\n            PAH[\"Polkadot Asset Hub\"]\n            PCOL[\"Polkadot Collectives\"]\n            PBH[\"Polkadot Bridge Hub\"]\n            PPC[\"Polkadot People Chain\"]\n            PCC[\"Polkadot Coretime Chain\"]\n    end\n\n    subgraph KUSAMA[\"Kusama\"]\n        direction LR\n            KAH[\"Kusama Asset Hub\"]\n            KBH[\"Kusama Bridge Hub\"]\n            KPC[\"Kusama People Chain\"]\n            KCC[\"Kusama Coretime Chain\"]\n            E[\"Encointer\"]\n        end\n```\n\nAll system parachains are on both Polkadot and Kusama with the following exceptions:\n\n- **[Collectives](#collectives)**: Only on Polkadot\n- **[Encointer](#encointer)**: Only on Kusama\n\n### Asset Hub\n\nThe [Asset Hub](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/cumulus#asset-hub-){target=\\_blank} is an asset portal for the entire network. It helps asset creators, such as reserve-backed stablecoin issuers, track the total issuance of an asset in the network, including amounts transferred to other parachains. It also serves as the hub where asset creators can perform on-chain operations, such as minting and burning, to manage their assets effectively.\n\nThis asset management logic is encoded directly in the runtime of the chain rather than in smart contracts. The efficiency of executing logic in a parachain allows for fees and deposits that are about 1/10th of what is required on the relay chain. These low fees mean that the Asset Hub is well suited for handling the frequent transactions required when managing balances, transfers, and on-chain assets.\n\nThe Asset Hub also supports non-fungible assets (NFTs) via the [Uniques pallet](https://polkadot.js.org/docs/substrate/extrinsics#uniques){target=\\_blank} and [NFTs pallet](https://polkadot.js.org/docs/substrate/extrinsics#nfts){target=\\_blank}. For more information about NFTs, see the Polkadot Wiki section on [NFT Pallets](https://wiki.polkadot.com/learn/learn-nft-pallets/){target=\\_blank}.\n\n### Collectives\n\nThe Polkadot Collectives parachain was added in [Referendum 81](https://polkadot-old.polkassembly.io/referendum/81){target=\\_blank} and exists on Polkadot but not on Kusama. The Collectives chain hosts on-chain collectives that serve the Polkadot network, including the following:\n\n- [**Polkadot Alliance**](https://polkadot-old.polkassembly.io/referendum/94){target=\\_blank}: Provides a set of ethics and standards for the community to follow. Includes an on-chain means to call out bad actors.\n- [**Polkadot Technical Fellowship**](https://wiki.polkadot.com/learn/learn-polkadot-technical-fellowship/){target=\\_blank}: A rules-based social organization to support and incentivize highly-skilled developers to contribute to the technical stability, security, and progress of the network.\n\nThese on-chain collectives will play essential roles in the future of network stewardship and decentralized governance. Networks can use a bridge hub to help them act as collectives and express their legislative voices as single opinions within other networks.\n\n### Bridge Hub\n\nBefore parachains, the only way to design a bridge was to put the logic onto the relay chain. Since both networks now support parachains and the isolation they provide, each network can have a parachain dedicated to bridges. \n\nThe Bridge Hub system parachain operates on the relay chain, and is responsible for facilitating bridges to the wider Web3 space. It contains the required bridge [pallets](/polkadot-protocol/glossary/#pallet){target=\\_blank} in its runtime, which enable trustless bridging with other blockchain networks like Polkadot, Kusama, and Ethereum. The Bridge Hub uses the native token of the relay chain.\n\nSee the [Bridge Hub](/polkadot-protocol/architecture/system-chains/bridge-hub/){target=\\_blank} documentation for additional information.\n\n### People Chain\n\nThe People Chain provides a naming system that allows users to manage and verify their account [identity](https://wiki.polkadot.com/learn/learn-identity/){target=\\_blank}.\n\n### Coretime Chain\n\nThe Coretime system chain lets users buy coretime to access Polkadot's computation. [Coretime marketplaces](https://wiki.polkadot.com/learn/learn-guides-coretime-marketplaces/){target=\\_blank} run on top of the Coretime chain. Kusama does not use the Collectives system chain. Instead, Kusama relies on the Encointer system chain, which provides Sybil resistance as a service to the entire Kusama ecosystem.\n\nVisit [Introduction to Agile Coretime](https://wiki.polkadot.com/learn/learn-agile-coretime/#introduction-to-agile-coretime){target=\\_blank} in the Polkadot Wiki for more information.\n\n### Encointer\n\n[Encointer](https://encointer.org/encointer-for-web3/){target=\\_blank} is a blockchain platform for self-sovereign ID and a global [universal basic income (UBI)](https://book.encointer.org/economics-ubi.html){target=\\_blank}. The Encointer protocol uses a novel Proof of Personhood (PoP) system to create unique identities and resist Sybil attacks. PoP is based on the notion that a person can only be in one place at any given time. Encointer offers a framework that allows for any group of real people to create, distribute, and use their own digital community tokens.\n\nParticipants are requested to attend physical key-signing ceremonies with small groups of random people at randomized locations. These local meetings are part of one global signing ceremony occurring at the same time. Participants use the Encointer wallet app to participate in these ceremonies and manage local community currencies. \n\nTo learn more about Encointer, see the official [Encointer book](https://book.encointer.org/introduction.html){target=\\_blank} or watch an [Encointer ceremony](https://www.youtube.com/watch?v=tcgpCCYBqko){target=\\_blank} in action.\n"}
{"title": "Overview of the Polkadot Relay Chain", "slug": "polkadot-protocol-architecture-polkadot-chain-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-architecture-polkadot-chain-overview.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/architecture/polkadot-chain/overview/", "categories": ["Basics", "Polkadot Protocol", "Parachains"], "description": "Explore Polkadot's core architecture, including its multi-chain vision, shared security, and the DOT token's governance and staking roles.", "estimated_token_count": 2593, "token_estimator": "heuristic-v1", "content": "# Overview\n\n## Introduction\n\nPolkadot is a next-generation blockchain protocol designed to support a multi-chain future by enabling secure communication and interoperability between different blockchains. Built as a Layer-0 protocol, Polkadot introduces innovations like application-specific Layer-1 chains ([parachains](/polkadot-protocol/architecture/parachains/){targe=\\_blank}), shared security through [Nominated Proof of Stake (NPoS)](/polkadot-protocol/glossary/#nominated-proof-of-stake-npos){target=\\_blank}, and cross-chain interactions via its native [Cross-Consensus Messaging Format (XCM)](/develop/interoperability/intro-to-xcm/){target=\\_blank}.\n\nThis guide covers key aspects of Polkadot’s architecture, including its high-level protocol structure, blockspace commoditization, and the role of its native token, DOT, in governance, staking, and resource allocation.\n\n## Polkadot 1.0\n\nPolkadot 1.0 represents the state of Polkadot as of 2023, coinciding with the release of [Polkadot runtime v1.0.0](https://github.com/paritytech/polkadot/releases/tag/v1.0.0){target=\\_blank}. This section will focus on Polkadot 1.0, along with philosophical insights into network resilience and blockspace.\n\nAs a Layer-0 blockchain, Polkadot contributes to the multi-chain vision through several key innovations and initiatives, including:\n\n- **Application-specific Layer-1 blockchains (parachains)**: Polkadot's sharded network allows for parallel transaction processing, with shards that can have unique state transition functions, enabling custom-built L1 chains optimized for specific applications.\n\n- **Shared security and scalability**: L1 chains connected to Polkadot benefit from its [Nominated Proof of Stake (NPoS)](/polkadot-protocol/architecture/polkadot-chain/pos-consensus/#nominated-proof-of-stake){target=\\_blank} system, providing security out-of-the-box without the need to bootstrap their own.\n\n- **Secure interoperability**: Polkadot's native interoperability enables seamless data and value exchange between parachains. This interoperability can also be used outside of the ecosystem for bridging with external networks.\n\n- **Resilient infrastructure**: Decentralized and scalable, Polkadot ensures ongoing support for development and community initiatives via its on-chain [treasury](https://wiki.polkadot.com/learn/learn-polkadot-opengov-treasury/){target=\\_blank} and governance.\n\n- **Rapid L1 development**: The [Polkadot SDK](/develop/parachains/intro-polkadot-sdk/){target=\\_blank} allows fast, flexible creation and deployment of Layer-1 chains.\n\n- **Cultivating the next generation of Web3 developers**: Polkadot supports the growth of Web3 core developers through initiatives such as.\n\n    - [Polkadot Blockchain Academy](https://polkadot.com/blockchain-academy){target=\\_blank}\n    - [EdX courses](https://www.edx.org/school/web3x){target=\\_blank}\n    - Rust and Substrate courses (coming soon)\n\n### High-Level Architecture\n\nPolkadot features a chain that serves as the central component of the system. This chain is depicted as a ring encircled by several parachains that are connected to it.\n\nAccording to Polkadot's design, any blockchain that can compile to WebAssembly (Wasm) and adheres to the Parachains Protocol becomes a parachain on the Polkadot network.\n\nHere’s a high-level overview of the Polkadot protocol architecture:\n\n![](/images/polkadot-protocol/architecture/polkadot-chain/overview/overview-1.webp)\n\nParachains propose blocks to Polkadot validators, who check for availability and validity before finalizing them. With the relay chain providing security, collators—full nodes of parachains—can focus on their tasks without needing strong incentives.\n\nThe [Cross-Consensus Messaging Format (XCM)](/develop/interoperability/intro-to-xcm/){target=\\_blank} allows parachains to exchange messages freely, leveraging the chain's security for trust-free communication.\n\nIn order to interact with chains that want to use their own finalization process (e.g., Bitcoin), Polkadot has [bridges](/polkadot-protocol/parachain-basics/interoperability/#bridges-connecting-external-networks){target=\\_blank} that offer two-way compatibility, meaning that transactions can be made between different parachains.\n\n### Polkadot's Additional Functionalities\n\nHistorically, obtaining core slots on Polkadot chain relied upon crowdloans and auctions. Chain cores were leased through auctions for three-month periods, up to a maximum of two years. Crowdloans enabled users to securely lend funds to teams for lease deposits in exchange for pre-sale tokens, which is the only way to access slots on Polkadot 1.0. Auctions are now deprecated in favor of [coretime](/polkadot-protocol/architecture/system-chains/coretime/){target=\\_blank}.\n\nAdditionally, the chain handles [staking](https://wiki.polkadot.com/learn/learn-staking/){target=\\_blank}, [accounts](/polkadot-protocol/parachain-basics/accounts/){target=\\_blank}, balances, and [governance](/polkadot-protocol/onchain-governance/){target=\\_blank}.\n\n#### Agile Coretime\n\nThe new and more efficient way of obtaining core on Polkadot is to go through the process of purchasing coretime.\n\n[Agile coretime](/polkadot-protocol/architecture/polkadot-chain/agile-coretime/){target=\\_blank} improves the efficient use of Polkadot's network resources and offers economic flexibility for developers, extending Polkadot's capabilities far beyond the original vision outlined in the [whitepaper](https://polkadot.com/papers/Polkadot-whitepaper.pdf){target=\\_blank}.\n\nIt enables parachains to purchase monthly \"bulk\" allocations of coretime (the time allocated for utilizing a core, measured in Polkadot relay chain blocks), ensuring heavy-duty parachains that can author a block every six seconds with [Asynchronous Backing](https://wiki.polkadot.com/learn/learn-async-backing/#asynchronous-backing){target=\\_blank} can reliably renew their coretime each month. Although six-second block times are now the default, parachains have the option of producing blocks less frequently.\n\nRenewal orders are prioritized over new orders, offering stability against price fluctuations and helping parachains budget more effectively for project costs.\n\n### Polkadot's Resilience\n\nDecentralization is a vital component of blockchain networks, but it comes with trade-offs:\n\n- An overly decentralized network may face challenges in reaching consensus and require significant energy to operate.\n- Also, a network that achieves consensus quickly risks centralization, making it easier to manipulate or attack.\n\nA network should be decentralized enough to prevent manipulative or malicious influence. In this sense, decentralization is a tool for achieving resilience.\n\nPolkadot 1.0 currently achieves resilience through several strategies:\n\n- **Nominated Proof of Stake (NPoS)**: Ensures that the stake per validator is maximized and evenly distributed among validators.\n\n- **Decentralized nodes**: Designed to encourage operators to join the network. This program aims to expand and diversify the validators in the ecosystem who aim to become independent of the program during their term. Feel free to explore more about the program on the official [Decentralized Nodes](https://nodes.web3.foundation/){target=\\_blank} page.\n\n- **On-chain treasury and governance**: Known as [OpenGov](/polkadot-protocol/onchain-governance/overview/){target=\\_blank}, this system allows every decision to be made through public referenda, enabling any token holder to cast a vote.\n\n### Polkadot's Blockspace\n\nPolkadot 1.0’s design allows for the commoditization of blockspace.\n\nBlockspace is a blockchain's capacity to finalize and commit operations, encompassing its security, computing, and storage capabilities. Its characteristics can vary across different blockchains, affecting security, flexibility, and availability.\n\n- **Security**: Measures the robustness of blockspace in Proof of Stake (PoS) networks linked to the stake locked on validator nodes, the variance in stake among validators, and the total number of validators. It also considers social centralization (how many validators are owned by single operators) and physical centralization (how many validators run on the same service provider).\n\n- **Flexibility**: Reflects the functionalities and types of data that can be stored, with high-quality data essential to avoid bottlenecks in critical processes.\n\n- **Availability**: Indicates how easily users can access blockspace. It should be easily accessible, allowing diverse business models to thrive, ideally regulated by a marketplace based on demand and supplemented by options for \"second-hand\" blockspace.\n\nPolkadot is built on core blockspace principles, but there's room for improvement. Tasks like balance transfers, staking, and governance are managed on the relay chain.\n\nDelegating these responsibilities to [system chains](/polkadot-protocol/architecture/system-chains/){target=\\_blank} could enhance flexibility and allow the relay chain to concentrate on providing shared security and interoperability.\n\nFor more information about blockspace, watch [Robert Habermeier’s interview](https://www.youtube.com/watch?v=e1vISppPwe4){target=\\_blank} or read his [technical blog post](https://www.rob.tech/blog/polkadot-blockspace-over-blockchains/){target=\\_blank}.\n\n## DOT Token\n\nDOT is the native token of the Polkadot network, much like BTC for Bitcoin and Ether for the Ethereum blockchain. DOT has 10 decimals, uses the Planck base unit, and has a balance type of `u128`. The same is true for Kusama's KSM token with the exception of having 12 decimals.\n\n### Redenomination of DOT\n    \nPolkadot conducted a community poll, which ended on 27 July 2020 at block 888,888, to decide whether to redenominate the DOT token. The stakeholders chose to redenominate the token, changing the value of 1 DOT from 1e12 plancks to 1e10 plancks.\n\nImportantly, this did not affect the network's total number of base units (plancks); it only affects how a single DOT is represented. The redenomination became effective 72 hours after transfers were enabled, occurring at block 1,248,328 on 21 August 2020 around 16:50 UTC.\n\n### The Planck Unit\n\nThe smallest unit of account balance on Polkadot SDK-based blockchains (such as Polkadot and Kusama) is called _Planck_, named after the Planck length, the smallest measurable distance in the physical universe.\n\nSimilar to how BTC's smallest unit is the Satoshi and ETH's is the Wei, Polkadot's native token DOT equals 1e10 Planck, while Kusama's native token KSM equals 1e12 Planck.\n\n### Uses for DOT\n\nDOT serves three primary functions within the Polkadot network:\n\n- **Governance**: It is used to participate in the governance of the network.\n- **Staking**: DOT is staked to support the network's operation and security.\n- **Buying coretime**: Used to purchase coretime in-bulk or on-demand and access the  chain to benefit from Polkadot's security and interoperability.\n\nAdditionally, DOT can serve as a transferable token. For example, DOT, held in the treasury, can be allocated to teams developing projects that benefit the Polkadot ecosystem.\n\n## JAM and the Road Ahead\n\nThe Join-Accumulate Machine (JAM) represents a transformative redesign of Polkadot's core architecture, envisioned as the successor to the current relay chain. Unlike traditional blockchain architectures, JAM introduces a unique computational model that processes work through two primary functions:\n\n- **Join**: Handles data integration.\n- **Accumulate**: Folds computations into the chain's state.\n\nJAM removes many of the opinions and constraints of the current relay chain while maintaining its core security properties. Expected improvements include:\n\n- **Permissionless code execution**: JAM is designed to be more generic and flexible, allowing for permissionless code execution through services that can be deployed without governance approval.\n- **More effective block time utilization**: JAM's efficient pipeline processing model places the prior state root in block headers instead of the posterior state root, enabling more effective utilization of block time for computations.\n\nThis architectural evolution promises to enhance Polkadot's scalability and flexibility while maintaining robust security guarantees. JAM is planned to be rolled out to Polkadot as a single, complete upgrade rather than a stream of smaller updates. This approach seeks to minimize the developer overhead required to address any breaking changes.\n"}
{"title": "Polkadot SDK Accounts", "slug": "polkadot-protocol-parachain-basics-accounts", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-accounts.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/accounts/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn about account structures, balances, and address formats in the Polkadot SDK, including how to manage lifecycle, references, and balances.", "estimated_token_count": 6528, "token_estimator": "heuristic-v1", "content": "# Accounts\n\n## Introduction\n\nAccounts are essential for managing identity, transactions, and governance on the network in the Polkadot SDK. Understanding these components is critical for seamless development and operation on the network, whether you're building or interacting with Polkadot-based chains.\n\nThis page will guide you through the essential aspects of accounts, including their data structure, balance types, reference counters, and address formats. You’ll learn how accounts are managed within the runtime, how balances are categorized, and how addresses are encoded and validated. \n\n## Account Data Structure\n\nAccounts are foundational to any blockchain, and the Polkadot SDK provides a flexible management system. This section explains how the Polkadot SDK defines accounts and manages their lifecycle through data structures within the runtime.\n\n### Account\n\nThe [`Account` data type](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/type.Account.html){target=\\_blank} is a storage map within the [System pallet](https://paritytech.github.io/polkadot-sdk/master/src/frame_system/lib.rs.html){target=\\_blank} that links an account ID to its corresponding data. This structure is fundamental for mapping account-related information within the chain.\n\nThe code snippet below shows how accounts are defined:\n\n```rs\n -/// The full account information for a particular account ID.\n\t#[pallet::storage]\n\t#[pallet::getter(fn account)]\n\tpub type Account<T: Config> = StorageMap<\n\t\t_,\n\t\tBlake2_128Concat,\n\t\tT::AccountId,\n\t\tAccountInfo<T::Nonce, T::AccountData>,\n\t\tValueQuery,\n\t>;\n```\n\nThe preceding code block defines a storage map named `Account`. The `StorageMap` is a type of on-chain storage that maps keys to values. In the `Account` map, the key is an account ID, and the value is the account's information. Here, `T` represents the generic parameter for the runtime configuration, which is defined by the pallet's configuration trait (`Config`).\n\nThe `StorageMap` consists of the following parameters:\n\n- **`_`**: Used in macro expansion and acts as a placeholder for the storage prefix type. Tells the macro to insert the default prefix during expansion.\n- **`Blake2_128Concat`**: The hashing function applied to keys in the storage map.\n- **`T: :AccountId`**: Represents the key type, which corresponds to the account’s unique ID.\n- **`AccountInfo<T: :Nonce, T::AccountData>`**: The value type stored in the map. For each account ID, the map stores an `AccountInfo` struct containing:\n\n    - **`T::Nonce`**: A nonce for the account, which is incremented with each transaction to ensure transaction uniqueness.\n    - **`T: :AccountData`**: Custom account data defined by the runtime configuration, which could include balances, locked funds, or other relevant information.\n    \n- **`ValueQuery`**: Defines how queries to the storage map behave when no value is found; returns a default value instead of `None`.\n\nFor a detailed explanation of storage maps, see the [`StorageMap`](https://paritytech.github.io/polkadot-sdk/master/frame_support/storage/types/struct.StorageMap.html){target=\\_blank} entry in the Rust docs.\n\n### Account Info\n\nThe `AccountInfo` structure is another key element within the [System pallet](https://paritytech.github.io/polkadot-sdk/master/src/frame_system/lib.rs.html){target=\\_blank}, providing more granular details about each account's state. This structure tracks vital data, such as the number of transactions and the account’s relationships with other modules.\n\n```rs\n-/// Information of an account.\n#[derive(Clone, Eq, PartialEq, Default, RuntimeDebug, Encode, Decode, TypeInfo, MaxEncodedLen)]\npub struct AccountInfo<Nonce, AccountData> {\n\t/// The number of transactions this account has sent.\n\tpub nonce: Nonce,\n\t/// The number of other modules that currently depend on this account's existence. The account\n\t/// cannot be reaped until this is zero.\n\tpub consumers: RefCount,\n\t/// The number of other modules that allow this account to exist. The account may not be reaped\n\t/// until this and `sufficients` are both zero.\n\tpub providers: RefCount,\n\t/// The number of modules that allow this account to exist for their own purposes only. The\n\t/// account may not be reaped until this and `providers` are both zero.\n\tpub sufficients: RefCount,\n\t/// The additional data that belongs to this account. Used to store the balance(s) in a lot of\n\t/// chains.\n\tpub data: AccountData,\n}\n```\n\nThe `AccountInfo` structure includes the following components:\n\n- **`nonce`**: Tracks the number of transactions initiated by the account, which ensures transaction uniqueness and prevents replay attacks.\n- **`consumers`**: Counts how many other modules or pallets rely on this account’s existence. The account cannot be removed from the chain (reaped) until this count reaches zero.\n- **`providers`**: Tracks how many modules permit this account’s existence. An account can only be reaped once both `providers` and `sufficients` are zero.\n- **`sufficients`**: Represents the number of modules that allow the account to exist for internal purposes, independent of any other modules.\n- **`AccountData`**: A flexible data structure that can be customized in the runtime configuration, usually containing balances or other user-specific data.\n\nThis structure helps manage an account's state and prevents its premature removal while it is still referenced by other on-chain data or modules. The [`AccountInfo`](https://paritytech.github.io/polkadot-sdk/master/frame_system/struct.AccountInfo.html){target=\\_blank} structure can vary as long as it satisfies the trait bounds defined by the `AccountData` associated type in the [`frame-system::pallet::Config`](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/trait.Config.html){target=\\_blank} trait.\n\n### Account Reference Counters\n\nPolkadot SDK uses reference counters to track an account’s dependencies across different runtime modules. These counters ensure that accounts remain active while data is associated with them.\n\nThe reference counters include:\n\n- **`consumers`**: Prevents account removal while other pallets still rely on the account.\n- **`providers`**: Ensures an account is active before other pallets store data related to it.\n- **`sufficients`**: Indicates the account’s independence, ensuring it can exist even without a native token balance, such as when holding sufficient alternative assets.\n\n#### Providers Reference Counters\n\nThe `providers` counter ensures that an account is ready to be depended upon by other runtime modules. For example, it is incremented when an account has a balance above the existential deposit, which marks the account as active.\n\nThe system requires this reference counter to be greater than zero for the `consumers` counter to be incremented, ensuring the account is stable before any dependencies are added.\n\n#### Consumers Reference Counters\n\nThe `consumers` counter ensures that the account cannot be reaped until all references to it across the runtime have been removed. This check prevents the accidental deletion of accounts that still have active on-chain data.\n\nIt is the user’s responsibility to clear out any data from other runtime modules if they wish to remove their account and reclaim their existential deposit.\n\n#### Sufficients Reference Counter\n\nThe `sufficients` counter tracks accounts that can exist independently without relying on a native account balance. This is useful for accounts holding other types of assets, like tokens, without needing a minimum balance in the native token.\n\nFor instance, the [Assets pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_assets/index.html){target=\\_blank}, may increment this counter for an account holding sufficient tokens.\n\n#### Account Deactivation\n\nIn Polkadot SDK-based chains, an account is deactivated when its reference counters (such as `providers`, `consumers`, and `sufficient`) reach zero. These counters ensure the account remains active as long as other runtime modules or pallets reference it.\n\nWhen all dependencies are cleared and the counters drop to zero, the account becomes deactivated and may be removed from the chain (reaped). This is particularly important in Polkadot SDK-based blockchains, where accounts with balances below the existential deposit threshold are pruned from storage to conserve state resources.\n\nEach pallet that references an account has cleanup functions that decrement these counters when the pallet no longer depends on the account. Once these counters reach zero, the account is marked for deactivation.\n\n#### Updating Counters\n\nThe Polkadot SDK provides runtime developers with various methods to manage account lifecycle events, such as deactivation or incrementing reference counters. These methods ensure that accounts cannot be reaped while still in use.\n\nThe following helper functions manage these counters:\n\n- **`inc_consumers()`**: Increments the `consumer` reference counter for an account, signaling that another pallet depends on it.\n- **`dec_consumers()`**: Decrements the `consumer` reference counter, signaling that a pallet no longer relies on the account.\n- **`inc_providers()`**: Increments the `provider` reference counter, ensuring the account remains active.\n- **`dec_providers()`**: Decrements the `provider` reference counter, allowing for account deactivation when no longer in use.\n- **`inc_sufficients()`**: Increments the `sufficient` reference counter for accounts that hold sufficient assets.\n- **`dec_sufficients()`**: Decrements the `sufficient` reference counter.\n\nTo ensure proper account cleanup and lifecycle management, a corresponding decrement should be made for each increment action.\n\nThe `System` pallet offers three query functions to assist developers in tracking account states:\n\n- **[`can_inc_consumer()`](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/struct.Pallet.html#method.can_inc_consumer){target=\\_blank}**: Checks if the account can safely increment the consumer reference.\n- **[`can_dec_provider()`](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/struct.Pallet.html#method.can_dec_provider){target=\\_blank}**: Ensures that no consumers exist before allowing the decrement of the provider counter.\n- **[`is_provider_required()`](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/struct.Pallet.html#method.is_provider_required){target=\\_blank}**: Verifies whether the account still has any active consumer references.\n\nThis modular and flexible system of reference counters tightly controls the lifecycle of accounts in Polkadot SDK-based blockchains, preventing the accidental removal or retention of unneeded accounts. You can refer to the [System pallet Rust docs](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/struct.Pallet.html){target=\\_blank} for more details.\n    \n\n## Account Balance Types\n\nIn the Polkadot ecosystem, account balances are categorized into different types based on how the funds are utilized and their availability. These balance types determine the actions that can be performed, such as transferring tokens, paying transaction fees, or participating in governance activities. Understanding these balance types helps developers manage user accounts and implement balance-dependent logic.\n\n!!! note \"A more efficient distribution of account balance types is in development\"\n    Soon, pallets in the Polkadot SDK will implement the [`Fungible` trait](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/tokens/fungible/index.html){target=\\_blank} (see the [tracking issue](https://github.com/paritytech/polkadot-sdk/issues/226){target=\\_blank} for more details). For example, the [`transaction-storage`](https://paritytech.github.io/polkadot-sdk/master/pallet_transaction_storage/index.html){target=\\_blank} pallet changed the implementation of the [`Currency`](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/tokens/currency/index.html){target=\\_blank} trait (see the [Refactor transaction storage pallet to use fungible traits](https://github.com/paritytech/polkadot-sdk/pull/1800){target=\\_blank} PR for further details):\n\n    ```rust\n    type BalanceOf<T> = <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n    ```\n    \n    To the [`Fungible`](https://paritytech.github.io/polkadot-sdk/master/frame_support/traits/tokens/fungible/index.html){target=\\_blank} trait:\n\n    ```rust\n    type BalanceOf<T> = <<T as Config>::Currency as FnInspect<<T as frame_system::Config>::AccountId>>::Balance;\n    ```\n    \n    This update will enable more efficient use of account balances, allowing the free balance to be utilized for on-chain activities such as setting proxies and managing identities.\n\n### Balance Types\n\nThe five main balance types are:\n\n- **Free balance**: Represents the total tokens available to the account for any on-chain activity, including staking, governance, and voting. However, it may not be fully spendable or transferrable if portions of it are locked or reserved.\n- **Locked balance**: Portions of the free balance that cannot be spent or transferred because they are tied up in specific activities like [staking](https://wiki.polkadot.com/learn/learn-staking/#nominating-validators){target=\\_blank}, [vesting](https://wiki.polkadot.com/learn/learn-guides-transfers/#vested-transfers-with-the-polkadot-js-ui){target=\\_blank}, or participating in [governance](https://wiki.polkadot.com/learn/learn-polkadot-opengov/#voting-on-a-referendum){target=\\_blank}. While the tokens remain part of the free balance, they are non-transferable for the duration of the lock.\n- **Reserved balance**: Funds locked by specific system actions, such as setting up an [identity](https://wiki.polkadot.com/learn/learn-identity/){target=\\_blank}, creating [proxies](https://wiki.polkadot.com/learn/learn-proxies/){target=\\_blank}, or submitting [deposits for governance proposals](https://wiki.polkadot.com/learn/learn-guides-polkadot-opengov/#claiming-opengov-deposits){target=\\_blank}. These tokens are not part of the free balance and cannot be spent unless they are unreserved.\n- **Spendable balance**: The portion of the free balance that is available for immediate spending or transfers. It is calculated by subtracting the maximum of locked or reserved amounts from the free balance, ensuring that existential deposit limits are met.\n- **Untouchable balance**: Funds that cannot be directly spent or transferred but may still be utilized for on-chain activities, such as governance participation or staking. These tokens are typically tied to certain actions or locked for a specific period.\n\nThe spendable balance is calculated as follows:\n\n```text\nspendable = free - max(locked - reserved, ED)\n```\n\nHere, `free`, `locked`, and `reserved` are defined above. The `ED` represents the [existential deposit](https://wiki.polkadot.com/learn/learn-accounts/#existential-deposit-and-reaping){target=\\_blank}, the minimum balance required to keep an account active and prevent it from being reaped. You may find you can't see all balance types when looking at your account via a wallet. Wallet providers often display only spendable, locked, and reserved balances.\n\n### Locks\n\nLocks are applied to an account's free balance, preventing that portion from being spent or transferred. Locks are automatically placed when an account participates in specific on-chain activities, such as staking or governance. Although multiple locks may be applied simultaneously, they do not stack. Instead, the largest lock determines the total amount of locked tokens.\n\nLocks follow these basic rules:\n\n- If different locks apply to varying amounts, the largest lock amount takes precedence.\n- If multiple locks apply to the same amount, the lock with the longest duration governs when the balance can be unlocked.\n\n#### Locks Example\n\nConsider an example where an account has 80 DOT locked for both staking and governance purposes like so:\n\n- 80 DOT is staked with a 28-day lock period.\n- 24 DOT is locked for governance with a 1x conviction and a 7-day lock period.\n- 4 DOT is locked for governance with a 6x conviction and a 224-day lock period.\n\nIn this case, the total locked amount is 80 DOT because only the largest lock (80 DOT from staking) governs the locked balance. These 80 DOT will be released at different times based on the lock durations. In this example, the 24 DOT locked for governance will be released first since the shortest lock period is seven days. The 80 DOT stake with a 28-day lock period is released next. Now, all that remains locked is the 4 DOT for governance. After 224 days, all 80 DOT (minus the existential deposit) will be free and transferable.\n\n![Illustration of Lock Example](/images/polkadot-protocol/parachain-basics/accounts/locks-example-2.webp)\n\n#### Edge Cases for Locks\n\nIn scenarios where multiple convictions and lock periods are active, the lock duration and amount are determined by the longest period and largest amount. For example, if you delegate with different convictions and attempt to undelegate during an active lock period, the lock may be extended for the full amount of tokens. For a detailed discussion on edge case lock behavior, see this [Stack Exchange post](https://substrate.stackexchange.com/questions/5067/delegating-and-undelegating-during-the-lock-period-extends-it-for-the-initial-am){target=\\_blank}.\n\n### Balance Types on Polkadot.js\n\nPolkadot.js provides a user-friendly interface for managing and visualizing various account balances on Polkadot and Kusama networks. When interacting with Polkadot.js, you will encounter multiple balance types that are critical for understanding how your funds are distributed and restricted. This section explains how different balances are displayed in the Polkadot.js UI and what each type represents.\n\n![](/images/polkadot-protocol/parachain-basics/accounts/account-balance-types-1.webp)\n\nThe most common balance types displayed on Polkadot.js are:\n\n- **Total balance**: The total number of tokens available in the account. This includes all tokens, whether they are transferable, locked, reserved, or vested. However, the total balance does not always reflect what can be spent immediately. In this example, the total balance is 0.6274 KSM.\n\n- **Transferable balance**: Shows how many tokens are immediately available for transfer. It is calculated by subtracting the locked and reserved balances from the total balance. For example, if an account has a total balance of 0.6274 KSM and a transferable balance of 0.0106 KSM, only the latter amount can be sent or spent freely.\n\n- **Vested balance**: Tokens that allocated to the account but released according to a specific schedule. Vested tokens remain locked and cannot be transferred until fully vested. For example, an account with a vested balance of 0.2500 KSM means that this amount is owned but not yet transferable.\n\n- **Locked balance**: Tokens that are temporarily restricted from being transferred or spent. These locks typically result from participating in staking, governance, or vested transfers. In Polkadot.js, locked balances do not stack—only the largest lock is applied. For instance, if an account has 0.5500 KSM locked for governance and staking, the locked balance would display 0.5500 KSM, not the sum of all locked amounts.\n\n- **Reserved balance**: Refers to tokens locked for specific on-chain actions, such as setting an identity, creating a proxy, or making governance deposits. Reserved tokens are not part of the free balance, but can be freed by performing certain actions. For example, removing an identity would unreserve those funds.\n\n- **Bonded balance**: The tokens locked for staking purposes. Bonded tokens are not transferable until they are unbonded after the unbonding period.\n\n- **Redeemable balance**: The number of tokens that have completed the unbonding period and are ready to be unlocked and transferred again. For example, if an account has a redeemable balance of 0.1000 KSM, those tokens are now available for spending.\n\n- **Democracy balance**: Reflects the number of tokens locked for governance activities, such as voting on referenda. These tokens are locked for the duration of the governance action and are only released after the lock period ends.\n\nBy understanding these balance types and their implications, developers and users can better manage their funds and engage with on-chain activities more effectively.\n\n## Address Formats\n\nThe SS58 address format is a core component of the Polkadot SDK that enables accounts to be uniquely identified across Polkadot-based networks. This format is a modified version of Bitcoin's Base58Check encoding, specifically designed to accommodate the multi-chain nature of the Polkadot ecosystem. SS58 encoding allows each chain to define its own set of addresses while maintaining compatibility and checksum validation for security. \n\n### Basic Format\n\nSS58 addresses consist of three main components:\n\n```text\nbase58encode(concat(<address-type>, <address>, <checksum>))\n```\n\n- **Address type**: A byte or set of bytes that define the network (or chain) for which the address is intended. This ensures that addresses are unique across different Polkadot SDK-based chains.\n- **Address**: The public key of the account encoded as bytes.\n- **Checksum**: A hash-based checksum which ensures that addresses are valid and unaltered. The checksum is derived from the concatenated address type and address components, ensuring integrity.\n\nThe encoding process transforms the concatenated components into a Base58 string, providing a compact and human-readable format that avoids easily confused characters (e.g., zero '0', capital 'O', lowercase 'l'). This encoding function ([`encode`](https://docs.rs/bs58/latest/bs58/fn.encode.html){target=\\_blank}) is implemented exactly as defined in Bitcoin and IPFS specifications, using the same alphabet as both implementations.\n\nFor more details about the SS58 address format implementation, see the [`Ss58Codec`](https://paritytech.github.io/polkadot-sdk/master/sp_core/crypto/trait.Ss58Codec.html){target=\\_blank} trait in the Rust Docs.\n\n### Address Type\n\nThe address type defines how an address is interpreted and to which network it belongs. Polkadot SDK uses different prefixes to distinguish between various chains and address formats:\n\n- **Address types `0-63`**: Simple addresses, commonly used for network identifiers.\n- **Address types `64-127`**: Full addresses that support a wider range of network identifiers.\n- **Address types `128-255`**: Reserved for future address format extensions.\n\nFor example, Polkadot’s main network uses an address type of 0, while Kusama uses 2. This ensures that addresses can be used without confusion between networks.\n\nThe address type is always encoded as part of the SS58 address, making it easy to quickly identify the network. Refer to the [SS58 registry](https://github.com/paritytech/ss58-registry){target=\\_blank} for the canonical listing of all address type identifiers and how they map to Polkadot SDK-based networks.\n\n### Address Length\n\nSS58 addresses can have different lengths depending on the specific format. Address lengths range from as short as 3 to 35 bytes, depending on the complexity of the address and network requirements. This flexibility allows SS58 addresses to adapt to different chains while providing a secure encoding mechanism.\n\n| Total | Type | Raw account | Checksum |\n|-------|------|-------------|----------|\n| 3     | 1    | 1           | 1        |\n| 4     | 1    | 2           | 1        |\n| 5     | 1    | 2           | 2        |\n| 6     | 1    | 4           | 1        |\n| 7     | 1    | 4           | 2        |\n| 8     | 1    | 4           | 3        |\n| 9     | 1    | 4           | 4        |\n| 10    | 1    | 8           | 1        |\n| 11    | 1    | 8           | 2        |\n| 12    | 1    | 8           | 3        |\n| 13    | 1    | 8           | 4        |\n| 14    | 1    | 8           | 5        |\n| 15    | 1    | 8           | 6        |\n| 16    | 1    | 8           | 7        |\n| 17    | 1    | 8           | 8        |\n| 35    | 1    | 32          | 2        |\n\nSS58 addresses also support different payload sizes, allowing a flexible range of account identifiers.\n\n### Checksum Types\n\nA checksum is applied to validate SS58 addresses. Polkadot SDK uses a Blake2b-512 hash function to calculate the checksum, which is appended to the address before encoding. The checksum length can vary depending on the address format (e.g., 1-byte, 2-byte, or longer), providing varying levels of validation strength.\n\nThe checksum ensures that an address is not modified or corrupted, adding an extra layer of security for account management.\n\n### Validating Addresses\n\nSS58 addresses can be validated using the subkey command-line interface or the Polkadot.js API. These tools help ensure an address is correctly formatted and valid for the intended network. The following sections will provide an overview of how validation works with these tools.\n\n#### Using Subkey\n\n[Subkey](https://paritytech.github.io/polkadot-sdk/master/subkey/index.html){target=\\_blank} is a CLI tool provided by Polkadot SDK for generating and managing keys. It can inspect and validate SS58 addresses.\n\nThe `inspect` command gets a public key and an SS58 address from the provided secret URI. The basic syntax for the `subkey inspect` command is:\n\n```bash\nsubkey inspect [flags] [options] uri\n```\n\nFor the `uri` command-line argument, you can specify the secret seed phrase, a hex-encoded private key, or an SS58 address. If the input is a valid address, the `subkey` program displays the corresponding hex-encoded public key, account identifier, and SS58 addresses.\n\nFor example, to inspect the public keys derived from a secret seed phrase, you can run a command similar to the following:\n\n```bash\nsubkey inspect \"caution juice atom organ advance problem want pledge someone senior holiday very\"\n```\n\nThe command displays output similar to the following:\n\n-<div id=\"termynal\" data-termynal markdown>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>subkey inspect \"caution juice atom organ advance problem want pledge someone senior holiday very\"</span>\n  <span data-ty>Secret phrase `caution juice atom organ advance problem want pledge someone senior holiday very` is account:</span>\n  <span data-ty> Secret seed: 0xc8fa03532fb22ee1f7f6908b9c02b4e72483f0dbd66e4cd456b8f34c6230b849</span>\n  <span data-ty> Public key (hex): 0xd6a3105d6768e956e9e5d41050ac29843f98561410d3a47f9dd5b3b227ab8746</span>\n  <span data-ty> Public key (SS58): 5Gv8YYFu8H1btvmrJy9FjjAWfb99wrhV3uhPFoNEr918utyR</span>\n  <span data-ty> Account ID: 0xd6a3105d6768e956e9e5d41050ac29843f98561410d3a47f9dd5b3b227ab8746</span>\n  <span data-ty> SS58 Address: 5Gv8YYFu8H1btvmrJy9FjjAWfb99wrhV3uhPFoNEr918utyR</span>\n</div>\n\n\nThe `subkey` program assumes an address is based on a public/private key pair. If you inspect an address, the command returns the 32-byte account identifier.\n\nHowever, not all addresses in Polkadot SDK-based networks are based on keys.\n\nDepending on the command-line options you specify and the input you provided, the command output might also display the network for which the address has been encoded. For example:\n\n```bash\nsubkey inspect \"12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU\"\n```\n\nThe command displays output similar to the following:\n\n-<div id=\"termynal\" data-termynal markdown>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>subkey inspect \"12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU\"</span>\n  <span data-ty>Public Key URI `12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU` is account:</span>\n  <span data-ty> Network ID/Version: polkadot</span>\n  <span data-ty> Public key (hex): 0x46ebddef8cd9bb167dc30878d7113b7e168e6f0646beffd77d69d39bad76b47a</span>\n  <span data-ty> Account ID: 0x46ebddef8cd9bb167dc30878d7113b7e168e6f0646beffd77d69d39bad76b47a</span>\n  <span data-ty> Public key (SS58): 12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU</span>\n  <span data-ty> SS58 Address: 12bzRJfh7arnnfPPUZHeJUaE62QLEwhK48QnH9LXeK2m1iZU</span>\n</div>\n\n\n#### Using Polkadot.js API\n\nTo verify an address in JavaScript or TypeScript projects, you can use the functions built into the [Polkadot.js API](https://polkadot.js.org/docs/){target=\\_blank}. For example:\n\n```js\n-// Import Polkadot.js API dependencies\nconst { decodeAddress, encodeAddress } = require('@polkadot/keyring');\nconst { hexToU8a, isHex } = require('@polkadot/util');\n\n// Specify an address to test.\nconst address = 'INSERT_ADDRESS_TO_TEST';\n\n// Check address\nconst isValidSubstrateAddress = () => {\n  try {\n    encodeAddress(isHex(address) ? hexToU8a(address) : decodeAddress(address));\n\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Query result\nconst isValid = isValidSubstrateAddress();\nconsole.log(isValid);\n\n```\n\nIf the function returns `true`, the specified address is a valid address.\n\n#### Other SS58 Implementations\n\nSupport for encoding and decoding Polkadot SDK SS58 addresses has been implemented in several other languages and libraries.\n\n- **Crystal**: [`wyhaines/base58.cr`](https://github.com/wyhaines/base58.cr){target=\\_blank}\n- **Go**: [`itering/subscan-plugin`](https://github.com/itering/subscan-plugin){target=\\_blank}\n- **Python**: [`polkascan/py-scale-codec`](https://github.com/polkascan/py-scale-codec){target=\\_blank}\n- **TypeScript**: [`subsquid/squid-sdk`](https://github.com/subsquid/squid-sdk){target=\\_blank}\n"}
{"title": "PolkaVM Design", "slug": "polkadot-protocol-smart-contract-basics-polkavm-design", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-smart-contract-basics-polkavm-design.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/smart-contract-basics/polkavm-design/", "categories": ["Basics", "Polkadot Protocol"], "description": "Discover PolkaVM, a high-performance smart contract VM for Polkadot, enabling Ethereum compatibility via pallet_revive, Solidity support & optimized execution.", "estimated_token_count": 1030, "token_estimator": "heuristic-v1", "content": "# PolkaVM Design\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nThe Asset Hub smart contracts solution includes multiple components to ensure Ethereum compatibility and high performance. Its architecture allows for integration with current Ethereum tools, while its innovative virtual machine design enhances performance characteristics.\n\n## PolkaVM\n\n[**PolkaVM**](https://github.com/paritytech/polkavm){target=\\_blank} is a custom virtual machine optimized for performance with [RISC-V-based](https://en.wikipedia.org/wiki/RISC-V){target=\\_blank} architecture, supporting Solidity and additional high-performance languages. It serves as the core execution environment, integrated directly within the runtime. It features:\n\n- An efficient interpreter for immediate code execution.\n- A planned JIT compiler for optimized performance.\n- Dual-mode execution capability, allowing selection of the most appropriate backend for specific workloads.\n- Optimized performance for short-running contract calls through the interpreter.\n\nThe interpreter remains particularly beneficial for contracts with minimal code execution, as it eliminates JIT compilation overhead and enables immediate code execution through lazy interpretation.\n\n## Architecture\n\nThe smart contract solution consists of the following key components that work together to enable Ethereum compatibility on Polkadot-based chains.\n\n### Pallet Revive\n\n[**`pallet_revive`**](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/index.html){target=\\_blank} is a runtime module that executes smart contracts by adding extrinsics, runtime APIs, and logic to convert Ethereum-style transactions into formats compatible with Polkadot SDK-based blockchains. It processes Ethereum-style transactions through the following workflow:\n\n```mermaid\nsequenceDiagram\n    participant User as User/dApp\n    participant Proxy as Ethereum JSON RPC Proxy\n    participant Chain as Blockchain Node\n    participant Pallet as pallet_revive\n    \n    User->>Proxy: Submit Ethereum Transaction\n    Proxy->>Chain: Repackage as Polkadot Compatible Transaction\n    Chain->>Pallet: Process Transaction\n    Pallet->>Pallet: Decode Ethereum Transaction\n    Pallet->>Pallet: Execute Contract via PolkaVM\n    Pallet->>Chain: Return Results\n    Chain->>Proxy: Forward Results\n    Proxy->>User: Return Ethereum-compatible Response\n```\n\nThis proxy-based approach eliminates the need for node binary modifications, maintaining compatibility across different client implementations. Preserving the original Ethereum transaction payload simplifies adapting existing tools, which can continue processing familiar transaction formats.\n\n### PolkaVM Design Fundamentals\n\nPolkaVM introduces two fundamental architectural differences compared to the Ethereum Virtual Machine (EVM):\n\n```mermaid\nflowchart TB\n    subgraph \"EVM Architecture\"\n        EVMStack[Stack-Based]\n        EVM256[256-bit Word Size]\n    end\n    \n    subgraph \"PolkaVM Architecture\"\n        PVMReg[Register-Based]\n        PVM64[64-bit Word Size]\n    end\n```\n\n- **Register-based design**: PolkaVM utilizes a RISC-V register-based approach. This design:\n\n    - Employs a finite set of registers for argument passing instead of an infinite stack.\n    - Facilitates efficient translation to underlying hardware architectures.\n    - Optimizes register allocation through careful register count selection.\n    - Enables simple 1:1 mapping to x86-64 instruction sets.\n    - Reduces compilation complexity through strategic register limitation.\n    - Improves overall execution performance through hardware-aligned design.\n\n- **64-bit word size**: PolkaVM operates with a 64-bit word size. This design:\n\n    - Enables direct hardware-supported arithmetic operations.\n    - Maintains compatibility with Solidity's 256-bit operations through YUL translation.\n    - Allows integration of performance-critical components written in lower-level languages.\n    - Optimizes computation-intensive operations through native word size alignment.\n    - Reduces overhead for operations not requiring extended precision.\n    - Facilitates efficient integration with modern CPU architectures.\n\n## Compilation Process\n\nWhen compiling a Solidity smart contract, the code passes through the following stages:\n\n```mermaid\nflowchart LR\n    Dev[Developer] --> |Solidity<br>Source<br>Code| Solc\n    \n    subgraph \"Compilation Process\"\n        direction LR\n        Solc[solc] --> |YUL<br>IR| Revive\n        Revive[Revive Compiler] --> |LLVM<br>IR| LLVM\n        LLVM[LLVM<br>Optimizer] --> |RISC-V ELF<br>Shared Object| PVMLinker\n    end\n    \n    PVMLinker[PVM Linker] --> PVM[PVM Blob<br>with Metadata]\n```\n\nThe compilation process integrates several specialized components:\n\n1. **Solc**: The standard Ethereum Solidity compiler that translates Solidity source code to [YUL IR](https://docs.soliditylang.org/en/latest/yul.html){target=\\_blank}.\n2. **Revive Compiler**: Takes YUL IR and transforms it to [LLVM IR](https://llvm.org/){target=\\_blank}.\n3. **LLVM**: A compiler infrastructure that optimizes the code and generates RISC-V ELF objects.\n4. **PVM linker**: Links the RISC-V ELF object into a final PolkaVM blob with metadata.\n"}
{"title": "Randomness", "slug": "polkadot-protocol-parachain-basics-randomness", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-randomness.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/randomness/", "categories": ["Basics", "Polkadot Protocol"], "description": "Explore the importance of randomness in PoS blockchains, focusing on Polkadot’s VRF-based approach to ensure fairness and security in validator selection.", "estimated_token_count": 1396, "token_estimator": "heuristic-v1", "content": "# Randomness\n\n## Introduction\n\nRandomness is crucial in Proof of Stake (PoS) blockchains to ensure a fair and unpredictable distribution of validator duties. However, computers are inherently deterministic, meaning the same input always produces the same output. What we typically refer to as \"random\" numbers on a computer are actually pseudo-random. These numbers rely on an initial \"seed,\" which can come from external sources like [atmospheric noise](https://www.random.org/randomness/){target=\\_blank}, [heart rates](https://mdpi.altmetric.com/details/47574324){target=\\_blank}, or even [lava lamps](https://en.wikipedia.org/wiki/Lavarand){target=\\_blank}. While this may seem random, given the same \"seed,\" the same sequence of numbers will always be generated.\n\nIn a global blockchain network, relying on real-world entropy for randomness isn’t feasible because these inputs vary by time and location. If nodes use different inputs, blockchains can fork. Hence, real-world randomness isn't suitable for use as a seed in blockchain systems.\n\nCurrently, two primary methods for generating randomness in blockchains are used: [`RANDAO`](#randao) and [`VRF`](#vrf) (Verifiable Random Function). Polkadot adopts the `VRF` approach for its randomness.\n\n## VRF\n\nA Verifiable Random Function (VRF) is a cryptographic function that generates a random number and proof that ensures the submitter produced the number. This proof allows anyone to verify the validity of the random number.\n\nPolkadot's VRF is similar to the one used in [**Ouroboros Praos**](https://eprint.iacr.org/2017/573.pdf){target=\\_blank}, which secures randomness for block production in systems like [BABE](/polkadot-protocol/architecture/polkadot-chain/pos-consensus/#block-production-babe){target=\\_blank} (Polkadot’s block production mechanism). \n\nThe key difference is that Polkadot's VRF doesn’t rely on a central clock—avoiding the issue of whose clock to trust. Instead, it uses its own past results and slot numbers to simulate time and determine future outcomes.\n\n### How VRF Works\n\nSlots on Polkadot are discrete units of time, each lasting six seconds, and can potentially hold a block. Multiple slots form an epoch, with 2400 slots making up one four-hour epoch.\n\nIn each slot, validators execute a \"die roll\" using a VRF. The VRF uses three inputs:\n\n1. A \"secret key,\" unique to each validator, is used for the die roll.\n2. An epoch randomness value, derived from the hash of VRF outputs from blocks two epochs ago (N-2), so past randomness influences the current epoch (N).\n3. The current slot number.\n\nThis process helps maintain fair randomness across the network.\n\nHere is a graphical representation:\n\n![](/images/polkadot-protocol/parachain-basics/blocks-transactions-fees/randomness/slots-epochs.webp)\n\nThe VRF produces two outputs: a result (the random number) and a proof (verifying that the number was generated correctly).\n\nThe result is checked by the validator against a protocol threshold. If it's below the threshold, the validator becomes a candidate for block production in that slot. \n\nThe validator then attempts to create a block, submitting it along with the `PROOF` and `RESULT`.\n\nSo, VRF can be expressed like:\n\n`(RESULT, PROOF) = VRF(SECRET, EPOCH_RANDOMNESS_VALUE, CURRENT_SLOT_NUMBER)`\n\nPut simply, performing a \"VRF roll\" generates a random number along with proof that the number was genuinely produced and not arbitrarily chosen.\n\nAfter executing the VRF, the `RESULT` is compared to a protocol-defined `THRESHOLD`. If the `RESULT` is below the `THRESHOLD`, the validator becomes a valid candidate to propose a block for that slot. Otherwise, the validator skips the slot.\n\nAs a result, there may be multiple validators eligible to propose a block for a slot. In this case, the block accepted by other nodes will prevail, provided it is on the chain with the latest finalized block as determined by the GRANDPA finality gadget. It's also possible for no block producers to be available for a slot, in which case the AURA consensus takes over. AURA is a fallback mechanism that randomly selects a validator to produce a block, running in parallel with BABE and only stepping in when no block producers exist for a slot. Otherwise, it remains inactive.\n\nBecause validators roll independently, no block candidates may appear in some slots if all roll numbers are above the threshold. \n\nTo verify resolution of this issue and that Polkadot block times remain near constant-time, see the [PoS Consensus](/polkadot-protocol/architecture/polkadot-chain/pos-consensus/){target=\\_blank} page of this documentation.\n\n## RANDAO\n\nAn alternative on-chain randomness method is Ethereum's RANDAO, where validators perform thousands of hashes on a seed and publish the final hash during a round. The collective input from all validators forms the random number, and as long as one honest validator participates, the randomness is secure.\n\nTo enhance security, RANDAO can optionally be combined with a Verifiable Delay Function (VDF), ensuring that randomness can't be predicted or manipulated during computation.\n\nFor more information about RANDAO, see the [Randomness - RANDAO](https://eth2book.info/capella/part2/building_blocks/randomness/){target=\\_blank} section of the Upgrading Ethereum documentation.\n\n## VDFs\n\nVerifiable Delay Functions (VDFs) are time-bound computations that, even on parallel computers, take a set amount of time to complete. \n\nThey produce a unique result that can be quickly verified publicly. When combined with RANDAO, feeding RANDAO's output into a VDF introduces a delay that nullifies an attacker's chance to influence the randomness.\n\nHowever, VDF likely requires specialized ASIC devices to run separately from standard nodes.\n\n!!!warning \n    While only one is needed to secure the system, and they will be open-source and inexpensive, running VDF devices involves significant costs without direct incentives, adding friction for blockchain users.\n\n## Additional Resources\n\nFor more information about the reasoning for choices made along with proofs, see Polkadot's research on blockchain randomness and sortition in the [Block production](https://research.web3.foundation/Polkadot/protocols/block-production){target=\\_blank} entry of the Polkadot Wiki. \n\nFor a discussion with Web3 Foundation researchers about when and under what conditions Polkadot's randomness can be utilized, see the [Discussion on Randomness used in Polkadot](https://github.com/use-ink/ink/issues/57){target=\\_blank} issue on GitHub.\n"}
{"title": "Register a Local Asset", "slug": "tutorials-polkadot-sdk-system-chains-asset-hub-register-local-asset", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-polkadot-sdk-system-chains-asset-hub-register-local-asset.md", "html_url": "https://docs.polkadot.com/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-asset/", "categories": ["Basics", "dApps"], "description": "Comprehensive guide to registering a local asset on the Asset Hub system parachain, including step-by-step instructions.", "estimated_token_count": 1579, "token_estimator": "heuristic-v1", "content": "# Register a Local Asset on Asset Hub\n\n## Introduction\n\nAs detailed in the [Asset Hub Overview](/polkadot-protocol/architecture/system-chains/asset-hub){target=\\_blank} page, Asset Hub accommodates two types of assets: local and foreign. Local assets are those that were created in Asset Hub and are identifiable by an integer ID. On the other hand, foreign assets originate from a sibling parachain and are identified by a Multilocation.\n\nThis guide will take you through the steps of registering a local asset on the Asset Hub parachain.\n\n## Prerequisites\n\nBefore you begin, ensure you have access to the [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\\_blank} interface and a funded wallet with DOT or KSM.\n\n- For Polkadot Asset Hub, you would need a deposit of 10 DOT and around 0.201 DOT for the metadata.\n- For Kusama Asset Hub, the deposit is 0.1 KSM and around 0.000669 KSM for the metadata.\n\nYou need to ensure that your Asset Hub account balance is a bit more than the sum of those two deposits, which should seamlessly account for the required deposits and transaction fees.\n\n## Steps to Register a Local Asset\n\nTo register a local asset on the Asset Hub parachain, follow these steps:\n\n1. Open the [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\\_blank} interface and connect to the Asset Hub parachain using the network selector in the top left corner.\n\n      - You may prefer to test local asset registration on TestNet before registering the asset on a MainNet hub. If you still need to set up a local testing environment, review the [Environment setup](#test-setup-environment) section for instructions. Once the local environment is set up, connect to the Local Node (Chopsticks) available on `ws://127.0.0.1:8000`.\n      - For the live network, connect to the **Asset Hub** parachain. Either Polkadot or Kusama Asset Hub can be selected from the dropdown list, choosing the desired RPC provider.\n\n2. Click on the **Network** tab on the top navigation bar and select **Assets** from the dropdown list.\n\n      ![Access to Asset Hub through Polkadot.JS](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-1.webp)\n\n3. Now, you need to examine all the registered asset IDs. This step is crucial to ensure that the asset ID you are about to register is unique. Asset IDs are displayed in the **assets** column.\n\n      ![Asset IDs on Asset Hub](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-2.webp)\n\n4. Once you have confirmed that the asset ID is unique, click on the **Create** button on the top right corner of the page.\n\n      ![Create a new asset](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-3.webp)\n\n5. Fill in the required fields in the **Create Asset** form:\n\n    1. **creator account**: The account to be used for creating this asset and setting up the initial metadata.\n    2. **asset name**: The descriptive name of the asset you are registering.\n    3. **asset symbol**: The symbol that will be used to represent the asset.\n    4. **asset decimals**: The number of decimal places for this token, with a maximum of 20 allowed through the user interface.\n    5. **minimum balance**: The minimum balance for the asset. This is specified in the units and decimals as requested.\n    6. **asset ID**: The selected id for the asset. This should not match an already-existing asset id.\n    7. Click on the **Next** button.\n \n    ![Create Asset Form](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-4.webp)\n\n6. Choose the accounts for the roles listed below:\n\n    1. **admin account**: The account designated for continuous administration of the token.\n    2. **issuer account**: The account that will be used for issuing this token.\n    3. **freezer account**: The account that will be used for performing token freezing operations.\n    4. Click on the **Create** button.\n\n    ![Admin, Issuer, Freezer accounts](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-5.webp)\n\n7. Click on the **Sign and Submit** button to complete the asset registration process.\n\n    ![Sign and Submit](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-6.webp)\n\n## Verify Asset Registration\n\nAfter completing these steps, the asset will be successfully registered. You can now view your asset listed on the [**Assets**](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fasset-hub-polkadot-rpc.dwellir.com#/assets){target=\\_blank} section of the Polkadot.js Apps interface.\n\n![Asset listed on Polkadot.js Apps](/images/tutorials/polkadot-sdk/system-chains/asset-hub/register-local-assets/register-a-local-asset-7.webp)\n\n!!! tip\n    Take into consideration that the **Assets** section’s link may differ depending on the network you are using. For the local environment, enter `ws://127.0.0.1:8000` into the **Custom Endpoint** field.\n\nIn this way, you have successfully registered a local asset on the Asset Hub parachain.\n\nFor an in-depth explanation about Asset Hub and its features, see the [Asset Hub](/tutorials/polkadot-sdk/system-chains/asset-hub/asset-conversion/){target=\\_blank} entry in the Polkadot Wiki.\n\n## Test Setup Environment\n\nYou can set up a local parachain environment to test the asset registration process before deploying it on the live network. This guide uses Chopsticks to simulate that process. For further information on chopsticks usage, refer to the [Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started){target=\\_blank} documentation.\n\nTo set up a test environment, execute the following command:\n\n```bash\nnpx @acala-network/chopsticks \\\n--config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml\n```\n\nThe above command will spawn a lazy fork of Polkadot Asset Hub with the latest block data from the network. If you need to test Kusama Asset Hub, replace `polkadot-asset-hub.yml` with `kusama-asset-hub.yml` in the command.\n\nAn Asset Hub instance is now running locally, and you can proceed with the asset registration process. Note that the local registration process does not differ from the live network process. Once you have a successful TestNet transaction, you can use the same steps to register the asset on MainNet.\n"}
{"title": "Send XCM Messages", "slug": "develop-interoperability-send-messages", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-interoperability-send-messages.md", "html_url": "https://docs.polkadot.com/develop/interoperability/send-messages/", "categories": ["Basics", "Polkadot Protocol"], "description": "Send cross-chain messages using XCM, Polkadot's Cross-Consensus Messaging format, designed to support secure communication between chains.", "estimated_token_count": 1660, "token_estimator": "heuristic-v1", "content": "# Send XCM Messages\n\n## Introduction\n\nOne of the core FRAME pallets that enables parachains to engage in cross-chain communication using the Cross-Consensus Message (XCM) format is [`pallet-xcm`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/index.html){target=\\_blank}. It facilitates the sending, execution, and management of XCM messages, thereby allowing parachains to interact with other chains within the ecosystem. Additionally, `pallet-xcm`, also referred to as the XCM pallet, supports essential operations like asset transfers, version negotiation, and message routing.\n\nThis page provides a detailed overview of the XCM pallet's key features, its primary roles in XCM operations, and the main extrinsics it offers. Whether aiming to execute XCM messages locally or send them to external chains, this guide covers the foundational concepts and practical applications you need to know.\n\n## XCM Frame Pallet Overview\n\nThe [`pallet-xcm`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/index.html){target=\\_blank} provides a set of pre-defined, commonly used [XCVM programs](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#12-the-xcvm){target=\\_blank} in the form of a [set of extrinsics](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/dispatchables/index.html){target=\\blank}. This pallet provides some [default implementations](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html#implementations){target=\\_blank} for traits required by [`XcmConfig`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm_benchmarks/trait.Config.html#associatedtype.XcmConfig){target=\\_blank}. The [XCM executor](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/struct.XcmExecutor.html){target=\\_blank} is also included as an associated type within the pallet's configuration. \n\nFor further details about the XCM configuration, see the [XCM Configuration](/develop/interoperability/xcm-config/){target=\\_blank} page.\n\nWhere the [XCM format](https://github.com/polkadot-fellows/xcm-format){target=\\_blank} defines a set of instructions used to construct XCVM programs, `pallet-xcm` defines a set of extrinsics that can be utilized to build XCVM programs, either to target the local or external chains. The `pallet-xcm` functionality is divided into three categories:\n\n- **Primitive**: Dispatchable functions to execute XCM locally.\n- **High-level**: Functions for asset transfers between chains.\n- **Version negotiation-specific**: Functions for managing XCM version compatibility.\n\n### Key Roles of the XCM Pallet\n\nThe XCM pallet plays a central role in managing cross-chain messages, with its primary responsibilities including:\n\n- **Execute XCM messages**: Interacts with the XCM executor to validate and execute messages, adhering to predefined security and filter criteria.\n- **Send messages across chains**: Allows authorized origins to send XCM messages, enabling controlled cross-chain communication.\n- **Reserve-based transfers and teleports**: Supports asset movement between chains, governed by filters that restrict operations to authorized origins.\n- **XCM version negotiation**: Ensures compatibility by selecting the appropriate XCM version for inter-chain communication.\n- **Asset trapping and recovery**: Manages trapped assets, enabling safe reallocation or recovery when issues occur during cross-chain transfers.\n- **Support for XCVM operations**: Oversees state and configuration requirements necessary for executing cross-consensus programs within the XCVM framework.\n\n## Primary Extrinsics of the XCM Pallet\n\nThis page will highlight the two **Primary Primitive Calls** responsible for sending and executing XCVM programs as dispatchable functions within the pallet.\n\n### Execute\n\nThe [`execute`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Call.html#variant.execute){target=\\_blank} call directly interacts with the XCM executor, allowing for the execution of XCM messages originating from a locally signed origin. The executor validates the message, ensuring it complies with any configured barriers or filters before executing.\n\nOnce validated, the message is executed locally, and an event is emitted to indicate the result—whether the message was fully executed or only partially completed. Execution is capped by a maximum weight ([`max_weight`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Call.html#variant.execute.field.max_weight){target=\\_blank}); if the required weight exceeds this limit, the message will not be executed.\n\n```rust\npub fn execute<T: Config>(\n    message: Box<VersionedXcm<<T as Config>::RuntimeCall>>,\n    max_weight: Weight,\n)\n```\n\nFor further details about the `execute` extrinsic, see the [`pallet-xcm` documentation](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html){target=\\_blank}.\n\n!!!warning\n    Partial execution of messages may occur depending on the constraints or barriers applied.\n\n\n\n### Send\n\nThe [`send`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Call.html#variant.send){target=\\_blank} call enables XCM messages to be sent to a specified destination. This could be a parachain, smart contract, or any external system governed by consensus. Unlike the execute call, the message is not executed locally but is transported to the destination chain for processing.\n\nThe destination is defined using a [Location](https://paritytech.github.io/polkadot-sdk/master/xcm_docs/glossary/index.html#location){target=\\_blank}, which describes the target chain or system. This ensures precise delivery through the configured XCM transport mechanism.\n\n```rust\npub fn send<T: Config>(\n    dest: Box<MultiLocation>,\n    message: Box<VersionedXcm<<T as Config>::RuntimeCall>>,\n)\n```\n\nFor further information about the `send` extrinsic, see the [`pallet-xcm` documentation](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html){target=\\_blank}.\n\n\n\n## XCM Router\n\nThe [`XcmRouter`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/trait.Config.html#associatedtype.XcmRouter){target=\\_blank} is a critical component the XCM pallet requires to facilitate sending XCM messages. It defines where messages can be sent and determines the appropriate XCM transport protocol for the operation.\n\nFor instance, the Kusama network employs the [`ChildParachainRouter`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_common/xcm_sender/struct.ChildParachainRouter.html){target=\\_blank}, which restricts routing to [Downward Message Passing (DMP)](https://wiki.polkadot.com/learn/learn-xcm-transport/#dmp-downward-message-passing){target=\\_blank} from the relay chain to parachains, ensuring secure and controlled communication.\n\n```rust\n-pub type XcmRouter = WithUniqueTopic<(\n\t// Only one router so far - use DMP to communicate with child parachains.\n\tChildParachainRouter<Runtime, XcmPallet, PriceForChildParachainDelivery>,\n)>;\n```\n\nFor more details about XCM transport protocols, see the [XCM Channels](/develop/interoperability/xcm-channels/){target=\\_blank} page.\n"}
{"title": "Set Up a Template", "slug": "tutorials-polkadot-sdk-parachains-zero-to-hero-set-up-a-template", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-polkadot-sdk-parachains-zero-to-hero-set-up-a-template.md", "html_url": "https://docs.polkadot.com/tutorials/polkadot-sdk/parachains/zero-to-hero/set-up-a-template/", "categories": ["Basics", "Parachains"], "description": "Learn to compile and run a local parachain node using Polkadot SDK. Launch, run, and interact with a pre-configured runtime template.", "estimated_token_count": 3208, "token_estimator": "heuristic-v1", "content": "# Set Up a Template\n\n## Introduction\n\n[Polkadot SDK](https://github.com/paritytech/polkadot-sdk){target=\\_blank} offers a versatile and extensible blockchain development framework, enabling you to create custom blockchains tailored to your specific application or business requirements. \n\nThis tutorial guides you through compiling and running a parachain node using the [Polkadot SDK Parachain Template](https://github.com/paritytech/polkadot-sdk/tree/master/templates/parachain){target=\\_blank}.\n\nThe parachain template provides a pre-configured, functional runtime you can use in your local development environment. It includes several key components, such as user accounts and account balances.\n\nThese predefined elements allow you to experiment with common blockchain operations without requiring initial template modifications.\nIn this tutorial, you will:\n\n- Build and start a local parachain node using the node template.\n- Explore how to use a front-end interface to:\n    - View information about blockchain activity.\n    - Submit a transaction.\n\nBy the end of this tutorial, you'll have a working local parachain and understand how to interact with it, setting the foundation for further customization and development.\n\n## Prerequisites\n\nBefore getting started, ensure you have done the following:\n\n- Completed the [Install Polkadot SDK Dependencies](/develop/parachains/install-polkadot-sdk/){target=\\_blank} guide and successfully installed [Rust](https://www.rust-lang.org/){target=\\_blank} and the required packages to set up your development environment.\n\nFor this tutorial series, you need to use Rust `1.86`. Newer versions of the compiler may not work with this parachain template version.\n\nRun the following commands to set up the correct Rust version:\n\n```bash\nrustup default 1.86\nrustup target add wasm32-unknown-unknown --toolchain 1.86-aarch64-apple-darwin\nrustup component add rust-src --toolchain 1.86-aarch64-apple-darwin\n```\n\n## Utility Tools\n\nThis tutorial requires two essential tools:\n\n- [**Chain spec builder**](https://crates.io/crates/staging-chain-spec-builder/10.0.0){target=\\_blank}: A Polkadot SDK utility for generating chain specifications. Refer to the [Generate Chain Specs](/develop/parachains/deployment/generate-chain-specs/){target=\\_blank} documentation for detailed usage.\n    \n    Install it by executing the following command:\n    \n    ```bash\n    cargo install --locked staging-chain-spec-builder@10.0.0\n    ```\n\n    This installs the `chain-spec-builder` binary.\n\n- [**Polkadot Omni Node**](https://crates.io/crates/polkadot-omni-node/0.5.0){target=\\_blank}: A white-labeled binary, released as a part of Polkadot SDK that can act as the collator of a parachain in production, with all the related auxiliary functionalities that a normal collator node has: RPC server, archiving state, etc. Moreover, it can also run the wasm blob of the parachain locally for testing and development.\n\n    To install it, run the following command:\n\n    ```bash\n    cargo install --locked polkadot-omni-node@0.5.0\n    ```\n\n    This installs the `polkadot-omni-node` binary.\n\n## Compile the Runtime\n\nThe [Polkadot SDK Parachain Template](https://github.com/paritytech/polkadot-sdk/tree/master/templates/parachain){target=\\_blank} provides a ready-to-use development environment for building using the [Polkadot SDK](https://github.com/paritytech/polkadot-sdk){target=\\_blank}. Follow these steps to compile the runtime:\n\n1. Clone the template repository:\n\n    ```bash\n    git clone -b v0.0.4 https://github.com/paritytech/polkadot-sdk-parachain-template.git parachain-template\n    ```\n\n2. Navigate into the project directory:\n\n    ```bash\n    cd parachain-template\n    ```\n\n3. Compile the runtime:\n\n    ```bash\n    cargo build --release --locked\n    ```\n\n    !!!tip\n        Initial compilation may take several minutes, depending on your machine specifications. Use the `--release` flag for improved runtime performance compared to the default `--debug` build. If you need to troubleshoot issues, the `--debug` build provides better diagnostics.\n        \n        For production deployments, consider using a dedicated [`--profile production`](https://github.com/paritytech/polkadot-sdk-parachain-template/blob/v0.0.4/Cargo.toml#L42-L45){target=\\_blank} flag - this can provide an additional 15-30% performance improvement over the standard `--release` profile.\n\n4. Upon successful compilation, you should see output similar to:\n\n    -<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>cargo build --release --locked</span>\n  <span data-ty>...</span>\n  <span data-ty>Finished `release` profile [optimized] target(s) in 1.79s</span>\n  <span data-ty=\"input\"><span class=\"file-path\"></span></span>\n</div>\n\n\n## Start the Local Chain\n\nAfter successfully compiling your runtime, you can spin up a local chain and produce blocks. This process will start your local parachain and allow you to interact with it. You'll first need to generate a chain specification that defines your network's identity, initial connections, and genesis state, providing the foundational configuration for how your nodes connect and what initial state they agree upon, and then run the chain. \n\nFollow these steps to launch your node in development mode:\n\n1. Generate the chain specification file of your parachain:\n\n    ```bash\n    chain-spec-builder create -t development \\\n    --relay-chain paseo \\\n    --para-id 1000 \\\n    --runtime ./target/release/wbuild/parachain-template-runtime/parachain_template_runtime.compact.compressed.wasm \\\n    named-preset development\n    ```\n\n2. Start the omni node with the generated chain spec. You'll start it in development mode (without a relay chain config), producing and finalizing blocks:\n\n    ```bash\n    polkadot-omni-node --chain ./chain_spec.json --dev\n    ```\n\n    The `--dev` option does the following:\n\n    - Deletes all active data (keys, blockchain database, networking information) when stopped.\n    - Ensures a clean working state each time you restart the node.\n\n3. Verify that your node is running by reviewing the terminal output. You should see something similar to:\n\n    -<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot-omni-node --chain ./chain_spec.json --dev</span>\n  <br />\n  <span data-ty>2024-12-12 12:44:02 polkadot-omni-node</span>\n  <span data-ty>2024-12-12 12:44:02 ✌️ version 0.1.0-da2dd9b7737</span>\n  <span data-ty>2024-12-12 12:44:02 ❤️ by Parity Technologies admin@parity.io, 2017-2024</span>\n  <span data-ty>2024-12-12 12:44:02 📋 Chain specification: Custom</span>\n  <span data-ty>2024-12-12 12:44:02 🏷 Node name: grieving-drum-1926</span>\n  <span data-ty>2024-12-12 12:44:02 👤 Role: AUTHORITY</span>\n  <span data-ty>2024-12-12 12:44:02 💾 Database: RocksDb at /var/folders/x0/xl_kjddj3ql3bx7752yr09hc0000gn/T/substrateoUrZMQ/chains/custom/db/full</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] assembling new collators for new session 0 at #0</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] assembling new collators for new session 1 at #0</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] 🔨 Initializing Genesis block/state (state: 0xa6f8…5b46, header-hash: 0x0579…2153)</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] creating SingleState txpool Limit { count: 8192, total_bytes: 20971520 }/Limit { count: 819, total_bytes: 2097152 }.</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] Using default protocol ID \"sup\" because none is configured in the chain specs</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] 🏷 Local node identity is: 12D3KooWCSXy6rBuJVsn5mx8uyNqkdfNfFzEbToi4hR31v3PwdgX</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] Running libp2p network backend</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] 💻 Operating system: macos</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] 💻 CPU architecture: aarch64</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] 📦 Highest known block at #0</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] 〽️ Prometheus exporter started at 127.0.0.1:9615</span>\n  <span data-ty>2024-12-12 12:44:03 [Parachain] Running JSON-RPC server: addr=127.0.0.1:9944,[::1]:9944</span>\n  <span data-ty>2024-12-12 12:44:06 [Parachain] 🙌 Starting consensus session on top of parent 0x05794f9adcdaa23a5edd335e8310637d3a7e6e9393f2b0794af7d3e219f62153 (#0)</span>\n  <span data-ty>2024-12-12 12:44:06 [Parachain] 🎁 Prepared block for proposing at 1 (2 ms) hash: 0x6fbea46711e9b38bab8e7877071423cd03feab03d3f4a0d578a03ab42dcee34b; parent_hash: 0x0579…2153; end: NoMoreTransactions; extrinsics_count: 2</span>\n  <span data-ty>2024-12-12 12:44:06 [Parachain] 🏆 Imported #1 (0x0579…2153 → 0x6fbe…e34b)</span>\n  <span data-ty>...</span>\n</div>\n\n\n4. Confirm that your blockchain is producing new blocks by checking if the number after `finalized` is increasing.\n\n    -<div id=\"termynal\" data-termynal>\n  <span data-ty>...</span>\n  <span data-ty>2024-12-12 12:49:20 [Parachain] 💤 Idle (0 peers), best: #1 (0x6fbe…e34b), finalized #1 (0x6fbe…e34b), ⬇ 0 ⬆ 0</span>\n  <span data-ty>...</span>\n  <span data-ty>2024-12-12 12:49:25 [Parachain] 💤 Idle (0 peers), best: #3 (0x7543…bcfc), finalized #3 (0x7543…bcfc), ⬇ 0 ⬆ 0</span>\n  <span data-ty>...</span>\n  <span data-ty>2024-12-12 12:49:30 [Parachain] 💤 Idle (0 peers), best: #4 (0x0478…8d63), finalized #4 (0x0478…8d63), ⬇ 0 ⬆ 0</span>\n  <span data-ty>...</span>\n</div>\n\n\nThe details of the log output will be explored in a later tutorial. For now, knowing that your node is running and producing blocks is sufficient.\n\n## Interact with the Node\n\nWhen running the template node, it's accessible by default at `ws://localhost:9944`. To interact with your node using the [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank} interface, follow these steps:\n\n1. Open [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank} in your web browser and click the network icon (which should be the Polkadot logo) in the top left corner as shown in the image below:\n    \n    ![](/images/tutorials/polkadot-sdk/parachains/zero-to-hero/set-up-a-template/set-up-a-template-1.webp)\n\n2. Connect to your local node:\n\n    1. Scroll to the bottom and select **Development**.\n    2. Choose **Custom**.\n    3. **Enter `ws**: //localhost:9944` in the input field.\n    4. Click the **Switch** button.\n    \n    ![](/images/tutorials/polkadot-sdk/parachains/zero-to-hero/set-up-a-template/set-up-a-template-2.webp)\n\n3. Verify connection:\n\n    - Once connected, you should see **parachain-template-runtime** in the top left corner.\n    - The interface will display information about your local blockchain.\n    \n    ![](/images/tutorials/polkadot-sdk/parachains/zero-to-hero/set-up-a-template/set-up-a-template-3.webp)\n\nYou are now connected to your local node and can now interact with it through the Polkadot.js Apps interface. This tool enables you to explore blocks, execute transactions, and interact with your blockchain's features. For in-depth guidance on using the interface effectively, refer to the [Polkadot.js Guides](https://wiki.polkadot.com/general/polkadotjs/){target=\\_blank} available on the Polkadot Wiki.\n\n## Stop the Node\n\nWhen you're done exploring your local node, you can stop it to remove any state changes you've made. Since you started the node with the `--dev` option, stopping the node will purge all persistent block data, allowing you to start fresh the next time.\n\nTo stop the local node:\n\n1. Return to the terminal window where the node output is displayed.\n2. Press `Control-C` to stop the running process.\n3. Verify that your terminal returns to the prompt in the `parachain-template` directory.\n\n## Where to Go Next\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Build a Custom Pallet__\n\n    ---\n\n    Build your own custom pallet for Polkadot SDK-based blockchains! Follow this step-by-step guide to create and configure a simple counter pallet from scratch.\n\n    [:octicons-arrow-right-24: Get Started](/tutorials/polkadot-sdk/parachains/zero-to-hero/build-custom-pallet/)\n\n</div>\n"}
{"title": "Smart Contracts Basics Overview", "slug": "polkadot-protocol-smart-contract-basics-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-smart-contract-basics-overview.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/smart-contract-basics/overview/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn how developers can build smart contracts on Polkadot by leveraging either Wasm/ink! or EVM contracts across many parachains.", "estimated_token_count": 2614, "token_estimator": "heuristic-v1", "content": "# An Overview of the Smart Contract Landscape on Polkadot\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nPolkadot is designed to support an ecosystem of parachains, rather than hosting smart contracts directly. Developers aiming to build smart contract applications on Polkadot rely on parachains within the ecosystem that provide smart contract functionality.\n\nThis guide outlines the primary approaches to developing smart contracts in the Polkadot ecosystem:\n\n- **PolkaVM-compatible contracts**: Support Solidity and any language that compiles down to RISC-V while maintaining compatibility with Ethereum based tools.\n- **EVM-compatible contracts**: Support languages like [Solidity](https://soliditylang.org/){target=\\_blank} and [Vyper](https://vyperlang.org/){target=\\_blank}, offering compatibility with popular Ethereum tools and wallets.\n- **Wasm-based smart contracts**: Using [ink!](https://use.ink/){target=\\_blank}, a Rust-based embedded domain-specific language (eDSL), enabling developers to leverage Rust’s safety and tooling.\n\nYou'll explore the key differences between these development paths, along with considerations for parachain developers integrating smart contract functionality.\n\n!!!note \"Parachain Developer?\"\n    If you are a parachain developer looking to add smart contract functionality to your chain, please refer to the [Add Smart Contract Functionality](/develop/parachains/customize-parachain/add-smart-contract-functionality/){target=\\_blank} page, which covers both Wasm and EVM-based contract implementations.\n\n## Smart Contracts Versus Parachains\n\nA smart contract is a program that executes specific logic isolated to the chain on which it is being executed. All the logic executed is bound to the same state transition rules determined by the underlying virtual machine (VM). Consequently, smart contracts are more streamlined to develop, and programs can easily interact with each other through similar interfaces.\n\n``` mermaid\nflowchart LR\n  subgraph A[Chain State]\n    direction LR\n    B[\"Program Logic and Storage<br/>(Smart Contract)\"]\n    C[\"Tx Relevant Storage\"]\n  end\n  A --> D[[Virtual Machine]]\n  E[Transaction] --> D\n  D --> F[(New State)]\n  D --> G[Execution Logs]\n  style A fill:#ffffff,stroke:#000000,stroke-width:1px\n```\n\nIn addition, because smart contracts are programs that execute on top of existing chains, teams don't have to think about the underlying consensus they are built on.\n\nThese strengths do come with certain limitations. Some smart contracts environments, like EVM, tend to be immutable by default. Developers have developed different [proxy strategies](https://blog.openzeppelin.com/proxy-patterns){target=\\_blank} to be able to upgrade smart contracts over time. The typical pattern relies on a proxy contract which holds the program storage forwarding a call to an implementation contract where the execution logic resides. Smart contract upgrades require changing the implementation contract while retaining the same storage structure, necessitating careful planning.\n\nAnother downside is that smart contracts often follow a gas metering model, where program execution is associated with a given unit and a marketplace is set up to pay for such an execution unit. This fee system is often very rigid, and some complex flows, like account abstraction, have been developed to circumvent this problem.\n\nIn contrast, parachains can create their own custom logics (known as pallets or modules), and combine them as the state transition function (STF or runtime) thanks to the modularity provided by the [Polkadot-SDK](https://github.com/paritytech/polkadot-sdk/){target=\\_blank}. The different pallets within the parachain runtime can give developers a lot of flexibility when building applications on top of it.\n\n``` mermaid\nflowchart LR\n    A[(Chain State)] --> B[[\"STF<br/>[Pallet 1]<br/>[Pallet 2]<br/>...<br/>[Pallet N]\"]]\n    C[Transaction<br/>Targeting Pallet 2] --> B\n    B --> E[(New State)]\n    B --> F[Execution Logs]\n```\n\nParachains inherently offer features such as logic upgradeability, flexible transaction fee mechanisms, and chain abstraction logic. More so, by using Polkadot, parachains can benefit from robust consensus guarantees with little engineering overhead.\n\nTo read more about the differences between smart contracts and parachain runtimes, see the [Runtime vs. Smart Contracts](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/runtime_vs_smart_contract/index.html){target=\\_blank} section of the Polkadot SDK Rust docs. For a more in-depth discussion about choosing between runtime development and smart contract development, see the Stack Overflow post on [building a Polkadot SDK runtime versus a smart contract](https://stackoverflow.com/a/56041305){target=\\_blank}.\n\n## Building a Smart Contract\n\nThe Polkadot SDK supports multiple smart contract execution environments:\n\n- **PolkaVM**: A cutting-edge virtual machine tailored to optimize smart contract execution on Polkadot. Unlike traditional EVMs, PolkaVM is built with a [RISC-V-based register architecture](https://en.wikipedia.org/wiki/RISC-V){target=\\_blank} for increased performance and scalability.\n- **EVM**: Through [Frontier](https://github.com/polkadot-evm/frontier){target=\\_blank}. It consists of a full Ethereum JSON RPC compatible client, an Ethereum emulation layer, and a [Rust-based EVM](https://github.com/rust-ethereum/evm){target=\\_blank}. This is used by chains like [Acala](https://acala.network/){target=\\_blank}, [Astar](https://astar.network/){target=\\_blank}, [Moonbeam](https://moonbeam.network){target=\\_blank} and more.\n- **Wasm**: [ink!](https://use.ink/){target=\\_blank} is a domain-specific language (DSL) for Rust smart contract development that uses the [Contracts pallet](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/contracts/){target=\\_blank} with [`cargo-contract`](https://github.com/use-ink/cargo-contract){target=\\_blank} serving as the compiler to WebAssembly. Wasm contracts can be used by chains like [Astar](https://astar.network/){target=\\_blank}.\n\n### PolkaVM Contracts\n\nA component of the Asset Hub parachain, PolkaVM helps enable the deployment of Solidity-based smart contracts directly on Asset Hub. Learn more about how this cutting edge virtual machine facilitates using familiar Ethereum-compatible contracts and tools with Asset Hub by visiting the [Native Smart Contracts](/develop/smart-contracts/overview#native-smart-contracts){target=\\_blank} guide.\n\n### EVM Contracts\n\nThe [Frontier](https://github.com/polkadot-evm/frontier){target=\\_blank} project provides a set of modules that enables a Polkadot SDK-based chain to run an Ethereum emulation layer that allows the execution of EVM smart contracts natively with the same API/RPC interface.\n\n[Ethereum addresses (ECDSA)](https://ethereum.org/en/glossary/#address){target=\\_blank} can also be mapped directly to and from the Polkadot SDK's SS58 scheme from existing accounts. Moreover, you can modify Polkadot SDK to use the ECDSA signature scheme directly to avoid any mapping.\n\nAt a high level, [Frontier](https://github.com/polkadot-evm/frontier){target=\\_blank} is composed of three main components:\n\n- **[Ethereum Client](https://github.com/polkadot-evm/frontier/tree/master/client){target=\\_blank}**: An Ethereum JSON RPC compliant client that allows any request coming from an Ethereum tool, such as [Remix](https://remix.ethereum.org/){target=\\_blank}, [Hardhat](https://hardhat.org/){target=\\_blank} or [Foundry](https://getfoundry.sh/){target=\\_blank}, to be admitted by the network.\n- **[Pallet Ethereum](https://docs.rs/pallet-ethereum/latest/pallet_ethereum/){target=\\_blank}**: A block emulation and Ethereum transaction validation layer that works jointly with the Ethereum client to ensure compatibility with Ethereum tools.\n- **[Pallet EVM](https://docs.rs/pallet-evm/latest/pallet_evm/){target=\\_blank}**: Access layer to the [Rust-based EVM](https://github.com/rust-ethereum/evm){target=\\_blank}, enabling the execution of EVM smart contract logic natively.\n\nThe following diagram illustrates a high-level overview of the path an EVM transaction follows when using this configuration:\n\n``` mermaid\nflowchart TD\n    A[Users and Devs] -->|Send Tx| B[Frontier RPC Ext]\n    subgraph C[Pallet Ethereum]\n        D[Validate Tx]\n        E[Send<br/>Valid Tx]    \n    end\n    B -->|Interact with| C\n    D --> E\n    subgraph F[Pallet EVM]\n        G[Rust EVM]\n    end\n    I[(Current EVM<br/>Emulated State)]\n\n    H[Smart Contract<br/>Solidity, Vyper...] <-->|Compiled to EVM<br/>Bytecode| I\n\n    C --> F\n    I --> F\n    F --> J[(New Ethereum<br/>Emulated State)]\n    F --> K[Execution Logs]\n\n    style C fill:#ffffff,stroke:#000000,stroke-width:1px\n    style F fill:#ffffff,stroke:#000000,stroke-width:1px\n```\n\nAlthough it seems complex, users and developers are abstracted of that complexity, and tools can easily interact with the parachain as they would with any other Ethereum-compatible environment.\n\nThe Rust EVM is capable of executing regular [EVM bytecode](https://www.ethervm.io/){target=\\_blank}. Consequently, any language that compiles to EVM bytecode can be used to create programs that the parachain can execute.\n\n### Wasm Contracts\n\nThe [`pallet_contracts`](https://docs.rs/pallet-contracts/latest/pallet_contracts/index.html#contracts-pallet){target=\\_blank} provides the execution environment for Wasm-based smart contracts. Consequently, any smart contract language that compiles to Wasm can be executed in a parachain that enables this module.\n\nAt the time of writing there are two main languages that can be used for Wasm programs:\n\n- **[ink!](https://use.ink/){target=\\_blank}**: A Rust-based language that compiles to Wasm. It allows developers to inherit all its safety guarantees and use normal Rust tooling, being the dedicated domain-specific language.\n- **Solidity**: Can be compiled to Wasm via the [Solang](https://github.com/hyperledger-solang/solang/){target=\\_blank} compiler. Consequently, developers can write Solidity 0.8 smart contracts that can be executed as Wasm programs in parachains.\n\nThe following diagram illustrates a high-level overview of the path a transaction follows when using [`pallet_contracts`](https://docs.rs/pallet-contracts/latest/pallet_contracts/index.html#contracts-pallet){target=\\_blank}:\n\n``` mermaid\nflowchart TD\n    \n    subgraph A[Wasm Bytecode API]\n        C[Pallet Contracts]\n    end\n\n    B[Users and Devs] -- Interact with ---> A\n    \n    D[(Current State)]\n\n    E[Smart Contract<br/>ink!, Solidity...] <-->|Compiled to Wasm<br/>Bytecode| D\n\n    D --> A\n    A --> F[(New State)]\n    A --> G[Execution Logs]\n\n    style A fill:#ffffff,stroke:#000000,stroke-width:1px\n```\n"}
{"title": "Smart Contracts Overview", "slug": "develop-smart-contracts-overview", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-smart-contracts-overview.md", "html_url": "https://docs.polkadot.com/develop/smart-contracts/overview/", "categories": ["Basics", "Smart Contracts"], "description": "Learn about smart contract development capabilities in the Polkadot ecosystem, either by leveraging Polkadot Hub or other alternatives.", "estimated_token_count": 1156, "token_estimator": "heuristic-v1", "content": "# Smart Contracts on Polkadot\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nPolkadot offers developers multiple approaches to building and deploying smart contracts within its ecosystem. As a multi-chain network designed for interoperability, Polkadot provides various environments optimized for different developer preferences and application requirements. From native smart contract support on Polkadot Hub to specialized parachain environments, developers can choose the platform that best suits their technical needs while benefiting from Polkadot's shared security model and cross-chain messaging capabilities.\n\nWhether you're looking for Ethereum compatibility through EVM-based parachains like [Moonbeam](https://docs.moonbeam.network/){target=\\_blank}, [Astar](https://docs.astar.network/){target=\\_blank}, and [Acala](https://evmdocs.acala.network/){target=\\_blank} or prefer PolkaVM-based development with [ink!](https://use.ink/docs/v6/){target=\\_blank}, the Polkadot ecosystem accommodates a range of diverse developers.\n\nThese guides explore the diverse smart contract options available in the Polkadot ecosystem, helping developers understand the unique advantages of each approach and make informed decisions about where to deploy their decentralized applications.\n\n## Native Smart Contracts\n\n### Introduction\n\nPolkadot Hub enables smart contract deployment and execution through PolkaVM, a cutting-edge virtual machine designed specifically for the Polkadot ecosystem. This native integration allows developers to deploy smart contracts directly on Polkadot's system chain while maintaining compatibility with Ethereum development tools and workflows.\n\n### Smart Contract Development\n\nThe smart contract platform on Polkadot Hub combines _Polkadot's robust security and scalability_ with the extensive Ethereum development ecosystem. Developers can utilize familiar Ethereum libraries for contract interactions and leverage industry-standard development environments for writing and testing smart contracts.\n\nPolkadot Hub provides _full Ethereum JSON-RPC API compatibility_, ensuring seamless integration with existing development tools and services. This compatibility enables developers to maintain their preferred workflows while building on Polkadot's native infrastructure.\n\n### Technical Architecture\n\nPolkaVM, the underlying virtual machine, utilizes a RISC-V-based register architecture _optimized for the Polkadot ecosystem_. This design choice offers several advantages:\n\n- Enhanced performance for smart contract execution.\n- Improved gas efficiency for complex operations.\n- Native compatibility with Polkadot's runtime environment.\n- Optimized storage and state management.\n\n### Development Tools and Resources\n\nPolkadot Hub supports a comprehensive suite of development tools familiar to Ethereum developers. The platform integrates with popular development frameworks, testing environments, and deployment tools. Key features include:\n\n- Contract development in Solidity or Rust.\n- Support for standard Ethereum development libraries.\n- Integration with widely used development environments.\n- Access to blockchain explorers and indexing solutions.\n- Compatibility with contract monitoring and management tools.\n\n### Cross-Chain Capabilities\n\nSmart contracts deployed on Polkadot Hub can leverage Polkadot's [cross-consensus messaging (XCM) protocol](/develop/interoperability/intro-to-xcm/){target=\\_blank} protocol to seamlessly _transfer tokens and call functions on other blockchain networks_ within the Polkadot ecosystem, all without complex bridging infrastructure or third-party solutions. For further references, check the [Interoperability](/develop/interoperability/){target=\\_blank} section.\n\n### Use Cases\n\nPolkadot Hub's smart contract platform is suitable for a wide range of applications:\n\n- DeFi protocols leveraging _cross-chain capabilities_.\n- NFT platforms utilizing Polkadot's native token standards.\n- Governance systems integrated with Polkadot's democracy mechanisms.\n- Cross-chain bridges and asset management solutions.\n\n## Other Smart Contract Environments\n\nBeyond Polkadot Hub's native PolkaVM support, the ecosystem offers two main alternatives for smart contract development:\n\n- **EVM-compatible parachains**: Provide access to Ethereum's extensive developer ecosystem, smart contract portability, and established tooling like Hardhat, Remix, Foundry, and OpenZeppelin. The main options include Moonbeam (the first full Ethereum-compatible parachain serving as an interoperability hub), Astar (featuring dual VM support for both EVM and WebAssembly contracts), and Acala (DeFi-focused with enhanced Acala EVM+ offering advanced DeFi primitives).\n\n- **Rust (ink!)**: ink! is a Rust-based framework that can compile to PolkaVM. It uses [`#[ink(...)]`](https://use.ink/docs/v6/macros-attributes/){target=\\_blank} attribute macros to create Polkadot SDK-compatible PolkaVM bytecode, offering strong memory safety from Rust, an advanced type system, high-performance PolkaVM execution, and platform independence with sandboxed security.\n\n\nEach environment provides unique advantages based on developer preferences and application requirements.\n\n## Where to Go Next\n\nDevelopers can use their existing Ethereum development tools and connect to Polkadot Hub's RPC endpoints. The platform's Ethereum compatibility layer ensures a smooth transition for teams already building on Ethereum-compatible chains.\n\nSubsequent sections of this guide provide detailed information about specific development tools, advanced features, and best practices for building on Polkadot Hub.\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> __Libraries__\n\n    ---\n\n    Explore essential libraries to optimize smart contract development and interaction.\n\n    [:octicons-arrow-right-24: Reference](/develop/smart-contracts/libraries/)\n\n-   <span class=\"badge guide\">Guide</span> __Dev Environments__\n\n    ---\n\n    Set up your development environment for seamless contract deployment and testing.\n\n    [:octicons-arrow-right-24: Reference](/develop/smart-contracts/dev-environments/)\n\n</div>\n"}
{"title": "Spawn a Basic Chain with Zombienet", "slug": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/tutorials-polkadot-sdk-testing-spawn-basic-chain.md", "html_url": "https://docs.polkadot.com/tutorials/polkadot-sdk/testing/spawn-basic-chain/", "categories": ["Basics", "dApps", "Tooling"], "description": "Learn to spawn, connect to and monitor a basic blockchain network with Zombienet, using customizable configurations for streamlined development and debugging.", "estimated_token_count": 2590, "token_estimator": "heuristic-v1", "content": "# Spawn a Basic Chain with Zombienet\n\n## Introduction\n\nZombienet simplifies blockchain development by enabling developers to create temporary, customizable networks for testing and validation. These ephemeral chains are ideal for experimenting with configurations, debugging applications, and validating functionality in a controlled environment.\n\nIn this guide, you'll learn how to define a basic network configuration file, spawn a blockchain network using Zombienet's CLI, and interact with nodes and monitor network activity using tools like Polkadot.js Apps and Prometheus\n\nBy the end of this tutorial, you'll be equipped to deploy and test your own blockchain networks, paving the way for more advanced setups and use cases.\n\n## Prerequisites\n\nTo successfully complete this tutorial, you must ensure you've first:\n\n- [Installed Zombienet](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#install-zombienet){target=\\_blank}. This tutorial requires Zombienet version `v1.3.133`. Verify that you're using the specified version to ensure compatibility with the instructions.\n- Reviewed the information in [Configure Zombienet](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#configure-zombienet){target=\\_blank} and understand how to customize a spawned network.\n\n## Set Up Local Provider\n\nIn this tutorial, you will use the Zombienet [local provider](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#local-provider){target=\\_blank} (also called native provider) that enables you to run nodes as local processes in your development environment.\n\nYou must have the necessary binaries installed (such as `polkadot` and `polkadot-parachain`) to spin up your network successfully.\n\nTo install the required binaries, use the following Zombienet CLI command:\n\n```bash\nzombienet setup polkadot polkadot-parachain\n```\n\nThis command downloads the following binaries:\n\n- `polkadot`\n- `polkadot-execute-worker`\n- `polkadot-parachain`\n- `polkadot-prepare-worker`\n\nFinally, add these binaries to your PATH environment variable to ensure Zombienet can locate them when spawning the network.\n\nFor example, you can move the binaries to a directory in your PATH, such as `/usr/local/bin`:\n\n```bash\nsudo mv ./polkadot ./polkadot-execute-worker ./polkadot-parachain ./polkadot-prepare-worker /usr/local/bin\n```\n\n## Define the Network\n\nZombienet uses a [configuration file](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#configuration-files){target=\\_blank} to define the ephemeral network that will be spawned. Follow these steps to create and define the configuration file:\n\n1. Create a file named `spawn-a-basic-network.toml`:\n\n    ```bash\n    touch spawn-a-basic-network.toml\n    ```\n\n2. Add the following code to the file you just created:\n\n    ```toml title=\"spawn-a-basic-network.toml\"\n    -[settings]\ntimeout = 120\n\n[relaychain]\n\n[[relaychain.nodes]]\nname = \"alice\"\nvalidator = true\n\n[[relaychain.nodes]]\nname = \"bob\"\nvalidator = true\n\n[[parachains]]\nid = 100\n\n[parachains.collator]\nname = \"collator01\"\n\n    ```\n\nThis configuration file defines a network with the following chains:\n\n- **relaychain**: With two nodes named `alice` and `bob`.\n- **parachain**: With a collator named `collator01`.\n\nSettings also defines a timeout of 120 seconds for the network to be ready.\n\n## Spawn the Network\n\nTo spawn the network, run the following command:\n\n```bash\nzombienet -p native spawn spawn-a-basic-network.toml\n```\n\nThis command will spawn the network defined in the `spawn-a-basic-network.toml` configuration file. The `-p native` flag specifies that the network will be spawned using the native provider.\n\nIf successful, you will see the following output:\n\n-<div id=\"termynal\" class=\"table-termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>zombienet -p native spawn spawn-a-basic-network.toml</span>\n  <table>\n    <thead>\n      <tr>\n        <th colspan=\"2\" class=\"center-header\">Network launched 🚀🚀</th>\n      </tr>\n    </thead>\n    <tr>\n      <th class=\"left-header\">Namespace</th>\n      <td>zombie-75a01b93c92d571f6198a67bcb380fcd</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Provider</th>\n      <td>native</td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" class=\"center-header\">Node Information</th>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Name</th>\n      <td>alice</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Direct Link</th>\n      <td><a href=\"https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer\">https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer</a></td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Prometheus Link</th>\n      <td>http://127.0.0.1:55310/metrics</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Log Cmd</th>\n      <td>tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/alice.log</td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" class=\"center-header\">Node Information</th>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Name</th>\n      <td>bob</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Direct Link</th>\n      <td><a href=\"https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:50312#explorer\">https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55312#explorer</a></td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Prometheus Link</th>\n      <td>http://127.0.0.1:50634/metrics</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Log Cmd</th>\n      <td>tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/bob.log</td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" class=\"center-header\">Node Information</th>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Name</th>\n      <td>collator01</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Direct Link</th>\n      <td><a href=\"https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55316#explorer\">https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55316#explorer</a></td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Prometheus Link</th>\n      <td>http://127.0.0.1:55318/metrics</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Log Cmd</th>\n      <td>tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/collator01.log</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Parachain ID</th>\n      <td>100</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">ChainSpec Path</th>\n      <td>/tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/100-rococo-local.json</td>\n    </tr>\n  </table>\n</div>\n\n\n!!! note \n    If the IPs and ports aren't explicitly defined in the configuration file, they may change each time the network is started, causing the links provided in the output to differ from the example.\n\n## Interact with the Spawned Network\n\nAfter the network is launched, you can interact with it using [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\\_blank}. To do so, open your browser and use the provided links listed by the output as `Direct Link`.\n\n### Connect to the Nodes\n\nUse the [55308 port address](https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer){target=\\_blank} to interact with the same `alice` node used for this tutorial. Ports can change from spawn to spawn so be sure to locate the link in the output when spawning your own node to ensure you are accessing the correct port.\n\nIf you want to interact with the nodes more programmatically, you can also use the [Polkadot.js API](https://polkadot.js.org/docs/api/){target=\\_blank}. For example, the following code snippet shows how to connect to the `alice` node using the Polkadot.js API and log some information about the chain and node:\n\n```typescript\n-import { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://127.0.0.1:55308');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain & node information via rpc calls\n  const [chain, nodeName, nodeVersion] = await Promise.all([\n    api.rpc.system.chain(),\n    api.rpc.system.name(),\n    api.rpc.system.version(),\n  ]);\n\n  console.log(\n    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`\n  );\n}\n\nmain()\n  .catch(console.error)\n  .finally(() => process.exit());\n\n```\n\nBoth methods allow you to interact easily with the network and its nodes.\n\n### Check Metrics\n\nYou can also check the metrics of the nodes by accessing the links provided in the output as `Prometheus Link`. [Prometheus](https://prometheus.io/){target=\\_blank} is a monitoring and alerting toolkit that collects metrics from the nodes. By accessing the provided links, you can see the metrics of the nodes in a web interface. So, for example, the following image shows the Prometheus metrics for Bob's node from the Zombienet test:\n\n![](/images/tutorials/polkadot-sdk/testing/spawn-basic-chain/spawn-basic-network-01.webp)\n\n### Check Logs\n\nTo view individual node logs, locate the `Log Cmd` command in Zombienet's startup output. For example, to see what the alice node is doing, find the log command that references `alice.log` in its file path. Note that Zombienet will show you the correct path for your instance when it starts up, so use that path rather than copying from the below example:\n\n```bash\ntail -f  /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/alice.log\n```\n\nAfter running this command, you will see the logs of the `alice` node in real-time, which can be useful for debugging purposes. The logs of the `bob` and `collator01` nodes can be checked similarly.\n"}
{"title": "Testing and Debugging", "slug": "develop-interoperability-test-and-debug", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-interoperability-test-and-debug.md", "html_url": "https://docs.polkadot.com/develop/interoperability/test-and-debug/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn how to test and debug cross-chain communication via the XCM Emulator to ensure interoperability and reliable execution.", "estimated_token_count": 1481, "token_estimator": "heuristic-v1", "content": "# Testing and Debugging\n\n## Introduction\n\nCross-Consensus Messaging (XCM) is a core feature of the Polkadot ecosystem, enabling communication between parachains, relay chains, and system chains. To ensure the reliability of XCM-powered blockchains, thorough testing and debugging are essential before production deployment.\n\nThis guide covers the XCM Emulator, a tool designed to facilitate onboarding and testing for developers. Use the emulator if:\n\n- A live runtime is not yet available.\n- Extensive configuration adjustments are needed, as emulated chains differ from live networks.\n- Rust-based tests are preferred for automation and integration.\n\nFor scenarios where real blockchain state is required, [Chopsticks](/tutorials/polkadot-sdk/testing/fork-live-chains/#xcm-testing){target=\\_blank} allows testing with any client compatible with Polkadot SDK-based chains.\n\n## XCM Emulator\n\nSetting up a live network with multiple interconnected parachains for XCM testing can be complex and resource-intensive. \n\nThe [`xcm-emulator`](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/cumulus/xcm/xcm-emulator){target=\\_blank} is a tool designed to simulate the execution of XCM programs using predefined runtime configurations. These configurations include those utilized by live networks like Kusama, Polkadot, and Asset Hub.\n\nThis tool enables testing of cross-chain message passing, providing a way to verify outcomes, weights, and side effects efficiently. It achieves this by utilizing mocked runtimes for both the relay chain and connected parachains, enabling developers to focus on message logic and configuration without needing a live network.\n\nThe `xcm-emulator` relies on transport layer pallets. However, the messages do not leverage the same messaging infrastructure as live networks since the transport mechanism is mocked. Additionally, consensus-related events are not covered, such as disputes and staking events. Parachains should use end-to-end (E2E) tests to validate these events.\n\n### Advantages and Limitations\n\nThe XCM Emulator provides both advantages and limitations when testing cross-chain communication in simulated environments.\n\n- **Advantages**:\n    - **Interactive debugging**: Offers tracing capabilities similar to EVM, enabling detailed analysis of issues.\n    - **Runtime composability**: Facilitates testing and integration of multiple runtime components.\n    - **Immediate feedback**: Supports Test-Driven Development (TDD) by providing rapid test results.\n    - **Seamless integration testing**: Simplifies the process of testing new runtime versions in an isolated environment.\n\n- **Limitations**:\n    - **Simplified emulation**: Always assumes message delivery, which may not mimic real-world network behavior.\n    - **Dependency challenges**: Requires careful management of dependency versions and patching. Refer to the [Cargo dependency documentation](https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html){target=\\_blank}.\n    - **Compilation overhead**: Testing environments can be resource-intensive, requiring frequent compilation updates.\n\n### How Does It Work?\n\nThe `xcm-emulator` provides macros for defining a mocked testing environment. Check all the existing macros and functionality in the [XCM Emulator source code](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506/cumulus/xcm/xcm-emulator/src/lib.rs){target=\\_blank}. The most important macros are:\n\n- **[`decl_test_relay_chains`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506/cumulus/xcm/xcm-emulator/src/lib.rs#L361){target=\\_blank}**: Defines runtime and configuration for the relay chains. Example:\n\n    ```rust\n    -decl_test_relay_chains! {\n\t#[api_version(13)]\n\tpub struct Westend {\n\t\tgenesis = genesis::genesis(),\n\t\ton_init = (),\n\t\truntime = westend_runtime,\n\t\tcore = {\n\t\t\tSovereignAccountOf: westend_runtime::xcm_config::LocationConverter,\n\t\t},\n\t\tpallets = {\n\t\t\tXcmPallet: westend_runtime::XcmPallet,\n\t\t\tSudo: westend_runtime::Sudo,\n\t\t\tBalances: westend_runtime::Balances,\n\t\t\tTreasury: westend_runtime::Treasury,\n\t\t\tAssetRate: westend_runtime::AssetRate,\n\t\t\tHrmp: westend_runtime::Hrmp,\n\t\t\tIdentity: westend_runtime::Identity,\n\t\t\tIdentityMigrator: westend_runtime::IdentityMigrator,\n\t\t}\n\t},\n}\n    ```\n\n- **[`decl_test_parachains`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506/cumulus/xcm/xcm-emulator/src/lib.rs#L596){target=\\_blank}**: Defines runtime and configuration for parachains. Example:\n\n    ```rust\n    -decl_test_parachains! {\n\tpub struct AssetHubWestend {\n\t\tgenesis = genesis::genesis(),\n\t\ton_init = {\n\t\t\tasset_hub_westend_runtime::AuraExt::on_initialize(1);\n\t\t},\n\t\truntime = asset_hub_westend_runtime,\n\t\tcore = {\n\t\t\tXcmpMessageHandler: asset_hub_westend_runtime::XcmpQueue,\n\t\t\tLocationToAccountId: asset_hub_westend_runtime::xcm_config::LocationToAccountId,\n\t\t\tParachainInfo: asset_hub_westend_runtime::ParachainInfo,\n\t\t\tMessageOrigin: cumulus_primitives_core::AggregateMessageOrigin,\n\t\t\tDigestProvider: (),\n\t\t},\n\t\tpallets = {\n\t\t\tPolkadotXcm: asset_hub_westend_runtime::PolkadotXcm,\n\t\t\tBalances: asset_hub_westend_runtime::Balances,\n\t\t\tAssets: asset_hub_westend_runtime::Assets,\n\t\t\tForeignAssets: asset_hub_westend_runtime::ForeignAssets,\n\t\t\tPoolAssets: asset_hub_westend_runtime::PoolAssets,\n\t\t\tAssetConversion: asset_hub_westend_runtime::AssetConversion,\n\t\t\tSnowbridgeSystemFrontend: asset_hub_westend_runtime::SnowbridgeSystemFrontend,\n\t\t\tRevive: asset_hub_westend_runtime::Revive,\n\t\t}\n\t},\n}\n    ```\n\n- **[`decl_test_bridges`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506/cumulus/xcm/xcm-emulator/src/lib.rs#L1221){target=\\_blank}**: Creates bridges between chains, specifying the source, target, and message handler. Example:\n\n    ```rust\n    -decl_test_bridges! {\n\tpub struct RococoWestendMockBridge {\n\t\tsource = BridgeHubRococoPara,\n\t\ttarget = BridgeHubWestendPara,\n\t\thandler = RococoWestendMessageHandler\n\t},\n\tpub struct WestendRococoMockBridge {\n\t\tsource = BridgeHubWestendPara,\n\t\ttarget = BridgeHubRococoPara,\n\t\thandler = WestendRococoMessageHandler\n\t}\n}\n    ```\n\n- **[`decl_test_networks`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506/cumulus/xcm/xcm-emulator/src/lib.rs#L958){target=\\_blank}**: Defines a testing network with relay chains, parachains, and bridges, implementing message transport and processing logic. Example:\n\n    ```rust\n    -decl_test_networks! {\n\tpub struct WestendMockNet {\n\t\trelay_chain = Westend,\n\t\tparachains = vec![\n\t\t\tAssetHubWestend,\n\t\t\tBridgeHubWestend,\n\t\t\tCollectivesWestend,\n\t\t\tCoretimeWestend,\n\t\t\tPeopleWestend,\n\t\t\tPenpalA,\n\t\t\tPenpalB,\n\t\t],\n\t\tbridge = ()\n\t},\n}\n    ```\n\nBy leveraging these macros, developers can customize their testing networks by defining relay chains and parachains tailored to their needs. For guidance on implementing a mock runtime for a Polkadot SDK-based chain, refer to the [Pallet Testing](/develop/parachains/testing/pallet-testing/){target=\\_blank} article. \n\nThis framework enables thorough testing of runtime and cross-chain interactions, enabling developers to effectively design, test, and optimize cross-chain functionality.\n\nTo see a complete example of implementing and executing tests, refer to the [integration tests](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/cumulus/parachains/integration-tests/emulated){target=\\_blank} in the Polkadot SDK repository.\n"}
{"title": "Transactions", "slug": "polkadot-protocol-parachain-basics-blocks-transactions-fees-transactions", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-blocks-transactions-fees-transactions.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn how to construct, submit, and validate transactions in the Polkadot SDK, covering signed, unsigned, and inherent types of transactions.", "estimated_token_count": 4708, "token_estimator": "heuristic-v1", "content": "# Transactions\n\n## Introduction\n\nTransactions are essential components of blockchain networks, enabling state changes and the execution of key operations. In the Polkadot SDK, transactions, often called extrinsics, come in multiple forms, including signed, unsigned, and inherent transactions.\n\nThis guide walks you through the different transaction types and how they're formatted, validated, and processed within the Polkadot ecosystem. You'll also learn how to customize transaction formats and construct transactions for FRAME-based runtimes, ensuring a complete understanding of how transactions are built and executed in Polkadot SDK-based chains.\n\n## What Is a Transaction?\n\nIn the Polkadot SDK, transactions represent operations that modify the chain's state, bundled into blocks for execution. The term extrinsic is often used to refer to any data that originates outside the runtime and is included in the chain. While other blockchain systems typically refer to these operations as \"transactions,\" the Polkadot SDK adopts the broader term \"extrinsic\" to capture the wide variety of data types that can be added to a block.\n\nThere are three primary types of transactions (extrinsics) in the Polkadot SDK:\n\n- **Signed transactions**: Signed by the submitting account, often carrying transaction fees.\n- **Unsigned transactions**: Submitted without a signature, often requiring custom validation logic.\n- **Inherent transactions**: Typically inserted directly into blocks by block authoring nodes, without gossiping between peers.\n\nEach type serves a distinct purpose, and understanding when and how to use each is key to efficiently working with the Polkadot SDK.\n\n### Signed Transactions\n\nSigned transactions require an account's signature and typically involve submitting a request to execute a runtime call. The signature serves as a form of cryptographic proof that the sender has authorized the action, using their private key. These transactions often involve a transaction fee to cover the cost of execution and incentivize block producers.\n\nSigned transactions are the most common type of transaction and are integral to user-driven actions, such as token transfers. For instance, when you transfer tokens from one account to another, the sending account must sign the transaction to authorize the operation.\n\nFor example, the [`pallet_balances::Call::transfer_allow_death`](https://paritytech.github.io/polkadot-sdk/master/pallet_balances/pallet/struct.Pallet.html#method.transfer_allow_death){target=\\_blank} extrinsic in the Balances pallet allows you to transfer tokens. Since your account initiates this transaction, your account key is used to sign it. You'll also be responsible for paying the associated transaction fee, with the option to include an additional tip to incentivize faster inclusion in the block.\n\n### Unsigned Transactions\n\nUnsigned transactions do not require a signature or account-specific data from the sender. Unlike signed transactions, they do not come with any form of economic deterrent, such as fees, which makes them susceptible to spam or replay attacks. Custom validation logic must be implemented to mitigate these risks and ensure these transactions are secure.\n\nUnsigned transactions typically involve scenarios where including a fee or signature is unnecessary or counterproductive. However, due to the absence of fees, they require careful validation to protect the network. For example, [`pallet_im_online::Call::heartbeat`](https://paritytech.github.io/polkadot-sdk/master/pallet_im_online/pallet/struct.Pallet.html#method.heartbeat){target=\\_blank} extrinsic allows validators to send a heartbeat signal, indicating they are active. Since only validators can make this call, the logic embedded in the transaction ensures that the sender is a validator, making the need for a signature or fee redundant.\n\nUnsigned transactions are more resource-intensive than signed ones because custom validation is required, but they play a crucial role in certain operational scenarios, especially when regular user accounts aren't involved.\n\n### Inherent Transactions\n\nInherent transactions are a specialized type of unsigned transaction that is used primarily for block authoring. Unlike signed or other unsigned transactions, inherent transactions are added directly by block producers and are not broadcasted to the network or stored in the transaction queue. They don't require signatures or the usual validation steps and are generally used to insert system-critical data directly into blocks.\n\nA key example of an inherent transaction is inserting a timestamp into each block. The [`pallet_timestamp::Call::now`](https://paritytech.github.io/polkadot-sdk/master/pallet_timestamp/pallet/struct.Pallet.html#method.now-1){target=\\_blank} extrinsic allows block authors to include the current time in the block they are producing. Since the block producer adds this information, there is no need for transaction validation, like signature verification. The validation in this case is done indirectly by the validators, who check whether the timestamp is within an acceptable range before finalizing the block.\n\nAnother example is the [`paras_inherent::Call::enter`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/paras_inherent/pallet/struct.Pallet.html#method.enter){target=\\_blank} extrinsic, which enables parachain collator nodes to send validation data to the relay chain. This inherent transaction ensures that the necessary parachain data is included in each block without the overhead of gossiped transactions.\n\nInherent transactions serve a critical role in block authoring by allowing important operational data to be added directly to the chain without needing the validation processes required for standard transactions.\n\n## Transaction Formats\n\nUnderstanding the structure of signed and unsigned transactions is crucial for developers building on Polkadot SDK-based chains. Whether you're optimizing transaction processing, customizing formats, or interacting with the transaction pool, knowing the format of extrinsics, Polkadot's term for transactions, is essential.\n\n### Types of Transaction Formats\n\nIn Polkadot SDK-based chains, extrinsics can fall into three main categories:\n\n- **Unchecked extrinsics**: Typically used for signed transactions that require validation. They contain a signature and additional data, such as a nonce and information for fee calculation. Unchecked extrinsics are named as such because they require validation checks before being accepted into the transaction pool.\n- **Checked extrinsics**: Typically used for inherent extrinsics (unsigned transactions); these don't require signature verification. Instead, they carry information such as where the extrinsic originates and any additional data required for the block authoring process.\n- **Opaque extrinsics**: Used when the format of an extrinsic is not yet fully committed or finalized. They are still decodable, but their structure can be flexible depending on the context.\n\n### Signed Transaction Data Structure\n\nA signed transaction typically includes the following components:\n\n- **Signature**: Verifies the authenticity of the transaction sender.\n- **Call**: The actual function or method call the transaction is requesting (for example, transferring funds).\n- **Nonce**: Tracks the number of prior transactions sent from the account, helping to prevent replay attacks.\n- **Tip**: An optional incentive to prioritize the transaction in block inclusion.\n- **Additional data**: Includes details such as spec version, block hash, and genesis hash to ensure the transaction is valid within the correct runtime and chain context.\n\nHere's a simplified breakdown of how signed transactions are typically constructed in a Polkadot SDK runtime:\n\n``` code\n<signing account ID> + <signature> + <additional data>\n```\n\nEach part of the signed transaction has a purpose, ensuring the transaction's authenticity and context within the blockchain.\n\n### Signed Extensions\n\nPolkadot SDK also provides the concept of [signed extensions](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/signed_extensions/index.html){target=\\_blank}, which allow developers to extend extrinsics with additional data or validation logic before they are included in a block. The [`SignedExtension`](https://paritytech.github.io/try-runtime-cli/sp_runtime/traits/trait.SignedExtension.html){target=\\_blank} set helps enforce custom rules or protections, such as ensuring the transaction's validity or calculating priority.\n\nThe transaction queue regularly calls signed extensions to verify a transaction's validity before placing it in the ready queue. This safeguard ensures transactions won't fail in a block. Signed extensions are commonly used to enforce validation logic and protect the transaction pool from spam and replay attacks.\n\nIn FRAME, a signed extension can hold any of the following types by default:\n\n- **[`AccountId`](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_frame/runtime/types_common/type.AccountId.html){target=\\_blank}**: To encode the sender's identity.\n- **[`Call`](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_frame/traits/trait.SignedExtension.html#associatedtype.Call){target=\\_blank}**: To encode the pallet call to be dispatched. This data is used to calculate transaction fees.\n- **[`AdditionalSigned`](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_frame/traits/trait.SignedExtension.html#associatedtype.AdditionalSigned){target=\\_blank}**: To handle any additional data to go into the signed payload allowing you to attach any custom logic prior to dispatching a transaction.\n- **[`Pre`](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_frame/traits/trait.SignedExtension.html#associatedtype.Pre){target=\\_blank}**: To encode the information that can be passed from before a call is dispatched to after it gets dispatched.\n\nSigned extensions can enforce checks like:\n\n- **[`CheckSpecVersion`](https://paritytech.github.io/polkadot-sdk/master/src/frame_system/extensions/check_spec_version.rs.html){target=\\_blank}**: Ensures the transaction is compatible with the runtime's current version.\n- **[`CheckWeight`](https://paritytech.github.io/polkadot-sdk/master/frame_system/struct.CheckWeight.html){target=\\_blank}**: Calculates the weight (or computational cost) of the transaction, ensuring the block doesn't exceed the maximum allowed weight.\n\nThese extensions are critical in the transaction lifecycle, ensuring that only valid and prioritized transactions are processed.\n\n## Transaction Construction\n\nBuilding transactions in the Polkadot SDK involves constructing a payload that can be verified, signed, and submitted for inclusion in a block. Each runtime in the Polkadot SDK has its own rules for validating and executing transactions, but there are common patterns for constructing a signed transaction.\n\n### Construct a Signed Transaction\n\nA signed transaction in the Polkadot SDK includes various pieces of data to ensure security, prevent replay attacks, and prioritize processing. Here's an overview of how to construct one:\n\n1. **Construct the unsigned payload**: Gather the necessary information for the call, including:\n\n    - **Pallet index**: Identifies the pallet where the runtime function resides.\n    - **Function index**: Specifies the particular function to call in the pallet.\n    - **Parameters**: Any additional arguments required by the function call.\n\n2. **Create a signing payload**: Once the unsigned payload is ready, additional data must be included:\n\n    - **Transaction nonce**: Unique identifier to prevent replay attacks.\n    - **Era information**: Defines how long the transaction is valid before it's dropped from the pool.\n    - **Block hash**: Ensures the transaction doesn't execute on the wrong chain or fork.\n\n3. **Sign the payload**: Using the sender's private key, sign the payload to ensure that the transaction can only be executed by the account holder.\n4. **Serialize the signed payload**: Once signed, the transaction must be serialized into a binary format, ensuring the data is compact and easy to transmit over the network.\n5. **Submit the serialized transaction**: Finally, submit the serialized transaction to the network, where it will enter the transaction pool and wait for processing by an authoring node.\n\nThe following is an example of how a signed transaction might look:\n\n``` rust\n-node_runtime::UncheckedExtrinsic::new_signed(\n    function.clone(),                                      // some call\n    sp_runtime::AccountId32::from(sender.public()).into(), // some sending account\n    node_runtime::Signature::Sr25519(signature.clone()),   // the account's signature\n    extra.clone(),                                         // the signed extensions\n)\n```\n\n### Transaction Encoding\n\nBefore a transaction is sent to the network, it is serialized and encoded using a structured encoding process that ensures consistency and prevents tampering:\n\n- **`[1]`**: Compact encoded length in bytes of the entire transaction.\n- **`[2]`**: A u8 containing 1 byte to indicate whether the transaction is signed or unsigned (1 bit) and the encoded transaction version ID (7 bits).\n- **`[3]`**: If signed, this field contains an account ID, an SR25519 signature, and some extra data.\n- **`[4]`**: Encoded call data, including pallet and function indices and any required arguments.\n\nThis encoded format ensures consistency and efficiency in processing transactions across the network. By adhering to this format, applications can construct valid transactions and pass them to the network for execution.\n\nTo learn more about how compact encoding works using SCALE, see the [SCALE Codec](https://github.com/paritytech/parity-scale-codec){target=\\_blank} README on GitHub.\n\n### Customize Transaction Construction\n\nAlthough the basic steps for constructing transactions are consistent across Polkadot SDK-based chains, developers can customize transaction formats and validation rules. For example:\n\n- **Custom pallets**: You can define new pallets with custom function calls, each with its own parameters and validation logic.\n- **Signed extensions**: Developers can implement custom extensions that modify how transactions are prioritized, validated, or included in blocks.\n\nBy leveraging Polkadot SDK's modular design, developers can create highly specialized transaction logic tailored to their chain's needs.\n\n## Lifecycle of a Transaction\n\nIn the Polkadot SDK, transactions are often referred to as extrinsics because the data in transactions originates outside of the runtime. These transactions contain data that initiates changes to the chain state. The most common type of extrinsic is a signed transaction, which is cryptographically verified and typically incurs a fee. This section focuses on how signed transactions are processed, validated, and ultimately included in a block.\n\n### Define Transaction Properties\n\nThe Polkadot SDK runtime defines key transaction properties, such as:\n\n- **Transaction validity**: Ensures the transaction meets all runtime requirements.\n- **Signed or unsigned**: Identifies whether a transaction needs to be signed by an account.\n- **State changes**: Determines how the transaction modifies the state of the chain.\n\nPallets, which compose the runtime's logic, define the specific transactions that your chain supports. When a user submits a transaction, such as a token transfer, it becomes a signed transaction, verified by the user's account signature. If the account has enough funds to cover fees, the transaction is executed, and the chain's state is updated accordingly.\n\n### Process on a Block Authoring Node\n\nIn Polkadot SDK-based networks, some nodes are authorized to author blocks. These nodes validate and process transactions. When a transaction is sent to a node that can produce blocks, it undergoes a lifecycle that involves several stages, including validation and execution. Non-authoring nodes gossip the transaction across the network until an authoring node receives it. The following diagram illustrates the lifecycle of a transaction that's submitted to a network and processed by an authoring node.\n\n![Transaction lifecycle diagram](/images/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/transaction-lifecycle-1.webp)\n\n### Validate and Queue\n\nOnce a transaction reaches an authoring node, it undergoes an initial validation process to ensure it meets specific conditions defined in the runtime. This validation includes checks for:\n\n- **Correct nonce**: Ensures the transaction is sequentially valid for the account.\n- **Sufficient funds**: Confirms the account can cover any associated transaction fees.\n- **Signature validity**: Verifies that the sender's signature matches the transaction data.\n\nAfter these checks, valid transactions are placed in the transaction pool, where they are queued for inclusion in a block. The transaction pool regularly re-validates queued transactions to ensure they remain valid before being processed. To reach consensus, two-thirds of the nodes must agree on the order of the transactions executed and the resulting state change. Transactions are validated and queued on the local node in a transaction pool to prepare for consensus.\n\n#### Transaction Pool\n\nThe transaction pool is responsible for managing valid transactions. It ensures that only transactions that pass initial validity checks are queued. Transactions that fail validation, expire, or become invalid for other reasons are removed from the pool.\n\nThe transaction pool organizes transactions into two queues:\n\n- **Ready queue**: Transactions that are valid and ready to be included in a block.\n- **Future queue**: Transactions that are not yet valid but could be in the future, such as transactions with a nonce too high for the current state.\n\nDetails on how the transaction pool validates transactions, including fee and signature handling, can be found in the [`validate_transaction`](https://paritytech.github.io/polkadot-sdk/master/sp_transaction_pool/runtime_api/trait.TaggedTransactionQueue.html#method.validate_transaction){target=\\_blank} method.\n\n#### Invalid Transactions\n\nIf a transaction is invalid, for example, due to an invalid signature or insufficient funds, it is rejected and won't be added to the block. Invalid transactions might be rejected for reasons such as:\n\n- The transaction has already been included in a block.\n- The transaction's signature does not match the sender.\n- The transaction is too large to fit in the current block.\n\n### Transaction Ordering and Priority\n\nWhen a node is selected as the next block author, it prioritizes transactions based on weight, length, and tip amount. The goal is to fill the block with high-priority transactions without exceeding its maximum size or computational limits. Transactions are ordered as follows:\n\n- **Inherents first**: Inherent transactions, such as block timestamp updates, are always placed first.\n- **Nonce-based ordering**: Transactions from the same account are ordered by their nonce.\n- **Fee-based ordering**: Among transactions with the same nonce or priority level, those with higher fees are prioritized.\n\n### Transaction Execution\n\nOnce a block author selects transactions from the pool, the transactions are executed in priority order. As each transaction is processed, the state changes are written directly to the chain's storage. It's important to note that these changes are not cached, meaning a failed transaction won't revert earlier state changes, which could leave the block in an inconsistent state.\n\nEvents are also written to storage. Runtime logic should not emit an event before performing the associated actions. If the associated transaction fails after the event was emitted, the event will not revert.\n\n## Transaction Mortality\n\nTransactions in the network can be configured as either mortal (with expiration) or immortal (without expiration). Every transaction payload contains a block checkpoint (reference block number and hash) and an era/validity period that determines how many blocks after the checkpoint the transaction remains valid.\n\nWhen a transaction is submitted, the network validates it against these parameters. If the transaction is not included in a block within the specified validity window, it is automatically removed from the transaction queue.\n\n- **Mortal transactions**: Have a finite lifespan and will expire after a specified number of blocks. For example, a transaction with a block checkpoint of 1000 and a validity period of 64 blocks will be valid from blocks 1000 to 1064.\n\n- **Immortal transactions**: Never expire and remain valid indefinitely. To create an immortal transaction, set the block checkpoint to 0 (genesis block), use the genesis hash as a reference, and set the validity period to 0.\n\nHowever, immortal transactions pose significant security risks through replay attacks. If an account is reaped (balance drops to zero, account removed) and later re-funded, malicious actors can replay old immortal transactions.\n\nThe blockchain maintains only a limited number of prior block hashes for reference validation, called `BlockHashCount`. If your validity period exceeds `BlockHashCount`, the effective validity period becomes the minimum of your specified period and the block hash count.\n\n## Unique Identifiers for Extrinsics\n\nTransaction hashes are **not unique identifiers** in Polkadot SDK-based chains.\n\nKey differences from traditional blockchains:\n\n- Transaction hashes serve only as fingerprints of transaction information.\n- Multiple valid transactions can share the same hash.\n- Hash uniqueness assumptions lead to serious issues.\n\nFor example, when an account is reaped (removed due to insufficient balance) and later recreated, it resets to nonce 0, allowing identical transactions to be valid at different points:\n\n| Block | Extrinsic Index | Hash | Origin    | Nonce | Call                | Result                        |\n|-------|----------------|------|-----------|-------|---------------------|-------------------------------|\n| 100   | 0              | 0x01 | Account A | 0     | Transfer 5 DOT to B | Account A reaped              |\n| 150   | 5              | 0x02 | Account B | 4     | Transfer 7 DOT to A | Account A created (nonce = 0) |\n| 200   | 2              | 0x01 | Account A | 0     | Transfer 5 DOT to B | Successful transaction        |\n\nNotice that blocks 100 and 200 contain transactions with identical hashes (0x01) but are completely different, valid operations occurring at different times.\n\nAdditional complexity comes from Polkadot SDK's origin abstraction. Origins can represent collectives, governance bodies, or other non-account entities that don't maintain nonces like regular accounts and might dispatch identical calls multiple times with the same hash values. Each execution occurs in different chain states with different results.\n\nThe correct way to uniquely identify an extrinsic on a Polkadot SDK-based chain is to use the block ID (height or hash) and the extrinsic index. Since the Polkadot SDK defines blocks as headers plus ordered arrays of extrinsics, the index position within a canonical block provides guaranteed uniqueness.\n\n## Additional Resources\n\nFor a video overview of the lifecycle of transactions and the types of transactions that exist, see the [Transaction lifecycle](https://www.youtube.com/watch?v=3pfM0GOp02c){target=\\_blank} seminar from Parity Tech.\n"}
{"title": "Transactions and Fees on Asset Hub", "slug": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-smart-contract-basics-blocks-transactions-fees.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/smart-contract-basics/blocks-transactions-fees/", "categories": ["Basics", "Polkadot Protocol"], "description": "Explore how Asset Hub smart contracts handle blocks, transactions, and fees with EVM compatibility, supporting various Ethereum transaction types.", "estimated_token_count": 1218, "token_estimator": "heuristic-v1", "content": "# Blocks, Transactions, and Fees\n\n-!!! smartcontract \"PolkaVM Preview Release\"\n    PolkaVM smart contracts with Ethereum compatibility are in **early-stage development and may be unstable or incomplete**.\n\n## Introduction\n\nAsset Hub smart contracts operate within the Polkadot ecosystem using the [`pallet_revive`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/){target=\\_blank} implementation, which provides EVM compatibility. While many aspects of blocks and transactions are inherited from the underlying parachain architecture, there are specific considerations and mechanisms unique to smart contract operations on Asset Hub.\n\n## Smart Contract Blocks\n\nSmart contract blocks in Asset Hub follow the same fundamental structure as parachain blocks, inheriting all standard parachain block components. The `pallet_revive` implementation maintains this consistency while adding necessary [EVM-specific features](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm){target=\\_blank}. For detailed implementation specifics, the [`Block`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Block.html){target=\\_blank} struct in `pallet_revive` demonstrates how parachain and smart contract block implementations align.\n\n## Smart Contract Transactions\n\nAsset Hub implements a sophisticated transaction system that supports various transaction types and formats, encompassing both traditional parachain operations and EVM-specific interactions.\n\n### EVM Transaction Types\n\nThe system provides a fundamental [`eth_transact`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/dispatchables/fn.eth_transact.html){target=\\_blank} interface for processing raw EVM transactions dispatched through [Ethereum JSON-RPC APIs](/develop/smart-contracts/json-rpc-apis/){target=\\_blank}. This interface acts as a wrapper for Ethereum transactions, requiring an encoded signed transaction payload, though it cannot be dispatched directly. Building upon this foundation, the system supports multiple transaction formats to accommodate different use cases and optimization needs:\n\n- **[Legacy transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.TransactionLegacyUnsigned.html){target=\\_blank}**: The original Ethereum transaction format, providing basic transfer and contract interaction capabilities. These transactions use a simple pricing mechanism and are supported for backward compatibility.\n\n- **[EIP-1559 transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Transaction1559Unsigned.html){target=\\_blank}**: An improved transaction format that introduces a more predictable fee mechanism with base fee and priority fee components. This format helps optimize gas fee estimation and network congestion management.\n\n- **[EIP-2930 transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Transaction2930Unsigned.html){target=\\_blank}**: Introduces access lists to optimize gas costs for contract interactions by pre-declaring accessed addresses and storage slots.\n\n- **[EIP-4844 transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Transaction4844Unsigned.html){target=\\_blank}**: Implements blob-carrying transactions, designed to optimize Layer 2 scaling solutions by providing dedicated space for roll-up data.\n\nEach transaction type can exist in both signed and unsigned states, with appropriate validation and processing mechanisms for each.\n\n## Fees and Gas\n\nAsset Hub implements a sophisticated resource management system that combines parachain transaction fees with EVM gas mechanics, providing both Ethereum compatibility and enhanced features.\n\n### Gas Model Overview\n\nGas serves as the fundamental unit for measuring computational costs, with each network operation consuming a specified amount. This implementation maintains compatibility with Ethereum's approach while adding parachain-specific optimizations.\n\n- **Dynamic gas scaling**: Asset Hub implements a dynamic pricing mechanism that reflects actual execution performance. This results in:\n\n    - More efficient pricing for computational instructions relative to I/O operations.\n    - Better correlation between gas costs and actual resource consumption.\n    - Need for developers to implement flexible gas calculation rather than hardcoding values.\n\n- **Multi-dimensional resource metering**: Asset Hub extends beyond the traditional single-metric gas model to track three distinct resources.\n\n    - `ref_time` (computation time):\n\n        - Functions as traditional gas equivalent.\n        - Measures actual computational resource usage.\n        - Primary metric for basic operation costs.\n\n\n    - `proof_size` (verification overhead):\n\n        - Tracks state proof size required for validator verification.\n        - Helps manage consensus-related resource consumption.\n        - Important for cross-chain operations.\n\n\n    - `storage_deposit` (state management):\n\n        - Manages blockchain state growth.\n        - Implements a deposit-based system for long-term storage.\n        - Refundable when storage is freed.\n\nThese resources can be limited at both transaction and contract levels, similar to Ethereum's gas limits. For more information, check the [Gas Model](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm#gas-model){target=\\_blank} section in the [EVM vs PolkaVM](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm/){target=\\_blank} article.\n\n### Fee Components\n\n- Base fees:\n\n    - Storage deposit for contract deployment.\n    - Minimum transaction fee for network access.\n    - Network maintenance costs.\n\n- Execution fees:\n\n    - Computed based on gas consumption.\n    - Converted to native currency using network-defined rates.\n    - Reflects actual computational resource usage.\n\n- Storage fees:\n\n    - Deposit for long-term storage usage.\n    - Refundable when storage is freed.\n    - Helps prevent state bloat.\n\n### Gas Calculation and Conversion\n\nThe system maintains precise conversion mechanisms between:\n\n- Substrate weights and EVM gas units.\n- Native currency and gas costs.\n- Different resource metrics within the multi-dimensional model.\n\nThis ensures accurate fee calculation while maintaining compatibility with existing Ethereum tools and workflows.\n"}
{"title": "Transactions Weights and Fees", "slug": "polkadot-protocol-parachain-basics-blocks-transactions-fees-fees", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/polkadot-protocol-parachain-basics-blocks-transactions-fees-fees.md", "html_url": "https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/", "categories": ["Basics", "Polkadot Protocol"], "description": "Overview of transaction weights and fees in Polkadot SDK chains, detailing how fees are calculated using a defined formula and runtime specifics.", "estimated_token_count": 4472, "token_estimator": "heuristic-v1", "content": "# Transactions Weights and Fees\n\n## Introductions\n\nWhen transactions are executed, or data is stored on-chain, the activity changes the chain's state and consumes blockchain resources. Because the resources available to a blockchain are limited, managing how operations on-chain consume them is important. In addition to being limited in practical terms, such as storage capacity, blockchain resources represent a potential attack vector for malicious users. For example, a malicious user might attempt to overload the network with messages to stop the network from producing new blocks. To protect blockchain resources from being drained or overloaded, you need to manage how they are made available and how they are consumed. The resources to be aware of include:\n\n- Memory usage\n- Storage input and output\n- Computation\n- Transaction and block size\n- State database size\n\nThe Polkadot SDK provides block authors with several ways to manage access to resources and to prevent individual components of the chain from consuming too much of any single resource. Two of the most important mechanisms available to block authors are weights and transaction fees.\n\n[Weights](/polkadot-protocol/glossary/#weight){target=\\_blank} manage the time it takes to validate a block and characterize the time it takes to execute the calls in the block's body. By controlling the execution time a block can consume, weights set limits on storage input, output, and computation.\n\nSome of the weight allowed for a block is consumed as part of the block's initialization and finalization. The weight might also be used to execute mandatory inherent extrinsic calls. To help ensure blocks don’t consume too much execution time and prevent malicious users from overloading the system with unnecessary calls, weights are combined with transaction fees.\n\n[Transaction fees](/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/#transaction-fees){target=\\_blank} provide an economic incentive to limit execution time, computation, and the number of calls required to perform operations. Transaction fees are also used to make the blockchain economically sustainable because they are typically applied to transactions initiated by users and deducted before a transaction request is executed.\n\n## How Fees are Calculated\n\nThe final fee for a transaction is calculated using the following parameters:\n\n- **`base fee`**: This is the minimum amount a user pays for a transaction. It is declared a base weight in the runtime and converted to a fee using the [`WeightToFee`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/trait.Config.html#associatedtype.WeightToFee){target=\\_blank} conversion.\n- **`weight fee`**: A fee proportional to the execution time (input and output and computation) that a transaction consumes.\n- **`length fee`**: A fee proportional to the encoded length of the transaction.\n- **`tip`**: An optional tip to increase the transaction’s priority, giving it a higher chance to be included in the transaction queue.\n\nThe base fee and proportional weight and length fees constitute the inclusion fee. The inclusion fee is the minimum fee that must be available for a transaction to be included in a block.\n\n```text\ninclusion fee = base fee + weight fee + length fee\n```\n\nTransaction fees are withdrawn before the transaction is executed. After the transaction is executed, the weight can be adjusted to reflect the resources used. If a transaction uses fewer resources than expected, the transaction fee is corrected, and the adjusted transaction fee is deposited.\n\n## Using the Transaction Payment Pallet\n\nThe [Transaction Payment pallet](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/substrate/frame/transaction-payment){target=\\_blank} provides the basic logic for calculating the inclusion fee. You can also use the Transaction Payment pallet to:\n\n- Convert a weight value into a deductible fee based on a currency type using [`Config::WeightToFee`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/trait.Config.html#associatedtype.WeightToFee){target=\\_blank}.\n- Update the fee for the next block by defining a multiplier based on the chain’s final state at the end of the previous block using [`Config::FeeMultiplierUpdate`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/trait.Config.html#associatedtype.FeeMultiplierUpdate){target=\\_blank}.\n- Manage the withdrawal, refund, and deposit of transaction fees using [`Config::OnChargeTransaction`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/trait.Config.html#associatedtype.OnChargeTransaction){target=\\_blank}.\n\nYou can learn more about these configuration traits in the [Transaction Payment documentation](https://paritytech.github.io/polkadot-sdk/master/pallet_transaction_payment/index.html){target=\\_blank}.\n\n### Understanding the Inclusion Fee\n\nThe formula for calculating the inclusion fee is as follows:\n\n```text\ninclusion_fee = base_fee + length_fee + [targeted_fee_adjustment * weight_fee]\n```\n\nAnd then, for calculating the final fee:\n\n```text\nfinal_fee = inclusion_fee + tip\n```\n\nIn the first formula, the `targeted_fee_adjustment` is a multiplier that can tune the final fee based on the network’s congestion.\n\n- The `base_fee` derived from the base weight covers inclusion overhead like signature verification.\n- The `length_fee` is a per-byte fee that is multiplied by the length of the encoded extrinsic.\n- The `weight_fee` fee is calculated using two parameters:\n  - The `ExtrinsicBaseWeight` that is declared in the runtime and applies to all extrinsics.\n  - The `#[pallet::weight]` annotation that accounts for an extrinsic's complexity.\n\nTo convert the weight to `Currency`, the runtime must define a `WeightToFee` struct that implements a conversion function, [`Convert<Weight,Balance>`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/struct.Pallet.html#method.weight_to_fee){target=\\_blank}.\n\nNote that the extrinsic sender is charged the inclusion fee before the extrinsic is invoked. The fee is deducted from the sender's balance even if the transaction fails upon execution.\n\n### Accounts with an Insufficient Balance\n\nIf an account does not have a sufficient balance to pay the inclusion fee and remain alive—that is, enough to pay the inclusion fee and maintain the minimum existential deposit—then you should ensure the transaction is canceled so that no fee is deducted and the transaction does not begin execution.\n\nThe Polkadot SDK doesn't enforce this rollback behavior. However, this scenario would be rare because the transaction queue and block-making logic perform checks to prevent it before adding an extrinsic to a block.\n\n### Fee Multipliers\n\nThe inclusion fee formula always results in the same fee for the same input. However, weight can be dynamic and—based on how [`WeightToFee`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/trait.Config.html#associatedtype.WeightToFee){target=\\_blank} is defined—the final fee can include some degree of variability.\nThe Transaction Payment pallet provides the [`FeeMultiplierUpdate`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/pallet/trait.Config.html#associatedtype.FeeMultiplierUpdate){target=\\_blank} configurable parameter to account for this variability.\n\nThe Polkadot network inspires the default update function and implements a targeted adjustment in which a target saturation level of block weight is defined. If the previous block is more saturated, the fees increase slightly. Similarly, if the last block has fewer transactions than the target, fees are decreased by a small amount. For more information about fee multiplier adjustments, see the [Web3 Research Page](https://research.web3.foundation/Polkadot/overview/token-economics#relay-chain-transaction-fees-and-per-block-transaction-limits){target=\\_blank}.\n\n## Transactions with Special Requirements\n\nInclusion fees must be computable before execution and can only represent fixed logic. Some transactions warrant limiting resources with other strategies. For example:\n\n- Bonds are a type of fee that might be returned or slashed after some on-chain event. For example, you might want to require users to place a bond to participate in a vote. The bond might then be returned at the end of the referendum or slashed if the voter attempted malicious behavior.\n- Deposits are fees that might be returned later. For example, you might require users to pay a deposit to execute an operation that uses storage. The user’s deposit could be returned if a subsequent operation frees up storage.\n- Burn operations are used to pay for a transaction based on its internal logic. For example, a transaction might burn funds from the sender if the transaction creates new storage items to pay for the increased state size.\n- Limits enable you to enforce constant or configurable limits on specific operations. For example, the default [Staking pallet](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/substrate/frame/staking){target=\\_blank} only allows nominators to nominate 16 validators to limit the complexity of the validator election process.\n\nIt is important to note that if you query the chain for a transaction fee, it only returns the inclusion fee.\n\n## Default Weight Annotations\n\nAll dispatchable functions in the Polkadot SDK must specify a weight. The way of doing that is using the annotation-based system that lets you combine fixed values for database read/write weight and/or fixed values based on benchmarks. The most basic example would look like this:\n\n```rust\n-#[pallet::weight(100_000)]\nfn my_dispatchable() {\n    // ...\n}\n```\n\nNote that the [`ExtrinsicBaseWeight`](https://crates.parity.io/frame_support/weights/constants/struct.ExtrinsicBaseWeight.html){target=\\_blank} is automatically added to the declared weight to account for the costs of simply including an empty extrinsic into a block.\n\n### Weights and Database Read/Write Operations\n\nTo make weight annotations independent of the deployed database backend, they are defined as a constant and then used in the annotations when expressing database accesses performed by the dispatchable:\n\n```rust\n-#[pallet::weight(T::DbWeight::get().reads_writes(1, 2) + 20_000)]\nfn my_dispatchable() {\n    // ...\n}\n```\n\nThis dispatchable allows one database to read and two to write, in addition to other things that add the additional 20,000. Database access is generally every time a value declared inside the [`#[pallet::storage]`](https://paritytech.github.io/polkadot-sdk/master/frame_support/pallet_macros/attr.storage.html){target=\\_blank} block is accessed. However, unique accesses are counted because after a value is accessed, it is cached, and reaccessing it does not result in a database operation. That is:\n\n- Multiple reads of the exact value count as one read.\n- Multiple writes of the exact value count as one write.\n- Multiple reads of the same value, followed by a write to that value, count as one read and one write.\n- A write followed by a read-only counts as one write.\n\n### Dispatch Classes\n\nDispatches are broken into three classes:\n\n- Normal\n- Operational\n- Mandatory\n\nIf a dispatch is not defined as `Operational` or `Mandatory` in the weight annotation, the dispatch is identified as `Normal` by default. You can specify that the dispatchable uses another class like this:\n\n```rust\n-#[pallet::dispatch((DispatchClass::Operational))]\nfn my_dispatchable() {\n    // ...\n}\n```\n\nThis tuple notation also allows you to specify a final argument determining whether the user is charged based on the annotated weight. If you don't specify otherwise, `Pays::Yes` is assumed:\n\n```rust\n-#[pallet::dispatch(DispatchClass::Normal, Pays::No)]\nfn my_dispatchable() {\n    // ...\n}\n```\n\n#### Normal Dispatches\n\nDispatches in this class represent normal user-triggered transactions. These types of dispatches only consume a portion of a block's total weight limit. For information about the maximum portion of a block that can be consumed for normal dispatches, see [`AvailableBlockRatio`](https://paritytech.github.io/polkadot-sdk/master/frame_system/limits/struct.BlockLength.html){target=\\_blank}. Normal dispatches are sent to the transaction pool.\n\n#### Operational Dispatches\n\nUnlike normal dispatches, which represent the usage of network capabilities, operational dispatches are those that provide network capabilities. Operational dispatches can consume the entire weight limit of a block. They are not bound by the [`AvailableBlockRatio`](https://paritytech.github.io/polkadot-sdk/master/frame_system/limits/struct.BlockLength.html){target=\\_blank}. Dispatches in this class are given maximum priority and are exempt from paying the [`length_fee`](https://docs.rs/pallet-transaction-payment/latest/pallet_transaction_payment/){target=\\_blank}.\n\n#### Mandatory Dispatches\n\nMandatory dispatches are included in a block even if they cause the block to surpass its weight limit. You can only use the mandatory dispatch class for inherent transactions that the block author submits. This dispatch class is intended to represent functions in the block validation process. Because these dispatches are always included in a block regardless of the function weight, the validation process must prevent malicious nodes from abusing the function to craft valid but impossibly heavy blocks. You can typically accomplish this by ensuring that:\n\n- The operation performed is always light.\n- The operation can only be included in a block once.\n\nTo make it more difficult for malicious nodes to abuse mandatory dispatches, they cannot be included in blocks that return errors. This dispatch class serves the assumption that it is better to allow an overweight block to be created than not to allow any block to be created at all.\n\n### Dynamic Weights\n\nIn addition to purely fixed weights and constants, the weight calculation can consider the input arguments of a dispatchable. The weight should be trivially computable from the input arguments with some basic arithmetic:\n\n```rust\n-use frame_support:: {\n    dispatch:: {\n        DispatchClass::Normal,\n        Pays::Yes,\n    },\n   weights::Weight,\n};\n\n#[pallet::weight(FunctionOf(\n  |args: (&Vec<User>,)| args.0.len().saturating_mul(10_000),\n  )\n]\nfn handle_users(origin, calls: Vec<User>) {\n    // Do something per user\n}\n```\n\n## Post Dispatch Weight Correction\n\nDepending on the execution logic, a dispatchable function might consume less weight than was prescribed pre-dispatch. To correct weight, the function declares a different return type and returns its actual weight:\n\n```rust\n-#[pallet::weight(10_000 + 500_000_000)]\nfn expensive_or_cheap(input: u64) -> DispatchResultWithPostInfo {\n    let was_heavy = do_calculation(input);\n\n    if (was_heavy) {\n        // None means \"no correction\" from the weight annotation.\n        Ok(None.into())\n    } else {\n        // Return the actual weight consumed.\n        Ok(Some(10_000).into())\n    }\n}\n```\n\n## Custom Fees\n\nYou can also define custom fee systems through custom weight functions or inclusion fee functions.\n\n### Custom Weights\n\nInstead of using the default weight annotations, you can create a custom weight calculation type using the weights module. The custom weight calculation type must implement the following traits:\n\n- [`WeighData<T>`](https://crates.parity.io/frame_support/weights/trait.WeighData.html){target=\\_blank} to determine the weight of the dispatch.\n- [`ClassifyDispatch<T>`](https://crates.parity.io/frame_support/weights/trait.ClassifyDispatch.html){target=\\_blank} to determine the class of the dispatch.\n- [`PaysFee<T>`](https://crates.parity.io/frame_support/weights/trait.PaysFee.html){target=\\_blank} to determine whether the sender of the dispatch pays fees.\n \nThe Polkadot SDK then bundles the output information of the three traits into the [`DispatchInfo`](https://paritytech.github.io/polkadot-sdk/master/frame_support/dispatch/struct.DispatchInfo.html){target=\\_blank} struct and provides it by implementing the [`GetDispatchInfo`](https://docs.rs/frame-support/latest/frame_support/dispatch/trait.GetDispatchInfo.html){target=\\_blank} for all `Call` variants and opaque extrinsic types. This is used internally by the System and Executive modules.\n\n`ClassifyDispatch`, `WeighData`, and `PaysFee` are generic over T, which gets resolved into the tuple of all dispatch arguments except for the origin. The following example illustrates a struct that calculates the weight as `m * len(args)`, where `m` is a given multiplier and args is the concatenated tuple of all dispatch arguments. In this example, the dispatch class is `Operational` if the transaction has more than 100 bytes of length in arguments and will pay fees if the encoded length exceeds 10 bytes.\n\n```rust\n-struct LenWeight(u32);\nimpl<T> WeighData<T> for LenWeight {\n    fn weigh_data(&self, target: T) -> Weight {\n        let multiplier = self.0;\n        let encoded_len = target.encode().len() as u32;\n        multiplier * encoded_len\n    }\n}\n\nimpl<T> ClassifyDispatch<T> for LenWeight {\n    fn classify_dispatch(&self, target: T) -> DispatchClass {\n        let encoded_len = target.encode().len() as u32;\n        if encoded_len > 100 {\n            DispatchClass::Operational\n        } else {\n            DispatchClass::Normal\n        }\n    }\n}\n\nimpl<T> PaysFee<T> {\n    fn pays_fee(&self, target: T) -> Pays {\n        let encoded_len = target.encode().len() as u32;\n        if encoded_len > 10 {\n            Pays::Yes\n        } else {\n            Pays::No\n        }\n    }\n}\n```\n\nA weight calculator function can also be coerced to the final type of the argument instead of defining it as a vague type that can be encoded. The code would roughly look like this:\n\n```rust\n-struct CustomWeight;\nimpl WeighData<(&u32, &u64)> for CustomWeight {\n    fn weigh_data(&self, target: (&u32, &u64)) -> Weight {\n        ...\n    }\n}\n\n// given a dispatch:\n#[pallet::call]\nimpl<T: Config<I>, I: 'static> Pallet<T, I> {\n    #[pallet::weight(CustomWeight)]\n    fn foo(a: u32, b: u64) { ... }\n}\n```\n\nIn this example, the `CustomWeight` can only be used in conjunction with a dispatch with a particular signature `(u32, u64)`, as opposed to `LenWeight`, which can be used with anything because there aren't any assumptions about `<T>`.\n\n#### Custom Inclusion Fee\n\nThe following example illustrates how to customize your inclusion fee. You must configure the appropriate associated types in the respective module.\n\n```rust\n-// Assume this is the balance type\ntype Balance = u64;\n\n// Assume we want all the weights to have a `100 + 2 * w` conversion to fees\nstruct CustomWeightToFee;\nimpl WeightToFee<Weight, Balance> for CustomWeightToFee {\n    fn convert(w: Weight) -> Balance {\n        let a = Balance::from(100);\n        let b = Balance::from(2);\n        let w = Balance::from(w);\n        a + b * w\n    }\n}\n\nparameter_types! {\n    pub const ExtrinsicBaseWeight: Weight = 10_000_000;\n}\n\nimpl frame_system::Config for Runtime {\n    type ExtrinsicBaseWeight = ExtrinsicBaseWeight;\n}\n\nparameter_types! {\n    pub const TransactionByteFee: Balance = 10;\n}\n\nimpl transaction_payment::Config {\n    type TransactionByteFee = TransactionByteFee;\n    type WeightToFee = CustomWeightToFee;\n    type FeeMultiplierUpdate = TargetedFeeAdjustment<TargetBlockFullness>;\n}\n\nstruct TargetedFeeAdjustment<T>(sp_std::marker::PhantomData<T>);\nimpl<T: Get<Perquintill>> WeightToFee<Fixed128, Fixed128> for TargetedFeeAdjustment<T> {\n    fn convert(multiplier: Fixed128) -> Fixed128 {\n        // Don't change anything. Put any fee update info here.\n        multiplier\n    }\n}\n```\n\n## Additional Resources\n\nYou now know the weight system, how it affects transaction fee computation, and how to specify weights for your dispatchable calls. The next step is determining the correct weight for your dispatchable operations. You can use Substrate benchmarking functions and frame-benchmarking calls to test your functions with different parameters and empirically determine the proper weight in their worst-case scenarios.\n\n- [Benchmark](/develop/parachains/testing/benchmarking/)\n- [`SignedExtension`](https://paritytech.github.io/polkadot-sdk/master/sp_runtime/traits/trait.SignedExtension.html){target=\\_blank}\n- [Custom weights for the Example pallet](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506/substrate/frame/examples/basic/src/weights.rs){target=\\_blank}\n- [Web3 Foundation Research](https://research.web3.foundation/Polkadot/overview/token-economics#relay-chain-transaction-fees-and-per-block-transaction-limits){target=\\_blank}\n"}
{"title": "XCM Channels", "slug": "develop-interoperability-xcm-channels", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-interoperability-xcm-channels.md", "html_url": "https://docs.polkadot.com/develop/interoperability/xcm-channels/", "categories": ["Basics", "Polkadot Protocol"], "description": "Learn how Polkadot's cross-consensus messaging (XCM) channels connect parachains, facilitating communication and blockchain interaction.", "estimated_token_count": 1376, "token_estimator": "heuristic-v1", "content": "# XCM Channels\n\n## Introduction\n\nPolkadot is designed to enable interoperability between its connected parachains. At the core of this interoperability is the [Cross-Consensus Message Format (XCM)](/develop/interoperability/intro-to-xcm/){target=\\_blank}, a standard language that allows parachains to communicate and interact with each other.\n\nThe network-layer protocol responsible for delivering XCM-formatted messages between parachains is the [Cross-Chain Message Passing (XCMP)](https://wiki.polkadot.com/learn/learn-xcm-transport/#xcmp-cross-chain-message-passing){target=\\_blank} protocol. XCMP maintains messaging queues on the relay chain, serving as a bridge to facilitate cross-chain interactions.\n\nAs XCMP is still under development, Polkadot has implemented a temporary alternative called [Horizontal Relay-routed Message Passing (HRMP)](https://wiki.polkadot.com/learn/learn-xcm-transport/#hrmp-xcmp-lite){target=\\_blank}. HRMP offers the same interface and functionality as the planned XCMP but it has a crucial difference, it stores all messages directly in the relay chain's storage, which is more resource-intensive.\n\nOnce XCMP is fully implemented, HRMP will be deprecated in favor of the native XCMP protocol. XCMP will offer a more efficient and scalable solution for cross-chain message passing, as it will not require the relay chain to store all the messages.\n\n## Establishing HRMP Channels\n\nTo enable communication between parachains using the HRMP protocol, the parachains must explicitly establish communication channels by registering them on the relay chain.\n\nDownward and upward channels from and to the relay chain are implicitly available, meaning they do not need to be explicitly opened.\n\nOpening an HRMP channel requires the parachains involved to make a deposit on the relay chain. This deposit serves a specific purpose, it covers the costs associated with using the relay chain's storage for the message queues linked to the channel. The amount of this deposit varies based on parameters defined by the specific relay chain being used.\n\n### Relay Chain Parameters\n\nEach Polkadot relay chain has a set of configurable parameters that control the behavior of the message channels between parachains. These parameters include [`hrmpSenderDeposit`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_sender_deposit){target=\\_blank}, [`hrmpRecipientDeposit`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_recipient_deposit){target=\\_blank}, [`hrmpChannelMaxMessageSize`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_channel_max_message_size){target=\\_blank}, [`hrmpChannelMaxCapacity`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_channel_max_capacity){target=\\_blank}, and more.\n\nWhen a parachain wants to open a new channel, it must consider these parameter values to ensure the channel is configured correctly.\n\nTo view the current values of these parameters in the Polkadot network:\n\n1. Visit [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fpolkadot.api.onfinality.io%2Fpublic-ws#/explorer), navigate to the **Developer** dropdown and select the **Chain state** option.\n\n    ![](/images/develop/interoperability/xcm-channels/xcm-channels-1.webp)\n\n2. Query the chain configuration parameters. The result will display the current settings for all the Polkadot network parameters, including the HRMP channel settings.\n\n    1. Select **`configuration`**.\n    2. Choose the **`activeConfig()`** call.\n    3. Click the **+** button to execute the query.\n    4. Check the chain configuration.\n\n        ![](/images/develop/interoperability/xcm-channels/xcm-channels-2.webp)\n\n### Dispatching Extrinsics\n\nEstablishing new HRMP channels between parachains requires dispatching specific extrinsic calls on the Polkadot Relay Chain from the parachain's origin.\n\nThe most straightforward approach is to implement the channel opening logic off-chain, then use the XCM pallet's [`send`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/dispatchables/fn.send.html){target=\\_blank} extrinsic to submit the necessary instructions to the relay chain. However, the ability to send arbitrary programs through the [`Transact`](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#transact){target=\\_blank} instruction in XCM is typically restricted to privileged origins, such as the [`sudo`](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/pallet/dispatchables/fn.sudo.html){target=\\_blank} pallet or governance mechanisms.\n\nParachain developers have a few options for triggering the required extrinsic calls from their parachain's origin, depending on the configuration and access controls defined:\n\n- **Sudo**: If the parachain has a `sudo` pallet configured, the sudo key holder can use the sudo extrinsic to dispatch the necessary channel opening calls.\n- **Governance**: The parachain's governance system, such as a council or OpenGov, can be used to authorize the channel opening calls.\n- **Privileged accounts**: The parachain may have other designated privileged accounts that are allowed to dispatch the HRMP channel opening extrinsics.\n\n## Where to Go Next\n\nExplore the following tutorials for detailed, step-by-step guidance on setting up cross-chain communication channels in Polkadot:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Opening HRMP Channels Between Parachains__\n\n    ---\n\n    Learn how to open HRMP channels between parachains on Polkadot. Discover the step-by-step process for establishing uni- and bidirectional communication.\n\n    [:octicons-arrow-right-24: Reference](/tutorials/interoperability/xcm-channels/para-to-para/)\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Opening HRMP Channels with System Parachains__\n\n    ---\n\n    Learn how to open HRMP channels with Polkadot system parachains. Discover the process for establishing bi-directional communication using a single XCM message.\n\n    [:octicons-arrow-right-24: Reference](/tutorials/interoperability/xcm-channels/para-to-system/)\n\n</div>\n"}
{"title": "XCM Config", "slug": "develop-interoperability-xcm-config", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-interoperability-xcm-config.md", "html_url": "https://docs.polkadot.com/develop/interoperability/xcm-config/", "categories": ["Reference", "Polkadot Protocol"], "description": "Learn how the XCM Executor configuration works for your custom Polkadot SDK-based runtime with detailed guidance and references.", "estimated_token_count": 4982, "token_estimator": "heuristic-v1", "content": "# XCM Config\n\n## Introduction\n\nThe [XCM executor](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/index.html){target=\\_blank} is a crucial component responsible for interpreting and executing XCM messages (XCMs) with Polkadot SDK-based chains. It processes and manages XCM instructions, ensuring they are executed correctly and in sequentially. Adhering to the [Cross-Consensus Virtual Machine (XCVM) specification](https://paritytech.github.io/xcm-docs/overview/xcvm.html#the-xcvm){target=\\_blank}, the XCM executor can be customized or replaced with an alternative that also complies with the [XCVM standards](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#12-the-xcvm){target=\\_blank}.\n\nThe `XcmExecutor` is not a pallet but a struct parameterized by a `Config` trait. The `Config` trait is the inner configuration, parameterizing the outer `XcmExecutor<Config>` struct. Both configurations are set up within the runtime.\n\nThe executor is highly configurable, with the [XCM builder](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/index.html){target=\\_blank} offering building blocks to tailor the configuration to specific needs. While they serve as a foundation, users can easily create custom blocks to suit unique configurations. Users can also create their building blocks to address unique needs. This article examines the XCM configuration process, explains each configurable item, and provides examples of the tools and types available to help customize these settings.\n\n## XCM Executor Configuration\n\nThe `Config` trait defines the XCM executor’s configuration, which requires several associated types. Each type has specific trait bounds that the concrete implementation must fulfill. Some types, such as `RuntimeCall`, come with a default implementation in most cases, while others use the unit type `()` as the default. For many of these types, selecting the appropriate implementation carefully is crucial. Predefined solutions and building blocks can be adapted to your specific needs. These solutions can be found in the [`xcm-builder`](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506/polkadot/xcm/xcm-builder){target=\\_blank} folder.\n\nEach type is explained below, along with an overview of some of its implementations:\n\n```rust\n-pub trait Config {\n    type RuntimeCall: Parameter + Dispatchable<PostInfo = PostDispatchInfo> + GetDispatchInfo;\n    type XcmSender: SendXcm;\n    type AssetTransactor: TransactAsset;\n    type OriginConverter: ConvertOrigin<<Self::RuntimeCall as Dispatchable>::RuntimeOrigin>;\n    type IsReserve: ContainsPair<MultiAsset, MultiLocation>;\n    type IsTeleporter: ContainsPair<MultiAsset, MultiLocation>;\n    type Aliasers: ContainsPair<Location, Location>;\n    type UniversalLocation: Get<InteriorMultiLocation>;\n    type Barrier: ShouldExecute;\n    type Weigher: WeightBounds<Self::RuntimeCall>;\n    type Trader: WeightTrader;\n    type ResponseHandler: OnResponse;\n    type AssetTrap: DropAssets;\n    type AssetClaims: ClaimAssets;\n    type AssetLocker: AssetLock;\n    type AssetExchanger: AssetExchange;\n    type SubscriptionService: VersionChangeNotifier;\n    type PalletInstancesInfo: PalletsInfoAccess;\n    type MaxAssetsIntoHolding: Get<u32>;\n    type FeeManager: FeeManager;\n    type MessageExporter: ExportXcm;\n    type UniversalAliases: Contains<(MultiLocation, Junction)>;\n    type CallDispatcher: CallDispatcher<Self::RuntimeCall>;\n    type SafeCallFilter: Contains<Self::RuntimeCall>;\n    type TransactionalProcessor: ProcessTransaction;\n    type HrmpNewChannelOpenRequestHandler: HandleHrmpNewChannelOpenRequest;\n    type HrmpChannelAcceptedHandler: HandleHrmpChannelAccepted;\n    type HrmpChannelClosingHandler: HandleHrmpChannelClosing;\n    type XcmRecorder: RecordXcm;\n}\n```\n\n## Config Items\n\nEach configuration item is explained below, detailing the associated type’s purpose and role in the XCM executor. Many of these types have predefined solutions available in the `xcm-builder`. Therefore, the available configuration items are:\n\n- **[`RuntimeCall`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.RuntimeCall){target=\\_blank}**: Defines the runtime's callable functions, created via the [`frame::runtime`](https://paritytech.github.io/polkadot-sdk/master/frame_support/attr.runtime.html){target=\\_blank} macro. It represents an enum listing the callable functions of all implemented pallets.\n\n    ```rust\n    type RuntimeCall: Parameter + Dispatchable<PostInfo = PostDispatchInfo> + GetDispatchInfo\n    ```\n   The associated traits signify:\n\n    - **`Parameter`**: Ensures the type is encodable, decodable, and usable as a parameter.\n    - **`Dispatchable`**: Indicates it can be executed in the runtime.\n    - **`GetDispatchInfo`**: Provides weight details, determining how long execution takes.\n\n- **[`XcmSender`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.XcmSender){target=\\_blank}**: Implements the [`SendXcm`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v4/trait.SendXcm.html){target=\\_blank} trait, specifying how the executor sends XCMs using transport layers (e.g., UMP for relay chains or XCMP for sibling chains). If a runtime lacks certain transport layers, such as [HRMP](https://wiki.polkadot.com/learn/learn-xcm-transport/#hrmp-xcmp-lite){target=\\_blank} (or [XCMP](https://wiki.polkadot.com/learn/learn-xcm-transport/#xcmp-cross-consensus-message-passing-design-summary){target=\\_blank}).\n\n    ```rust\n    type XcmSender: SendXcm;\n    ```\n\n- **[`AssetTransactor`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetTransactor){target=\\_blank}**: Implements the [`TransactAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.TransactAsset.html){target=\\_blank} trait, handling the conversion and transfer of MultiAssets between accounts or registers. It can be configured to support native tokens, fungibles, and non-fungibles or multiple tokens using pre-defined adapters like [`FungibleAdapter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.FungibleAdapter.html){target=\\_blank} or custom solutions.\n\n    ```rust\n    type AssetTransactor: TransactAsset;\n    ```\n\n- **[`OriginConverter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.OriginConverter){target=\\_blank}**: Implements the [`ConvertOrigin`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ConvertOrigin.html){target=\\_blank} trait to map `MultiLocation` origins to `RuntimeOrigin`. Multiple implementations can be combined, and [`OriginKind`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/test_utils/enum.OriginKind.html){target=\\_blank} is used to resolve conflicts. Pre-defined converters like [`SovereignSignedViaLocation`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.SovereignSignedViaLocation.html){target=\\_blank} and [`SignedAccountId32AsNative`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.SignedAccountId32AsNative.html){target=\\_blank} handle sovereign and local accounts respectively.\n\n    ```rust\n    type OriginConverter: ConvertOrigin<<Self::RuntimeCall as Dispatchable>::RuntimeOrigin>;\n    ```\n\n- **[`IsReserve`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.IsReserve){target=\\_blank}**: Specifies trusted `<MultiAsset, MultiLocation>` pairs for depositing reserve assets. Using the unit type `()` blocks reserve deposits. The [`NativeAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.NativeAsset.html){target=\\_blank} struct is an example of a reserve implementation.\n\n    ```rust\n    type IsReserve: ContainsPair<MultiAsset, MultiLocation>;\n    ```\n\n- **[`IsTeleporter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.IsTeleporter){target=\\_blank}**: Defines trusted `<MultiAsset, MultiLocation>` pairs for teleporting assets to the chain. Using `()` blocks the [`ReceiveTeleportedAssets`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/test_utils/enum.Instruction.html#variant.ReceiveTeleportedAsset){target=\\_blank} instruction. The [`NativeAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.NativeAsset.html){target=\\_blank} struct can act as an implementation.\n\n    ```rust\n    type IsTeleporter: ContainsPair<MultiAsset, MultiLocation>;\n    ```\n\n- **[`Aliasers`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Aliasers){target=\\_blank}**: A list of `(Origin, Target)` pairs enabling each `Origin` to be replaced with its corresponding `Target`.\n\n    ```rust\n    type Aliasers: ContainsPair<Location, Location>;\n    ```\n\n- **[`UniversalLocation`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.UniversalLocation){target=\\_blank}**: Specifies the runtime's location in the consensus universe.\n\n    ```rust\n    type UniversalLocation: Get<InteriorMultiLocation>;\n    ```\n\n    - Some examples are:\n        - `X1(GlobalConsensus(NetworkId::Polkadot))` for Polkadot\n        - `X1(GlobalConsensus(NetworkId::Kusama))` for Kusama\n        - `X2(GlobalConsensus(NetworkId::Polkadot), Parachain(1000))` for Statemint\n\n- **[`Barrier`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Barrier){target=\\_blank}**: Implements the [`ShouldExecute`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ShouldExecute.html){target=\\_blank} trait, functioning as a firewall for XCM execution. Multiple barriers can be combined in a tuple, where execution halts if one succeeds.\n\n    ```rust\n    type Barrier: ShouldExecute;\n    ```\n\n- **[`Weigher`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Weigher){target=\\_blank}**: Calculates the weight of XCMs and instructions, enforcing limits and refunding unused weight. Common solutions include [`FixedWeightBounds`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.FixedWeightBounds.html){target=\\_blank}, which uses a base weight and limits on instructions.\n\n    ```rust\n    type Weigher: WeightBounds<Self::RuntimeCall>;\n    ```\n\n- **[`Trader`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Trader){target=\\_blank}**: Manages asset-based weight purchases and refunds for `BuyExecution` instructions. The [`UsingComponents`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.UsingComponents.html){target=\\_blank} trader is a common implementation.\n\n    ```rust\n    type Trader: WeightTrader;\n    ```\n\n- **[`ResponseHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.ResponseHandler){target=\\_blank}**: Handles `QueryResponse` instructions, implementing the [`OnResponse`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.OnResponse.html){target=\\_blank} trait. FRAME systems typically use the pallet-xcm implementation.\n\n    ```rust\n    type ResponseHandler: OnResponse;\n    ```\n\n- **[`AssetTrap`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetTrap){target=\\_blank}**: Handles leftover assets in the holding register after XCM execution, allowing them to be claimed via `ClaimAsset`. If unsupported, assets are burned.\n\n    ```rust\n    type AssetTrap: DropAssets;\n    ```\n\n- **[`AssetClaims`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetClaims){target=\\_blank}**: Facilitates the claiming of trapped assets during the execution of the `ClaimAsset` instruction. Commonly implemented via pallet-xcm.\n\n    ```rust\n    type AssetClaims: ClaimAssets;\n    ```\n\n- **[`AssetLocker`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetLocker){target=\\_blank}**: Handles the locking and unlocking of assets. Can be omitted using `()` if asset locking is unnecessary.\n\n    ```rust\n    type AssetLocker: AssetLock;\n    ```\n\n- **[`AssetExchanger`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetExchanger){target=\\_blank}**: Implements the [`AssetExchange`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.AssetExchange.html){target=\\_blank} trait to manage asset exchanges during the `ExchangeAsset` instruction. The unit type `()` disables this functionality.\n\n    ```rust\n    type AssetExchanger: AssetExchange;\n    ```\n\n- **[`SubscriptionService`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.SubscriptionService){target=\\_blank}**: Manages `(Un)SubscribeVersion` instructions and returns the XCM version via `QueryResponse`. Typically implemented by pallet-xcm.\n\n    ```rust\n    type SubscriptionService: VersionChangeNotifier;\n    ```\n\n- **[`PalletInstancesInfo`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.PalletInstancesInfo){target=\\_blank}**: Provides runtime pallet information for `QueryPallet` and `ExpectPallet` instructions. FRAME-specific systems often use this, or it can be disabled with `()`.\n\n    ```rust\n    type PalletInstancesInfo: PalletsInfoAccess;\n    ```\n\n \n- [**`MaxAssetsIntoHolding`**](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.MaxAssetsIntoHolding){target=\\_blank}: Limits the number of assets in the [Holding register](https://wiki.polkadot.com/learn/learn-xcm/#holding-register){target=\\_blank}. At most, twice this limit can be held under worst-case conditions.\n    ```rust\n    type MaxAssetsIntoHolding: Get<u32>;\n    ```\n\n- **[`FeeManager`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.FeeManager){target=\\_blank}**: Manages fees for XCM instructions, determining whether fees should be paid, waived, or handled in specific ways. Fees can be waived entirely using `()`.\n\n    ```rust\n    type FeeManager: FeeManager;\n    ```\n\n- **[`MessageExporter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.MessageExporter){target=\\_blank}**: Implements the [`ExportXcm`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ExportXcm.html){target=\\_blank} trait, enabling XCMs export to other consensus systems. It can spoof origins for use in bridges. Use `()` to disable exporting.\n\n    ```rust\n    type MessageExporter: ExportXcm;\n    ```\n\n- **[`UniversalAliases`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.UniversalAliases){target=\\_blank}**: Lists origin locations and universal junctions allowed to elevate themselves in the `UniversalOrigin` instruction. Using `Nothing` prevents origin aliasing.\n\n    ```rust\n    type UniversalAliases: Contains<(MultiLocation, Junction)>;\n    ```\n\n- **[`CallDispatcher`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.CallDispatcher){target=\\_blank}**: Dispatches calls from the `Transact` instruction, adapting the origin or modifying the call as needed. Can default to `RuntimeCall`.\n\n    ```rust\n    type CallDispatcher: CallDispatcher<Self::RuntimeCall>;\n    ```\n\n- **[`SafeCallFilter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.SafeCallFilter){target=\\_blank}**: Whitelists calls permitted in the `Transact` instruction. Using `Everything` allows all calls, though this is temporary until proof size weights are accounted for.\n\n    ```rust\n    type SafeCallFilter: Contains<Self::RuntimeCall>;\n    ```\n\n- **[`TransactionalProcessor`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.TransactionalProcessor){target=\\_blank}**: Implements the [`ProccessTransaction`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ProcessTransaction.html){target=\\_blank} trait. It ensures that XCM instructions are executed atomically, meaning they either fully succeed or fully fail without any partial effects. This type allows for non-transactional XCM instruction processing by setting the `()` type.\n\n    ```rust\n    type TransactionalProcessor: ProcessTransaction;\n    ```\n\n- **[`HrmpNewChannelOpenRequestHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.HrmpNewChannelOpenRequestHandler){target=\\_blank}**: Enables optional logic execution in response to the `HrmpNewChannelOpenRequest` XCM notification.\n\n    ```rust\n    type HrmpNewChannelOpenRequestHandler: HandleHrmpNewChannelOpenRequest;\n    ```\n\n- **[`HrmpChannelAcceptedHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.HrmpChannelAcceptedHandler){target=\\_blank}**: Enables optional logic execution in response to the `HrmpChannelAccepted` XCM notification.\n\n    ```rust\n    type HrmpChannelAcceptedHandler: HandleHrmpChannelAccepted;\n    ```\n\n- **[`HrmpChannelClosingHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.HrmpChannelClosingHandler){target=\\_blank}**: Enables optional logic execution in response to the `HrmpChannelClosing` XCM notification.\n\n    ```rust\n    type HrmpChannelClosingHandler: HandleHrmpChannelClosing;\n    ```\n\n- **[`XcmRecorder`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.XcmRecorder){target=\\_blank}**: Allows tracking of the most recently executed XCM, primarily for use with dry-run runtime APIs.\n\n    ```rust\n    type XcmRecorder: RecordXcm;\n    ```\n\n### Inner Config\n\nThe `Config` trait underpins the `XcmExecutor`, defining its core behavior through associated types for asset handling, XCM processing, and permission management. These types are categorized as follows:\n\n- **Handlers**: Manage XCMs sending, asset transactions, and special notifications.\n- **Filters**: Define trusted combinations, origin substitutions, and execution barriers.\n- **Converters**: Handle origin conversion for call execution.\n- **Accessors**: Provide weight determination and pallet information.\n- **Constants**: Specify universal locations and asset limits.\n- **Common Configs**: Include shared settings like `RuntimeCall`.\n\nThe following diagram outlines this categorization:\n\n```mermaid\nflowchart LR\n    A[Inner Config] --> B[Handlers]\n    A --> C[Filters]\n    A --> D[Converters]\n    A --> E[Accessors]\n    A --> F[Constants]\n    A --> G[Common Configs]\n\n    B --> H[XcmSender]\n    B --> I[AssetTransactor]\n    B --> J[Trader]\n    B --> K[ResponseHandler]\n    B --> L[AssetTrap]\n    B --> M[AssetLocker]\n    B --> N[AssetExchanger]\n    B --> O[AssetClaims]\n    B --> P[SubscriptionService]\n    B --> Q[FeeManager]\n    B --> R[MessageExporter]\n    B --> S[CallDispatcher]\n    B --> T[HrmpNewChannelOpenRequestHandler]\n    B --> U[HrmpChannelAcceptedHandler]\n    B --> V[HrmpChannelClosingHandler]\n\n    C --> W[IsReserve]\n    C --> X[IsTeleporter]\n    C --> Y[Aliasers]\n    C --> Z[Barrier]\n    C --> AA[UniversalAliases]\n    C --> AB[SafeCallFilter]\n\n    D --> AC[OriginConverter]\n\n    E --> AD[Weigher]\n    E --> AE[PalletInstancesInfo]\n\n    F --> AF[UniversalLocation]\n    F --> AG[MaxAssetsIntoHolding]\n\n    G --> AH[RuntimeCall]\n```\n\n### Outer Config\n\nThe `XcmExecutor<Config>` struct extends the functionality of the inner config by introducing fields for execution context, asset handling, error tracking, and operational management. For further details, see the documentation for [`XcmExecutor<Config>`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/struct.XcmExecutor.html#impl-XcmExecutor%3CConfig%3E){target=\\_blank}.\n\n## Multiple Implementations\n\nSome associated types in the `Config` trait are highly configurable and may have multiple implementations (e.g., Barrier). These implementations are organized into a tuple `(impl_1, impl_2, ..., impl_n)`, and the execution follows a sequential order. Each item in the tuple is evaluated individually, each being checked to see if it fails. If an item passes (e.g., returns `Ok` or `true`), the execution stops, and the remaining items are not evaluated. The following example of the `Barrier` type demonstrates how this grouping operates (understanding each item in the tuple is unnecessary for this explanation).\n\nIn the following example, the system will first check the `TakeWeightCredit` type when evaluating the barrier. If it fails, it will check `AllowTopLevelPaidExecutionFrom`, and so on, until one of them returns a positive result. If all checks fail, a Barrier error will be triggered.\n\n```rust\n-pub type Barrier = (\n    TakeWeightCredit,\n    AllowTopLevelPaidExecutionFrom<Everything>,\n    AllowKnownQueryResponses<XcmPallet>,\n    AllowSubscriptionsFrom<Everything>,\n);\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n    ...\n    type Barrier = Barrier;\n    ...\n}\n```\n"}
{"title": "XCM Runtime APIs", "slug": "develop-interoperability-xcm-runtime-apis", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-interoperability-xcm-runtime-apis.md", "html_url": "https://docs.polkadot.com/develop/interoperability/xcm-runtime-apis/", "categories": ["Reference", "Polkadot Protocol"], "description": "Learn about XCM Runtime APIs in Polkadot for cross-chain communication. Explore the APIs to simulate and test XCM messages before execution on the network.", "estimated_token_count": 8559, "token_estimator": "heuristic-v1", "content": "# XCM Runtime APIs\n\n## Introduction\n\nRuntime APIs allow node-side code to extract information from the runtime state. While simple storage access retrieves stored values directly, runtime APIs enable arbitrary computation, making them a powerful tool for interacting with the chain's state.\n\nUnlike direct storage access, runtime APIs can derive values from storage based on arguments or perform computations that don't require storage access. For example, a runtime API might expose a formula for fee calculation, using only the provided arguments as inputs rather than fetching data from storage.\n\nIn general, runtime APIs are used for:\n\n- Accessing a storage item.\n- Retrieving a bundle of related storage items.\n- Deriving a value from storage based on arguments.\n- Exposing formulas for complex computational calculations.\n\nThis section will teach you about specific runtime APIs that support XCM processing and manipulation.\n\n## Dry Run API\n\nThe [Dry-run API](https://paritytech.github.io/polkadot-sdk/master/xcm_runtime_apis/dry_run/trait.DryRunApi.html){target=\\_blank}, given an extrinsic, or an XCM program, returns its effects:\n\n- Execution result\n- Local XCM (in the case of an extrinsic)\n- Forwarded XCMs\n- List of events\n\nThis API can be used independently for dry-running, double-checking, or testing. However, it mainly shines when used with the [Xcm Payment API](#xcm-payment-api), given that it only estimates fees if you know the specific XCM you want to execute or send.\n\n### Dry Run Call\n\nThis API allows a dry-run of any extrinsic and obtaining the outcome if it fails or succeeds, as well as the local xcm and remote xcm messages sent to other chains.\n\n```rust\n-fn dry_run_call(origin: OriginCaller, call: Call, result_xcms_version: XcmVersion) -> Result<CallDryRunEffects<Event>, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `origin` ++\"OriginCaller\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The origin used for executing the transaction.\n\n    ---\n\n    `call` ++\"Call\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    The extrinsic to be executed.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<CallDryRunEffects<Event>, Error>\"++\n\n    Effects of dry-running an extrinsic. If an error occurs, it is returned instead of the effects.\n\n    ??? child \"Type `CallDryRunEffects<Event>`\"\n\n        `execution_result` ++\"DispatchResultWithPostInfo\"++\n\n        The result of executing the extrinsic.\n\n        ---\n\n        `emitted_events` ++\"Vec<Event>\"++\n\n        The list of events fired by the extrinsic.\n\n        ---\n\n        `local_xcm` ++\"Option<VersionedXcm<()>>\"++\n\n        The local XCM that was attempted to be executed, if any.\n\n        ---\n\n        `forwarded_xcms` ++\"Vec<(VersionedLocation, Vec<VersionedXcm<()>>)>\"++\n\n        The list of XCMs that were queued for sending.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n\n??? interface \"Example\"\n\n    This example demonstrates how to simulate a cross-chain asset transfer from the Paseo network to the Pop Network using a [reserve transfer](https://wiki.polkadot.com/learn/learn-xcm-usecases/#reserve-asset-transfer){target=\\_blank} mechanism. Instead of executing the actual transfer, the code shows how to test and verify the transaction's behavior through a dry run before performing it on the live network.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n    ***Usage with PAPI***\n\n    ```js\n    -import { paseo } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\nimport {\n  PolkadotRuntimeOriginCaller,\n  XcmVersionedLocation,\n  XcmVersionedAssets,\n  XcmV3Junction,\n  XcmV3Junctions,\n  XcmV3WeightLimit,\n  XcmV3MultiassetFungibility,\n  XcmV3MultiassetAssetId,\n} from '@polkadot-api/descriptors';\nimport { DispatchRawOrigin } from '@polkadot-api/descriptors';\nimport { Binary } from 'polkadot-api';\nimport { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n// Connect to the Paseo relay chain\nconst client = createClient(\n  withPolkadotSdkCompat(getWsProvider('wss://paseo-rpc.dwellir.com')),\n);\n\nconst paseoApi = client.getTypedApi(paseo);\n\nconst popParaID = 4001;\nconst userAddress = 'INSERT_USER_ADDRESS';\nconst userPublicKey = ss58Decode(userAddress)[0];\nconst idBeneficiary = Binary.fromBytes(userPublicKey);\n\n// Define the origin caller\n// This is a regular signed account owned by a user\nlet origin = PolkadotRuntimeOriginCaller.system(\n  DispatchRawOrigin.Signed(userAddress),\n);\n\n// Define a transaction to transfer assets from Polkadot to Pop Network using a Reserve Transfer\nconst tx = paseoApi.tx.XcmPallet.limited_reserve_transfer_assets({\n  dest: XcmVersionedLocation.V3({\n    parents: 0,\n    interior: XcmV3Junctions.X1(\n      XcmV3Junction.Parachain(popParaID), // Destination is the Pop Network parachain\n    ),\n  }),\n  beneficiary: XcmVersionedLocation.V3({\n    parents: 0,\n    interior: XcmV3Junctions.X1(\n      XcmV3Junction.AccountId32({\n        // Beneficiary address on Pop Network\n        network: undefined,\n        id: idBeneficiary,\n      }),\n    ),\n  }),\n  assets: XcmVersionedAssets.V3([\n    {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 0,\n        interior: XcmV3Junctions.Here(), // Native asset from the sender. In this case PAS\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(120000000000n), // Asset amount to transfer\n    },\n  ]),\n  fee_asset_item: 0, // Asset used to pay transaction fees\n  weight_limit: XcmV3WeightLimit.Unlimited(), // No weight limit on transaction\n});\n\n// Execute the dry run call to simulate the transaction\nconst dryRunResult = await paseoApi.apis.DryRunApi.dry_run_call(\n  origin,\n  tx.decodedCall,\n);\n\n// Extract the data from the dry run result\nconst {\n  execution_result: executionResult,\n  emitted_events: emmittedEvents,\n  local_xcm: localXcm,\n  forwarded_xcms: forwardedXcms,\n} = dryRunResult.value;\n\n// Extract the XCM generated by this call\nconst xcmsToPop = forwardedXcms.find(\n  ([location, _]) =>\n    location.type === 'V4' &&\n    location.value.parents === 0 &&\n    location.value.interior.type === 'X1' &&\n    location.value.interior.value.type === 'Parachain' &&\n    location.value.interior.value.value === popParaID, // Pop network's ParaID\n);\nconst destination = xcmsToPop[0];\nconst remoteXcm = xcmsToPop[1][0];\n\n// Print the results\nconst resultObject = {\n  execution_result: executionResult,\n  emitted_events: emmittedEvents,\n  local_xcm: localXcm,\n  destination: destination,\n  remote_xcm: remoteXcm,\n};\n\nconsole.dir(resultObject, { depth: null });\n\nclient.destroy();\n\n    ```\n\n    ***Output***\n\n    -<div id=\"termynal\" data-termynal>\n  <pre>\n    {\n      execution_result: {\n        success: true,\n        value: {\n          actual_weight: undefined,\n          pays_fee: { type: 'Yes', value: undefined }\n        }\n      },\n      emitted_events: [\n        {\n          type: 'Balances',\n          value: {\n            type: 'Transfer',\n            value: {\n              from: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n              to: '13YMK2ePPKQeW7ynqLozB65WYjMnNgffQ9uR4AzyGmqnKeLq',\n              amount: 120000000000n\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: { type: 'Issued', value: { amount: 0n } }\n        },\n        {\n          type: 'XcmPallet',\n          value: {\n            type: 'Attempted',\n            value: {\n              outcome: {\n                type: 'Complete',\n                value: { used: { ref_time: 251861000n, proof_size: 6196n } }\n              }\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Burned',\n            value: {\n              who: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n              amount: 397000000n\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Minted',\n            value: {\n              who: '13UVJyLnbVp9RBZYFwFGyDvVd1y27Tt8tkntv6Q7JVPhFsTB',\n              amount: 397000000n\n            }\n          }\n        },\n        {\n          type: 'XcmPallet',\n          value: {\n            type: 'FeesPaid',\n            value: {\n              paying: {\n                parents: 0,\n                interior: {\n                  type: 'X1',\n                  value: {\n                    type: 'AccountId32',\n                    value: {\n                      network: { type: 'Polkadot', value: undefined },\n                      id: FixedSizeBinary {\n                        asText: [Function (anonymous)],\n                        asHex: [Function (anonymous)],\n                        asOpaqueHex: [Function (anonymous)],\n                        asBytes: [Function (anonymous)],\n                        asOpaqueBytes: [Function (anonymous)]\n                      }\n                    }\n                  }\n                }\n              },\n              fees: [\n                {\n                  id: {\n                    parents: 0,\n                    interior: { type: 'Here', value: undefined }\n                  },\n                  fun: { type: 'Fungible', value: 397000000n }\n                }\n              ]\n            }\n          }\n        },\n        {\n          type: 'XcmPallet',\n          value: {\n            type: 'Sent',\n            value: {\n              origin: {\n                parents: 0,\n                interior: {\n                  type: 'X1',\n                  value: {\n                    type: 'AccountId32',\n                    value: {\n                      network: { type: 'Polkadot', value: undefined },\n                      id: FixedSizeBinary {\n                        asText: [Function (anonymous)],\n                        asHex: [Function (anonymous)],\n                        asOpaqueHex: [Function (anonymous)],\n                        asBytes: [Function (anonymous)],\n                        asOpaqueBytes: [Function (anonymous)]\n                      }\n                    }\n                  }\n                }\n              },\n              destination: {\n                parents: 0,\n                interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n              },\n              message: [\n                {\n                  type: 'ReserveAssetDeposited',\n                  value: [\n                    {\n                      id: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      },\n                      fun: { type: 'Fungible', value: 120000000000n }\n                    }\n                  ]\n                },\n                { type: 'ClearOrigin', value: undefined },\n                {\n                  type: 'BuyExecution',\n                  value: {\n                    fees: {\n                      id: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      },\n                      fun: { type: 'Fungible', value: 120000000000n }\n                    },\n                    weight_limit: { type: 'Unlimited', value: undefined }\n                  }\n                },\n                {\n                  type: 'DepositAsset',\n                  value: {\n                    assets: {\n                      type: 'Wild',\n                      value: { type: 'AllCounted', value: 1 }\n                    },\n                    beneficiary: {\n                      parents: 0,\n                      interior: {\n                        type: 'X1',\n                        value: {\n                          type: 'AccountId32',\n                          value: {\n                            network: undefined,\n                            id: FixedSizeBinary {\n                              asText: [Function (anonymous)],\n                              asHex: [Function (anonymous)],\n                              asOpaqueHex: [Function (anonymous)],\n                              asBytes: [Function (anonymous)],\n                              asOpaqueBytes: [Function (anonymous)]\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              ],\n              message_id: FixedSizeBinary {\n                asText: [Function (anonymous)],\n                asHex: [Function (anonymous)],\n                asOpaqueHex: [Function (anonymous)],\n                asBytes: [Function (anonymous)],\n                asOpaqueBytes: [Function (anonymous)]\n              }\n            }\n          }\n        }\n      ],\n      local_xcm: undefined,\n      destination: {\n        type: 'V4',\n        value: {\n          parents: 0,\n          interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n        }\n      },\n      remote_xcm: {\n        type: 'V3',\n        value: [\n          {\n            type: 'ReserveAssetDeposited',\n            value: [\n              {\n                id: {\n                  type: 'Concrete',\n                  value: {\n                    parents: 1,\n                    interior: { type: 'Here', value: undefined }\n                  }\n                },\n                fun: { type: 'Fungible', value: 120000000000n }\n              }\n            ]\n          },\n          { type: 'ClearOrigin', value: undefined },\n          {\n            type: 'BuyExecution',\n            value: {\n              fees: {\n                id: {\n                  type: 'Concrete',\n                  value: {\n                    parents: 1,\n                    interior: { type: 'Here', value: undefined }\n                  }\n                },\n                fun: { type: 'Fungible', value: 120000000000n }\n              },\n              weight_limit: { type: 'Unlimited', value: undefined }\n            }\n          },\n          {\n            type: 'DepositAsset',\n            value: {\n              assets: { type: 'Wild', value: { type: 'AllCounted', value: 1 } },\n              beneficiary: {\n                parents: 0,\n                interior: {\n                  type: 'X1',\n                  value: {\n                    type: 'AccountId32',\n                    value: {\n                      network: undefined,\n                      id: FixedSizeBinary {\n                        asText: [Function (anonymous)],\n                        asHex: [Function (anonymous)],\n                        asOpaqueHex: [Function (anonymous)],\n                        asBytes: [Function (anonymous)],\n                        asOpaqueBytes: [Function (anonymous)]\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          {\n            type: 'SetTopic',\n            value: FixedSizeBinary {\n              asText: [Function (anonymous)],\n              asHex: [Function (anonymous)],\n              asOpaqueHex: [Function (anonymous)],\n              asBytes: [Function (anonymous)],\n              asOpaqueBytes: [Function (anonymous)]\n            }\n          }\n        ]\n      }\n    }      \n  </pre>\n</div>\n\n                ...\n    -<div id=\"termynal\" data-termynal>\n  <pre>\n    {\n      execution_result: {\n        success: true,\n        value: {\n          actual_weight: undefined,\n          pays_fee: { type: 'Yes', value: undefined }\n        }\n      },\n      emitted_events: [\n        {\n          type: 'Balances',\n          value: {\n            type: 'Transfer',\n            value: {\n              from: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n              to: '13YMK2ePPKQeW7ynqLozB65WYjMnNgffQ9uR4AzyGmqnKeLq',\n              amount: 120000000000n\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: { type: 'Issued', value: { amount: 0n } }\n        },\n        {\n          type: 'XcmPallet',\n          value: {\n            type: 'Attempted',\n            value: {\n              outcome: {\n                type: 'Complete',\n                value: { used: { ref_time: 251861000n, proof_size: 6196n } }\n              }\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Burned',\n            value: {\n              who: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n              amount: 397000000n\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Minted',\n            value: {\n              who: '13UVJyLnbVp9RBZYFwFGyDvVd1y27Tt8tkntv6Q7JVPhFsTB',\n              amount: 397000000n\n            }\n          }\n        },\n        {\n          type: 'XcmPallet',\n          value: {\n            type: 'FeesPaid',\n            value: {\n              paying: {\n                parents: 0,\n                interior: {\n                  type: 'X1',\n                  value: {\n                    type: 'AccountId32',\n                    value: {\n                      network: { type: 'Polkadot', value: undefined },\n                      id: FixedSizeBinary {\n                        asText: [Function (anonymous)],\n                        asHex: [Function (anonymous)],\n                        asOpaqueHex: [Function (anonymous)],\n                        asBytes: [Function (anonymous)],\n                        asOpaqueBytes: [Function (anonymous)]\n                      }\n                    }\n                  }\n                }\n              },\n              fees: [\n                {\n                  id: {\n                    parents: 0,\n                    interior: { type: 'Here', value: undefined }\n                  },\n                  fun: { type: 'Fungible', value: 397000000n }\n                }\n              ]\n            }\n          }\n        },\n        {\n          type: 'XcmPallet',\n          value: {\n            type: 'Sent',\n            value: {\n              origin: {\n                parents: 0,\n                interior: {\n                  type: 'X1',\n                  value: {\n                    type: 'AccountId32',\n                    value: {\n                      network: { type: 'Polkadot', value: undefined },\n                      id: FixedSizeBinary {\n                        asText: [Function (anonymous)],\n                        asHex: [Function (anonymous)],\n                        asOpaqueHex: [Function (anonymous)],\n                        asBytes: [Function (anonymous)],\n                        asOpaqueBytes: [Function (anonymous)]\n                      }\n                    }\n                  }\n                }\n              },\n              destination: {\n                parents: 0,\n                interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n              },\n              message: [\n                {\n                  type: 'ReserveAssetDeposited',\n                  value: [\n                    {\n                      id: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      },\n                      fun: { type: 'Fungible', value: 120000000000n }\n                    }\n                  ]\n                },\n                { type: 'ClearOrigin', value: undefined },\n                {\n                  type: 'BuyExecution',\n                  value: {\n                    fees: {\n                      id: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      },\n                      fun: { type: 'Fungible', value: 120000000000n }\n                    },\n                    weight_limit: { type: 'Unlimited', value: undefined }\n                  }\n                },\n                {\n                  type: 'DepositAsset',\n                  value: {\n                    assets: {\n                      type: 'Wild',\n                      value: { type: 'AllCounted', value: 1 }\n                    },\n                    beneficiary: {\n                      parents: 0,\n                      interior: {\n                        type: 'X1',\n                        value: {\n                          type: 'AccountId32',\n                          value: {\n                            network: undefined,\n                            id: FixedSizeBinary {\n                              asText: [Function (anonymous)],\n                              asHex: [Function (anonymous)],\n                              asOpaqueHex: [Function (anonymous)],\n                              asBytes: [Function (anonymous)],\n                              asOpaqueBytes: [Function (anonymous)]\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              ],\n              message_id: FixedSizeBinary {\n                asText: [Function (anonymous)],\n                asHex: [Function (anonymous)],\n                asOpaqueHex: [Function (anonymous)],\n                asBytes: [Function (anonymous)],\n                asOpaqueBytes: [Function (anonymous)]\n              }\n            }\n          }\n        }\n      ],\n      local_xcm: undefined,\n      destination: {\n        type: 'V4',\n        value: {\n          parents: 0,\n          interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n        }\n      },\n      remote_xcm: {\n        type: 'V3',\n        value: [\n          {\n            type: 'ReserveAssetDeposited',\n            value: [\n              {\n                id: {\n                  type: 'Concrete',\n                  value: {\n                    parents: 1,\n                    interior: { type: 'Here', value: undefined }\n                  }\n                },\n                fun: { type: 'Fungible', value: 120000000000n }\n              }\n            ]\n          },\n          { type: 'ClearOrigin', value: undefined },\n          {\n            type: 'BuyExecution',\n            value: {\n              fees: {\n                id: {\n                  type: 'Concrete',\n                  value: {\n                    parents: 1,\n                    interior: { type: 'Here', value: undefined }\n                  }\n                },\n                fun: { type: 'Fungible', value: 120000000000n }\n              },\n              weight_limit: { type: 'Unlimited', value: undefined }\n            }\n          },\n          {\n            type: 'DepositAsset',\n            value: {\n              assets: { type: 'Wild', value: { type: 'AllCounted', value: 1 } },\n              beneficiary: {\n                parents: 0,\n                interior: {\n                  type: 'X1',\n                  value: {\n                    type: 'AccountId32',\n                    value: {\n                      network: undefined,\n                      id: FixedSizeBinary {\n                        asText: [Function (anonymous)],\n                        asHex: [Function (anonymous)],\n                        asOpaqueHex: [Function (anonymous)],\n                        asBytes: [Function (anonymous)],\n                        asOpaqueBytes: [Function (anonymous)]\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          },\n          {\n            type: 'SetTopic',\n            value: FixedSizeBinary {\n              asText: [Function (anonymous)],\n              asHex: [Function (anonymous)],\n              asOpaqueHex: [Function (anonymous)],\n              asBytes: [Function (anonymous)],\n              asOpaqueBytes: [Function (anonymous)]\n            }\n          }\n        ]\n      }\n    }      \n  </pre>\n</div>\n\n\n    ---\n\n### Dry Run XCM\n\nThis API allows the direct dry-run of an xcm message instead of an extrinsic one, checks if it will execute successfully, and determines what other xcm messages will be forwarded to other chains.\n\n```rust\n-fn dry_run_xcm(origin_location: VersionedLocation, xcm: VersionedXcm<Call>) -> Result<XcmDryRunEffects<Event>, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `origin_location` ++\"VersionedLocation\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    The location of the origin that will execute the xcm message.\n\n    ---\n\n    `xcm` ++\"VersionedXcm<Call>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    A versioned XCM message.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<XcmDryRunEffects<Event>, Error>\"++\n\n    Effects of dry-running an extrinsic. If an error occurs, it is returned instead of the effects.\n\n    ??? child \"Type `XcmDryRunEffects<Event>`\"\n\n        `execution_result` ++\"DispatchResultWithPostInfo\"++\n\n        The result of executing the extrinsic.\n\n        ---\n\n        `emitted_events` ++\"Vec<Event>\"++\n\n        The list of events fired by the extrinsic.\n\n        ---\n\n        `forwarded_xcms` ++\"Vec<(VersionedLocation, Vec<VersionedXcm<()>>)>\"++\n\n        The list of XCMs that were queued for sending.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to simulate a [teleport asset transfer](https://wiki.polkadot.com/learn/learn-xcm-usecases/#asset-teleportation){target=\\_blank} from the Paseo network to the Paseo Asset Hub parachain. The code shows how to test and verify the received XCM message's behavior in the destination chain through a dry run on the live network.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n     ***Usage with PAPI***\n\n    ```js\n    -import { createClient } from 'polkadot-api';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\nimport {\n  XcmVersionedXcm,\n  paseoAssetHub,\n  XcmVersionedLocation,\n  XcmV3Junction,\n  XcmV3Junctions,\n  XcmV3WeightLimit,\n  XcmV3MultiassetFungibility,\n  XcmV3MultiassetAssetId,\n  XcmV3Instruction,\n  XcmV3MultiassetMultiAssetFilter,\n  XcmV3MultiassetWildMultiAsset,\n} from '@polkadot-api/descriptors';\nimport { Binary } from 'polkadot-api';\nimport { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n// Connect to Paseo Asset Hub\nconst client = createClient(\n  withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n);\n\nconst paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\nconst userAddress = 'INSERT_USER_ADDRESS';\nconst userPublicKey = ss58Decode(userAddress)[0];\nconst idBeneficiary = Binary.fromBytes(userPublicKey);\n\n// Define the origin\nconst origin = XcmVersionedLocation.V3({\n  parents: 1,\n  interior: XcmV3Junctions.Here(),\n});\n\n// Define a xcm message comming from the Paseo relay chain to Asset Hub to Teleport some tokens\nconst xcm = XcmVersionedXcm.V3([\n  XcmV3Instruction.ReceiveTeleportedAsset([\n    {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 1,\n        interior: XcmV3Junctions.Here(),\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(12000000000n),\n    },\n  ]),\n  XcmV3Instruction.ClearOrigin(),\n  XcmV3Instruction.BuyExecution({\n    fees: {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 1,\n        interior: XcmV3Junctions.Here(),\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(BigInt(12000000000n)),\n    },\n    weight_limit: XcmV3WeightLimit.Unlimited(),\n  }),\n  XcmV3Instruction.DepositAsset({\n    assets: XcmV3MultiassetMultiAssetFilter.Wild(\n      XcmV3MultiassetWildMultiAsset.All(),\n    ),\n    beneficiary: {\n      parents: 0,\n      interior: XcmV3Junctions.X1(\n        XcmV3Junction.AccountId32({\n          network: undefined,\n          id: idBeneficiary,\n        }),\n      ),\n    },\n  }),\n]);\n\n// Execute dry run xcm\nconst dryRunResult = await paseoAssetHubApi.apis.DryRunApi.dry_run_xcm(\n  origin,\n  xcm,\n);\n\n// Print the results\nconsole.dir(dryRunResult.value, { depth: null });\n\nclient.destroy();\n\n    ```\n\n    ***Output***\n\n    -<div id=\"termynal\" data-termynal>\n  <pre>\n    {\n      execution_result: {\n        type: 'Complete',\n        value: { used: { ref_time: 15574200000n, proof_size: 359300n } }\n      },\n      emitted_events: [\n        {\n          type: 'System',\n          value: {\n            type: 'NewAccount',\n            value: { account: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET' }\n          }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Endowed',\n            value: {\n              account: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n              free_balance: 10203500000n\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Minted',\n            value: {\n              who: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n              amount: 10203500000n\n            }\n          }\n        },\n        {\n          type: 'Balances',\n          value: { type: 'Issued', value: { amount: 1796500000n } }\n        },\n        {\n          type: 'Balances',\n          value: {\n            type: 'Deposit',\n            value: {\n              who: '13UVJyLgBASGhE2ok3TvxUfaQBGUt88JCcdYjHvUhvQkFTTx',\n              amount: 1796500000n\n            }\n          }\n        }\n      ],\n      forwarded_xcms: [\n        [\n          {\n            type: 'V4',\n            value: { parents: 1, interior: { type: 'Here', value: undefined } }\n          },\n          []\n        ]\n      ]\n    }\n  </pre>\n</div>\n\n\n    ---\n\n## XCM Payment API\n\nThe [XCM Payment API](https://paritytech.github.io/polkadot-sdk/master/xcm_runtime_apis/fees/trait.XcmPaymentApi.html){target=\\_blank} provides a standardized way to determine the costs and payment options for executing XCM messages. Specifically, it enables clients to:\n\n- Retrieve the [weight](/polkadot-protocol/glossary/#weight) required to execute an XCM message.\n- Obtain a list of acceptable `AssetIds` for paying execution fees.\n- Calculate the cost of the weight in a specified `AssetId`.\n- Estimate the fees for XCM message delivery.\n\nThis API eliminates the need for clients to guess execution fees or identify acceptable assets manually. Instead, clients can query the list of supported asset IDs formatted according to the XCM version they understand. With this information, they can weigh the XCM program they intend to execute and convert the computed weight into its cost using one of the acceptable assets.\n\nTo use the API effectively, the client must already know the XCM program to be executed and the chains involved in the program's execution.\n\n### Query Acceptable Payment Assets\n\nRetrieves the list of assets that are acceptable for paying fees when using a specific XCM version\n\n```rust\n-fn query_acceptable_payment_assets(xcm_version: Version) -> Result<Vec<VersionedAssetId>, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `xcm_version` ++\"Version\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Specifies the XCM version that will be used to send the XCM message.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<Vec<VersionedAssetId>, Error>\"++\n\n    A list of acceptable payment assets. Each asset is provided in a versioned format (`VersionedAssetId`) that matches the specified XCM version. If an error occurs, it is returned instead of the asset list.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to query the acceptable payment assets for executing XCM messages on the Paseo Asset Hub network using XCM version 3.\n\n    ***Usage with PAPI***\n\n    ```js\n    -import { paseoAssetHub } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n\n// Connect to the polkadot relay chain\nconst client = createClient(\n  withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n);\n\nconst paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\n// Define the xcm version to use\nconst xcmVersion = 3;\n\n// Execute the runtime call to query the assets\nconst result =\n  await paseoAssetHubApi.apis.XcmPaymentApi.query_acceptable_payment_assets(\n    xcmVersion,\n  );\n\n// Print the assets\nconsole.dir(result.value, { depth: null });\n\nclient.destroy();\n\n    ```\n\n    ***Output***\n\n    -<div id=\"termynal\" data-termynal>\n  <pre>\n    [\n      {\n        type: 'V3',\n        value: {\n          type: 'Concrete',\n          value: { parents: 1, interior: { type: 'Here', value: undefined } }\n        }\n      }\n    ]\n  </pre>\n</div>\n\n\n    ---\n\n### Query XCM Weight\n\nCalculates the weight required to execute a given XCM message. It is useful for estimating the execution cost of a cross-chain message in the destination chain before sending it.\n\n```rust\n-fn query_xcm_weight(message: VersionedXcm<()>) -> Result<Weight, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `message` ++\"VersionedXcm<()>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    A versioned XCM message whose execution weight is being queried.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<Weight, Error>\"++\n    \n    The calculated weight required to execute the provided XCM message. If the calculation fails, an error is returned instead.\n\n    ??? child \"Type `Weight`\"\n\n        `ref_time` ++\"u64\"++\n\n        The weight of computational time used based on some reference hardware.\n\n        ---\n\n        `proof_size` ++\"u64\"++\n\n        The weight of storage space used by proof of validity.\n\n        ---\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to calculate the weight needed to execute a [teleport transfer](https://wiki.polkadot.com/learn/learn-xcm-usecases/#asset-teleportation){target=\\_blank} from the Paseo network to the Paseo Asset Hub parachain using the XCM Payment API. The result shows the required weight in terms of reference time and proof size needed in the destination chain.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n    ***Usage with PAPI***\n\n    ```js\n    -import { createClient } from 'polkadot-api';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\nimport {\n  XcmVersionedXcm,\n  paseoAssetHub,\n  XcmV3Junction,\n  XcmV3Junctions,\n  XcmV3WeightLimit,\n  XcmV3MultiassetFungibility,\n  XcmV3MultiassetAssetId,\n  XcmV3Instruction,\n  XcmV3MultiassetMultiAssetFilter,\n  XcmV3MultiassetWildMultiAsset,\n} from '@polkadot-api/descriptors';\nimport { Binary } from 'polkadot-api';\nimport { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n// Connect to Paseo Asset Hub\nconst client = createClient(\n  withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n);\n\nconst paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\nconst userAddress = 'INSERT_USER_ADDRESS';\nconst userPublicKey = ss58Decode(userAddress)[0];\nconst idBeneficiary = Binary.fromBytes(userPublicKey);\n\n// Define a xcm message comming from the Paseo relay chain to Asset Hub to Teleport some tokens\nconst xcm = XcmVersionedXcm.V3([\n  XcmV3Instruction.ReceiveTeleportedAsset([\n    {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 1,\n        interior: XcmV3Junctions.Here(),\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(12000000000n),\n    },\n  ]),\n  XcmV3Instruction.ClearOrigin(),\n  XcmV3Instruction.BuyExecution({\n    fees: {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 1,\n        interior: XcmV3Junctions.Here(),\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(BigInt(12000000000n)),\n    },\n    weight_limit: XcmV3WeightLimit.Unlimited(),\n  }),\n  XcmV3Instruction.DepositAsset({\n    assets: XcmV3MultiassetMultiAssetFilter.Wild(\n      XcmV3MultiassetWildMultiAsset.All(),\n    ),\n    beneficiary: {\n      parents: 0,\n      interior: XcmV3Junctions.X1(\n        XcmV3Junction.AccountId32({\n          network: undefined,\n          id: idBeneficiary,\n        }),\n      ),\n    },\n  }),\n]);\n\n// Execute the query weight runtime call\nconst result = await paseoAssetHubApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n\n// Print the results\nconsole.dir(result.value, { depth: null });\n\nclient.destroy();\n\n    ```\n\n    ***Output***\n\n    -<div id=\"termynal\" data-termynal>\n  <span data-ty>{ ref_time: 15574200000n, proof_size: 359300n }</span>\n</div>\n\n\n    ---\n\n### Query Weight to Asset Fee\n\nConverts a given weight into the corresponding fee for a specified `AssetId`. It allows clients to determine the cost of execution in terms of the desired asset.\n\n```rust\n-fn query_weight_to_asset_fee(weight: Weight, asset: VersionedAssetId) -> Result<u128, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `weight` ++\"Weight\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The execution weight to be converted into a fee.\n\n    ??? child \"Type `Weight`\"\n\n        `ref_time` ++\"u64\"++\n\n        The weight of computational time used based on some reference hardware.\n\n        ---\n\n        `proof_size` ++\"u64\"++\n\n        The weight of storage space used by proof of validity.\n\n        ---\n\n    ---\n\n    `asset` ++\"VersionedAssetId\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The asset in which the fee will be calculated. This must be a versioned asset ID compatible with the runtime.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<u128, Error>\"++\n    \n    The fee needed to pay for the execution for the given `AssetId.`\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to calculate the fee for a given execution weight using a specific versioned asset ID (PAS token) on Paseo Asset Hub.\n\n    ***Usage with PAPI***\n\n    ```js\n    -import { paseoAssetHub } from '@polkadot-api/descriptors';\nimport { createClient } from 'polkadot-api';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n\n// Connect to the polkadot relay chain\nconst client = createClient(\n  withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n);\n\nconst paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\n// Define the weight to convert to fee\nconst weight = { ref_time: 15574200000n, proof_size: 359300n };\n\n// Define the versioned asset id\nconst versionedAssetId = {\n  type: 'V4',\n  value: { parents: 1, interior: { type: 'Here', value: undefined } },\n};\n\n// Execute the runtime call to convert the weight to fee\nconst result =\n  await paseoAssetHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n    weight,\n    versionedAssetId,\n  );\n\n// Print the fee\nconsole.dir(result.value, { depth: null });\n\nclient.destroy();\n\n    ```\n\n    ***Output***\n\n    -<div id=\"termynal\" data-termynal>\n  <span data-ty>1796500000n</span>\n</div>\n\n    ---\n\n### Query Delivery Fees\n\nRetrieves the delivery fees for sending a specific XCM message to a designated destination. The fees are always returned in a specific asset defined by the destination chain.\n\n```rust\n-fn query_delivery_fees(destination: VersionedLocation, message: VersionedXcm<()>) -> Result<VersionedAssets, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `destination` ++\"VersionedLocation\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The target location where the message will be sent. Fees may vary depending on the destination, as different destinations often have unique fee structures and sender mechanisms.\n\n    ---\n\n    `message` ++\"VersionedXcm<()>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The XCM message to be sent. The delivery fees are calculated based on the message's content and size, which can influence the cost.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<VersionedAssets, Error>\"++\n    \n    The calculated delivery fees expressed in a specific asset supported by the destination chain. If an error occurs during the query, it returns an error instead.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to query the delivery fees for sending an XCM message from Paseo to Paseo Asset Hub.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n    ***Usage with PAPI***\n\n    ```js\n    -import { createClient } from 'polkadot-api';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\nimport {\n  XcmVersionedXcm,\n  paseo,\n  XcmVersionedLocation,\n  XcmV3Junction,\n  XcmV3Junctions,\n  XcmV3WeightLimit,\n  XcmV3MultiassetFungibility,\n  XcmV3MultiassetAssetId,\n  XcmV3Instruction,\n  XcmV3MultiassetMultiAssetFilter,\n  XcmV3MultiassetWildMultiAsset,\n} from '@polkadot-api/descriptors';\nimport { Binary } from 'polkadot-api';\nimport { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\nconst client = createClient(\n  withPolkadotSdkCompat(getWsProvider('wss://paseo-rpc.dwellir.com')),\n);\n\nconst paseoApi = client.getTypedApi(paseo);\n\nconst paseoAssetHubParaID = 1000;\nconst userAddress = 'INSERT_USER_ADDRESS';\nconst userPublicKey = ss58Decode(userAddress)[0];\nconst idBeneficiary = Binary.fromBytes(userPublicKey);\n\n// Define the destination\nconst destination = XcmVersionedLocation.V3({\n  parents: 0,\n  interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(paseoAssetHubParaID)),\n});\n\n// Define the xcm message that will be sent to the destination\nconst xcm = XcmVersionedXcm.V3([\n  XcmV3Instruction.ReceiveTeleportedAsset([\n    {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 1,\n        interior: XcmV3Junctions.Here(),\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(12000000000n),\n    },\n  ]),\n  XcmV3Instruction.ClearOrigin(),\n  XcmV3Instruction.BuyExecution({\n    fees: {\n      id: XcmV3MultiassetAssetId.Concrete({\n        parents: 1,\n        interior: XcmV3Junctions.Here(),\n      }),\n      fun: XcmV3MultiassetFungibility.Fungible(BigInt(12000000000n)),\n    },\n    weight_limit: XcmV3WeightLimit.Unlimited(),\n  }),\n  XcmV3Instruction.DepositAsset({\n    assets: XcmV3MultiassetMultiAssetFilter.Wild(\n      XcmV3MultiassetWildMultiAsset.All(),\n    ),\n    beneficiary: {\n      parents: 0,\n      interior: XcmV3Junctions.X1(\n        XcmV3Junction.AccountId32({\n          network: undefined,\n          id: idBeneficiary,\n        }),\n      ),\n    },\n  }),\n]);\n\n// Execute the query delivery fees runtime call\nconst result = await paseoApi.apis.XcmPaymentApi.query_delivery_fees(\n  destination,\n  xcm,\n);\n\n// Print the results\nconsole.dir(result.value, { depth: null });\n\nclient.destroy();\n\n    ```\n\n    ***Output***\n\n    -<div id=\"termynal\" data-termynal>\n  <pre>\n    {\n      type: 'V3',\n      value: [\n        {\n          id: {\n            type: 'Concrete',\n            value: { parents: 0, interior: { type: 'Here', value: undefined } }\n          },\n          fun: { type: 'Fungible', value: 396000000n }\n        }\n      ]\n    }\n  </pre>\n</div>\n\n    ---\n"}
{"title": "XCM Tools", "slug": "develop-toolkit-interoperability-xcm-tools", "raw_md_url": "https://raw.githubusercontent.com/polkadot-developers/polkadot-docs/dawn/improved-llms/.ai/pages/develop-toolkit-interoperability-xcm-tools.md", "html_url": "https://docs.polkadot.com/develop/toolkit/interoperability/xcm-tools/", "categories": ["Basics", "Tooling", "Dapps"], "description": "Explore essential XCM tools across Polkadot, crafted to enhance cross-chain functionality and integration within the ecosystem.", "estimated_token_count": 1703, "token_estimator": "heuristic-v1", "content": "# XCM Tools\n\n## Introduction\n\nAs described in the [Interoperability](/develop/interoperability){target=\\_blank} section, XCM (Cross-Consensus Messaging) is a protocol used in the Polkadot and Kusama ecosystems to enable communication and interaction between chains. It facilitates cross-chain communication, allowing assets, data, and messages to flow seamlessly across the ecosystem.\n\nAs XCM is central to enabling communication between blockchains, developers need robust tools to help interact with, build, and test XCM messages. Several XCM tools simplify working with the protocol by providing libraries, frameworks, and utilities that enhance the development process, ensuring that applications built within the Polkadot ecosystem can efficiently use cross-chain functionalities.\n\n## Popular XCM Tools\n\n### Moonsong Labs XCM Tools\n\n[Moonsong Labs XCM Tools](https://github.com/Moonsong-Labs/xcm-tools){target=\\_blank} provides a collection of scripts for managing and testing XCM operations between Polkadot SDK-based runtimes. These tools allow performing tasks like asset registration, channel setup, and XCM initialization. Key features include:\n\n- **Asset registration**: Registers assets, setting units per second (up-front fees), and configuring error (revert) codes.\n- **XCM initializer**: Initializes XCM, sets default XCM versions, and configures revert codes for XCM-related precompiles.\n- **HRMP manipulator**: Manages HRMP channel actions, including opening, accepting, or closing channels.\n- **XCM-Transactor-Info-Setter**: Configures transactor information, including extra weight and fee settings.\n- **Decode XCM**: Decodes XCM messages on the relay chain or parachains to help interpret cross-chain communication.\n\nTo get started, clone the repository and install the required dependencies:\n\n```bash\ngit clone https://github.com/Moonsong-Labs/xcm-tools && \ncd xcm-tools &&\nyarn install\n```\n\nFor a full overview of each script, visit the [scripts](https://github.com/Moonsong-Labs/xcm-tools/tree/main/scripts){target=\\_blank} directory or refer to the [official documentation](https://github.com/Moonsong-Labs/xcm-tools/blob/main/README.md){target=\\_blank} on GitHub.\n\n### ParaSpell\n\n[ParaSpell](https://paraspell.xyz/){target=\\_blank} is a collection of open-source XCM tools designed to streamline cross-chain asset transfers and interactions within the Polkadot and Kusama ecosystems. It equips developers with an intuitive interface to manage and optimize XCM-based functionalities. Some key points included by ParaSpell are:\n\n- **[XCM SDK](https://paraspell.xyz/#xcm-sdk){target=\\_blank}**: Provides a unified layer to incorporate XCM into decentralized applications, simplifying complex cross-chain interactions.\n- **[XCM API](https://paraspell.xyz/#xcm-api){target=\\_blank}**: Offers an efficient, package-free approach to integrating XCM functionality while offloading heavy computing tasks, minimizing costs and improving application performance.\n- **[XCM router](https://paraspell.xyz/#xcm-router){target=\\_blank}**: Enables cross-chain asset swaps in a single command, allowing developers to send one asset type (such as DOT on Polkadot) and receive a different asset on another chain (like ASTR on Astar).\n- **[XCM analyser](https://paraspell.xyz/#xcm-analyser){target=\\_blank}**: Decodes and translates complex XCM multilocation data into readable information, supporting easier troubleshooting and debugging.\n- **[XCM visualizator](https://paraspell.xyz/#xcm-visualizator){target=\\_blank}**: A tool designed to give developers a clear, interactive view of XCM activity across the Polkadot ecosystem, providing insights into cross-chain communication flow.\n\nParaSpell's tools make it simple for developers to build, test, and deploy cross-chain solutions without needing extensive knowledge of the XCM protocol. With features like message composition, decoding, and practical utility functions for parachain interactions, ParaSpell is especially useful for debugging and optimizing cross-chain communications.\n\n### Astar XCM Tools\n\nThe [Astar parachain](https://github.com/AstarNetwork/Astar/tree/master){target=\\_blank} offers a crate with a set of utilities for interacting with the XCM protocol. The [xcm-tools](https://github.com/AstarNetwork/Astar/tree/master/bin/xcm-tools){target=\\_blank} crate provides a straightforward method for users to locate a sovereign account or calculate an XC20 asset ID. Some commands included by the xcm-tools crate allow users to perform the following tasks:\n\n- **Sovereign accounts**: Obtain the sovereign account address for any parachain, either on the Relay Chain or for sibling parachains, using a simple command.\n- **XC20 EVM addresses**: Generate XC20-compatible Ethereum addresses for assets by entering the asset ID, making it easy to integrate assets across Ethereum-compatible environments.\n- **Remote accounts**: Retrieve remote account addresses needed for multi-location compatibility, using flexible options to specify account types and parachain IDs.\n\nTo start using these tools, clone the [Astar repository](https://github.com/AstarNetwork/Astar){target=\\_blank} and compile the xcm-tools package:\n\n```bash\ngit clone https://github.com/AstarNetwork/Astar &&\ncd Astar &&\ncargo build --release -p xcm-tools\n```\n\nAfter compiling, verify the setup with the following command:\n\n```bash\n./target/release/xcm-tools --help\n```\nFor more details on using Astar xcm-tools, consult the [official documentation](https://docs.astar.network/docs/learn/interoperability/xcm/integration/tools/){target=\\_blank}.\n\n### Chopsticks\n\nThe Chopsticks library provides XCM functionality for testing XCM messages across networks, enabling you to fork multiple parachains along with a relay chain. For further details, see the [Chopsticks documentation](/tutorials/polkadot-sdk/testing/fork-live-chains/){target=\\_blank} about XCM.\n\n### Moonbeam XCM SDK\n\nThe [Moonbeam XCM SDK](https://github.com/moonbeam-foundation/xcm-sdk){target=\\_blank} enables developers to easily transfer assets between chains, either between parachains or between a parachain and the relay chain, within the Polkadot/Kusama ecosystem. With the SDK, you don't need to worry about determining the [Multilocation](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#7-universal-consensus-location-identifiers){target=\\_blank} of the origin or destination assets or which extrinsics are used on which networks.\n\nThe SDK consists of two main packages:\n\n- **[XCM SDK](https://github.com/moonbeam-foundation/xcm-sdk/tree/main/packages/sdk){target=\\_blank}**: Core SDK for executing XCM transfers between chains in the Polkadot/Kusama ecosystem.\n- **[MRL SDK](https://github.com/moonbeam-foundation/xcm-sdk/tree/main/packages/mrl){target=\\_blank}**: Extension of the XCM SDK for transferring liquidity into and across the Polkadot ecosystem from other ecosystems like Ethereum.\n\nKey features include:\n\n- **Simplified asset transfers**: Abstracts away complex multilocation determinations and extrinsic selection.\n- **Cross-ecosystem support**: Enables transfers between Polkadot/Kusama chains and external ecosystems.\n- **Developer-friendly API**: Provides intuitive interfaces for cross-chain functionality.\n- **Comprehensive documentation**: Includes usage guides and API references for both packages.\n\nFor detailed usage examples and API documentation, visit the [official Moonbeam XCM SDK documentation](https://moonbeam-foundation.github.io/xcm-sdk/latest/){target=\\_blank}.\n"}
