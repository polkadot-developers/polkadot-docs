---
title: Wasm (ink!)
description: TODO
---

# Wasm (ink!)

## Introduction

ink! is an embedded domain-specific language (eDSL) designed to develop Wasm smart contracts using the Rust programming language. 

Rather than creating a new language, ink! is just standard Rust in a well-defined "contract format" with specialized `#[ink(…)]` attribute macros. These attribute macros tell ink! what the different parts of your Rust smart contract represent and ultimately allow ink! to do all the magic needed to create Polkadot SDK-compatible Wasm bytecode. Because of this, it inherits critical advantages such as:

- Strong memory safety guarantees
- Advanced type system
- Comprehensive development tooling
- Support from Rust's extensive developer community

And because ink! smart contracts are compiled to Wasm, they deliver:

- High execution speed
- Platform independence
- Enhanced security through sandboxed execution

These contracts can be deployed on any blockchain built with the Polkadot SDK that implements the [Contracts Pallet](https://docs.rs/pallet-contracts/latest/pallet_contracts/){target=\_blank}.

## Installation

ink! smart contract development requires the installation of [cargo-contract](https://github.com/use-ink/cargo-contract){target=\_blank}, a command-line interface (CLI) tool that provides essential utilities for creating, testing, and managing ink! projects.

For step-by-step installation instructions, including platform-specific requirements and troubleshooting tips, refer to the official cargo-contract [Installation](https://github.com/use-ink/cargo-contract?tab=readme-ov-file#installation){target=\_blank} guide.

## Quick Start

To create a new ink! smart contract project, use the `cargo contract` command:

```bash
cargo contract new your-project-name
```

This command generates a new project directory with the following structure:

```bash
your-project-name/
├── lib.rs          # Contract source code
├── Cargo.toml      # Project configuration and dependencies
└── .gitignore      # Git ignore rules
```

The `lib.rs` file includes a basic contract template with storage and message handling functionality. Customize this file to implement your contract’s logic. The `Cargo.toml` file defines project dependencies, including the necessary ink! libraries and configuration settings.

## Contract Structure

An ink! smart contract requires three fundamental components:

- A storage struct marked with `#[ink(storage)]`
- At least one constructor function marked with `#[ink(constructor)]`
- At least one message function marked with `#[ink(message)]`

### Default Template Structure

The following example shows the basic contract structure generated by running `cargo contract new`:

```rust
#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod flipper {

    /// Defines the storage of your contract.
    /// Add new fields to the below struct in order
    /// to add new static storage fields to your contract.
    #[ink(storage)]
    pub struct Flipper {
        /// Stores a single `bool` value on the storage.
        value: bool,
    }

    impl Flipper {
        /// Constructor that initializes the `bool` value to the given `init_value`.
        #[ink(constructor)]
        pub fn new(init_value: bool) -> Self {
            Self { value: init_value }
        }

        /// Constructor that initializes the `bool` value to `false`.
        ///
        /// Constructors can delegate to other constructors.
        #[ink(constructor)]
        pub fn default() -> Self {
            Self::new(Default::default())
        }

        /// A message that can be called on instantiated contracts.
        /// This one flips the value of the stored `bool` from `true`
        /// to `false` and vice versa.
        #[ink(message)]
        pub fn flip(&mut self) {
            self.value = !self.value;
        }

        /// Simply returns the current value of our `bool`.
        #[ink(message)]
        pub fn get(&self) -> bool {
            self.value
        }
    }
}
```

### Storage

In an ink! contract, persistent storage is defined by a single struct annotated with the `#[ink(storage)]` attribute. This struct represents the contract's state and can use various data types for storing information, such as:

- Common Data Types

    - Boolean values (`bool`)
    - Unsigned integers (`u8`, `u16`, `u32`, `u64`, `u128`)
    - Signed integers (`i8`, `i16`, `i32`, `i64`, `i128`)
    - Tuples and arrays

- Substrate-Specific Types

    - `AccountId` - contract and user addresses
    - `Balance` - token amounts
    - `Hash` - cryptographic hashes

- Data Structures

    - Struct - custom data structures
    - Vec - dynamic arrays
    - Mapping - key-value storage
    - BTreeMap- ordered maps
    - HashMap - unordered maps

Example of a storage struct using various supported types:

```rust
#[ink(storage)]
pub struct Data {
    /// A boolean flag to indicate a certain condition
    flag: bool,
    /// A vector to store multiple entries of unsigned 32-bit integers
    entries: Vec<u32>,
    /// An optional value that can store a specific integer or none
    optional_value: Option<i32>,
    /// A map to associate keys (as AccountId) with values (as unsigned 64-bit integers)
    key_value_store: Mapping<AccountId, u64>,
    /// A counter to keep track of some numerical value
    counter: u64,
}
```

For an in-depth explanation of storage and data structures in ink!, refer to the  [Storage & Data Structures](https://use.ink/datastructures/overview){target=\_blank} section in the official documentation.

### Constructors

Constructors are functions that execute once when deploying the contract, used to initialize the contract’s state. Each contract must have at least one constructor, though multiple constructors are allowed to provide different initialization options.

Example:

```rust
#[ink::contract]
mod mycontract {

    #[ink(storage)]
    pub struct MyContract {
        number: u32,
    }

    impl MyContract {
        /// Constructor that initializes the `u32` value to the given `init_value`.
        #[ink(constructor)]
        pub fn new(init_value: u32) -> Self {
            Self {
                number: init_value,
            }
        }

        /// Constructor that initializes the `u32` value to the `u32` default.
        #[ink(constructor)]
        pub fn default() -> Self {
            Self {
                number: Default::default(),
            }
        }
    }

    /* ... */
}
```

!!!note
    In this example, `new(init_value: u32)` initializes `number` with a specified value, while `default()` initializes it with the type’s default value (0 for `u32`). These constructors provide flexibility in contract deployment by supporting custom and default initialization options.

### Messages

### Errors

### Events

## Where to Go Next?

To deepen your knowledge of ink! development, whether you're exploring foundational concepts or advanced implementations, the following resources provide essential guidance:

- [**Official ink! documentation**](https://use.ink/){target=\_blank} — a thorough resource with guides, in-depth explanations, and technical references to support you in mastering ink! development

- [**ink-examples repository**](https://github.com/use-ink/ink-examples){target=\_blank} — a curated collection of smart contract examples that demonstrate best practices and commonly used design patterns