---
title: Wasm (ink!)
description: Learn to build Wasm smart contracts with ink!, a Rust-based eDSL. Explore installation, contract structure, and key features.
---

# Wasm (ink!)

## Introduction

The [pallet_contracts](https://docs.rs/pallet-contracts/latest/pallet_contracts/index.html#contracts-pallet){target=\_blank} is a specialized pallet within the Polkadot SDK that enables smart contract functionality through a WebAssembly (Wasm) execution environment. For developing smart contracts for this pallet, [ink!](https://use.ink/){target=\_blank} emerges as the primary and recommended language. 

ink! is an embedded domain-specific language (eDSL) designed to develop [Wasm](https://webassembly.org/){target=\_blank} smart contracts using the Rust programming language.

Rather than creating a new language, ink! is just standard Rust in a well-defined "contract format" with specialized `#[ink(…)]` attribute macros. These attribute macros tell ink! what the different parts of your Rust smart contract represent and ultimately allow ink! to do all the magic needed to create Polkadot SDK-compatible Wasm bytecode. Because of this, it inherits critical advantages such as:

- Strong memory safety guarantees
- Advanced type system
- Comprehensive development tooling
- Support from Rust's extensive developer community

Since ink! smart contracts are compiled to Wasm, they offer high execution speed, platform independence, and enhanced security through sandboxed execution.

## Installation

ink! smart contract development requires the installation of [cargo-contract](https://github.com/use-ink/cargo-contract){target=\_blank}, a command-line interface (CLI) tool that provides essential utilities for creating, testing, and managing ink! projects.

For step-by-step installation instructions, including platform-specific requirements and troubleshooting tips, refer to the official `cargo-contract` [Installation](https://github.com/use-ink/cargo-contract?tab=readme-ov-file#installation){target=\_blank} guide.

## Get Started

To create a new ink! smart contract project, use the `cargo contract` command:

```bash
cargo contract new INSERT_PROJECT_NAME
```

This command generates a new project directory with the following structure:

```bash
INSERT_PROJECT_NAME/
├── lib.rs          # Contract source code
├── Cargo.toml      # Project configuration and dependencies
└── .gitignore      # Git ignore rules
```

The `lib.rs` file includes a basic contract template with storage and message-handling functionality. Customize this file to implement your contract’s logic. The `Cargo.toml` file defines project dependencies, including the necessary ink! libraries and configuration settings.

## Contract Structure

An ink! smart contract requires three fundamental components:

- A storage struct marked with `#[ink(storage)]`
- At least one constructor function marked with `#[ink(constructor)]`
- At least one message function marked with `#[ink(message)]`

### Default Template Structure

The following example shows the basic contract structure generated by running `cargo contract new`:

```rust
--8<-- 'code/develop/smart-contracts/wasm-ink/flipper.rs'
```

### Storage

In an ink! contract, persistent storage is defined by a single struct annotated with the `#[ink(storage)]` attribute. This struct represents the contract's state and can use various data types for storing information, such as:

- **Common data types**:

    - Boolean values (`bool`)
    - Unsigned integers (`u8`, `u16`, `u32`, `u64`, `u128`)
    - Signed integers (`i8`, `i16`, `i32`, `i64`, `i128`)
    - Tuples and arrays

- **Substrate-specific types**:

    - **`AccountId`** - contract and user addresses
    - **`Balance`** - token amounts
    - **`Hash`** - cryptographic hashes

- **Data structures**:

    - **Struct** - custom data structures
    - **Vec** - dynamic arrays
    - **Mapping** - key-value storage
    - **BTreeMap**- ordered maps
    - **HashMap** - unordered maps

Example of a storage struct using various supported types:

```rust
--8<-- 'code/develop/smart-contracts/wasm-ink/storage.rs'
```

For an in-depth explanation of storage and data structures in ink!, refer to the  [Storage & Data Structures](https://use.ink/datastructures/overview){target=\_blank} section and the [`#[ink(storage)]`](https://use.ink/macros-attributes/storage){target=\_blank} macro definition in the official documentation.

### Constructors

Constructors are functions that execute once when deploying the contract and are used to initialize the contract’s state. Each contract must have at least one constructor, though multiple constructors can provide different initialization options.

Example:

```rust
--8<-- 'code/develop/smart-contracts/wasm-ink/constructors.rs'
```

In this example, `new(init_value: u32)` initializes `number` with a specified value, while `default()` initializes it with the type’s default value (0 for `u32`). These constructors provide flexibility in contract deployment by supporting custom and default initialization options.

For more information, refer to the official documentation for the [`#[ink(constructor)]`](https://use.ink/macros-attributes/constructor){target=\_blank} macro definition.

### Messages

Messages are functions that interact with the contract, allowing users or other contracts to call specific methods. Each contract must define at least one message.

There are two types of messages:

- **Immutable messages (`&self`)** - these messages can only read the contract's state and cannot modify it
- **Mutable messages (`&mut self`)** - these messages can read and modify the contract's state

In the example above, `&self` is a reference to the contract's storage.

Example:

```rust
--8<-- 'code/develop/smart-contracts/wasm-ink/messages.rs'
```

In the example above, `my_getter` is an immutable message that reads state, while `my_setter` is a mutable message that updates state.

For more information, refer to the official documentation on the [`#[ink(message)]`](https://use.ink/macros-attributes/message){target=\_blank} macro.

### Errors

For defining errors, ink! uses idiomatic Rust error handling with the `Result<T,E>` type. These errors are user-defined by creating an `Error` enum and all the necessary types.
If an error is returned, the contract reverts

In ink!, errors are handled using idiomatic Rust practices with the `Result<T, E>` type. Custom error types are defined by creating an `Error` enum and specifying any necessary variants. If a message returns an error, the contract execution reverts, ensuring no changes are applied to the contract's state.

Example:

```rust
--8<-- 'code/develop/smart-contracts/wasm-ink/errors.rs'
```

In this example, the `Error` enum defines custom error types `InsufficientBalance` and `InsufficientAllowance`. When `transfer_from` is called, it checks if the allowance is sufficient. If not, it returns an `InsufficientAllowance` error, causing the contract to revert. This approach ensures robust error handling for smart contracts.

### Events

Events are a way of letting the outside world know about what's happening inside the contract. They are user-defined in a struct and decorated with the `#[ink(event)]` macro.

Events allow the contract to communicate important occurrences to the outside world. They are user-defined by creating a struct and annotating it with the `#[ink(event)]` macro. Each field you want to index for efficient querying should be marked with `#[ink(topic)]`.

Example:

```rust
--8<-- 'code/develop/smart-contracts/wasm-ink/events.rs'
```

In this example, the `Transfer` event records the sender (`from`), the receiver (`to`), and the amount transferred (`value`). The event is emitted in the `transfer_from` function to notify external listeners whenever a transfer occurs.

For more details, check the [Events](https://use.ink/basics/events){target=\_blank} section and the [`#[ink(event)]`](https://use.ink/macros-attributes/event){target=\_blank} macro documentation.

## Where to Go Next?

To deepen your knowledge of ink! development, whether you're exploring foundational concepts or advanced implementations, the following resources provide essential guidance:

- [**Official ink! documentation**](https://use.ink/){target=\_blank} — a thorough resource with guides, in-depth explanations, and technical references to support you in mastering ink! development

- [**`ink-examples` repository**](https://github.com/use-ink/ink-examples){target=\_blank} — a curated collection of smart contract examples that demonstrate best practices and commonly used design patterns
