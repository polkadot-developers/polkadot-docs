{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 23, "end_char": 695, "estimated_token_count": 113, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPolkadot’s unique value lies in its ability to enable interoperability between parachains and other blockchain systems. At the core of this capability is XCM (Cross-Consensus Messaging)—a flexible messaging format that facilitates communication and collaboration between independent consensus systems.\n\nWith XCM, one chain can send intents to another one, fostering a more interconnected ecosystem. Although it was developed specifically for Polkadot, XCM is a universal format, usable in any blockchain environment. This guide provides an overview of XCM’s core principles, design, and functionality, alongside practical examples of its implementation."}
{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 1, "depth": 2, "title": "Messaging Format", "anchor": "messaging-format", "start_char": 695, "end_char": 1569, "estimated_token_count": 153, "token_estimator": "heuristic-v1", "text": "## Messaging Format\n\nXCM is not a protocol but a standardized [messaging format](https://github.com/polkadot-fellows/xcm-format){target=\\_blank}. It defines the structure and behavior of messages but does not handle their delivery. This separation allows developers to focus on crafting instructions for target systems without worrying about transmission mechanics.\n\nXCM messages are intent-driven, outlining desired actions for the receiving blockchain to consider and potentially alter its state. These messages do not directly execute changes; instead, they rely on the host chain's environment to interpret and implement them. By utilizing asynchronous composability, XCM facilitates efficient execution where messages can be processed independently of their original order, similar to how RESTful services handle HTTP requests without requiring sequential processing."}
{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 2, "depth": 2, "title": "The Four Principles of XCM", "anchor": "the-four-principles-of-xcm", "start_char": 1569, "end_char": 2505, "estimated_token_count": 174, "token_estimator": "heuristic-v1", "text": "## The Four Principles of XCM\n\nXCM adheres to four guiding principles that ensure robust and reliable communication across consensus systems:\n\n- **Asynchronous**: XCM messages operate independently of sender acknowledgment, avoiding delays due to blocked processes.\n- **Absolute**: XCM messages are guaranteed to be delivered and interpreted accurately, in order, and timely. Once a message is sent, one can be sure it will be processed as intended.\n- **Asymmetric**: XCM messages follow the 'fire and forget' paradigm meaning no automatic feedback is provided to the sender. Any results must be communicated separately to the sender with an additional message back to the origin.\n- **Agnostic**: XCM operates independently of the specific consensus mechanisms, making it compatible across diverse systems.\n\nThese principles guarantee that XCM provides a reliable framework for cross-chain communication, even in complex environments."}
{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 3, "depth": 2, "title": "The XCM Tech Stack", "anchor": "the-xcm-tech-stack", "start_char": 2505, "end_char": 2867, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "## The XCM Tech Stack\n\n![Diagram of the XCM tech stack](/images/develop/interoperability/intro-to-xcm/intro-to-xcm-01.webp)\n\nThe XCM tech stack is designed to facilitate seamless interoperable communication between chains that reside within the Polkadot ecosystem. XCM can be used to express the meaning of the messages over each of the communication channels."}
{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 4, "depth": 2, "title": "Core Functionalities of XCM", "anchor": "core-functionalities-of-xcm", "start_char": 2867, "end_char": 3863, "estimated_token_count": 165, "token_estimator": "heuristic-v1", "text": "## Core Functionalities of XCM\n\nXCM enhances cross-consensus communication by introducing several powerful features:\n\n- **Programmability**: Supports dynamic message handling, allowing for more comprehensive use cases. Includes branching logic, safe dispatches for version checks, and asset operations like NFT management.\n- **Functional Multichain Decomposition**: Enables mechanisms such as remote asset locking, asset namespacing, and inter-chain state referencing, with contextual message identification.\n- **Bridging**: Establishes a universal reference framework for multi-hop setups, connecting disparate systems like Ethereum and Bitcoin with the Polkadot relay chain acting as a universal location.\n\nThe standardized format for messages allows parachains to handle tasks like user balances, governance, and staking, freeing the Polkadot relay chain to focus on shared security. These features make XCM indispensable for implementing scalable and interoperable blockchain applications."}
{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 5, "depth": 2, "title": "XCM Example", "anchor": "xcm-example", "start_char": 3863, "end_char": 6883, "estimated_token_count": 706, "token_estimator": "heuristic-v1", "text": "## XCM Example\n\nThe following is a simplified XCM message demonstrating a token transfer from Alice to Bob on the same chain (ParaA).\n\n```rust\nlet message = Xcm(vec![\n    WithdrawAsset((Here, amount).into()),\n    BuyExecution { \n        fees: (Here, amount).into(), \n        weight_limit: WeightLimit::Unlimited \n    },\n    DepositAsset {\n        assets: All.into(),\n        beneficiary: MultiLocation {\n            parents: 0,\n            interior: Junction::AccountId32 {\n                network: None,\n                id: BOB.clone().into()\n            }.into(),\n        }.into()\n    }\n]);\n```\n\nThe message consists of three instructions described as follows:\n\n- **[WithdrawAsset](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#withdrawasset){target=\\_blank}**: Transfers a specified number of tokens from Alice's account to a holding register.\n\n    ```rust\n        WithdrawAsset((Here, amount).into()),\n    ```\n\n    - **`Here`**: The native parachain token.\n    - **`amount`**: The number of tokens that are transferred.\n\n    The first instruction takes as an input the MultiAsset that should be withdrawn. The MultiAsset describes the native parachain token with the `Here` keyword. The `amount` parameter is the number of tokens that are transferred. The withdrawal account depends on the origin of the message. In this example the origin of the message is Alice. The `WithdrawAsset` instruction moves `amount` number of native tokens from Alice's account into the holding register.\n\n- **[BuyExecution](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#buyexecution){target=\\_blank}**: Allocates fees to cover the execution [weight](/polkadot-protocol/glossary/#weight){target=\\_blank} of the XCM instructions.\n\n    ```rust\n        BuyExecution { \n            fees: (Here, amount).into(), \n            weight_limit: WeightLimit::Unlimited \n        },\n    ```\n\n    - **`fees`**: Describes the asset in the holding register that should be used to pay for the weight.\n    - **`weight_limit`**: Defines the maximum fees that can be used to buy weight.\n\n- **[DepositAsset](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#depositasset){target=\\_blank}**: Moves the remaining tokens from the holding register to Bob’s account.\n\n    ```rust\n        DepositAsset {\n            assets: All.into(),\n            beneficiary: MultiLocation {\n                parents: 0,\n                interior: Junction::AccountId32 {\n                    network: None,\n                    id: BOB.clone().into()\n                }.into(),\n            }.into()\n        }\n    ```\n\n    - **`All`**: The wildcard for the asset(s) to be deposited. In this case, all assets in the holding register should be deposited.\n    \nThis step-by-step process showcases how XCM enables precise state changes within a blockchain system. You can find a complete XCM message example in the [XCM repository](https://github.com/paritytech/xcm-docs/blob/main/examples/src/0_first_look/mod.rs){target=\\_blank}."}
{"page_id": "develop-interoperability-intro-to-xcm", "page_title": "Introduction to XCM", "index": 6, "depth": 2, "title": "Overview", "anchor": "overview", "start_char": 6883, "end_char": 7456, "estimated_token_count": 117, "token_estimator": "heuristic-v1", "text": "## Overview\n\nXCM revolutionizes cross-chain communication by enabling use cases such as:\n\n- Token transfers between blockchains.\n- Asset locking for cross-chain smart contract interactions.\n- Remote execution of functions on other blockchains.\n\nThese functionalities empower developers to build innovative, multi-chain applications, leveraging the strengths of various blockchain networks. To stay updated on XCM’s evolving format or contribute, visit the [XCM repository](https://github.com/paritytech/xcm-docs/blob/main/examples/src/0_first_look/mod.rs){target=\\_blank}."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 21, "end_char": 917, "estimated_token_count": 181, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nOne of the core FRAME pallets that enables parachains to engage in cross-chain communication using the Cross-Consensus Message (XCM) format is [`pallet-xcm`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/index.html){target=\\_blank}. It facilitates the sending, execution, and management of XCM messages, thereby allowing parachains to interact with other chains within the ecosystem. Additionally, `pallet-xcm`, also referred to as the XCM pallet, supports essential operations like asset transfers, version negotiation, and message routing.\n\nThis page provides a detailed overview of the XCM pallet's key features, its primary roles in XCM operations, and the main extrinsics it offers. Whether aiming to execute XCM messages locally or send them to external chains, this guide covers the foundational concepts and practical applications you need to know."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 1, "depth": 2, "title": "XCM Frame Pallet Overview", "anchor": "xcm-frame-pallet-overview", "start_char": 917, "end_char": 2612, "estimated_token_count": 439, "token_estimator": "heuristic-v1", "text": "## XCM Frame Pallet Overview\n\nThe [`pallet-xcm`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/index.html){target=\\_blank} provides a set of pre-defined, commonly used [XCVM programs](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#12-the-xcvm){target=\\_blank} in the form of a [set of extrinsics](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/dispatchables/index.html){target=\\blank}. This pallet provides some [default implementations](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html#implementations){target=\\_blank} for traits required by [`XcmConfig`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm_benchmarks/trait.Config.html#associatedtype.XcmConfig){target=\\_blank}. The [XCM executor](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/struct.XcmExecutor.html){target=\\_blank} is also included as an associated type within the pallet's configuration. \n\nFor further details about the XCM configuration, see the [XCM Configuration](/develop/interoperability/xcm-config/){target=\\_blank} page.\n\nWhere the [XCM format](https://github.com/polkadot-fellows/xcm-format){target=\\_blank} defines a set of instructions used to construct XCVM programs, `pallet-xcm` defines a set of extrinsics that can be utilized to build XCVM programs, either to target the local or external chains. The `pallet-xcm` functionality is divided into three categories:\n\n- **Primitive**: Dispatchable functions to execute XCM locally.\n- **High-level**: Functions for asset transfers between chains.\n- **Version negotiation-specific**: Functions for managing XCM version compatibility."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 2, "depth": 3, "title": "Key Roles of the XCM Pallet", "anchor": "key-roles-of-the-xcm-pallet", "start_char": 2612, "end_char": 3620, "estimated_token_count": 188, "token_estimator": "heuristic-v1", "text": "### Key Roles of the XCM Pallet\n\nThe XCM pallet plays a central role in managing cross-chain messages, with its primary responsibilities including:\n\n- **Execute XCM messages**: Interacts with the XCM executor to validate and execute messages, adhering to predefined security and filter criteria.\n- **Send messages across chains**: Allows authorized origins to send XCM messages, enabling controlled cross-chain communication.\n- **Reserve-based transfers and teleports**: Supports asset movement between chains, governed by filters that restrict operations to authorized origins.\n- **XCM version negotiation**: Ensures compatibility by selecting the appropriate XCM version for inter-chain communication.\n- **Asset trapping and recovery**: Manages trapped assets, enabling safe reallocation or recovery when issues occur during cross-chain transfers.\n- **Support for XCVM operations**: Oversees state and configuration requirements necessary for executing cross-consensus programs within the XCVM framework."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 3, "depth": 2, "title": "Primary Extrinsics of the XCM Pallet", "anchor": "primary-extrinsics-of-the-xcm-pallet", "start_char": 3620, "end_char": 3820, "estimated_token_count": 35, "token_estimator": "heuristic-v1", "text": "## Primary Extrinsics of the XCM Pallet\n\nThis page will highlight the two **Primary Primitive Calls** responsible for sending and executing XCVM programs as dispatchable functions within the pallet."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 4, "depth": 3, "title": "Execute", "anchor": "execute", "start_char": 3820, "end_char": 5071, "estimated_token_count": 298, "token_estimator": "heuristic-v1", "text": "### Execute\n\nThe [`execute`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Call.html#variant.execute){target=\\_blank} call directly interacts with the XCM executor, allowing for the execution of XCM messages originating from a locally signed origin. The executor validates the message, ensuring it complies with any configured barriers or filters before executing.\n\nOnce validated, the message is executed locally, and an event is emitted to indicate the result—whether the message was fully executed or only partially completed. Execution is capped by a maximum weight ([`max_weight`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Call.html#variant.execute.field.max_weight){target=\\_blank}); if the required weight exceeds this limit, the message will not be executed.\n\n```rust\npub fn execute<T: Config>(\n    message: Box<VersionedXcm<<T as Config>::RuntimeCall>>,\n    max_weight: Weight,\n)\n```\n\nFor further details about the `execute` extrinsic, see the [`pallet-xcm` documentation](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html){target=\\_blank}.\n\n!!!warning\n    Partial execution of messages may occur depending on the constraints or barriers applied."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 5, "depth": 3, "title": "Send", "anchor": "send", "start_char": 5071, "end_char": 6081, "estimated_token_count": 254, "token_estimator": "heuristic-v1", "text": "### Send\n\nThe [`send`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Call.html#variant.send){target=\\_blank} call enables XCM messages to be sent to a specified destination. This could be a parachain, smart contract, or any external system governed by consensus. Unlike the execute call, the message is not executed locally but is transported to the destination chain for processing.\n\nThe destination is defined using a [Location](https://paritytech.github.io/polkadot-sdk/master/xcm_docs/glossary/index.html#location){target=\\_blank}, which describes the target chain or system. This ensures precise delivery through the configured XCM transport mechanism.\n\n```rust\npub fn send<T: Config>(\n    dest: Box<MultiLocation>,\n    message: Box<VersionedXcm<<T as Config>::RuntimeCall>>,\n)\n```\n\nFor further information about the `send` extrinsic, see the [`pallet-xcm` documentation](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html){target=\\_blank}."}
{"page_id": "develop-interoperability-send-messages", "page_title": "Send XCM Messages", "index": 6, "depth": 2, "title": "XCM Router", "anchor": "xcm-router", "start_char": 6081, "end_char": 7146, "estimated_token_count": 240, "token_estimator": "heuristic-v1", "text": "## XCM Router\n\nThe [`XcmRouter`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/trait.Config.html#associatedtype.XcmRouter){target=\\_blank} is a critical component the XCM pallet requires to facilitate sending XCM messages. It defines where messages can be sent and determines the appropriate XCM transport protocol for the operation.\n\nFor instance, the Kusama network employs the [`ChildParachainRouter`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_common/xcm_sender/struct.ChildParachainRouter.html){target=\\_blank}, which restricts routing to [Downward Message Passing (DMP)](https://wiki.polkadot.com/learn/learn-xcm-transport/#dmp-downward-message-passing){target=\\_blank} from the relay chain to parachains, ensuring secure and controlled communication.\n\n```rust\npub type PriceForChildParachainDelivery =\n\tExponentialPrice<FeeAssetId, BaseDeliveryFee, TransactionByteFee, Dmp>;\n```\n\nFor more details about XCM transport protocols, see the [XCM Channels](/develop/interoperability/xcm-channels/){target=\\_blank} page."}
{"page_id": "develop-interoperability-test-and-debug", "page_title": "Testing and Debugging", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 25, "end_char": 875, "estimated_token_count": 162, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nCross-Consensus Messaging (XCM) is a core feature of the Polkadot ecosystem, enabling communication between parachains, relay chains, and system chains. To ensure the reliability of XCM-powered blockchains, thorough testing and debugging are essential before production deployment.\n\nThis guide covers the XCM Emulator, a tool designed to facilitate onboarding and testing for developers. Use the emulator if:\n\n- A live runtime is not yet available.\n- Extensive configuration adjustments are needed, as emulated chains differ from live networks.\n- Rust-based tests are preferred for automation and integration.\n\nFor scenarios where real blockchain state is required, [Chopsticks](/tutorials/polkadot-sdk/testing/fork-live-chains/#xcm-testing){target=\\_blank} allows testing with any client compatible with Polkadot SDK-based chains."}
{"page_id": "develop-interoperability-test-and-debug", "page_title": "Testing and Debugging", "index": 1, "depth": 2, "title": "XCM Emulator", "anchor": "xcm-emulator", "start_char": 875, "end_char": 2026, "estimated_token_count": 225, "token_estimator": "heuristic-v1", "text": "## XCM Emulator\n\nSetting up a live network with multiple interconnected parachains for XCM testing can be complex and resource-intensive. \n\nThe [`xcm-emulator`](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506-2/cumulus/xcm/xcm-emulator){target=\\_blank} is a tool designed to simulate the execution of XCM programs using predefined runtime configurations. These configurations include those utilized by live networks like Kusama, Polkadot, and Asset Hub.\n\nThis tool enables testing of cross-chain message passing, providing a way to verify outcomes, weights, and side effects efficiently. It achieves this by utilizing mocked runtimes for both the relay chain and connected parachains, enabling developers to focus on message logic and configuration without needing a live network.\n\nThe `xcm-emulator` relies on transport layer pallets. However, the messages do not leverage the same messaging infrastructure as live networks since the transport mechanism is mocked. Additionally, consensus-related events are not covered, such as disputes and staking events. Parachains should use end-to-end (E2E) tests to validate these events."}
{"page_id": "develop-interoperability-test-and-debug", "page_title": "Testing and Debugging", "index": 2, "depth": 3, "title": "Advantages and Limitations", "anchor": "advantages-and-limitations", "start_char": 2026, "end_char": 3130, "estimated_token_count": 219, "token_estimator": "heuristic-v1", "text": "### Advantages and Limitations\n\nThe XCM Emulator provides both advantages and limitations when testing cross-chain communication in simulated environments.\n\n- **Advantages**:\n    - **Interactive debugging**: Offers tracing capabilities similar to EVM, enabling detailed analysis of issues.\n    - **Runtime composability**: Facilitates testing and integration of multiple runtime components.\n    - **Immediate feedback**: Supports Test-Driven Development (TDD) by providing rapid test results.\n    - **Seamless integration testing**: Simplifies the process of testing new runtime versions in an isolated environment.\n\n- **Limitations**:\n    - **Simplified emulation**: Always assumes message delivery, which may not mimic real-world network behavior.\n    - **Dependency challenges**: Requires careful management of dependency versions and patching. Refer to the [Cargo dependency documentation](https://doc.rust-lang.org/cargo/reference/overriding-dependencies.html){target=\\_blank}.\n    - **Compilation overhead**: Testing environments can be resource-intensive, requiring frequent compilation updates."}
{"page_id": "develop-interoperability-test-and-debug", "page_title": "Testing and Debugging", "index": 3, "depth": 3, "title": "How Does It Work?", "anchor": "how-does-it-work", "start_char": 3130, "end_char": 7729, "estimated_token_count": 881, "token_estimator": "heuristic-v1", "text": "### How Does It Work?\n\nThe `xcm-emulator` provides macros for defining a mocked testing environment. Check all the existing macros and functionality in the [XCM Emulator source code](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506-2/cumulus/xcm/xcm-emulator/src/lib.rs){target=\\_blank}. The most important macros are:\n\n- **[`decl_test_relay_chains`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506-2/cumulus/xcm/xcm-emulator/src/lib.rs#L361){target=\\_blank}**: Defines runtime and configuration for the relay chains. Example:\n\n    ```rust\n    decl_test_relay_chains! {\n    \t#[api_version(13)]\n    \tpub struct Westend {\n    \t\tgenesis = genesis::genesis(),\n    \t\ton_init = (),\n    \t\truntime = westend_runtime,\n    \t\tcore = {\n    \t\t\tSovereignAccountOf: westend_runtime::xcm_config::LocationConverter,\n    \t\t},\n    \t\tpallets = {\n    \t\t\tXcmPallet: westend_runtime::XcmPallet,\n    \t\t\tSudo: westend_runtime::Sudo,\n    \t\t\tBalances: westend_runtime::Balances,\n    \t\t\tTreasury: westend_runtime::Treasury,\n    \t\t\tAssetRate: westend_runtime::AssetRate,\n    \t\t\tHrmp: westend_runtime::Hrmp,\n    \t\t\tIdentity: westend_runtime::Identity,\n    \t\t\tIdentityMigrator: westend_runtime::IdentityMigrator,\n    \t\t}\n    \t},\n    }\n    ```\n\n- **[`decl_test_parachains`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506-2/cumulus/xcm/xcm-emulator/src/lib.rs#L596){target=\\_blank}**: Defines runtime and configuration for parachains. Example:\n\n    ```rust\n    decl_test_parachains! {\n    \tpub struct AssetHubWestend {\n    \t\tgenesis = genesis::genesis(),\n    \t\ton_init = {\n    \t\t\tasset_hub_westend_runtime::AuraExt::on_initialize(1);\n    \t\t},\n    \t\truntime = asset_hub_westend_runtime,\n    \t\tcore = {\n    \t\t\tXcmpMessageHandler: asset_hub_westend_runtime::XcmpQueue,\n    \t\t\tLocationToAccountId: asset_hub_westend_runtime::xcm_config::LocationToAccountId,\n    \t\t\tParachainInfo: asset_hub_westend_runtime::ParachainInfo,\n    \t\t\tMessageOrigin: cumulus_primitives_core::AggregateMessageOrigin,\n    \t\t\tDigestProvider: (),\n    \t\t},\n    \t\tpallets = {\n    \t\t\tPolkadotXcm: asset_hub_westend_runtime::PolkadotXcm,\n    \t\t\tBalances: asset_hub_westend_runtime::Balances,\n    \t\t\tAssets: asset_hub_westend_runtime::Assets,\n    \t\t\tForeignAssets: asset_hub_westend_runtime::ForeignAssets,\n    \t\t\tPoolAssets: asset_hub_westend_runtime::PoolAssets,\n    \t\t\tAssetConversion: asset_hub_westend_runtime::AssetConversion,\n    \t\t\tSnowbridgeSystemFrontend: asset_hub_westend_runtime::SnowbridgeSystemFrontend,\n    \t\t\tRevive: asset_hub_westend_runtime::Revive,\n    \t\t}\n    \t},\n    }\n    ```\n\n- **[`decl_test_bridges`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506-2/cumulus/xcm/xcm-emulator/src/lib.rs#L1221){target=\\_blank}**: Creates bridges between chains, specifying the source, target, and message handler. Example:\n\n    ```rust\n    decl_test_bridges! {\n    \tpub struct RococoWestendMockBridge {\n    \t\tsource = BridgeHubRococoPara,\n    \t\ttarget = BridgeHubWestendPara,\n    \t\thandler = RococoWestendMessageHandler\n    \t},\n    \tpub struct WestendRococoMockBridge {\n    \t\tsource = BridgeHubWestendPara,\n    \t\ttarget = BridgeHubRococoPara,\n    \t\thandler = WestendRococoMessageHandler\n    \t}\n    }\n    ```\n\n- **[`decl_test_networks`](https://github.com/paritytech/polkadot-sdk/blob/polkadot-stable2506-2/cumulus/xcm/xcm-emulator/src/lib.rs#L958){target=\\_blank}**: Defines a testing network with relay chains, parachains, and bridges, implementing message transport and processing logic. Example:\n\n    ```rust\n    decl_test_networks! {\n    \tpub struct WestendMockNet {\n    \t\trelay_chain = Westend,\n    \t\tparachains = vec![\n    \t\t\tAssetHubWestend,\n    \t\t\tBridgeHubWestend,\n    \t\t\tCollectivesWestend,\n    \t\t\tCoretimeWestend,\n    \t\t\tPeopleWestend,\n    \t\t\tPenpalA,\n    \t\t\tPenpalB,\n    \t\t],\n    \t\tbridge = ()\n    \t},\n    }\n    ```\n\nBy leveraging these macros, developers can customize their testing networks by defining relay chains and parachains tailored to their needs. For guidance on implementing a mock runtime for a Polkadot SDK-based chain, refer to the [Pallet Testing](/develop/parachains/testing/pallet-testing/){target=\\_blank} article. \n\nThis framework enables thorough testing of runtime and cross-chain interactions, enabling developers to effectively design, test, and optimize cross-chain functionality.\n\nTo see a complete example of implementing and executing tests, refer to the [integration tests](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506-2/cumulus/parachains/integration-tests/emulated){target=\\_blank} in the Polkadot SDK repository."}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 0, "depth": 2, "title": "The problem before v5", "anchor": "the-problem-before-v5", "start_char": 446, "end_char": 932, "estimated_token_count": 102, "token_estimator": "heuristic-v1", "text": "## The problem before v5\n\nWhen XCM execution failed and assets became trapped:\n\n- **Governance dependency**: Most trapped asset recovery requires governance proposals.\n- **Complex procedures**: Manual intervention through referendum processes.\n- **Long delays**: Recovery could take weeks or months through governance.\n- **Risk of loss**: Assets could remain permanently trapped if governance didn't act.\n- **High barriers**: Small amounts often weren't worth the governance overhead."}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 1, "depth": 2, "title": "The V5 Solution: `AssetClaimer` Hint", "anchor": "the-v5-solution-assetclaimer-hint", "start_char": 932, "end_char": 1343, "estimated_token_count": 101, "token_estimator": "heuristic-v1", "text": "## The V5 Solution: `AssetClaimer` Hint\n\nThe new [`AssetClaimer`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Hint.html#variant.AssetClaimer){target=\\_blank} hint allows XCM programs to preemptively designate who can claim trapped assets:\n\n```typescript\n// Set asset claimer before risky operations\nXcmV5Instruction.SetHints({ \n  hints: [Enum('AssetClaimer', claimerLocation)] \n})\n```"}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 2, "depth": 2, "title": "How it Improves the Situation", "anchor": "how-it-improves-the-situation", "start_char": 1343, "end_char": 2490, "estimated_token_count": 222, "token_estimator": "heuristic-v1", "text": "## How it Improves the Situation\n\nThe `AssetClaimer` hint transforms the recovery process by allowing proactive designation of claimers, eliminating the need for governance intervention in most cases.\n\n- **Before XCM V5:**\n\n    ```typescript\n    // If this XCM fails, assets become trapped\n    const riskyXcm = [\n        XcmInstruction.WithdrawAsset([assets]),\n        XcmInstruction.BuyExecution({ fees, weight_limit }),\n        XcmInstruction.Transact({ /* risky call */ }),\n        XcmInstruction.DepositAsset({ assets, beneficiary })\n    ]\n\n    // Recovery required governance intervention\n    ```\n\n- **With XCM V5:**\n\n    ```typescript\n    // Proactive asset claimer setup\n    const saferXcm = [\n        // Anyone can now claim if execution fails\n        XcmV5Instruction.SetHints({ \n            hints: [Enum('AssetClaimer', claimerLocation)] \n        }),\n        XcmV5Instruction.WithdrawAsset([assets]),\n        XcmV5Instruction.PayFees({ asset }),\n        XcmV5Instruction.Transact({ /* risky call */ }),\n        XcmV5Instruction.DepositAsset({ assets, beneficiary })\n    ]\n\n    // Recovery can be done immediately by the claimer\n    ```"}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 3, "depth": 2, "title": "Key Improvements", "anchor": "key-improvements", "start_char": 2490, "end_char": 3242, "estimated_token_count": 168, "token_estimator": "heuristic-v1", "text": "## Key Improvements\n\nThe `AssetClaimer` hint addresses several critical pain points in trapped asset recovery, transforming the process from governance-dependent to user-controlled.\n\n| Feature | Before XCM V5 | After XCM V5 |\n| :-----: | :-----------: | :----------: |\n| **Recovery Speed** | Wait for governance process (weeks/months) | Designated claimer can act immediately |\n| **Governance Burden** | Every trapped asset requires a governance proposal | Only complex cases need governance intervention |\n| **Recovery Predictability** | Uncertain if governance would approve recovery | Predetermined claimer provides certainty |\n| **Accessibility** | Small amounts are often not worth governance overhead | Any amount can be efficiently recovered |"}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 4, "depth": 2, "title": "Best Practices", "anchor": "best-practices", "start_char": 3242, "end_char": 3398, "estimated_token_count": 26, "token_estimator": "heuristic-v1", "text": "## Best Practices\n\nFollowing these best practices ensures effective use of the `AssetClaimer` hint and maximizes the benefits of automated asset recovery."}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 5, "depth": 3, "title": "Set Hint Early", "anchor": "set-hint-early", "start_char": 3398, "end_char": 3767, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "### Set Hint Early\n\nAlways set the `AssetClaimer` hint before any operations that might fail, ensuring trapped assets can be recovered immediately without governance intervention.\n\n```typescript\n// Set claimer hint before any risky operations\nXcmV5Instruction.SetHints({ hints: [Enum('AssetClaimer', claimerLocation)] }),\n// ... other instructions that might fail\n```"}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 6, "depth": 3, "title": "Use for Cross-Chain Transfers", "anchor": "use-for-cross-chain-transfers", "start_char": 3767, "end_char": 4151, "estimated_token_count": 87, "token_estimator": "heuristic-v1", "text": "### Use for Cross-Chain Transfers\n\nParticularly useful for setting local accounts on destination chains:\n\n```typescript\n// In remote_xcm for cross-chain transfers\nconst remoteXcm = [\n  XcmV5Instruction.SetHints({ \n    hints: [Enum('AssetClaimer', {\n      parents: 0,\n      interior: { X1: { AccountId32: { id: localAccountId } } }\n    })] \n  }),\n  // ... transfer instructions\n]\n```"}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 7, "depth": 3, "title": "Consider Origin Preservation", "anchor": "consider-origin-preservation", "start_char": 4151, "end_char": 4344, "estimated_token_count": 29, "token_estimator": "heuristic-v1", "text": "### Consider Origin Preservation\n\nWhen origin preservation is available, trapped assets are automatically associated with the original origin, making claiming easier without additional hints."}
{"page_id": "develop-interoperability-versions-v5-asset-claimer", "page_title": "Asset claimer", "index": 8, "depth": 2, "title": "Migration Impact", "anchor": "migration-impact", "start_char": 4344, "end_char": 5080, "estimated_token_count": 143, "token_estimator": "heuristic-v1", "text": "## Migration Impact\n\nThe introduction of the `AssetClaimer` hint represents a significant improvement in XCM's fault tolerance and user experience, making cross-chain operations safer and more predictable.\n\nThis change makes XCM programs more resilient and user-friendly:\n\n- **Reduced risk**: Assets are less likely to be permanently lost.\n- **Better UX**: Users can recover their own assets without waiting for governance.\n- **Increased adoption**: Lower risk encourages more XCM usage.\n- **Operational efficiency**: Reduces governance workload for routine recoveries.\n\nThe `AssetClaimer` hint represents a significant improvement in XCM's fault tolerance and user experience, making cross-chain operations safer and more predictable."}
{"page_id": "develop-interoperability-versions-v5-fees", "page_title": "Fees", "index": 0, "depth": 2, "title": "Key Changes from V4", "anchor": "key-changes-from-v4", "start_char": 153, "end_char": 562, "estimated_token_count": 108, "token_estimator": "heuristic-v1", "text": "## Key Changes from V4\n\nXCM V5 replaces the [`BuyExecution`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.BuyExecution){target=\\_blank} instruction with a more predictable [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.PayFees){target=\\_blank} approach that handles both execution and delivery fees."}
{"page_id": "develop-interoperability-versions-v5-fees", "page_title": "Fees", "index": 1, "depth": 3, "title": "BuyExecution vs. PayFees", "anchor": "buyexecution-vs-payfees", "start_char": 562, "end_char": 1160, "estimated_token_count": 121, "token_estimator": "heuristic-v1", "text": "### BuyExecution vs. PayFees\n\n- **XCM V4 Approach:**\n\n    - Used `BuyExecution` instruction that handles only execution fees.\n    - Leftover assets after buying execution are returned to holding.\n    - Required explicit specification of execution weight limits.\n    - Delivery fees may not be found, and an error may occur.\n\n- **XCM V5 Approach:**\n\n    - Introduces `PayFees` instruction for unified fee handling.\n    - All assets passed to `PayFees` are kept in a special `fees` register; they are _NOT_ returned to holding.\n    - No need to specify weights, only assets.\n    - More predictable."}
{"page_id": "develop-interoperability-versions-v5-fees", "page_title": "Fees", "index": 2, "depth": 3, "title": "PayFees Instruction", "anchor": "payfees-instruction", "start_char": 1160, "end_char": 1759, "estimated_token_count": 135, "token_estimator": "heuristic-v1", "text": "### PayFees Instruction\n\nThe new `PayFees` instruction provides a cleaner interface:\n\n```typescript\n// XCM V5 - New PayFees instruction\nXcmV5Instruction.PayFees({\n  asset: {\n    id: // Asset id for fee payment\n    fun: // Amount to dedicate for fees (both execution + delivery)\n  },\n})\n```\n\nThis replaces the more complex `BuyExecution` pattern:\n\n```typescript\n// XCM V4 - BuyExecution instruction\nXcmV4Instruction.BuyExecution({\n  fees: {\n    id: // Asset id\n    fun: // Fee amount (only execution will be charged, rest is returned to holding)\n  },\n  weight_limit: // Explicit weight limit\n})\n```"}
{"page_id": "develop-interoperability-versions-v5-fees", "page_title": "Fees", "index": 3, "depth": 2, "title": "Backward Compatibility", "anchor": "backward-compatibility", "start_char": 1759, "end_char": 2099, "estimated_token_count": 58, "token_estimator": "heuristic-v1", "text": "## Backward Compatibility\n\nXCM V5 maintains backward compatibility with `BuyExecution` for existing implementations. Both instructions are supported, allowing gradual migration:\n\n- **BuyExecution**: Still supported for compatibility with existing XCM programs.\n- **PayFees**: Recommended for new development and simplified fee management."}
{"page_id": "develop-interoperability-versions-v5-fees", "page_title": "Fees", "index": 4, "depth": 2, "title": "Migration Considerations", "anchor": "migration-considerations", "start_char": 2099, "end_char": 2681, "estimated_token_count": 121, "token_estimator": "heuristic-v1", "text": "## Migration Considerations\n\nWhen migrating from XCM V4 to XCM V5:\n\n- `BuyExecution` can remain in existing programs.\n- New programs should use `PayFees` for better maintainability.\n- Fee estimation becomes more straightforward with the new approach.\n- No breaking changes to existing functionality.\n\nWhen using `PayFees`, keep in mind that _ALL_ assets passed to the instruction will be entirely dedicated to fees, not returned to holding.\nThat's why it's more important than before to [to estimate XCM fees properly](/develop/interoperability/xcm-runtime-apis/){target=\\_blank}."}
{"page_id": "develop-interoperability-versions-v5-fees", "page_title": "Fees", "index": 5, "depth": 2, "title": "`RefundSurplus` Instruction", "anchor": "refundsurplus-instruction", "start_char": 2681, "end_char": 4145, "estimated_token_count": 333, "token_estimator": "heuristic-v1", "text": "## `RefundSurplus` Instruction\n\nWhen you overestimate fees with [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.PayFees){target=\\_blank}, you can recover unused funds using the [`RefundSurplus`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.RefundSurplus){target=\\_blank} instruction.\n\nYou can use `RefundSurplus` to put the leftover fees back into holding. This is useful when you've overestimated the fees needed for your XCM program. You can then deposit them into some account with [`DepositAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.DepositAsset){target=\\_blank}.\n\n```typescript\n// After all instructions that send messages.\nXcmV5Instruction.RefundSurplus(),\nXcmV5Instruction.DepositAsset({\n  assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.All()),\n  beneficiary: {\n    parents: 0,\n    interior: XcmV5Junctions.X1(\n      XcmV5Junction.AccountId32({\n        id: ACCOUNT,\n        network: undefined,\n      }),\n    ),\n  }\n})\n```\n\nThe `RefundSurplus` instruction:\n\n- Takes any unused fees from the fees register.\n- Moves them back to the holding register.\n- Allows you to use or return the surplus assets with `DepositAsset`.\n\nThis is especially important with `PayFees` since all assets passed to it are dedicated to fees, unlike `BuyExecution` which automatically returned unused assets to holding."}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 0, "depth": 2, "title": "When to migrate", "anchor": "when-to-migrate", "start_char": 245, "end_char": 1319, "estimated_token_count": 240, "token_estimator": "heuristic-v1", "text": "## When to migrate\n\nMigrating to XCM V5 provides significant benefits, so migration is recommended as soon as possible.\n\nWhether migration is possible depends mainly on if the target chains have already upgraded to XCM V5 or not.\n\nTo determine whether a chain supports XCM V5:\n\n- Read the changelog.\n- Explore the metadata with PAPI's descriptors.\n- Explore the metadata with a tool like [subwasm](https://github.com/chevdor/subwasm){target=\\_blank}.\n\nFor example, when generating PAPI descriptors for a chain, you can check if the `XcmVersionedXcm` known type has the V5 variant.\n\n```bash\nnpx papi add myChain -w <INSERT_RPC_WEB_SOCKET_ENDPOINT>\n```\n\nEnsure to replace the `<INSERT_RPC_WEB_SOCKET_ENDPOINT>` with the actual RPC web socket endpoint of the chain.\n\nAlternatively, you can navigate to the [PAPI developer console](https://dev.papi.how/extrinsics){target=\\_blank}, connect to the chain, and under extrinsics choose `PolkadotXcm -> execute` and check for the V5 variant:\n\n![](/images/develop/interoperability/versions/v5/migration-guide/check-xcm-version.webp)"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 1, "depth": 2, "title": "Key Changes", "anchor": "key-changes", "start_char": 1319, "end_char": 1335, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Key Changes"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 2, "depth": 3, "title": "From Dedicated Extrinsics to Raw XCMs", "anchor": "from-dedicated-extrinsics-to-raw-xcms", "start_char": 1335, "end_char": 3773, "estimated_token_count": 565, "token_estimator": "heuristic-v1", "text": "### From Dedicated Extrinsics to Raw XCMs\n\nWith XCM V5, the ecosystem is shifting toward writing XCM programs directly instead of relying on an ever-increasing number of custom extrinsics.\n\n- **Before (XCM V4)**:\n\n    ```typescript\n    // Multiple extrinsics for different scenarios\n    api.tx.xcmPallet.teleportAssets(...)\n    api.tx.xcmPallet.limitedReserveTransferAssets(...)\n    api.tx.xcmPallet.limitedTeleportAssets(...)\n    ```\n\n- **After (XCM V5)**:\n\n    ```typescript\n    // Single pattern: craft XCM + execute\n    const xcm = XcmVersionedXcm.V5([\n    XcmV5Instruction.WithdrawAsset([...]),\n    XcmV5Instruction.PayFees({...}),\n    XcmV5Instruction.InitiateTransfer({...}),\n    ]);\n    const weight = api.apis.XcmPaymentApi.query_xcm_weight(xcm);\n\n    api.tx.PolkadotXcm.execute({\n    message: xcm,\n    max_weight: weight.value,\n    });\n    ```\n\nMigration Impact:\n\n- More verbose but significantly more flexible.\n- Need to calculate weights using runtime APIs.\n- Better control over execution flow.\n\n!!! note \"Is this `execute` new?\"\n\n    The XCM pallet has always had it, however, in previous versions of XCM (2 and below) it wasn't safe\n    to have it enabled for anyone to use. That's why some chains might have it disabled.\n\nThis approach adds more flexibility but clearly requires the developer to know how to build XCMs.\nIf XCM construction is unfamiliar, this approach enables other developers to build SDKs that handle these complexities.\n\nFor example, the [Paraspell SDK](https://paraspell.xyz){target=\\_blank} enables cross-chain transfers (and much more!) with a very simple API. The following example transfers 10 DOT from Asset Hub Polkadot to Hydration chain using the Paraspell SDK's builder pattern:\n\n```typescript\nimport { Builder } from '@paraspell/sdk';\n\nconst tx = await Builder()\n    .from('AssetHubPolkadot')\n    .to('Hydration')\n    .currency({ symbol: 'DOT', amount: '10000000000' })\n    .address(beneficiary)\n    .build();\nconst result = await tx.signAndSubmit(signer);\n```\n\n!!! note \"Are the extrinsics going away?\"\n\n    No! The extrinsics will continue to be supported in the XCM pallet for an undefined period of time. Although it is expected that as more chains support XCM V5 and more dApp developers use [execute](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html#method.execute){target=\\_blank},\n    they'll reap the benefits and no longer require extrinsics."}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 3, "depth": 3, "title": "Unified Transfer Instructions", "anchor": "unified-transfer-instructions", "start_char": 3773, "end_char": 4793, "estimated_token_count": 188, "token_estimator": "heuristic-v1", "text": "### Unified Transfer Instructions\n\nBeyond the shift to direct XCM execution, XCM V5 also consolidates transfer operations into a single, more powerful instruction.\n\n- **Before (XCM V4)**:\n\n    ```typescript\n    // Different instructions for different transfer types\n    XcmV4Instruction.InitiateTeleport({\n    assets,\n    dest: destination,\n    xcm: remoteXcm,\n    })\n\n    XcmV4Instruction.InitiateReserveWithdraw({\n    assets,\n    reserve: reserveLocation,\n    xcm: remoteXcm,\n    })\n    ```\n\n- **After (XCM V5)**:\n\n    ```typescript\n    // Single instruction with transfer type specified per asset.\n    XcmV5Instruction.InitiateTransfer({\n    destination: destination,\n    remote_fees: Enum('Teleport', feeAssets),\n    assets: [\n        Enum('Teleport', teleportAssets),\n        Enum('ReserveWithdraw', reserveAssets),\n    ],\n    remote_xcm: remoteXcm,\n    preserve_origin: false,\n    })\n    ```\n\nMigration Benefits:\n\n- Different transfer types in single operation\n- Clearer fee handling\n- Origin preservation option"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 4, "depth": 3, "title": "Predictable fee payment", "anchor": "predictable-fee-payment", "start_char": 4793, "end_char": 7410, "estimated_token_count": 550, "token_estimator": "heuristic-v1", "text": "### Predictable fee payment\n\n- **Before (XCM V4)**:\n\n    ```typescript\n    // Fees embedded in transfer instructions.\n    // Limited control over fee allocation.\n    api.tx.xcmPallet.limitedTeleportAssets({\n    dest: destination,\n    beneficiary: beneficiary,\n    assets: assets,\n    fee_asset_item: 0, // Index-based fee selection.\n    weight_limit: weightLimit,\n    })\n    ```\n\n- **After (XCM V5)**:\n\n    ```typescript\n    // Explicit fee management.\n    XcmV5Instruction.PayFees({\n    asset: {\n        id: feeAssetId,\n        fun: XcmV3MultiassetFungibility.Fungible(feeAmount),\n    },\n    }),\n    // Remote fees handled in InitiateTransfer\n    XcmV5Instruction.InitiateTransfer({\n    ...,\n    remote_fees: Enum('Teleport', remoteFeeAssets),\n    ...,\n    });\n    ```\n\nMigration Benefits:\n\n- Precise fee control\n- Multi-hop fee planning\n- Better fee estimation support\n\nThe old `BuyExecution` instruction looks like this:\n\n```typescript\nXcmV4Instruction.BuyExecution({\n    fees: {\n        id: feeAssetId,\n        fun: XcmV3MultiassetFungibility.Fungible(feeAmount),\n    },\n    weight_limit: XcmV3WeightLimit.Unlimited(),\n});\n```\n\nThe new `PayFees` instruction just has the asset for fee payment. The `weight_limit` parameter has historically been set to `Unlimited` due to the difficulty in estimating weight and the fees being sufficient to limit the maximum execution cost.\n\nThere is another key difference between `PayFees` and `BuyExecution`:\n\n- With `BuyExecution`, if too much was supplied for fees, the leftover after paying for execution would be returned to the [holding register](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/struct.XcmExecutor.html#method.holding) to be used in the rest of the XCM.\n- With `PayFees`, the full amount put into `assets` is stored in the fees register; nothing is returned to the holding register.\n\nThis means the full amount intended for fee payment must be specified. It makes it much more predictable. For example, withdrawing 11 DOT with 1 DOT in `PayFees` ensures exactly 10 DOT is sent.\n\nThe reason for this is the introduction of **delivery fees**, which are charged in addition to **execution fees**. Delivery fees are charged the moment an instruction is encountered that results in sending a new XCM. That's why fees can't be returned to the holding register as before; they need to be kept in the new fees register.\n\n!!! note \"Is BuyExecution going away?\"\n\n    No! As with many things in XCM V5, the old instruction is kept for backwards compatibility. However, it is planned for removal in future versions, once enough time has passed."}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 5, "depth": 2, "title": "Migration Examples", "anchor": "migration-examples", "start_char": 7410, "end_char": 7535, "estimated_token_count": 22, "token_estimator": "heuristic-v1", "text": "## Migration Examples\n\nThese practical examples demonstrate how to convert existing XCM V4 code to the new XCM V5 patterns."}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 6, "depth": 3, "title": "Simple Teleport", "anchor": "simple-teleport", "start_char": 7535, "end_char": 9768, "estimated_token_count": 462, "token_estimator": "heuristic-v1", "text": "### Simple Teleport\n\nThis example shows the basic migration from XCM V4's `limitedTeleportAssets` extrinsic to XCM V5's manual XCM construction using `PayFees` and `InitiateTransfer`.\n\n- **XCM V4 Code**:\n\n    ```typescript\n    const tx = api.tx.xcmPallet.limitedTeleportAssets({\n    dest: XcmVersionedLocation.V4({ parents: 1, interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(1000))}),\n    beneficiary: XcmVersionedLocation.V4({\n        parents: 0,\n        interior: XcmV3Junctions.X1(XcmV3Junction.AccountId32({ id: beneficiaryId, network: undefined })),\n    }),\n    assets: XcmVersionedAssets.V4([{ \n        id: { parents: 1, interior: XcmV3Junctions.Here() },\n        fun: XcmV3MultiassetFungibility.Fungible(amount),\n    ]),\n    fee_asset_item: 0,\n    weight_limit: XcmV3WeightLimit.Unlimited(),\n    });\n    ```\n\n- **XCM V5 Equivalent**:\n\n    ```typescript\n    const xcm = XcmVersionedXcm.V5([\n    XcmV5Instruction.WithdrawAsset([{\n        id: { parents: 1, interior: XcmV3Junctions.Here() },\n        fun: XcmV3MultiassetFungibility.Fungible(amount),\n    }]),\n    XcmV5Instruction.PayFees({\n        asset: {\n        id: { parents: 1, interior: XcmV3Junctions.Here() },\n        fun: XcmV3MultiassetFungibility.Fungible(feeAmount),\n        },\n    }),\n    XcmV5Instruction.InitiateTransfer({\n        destination: { parents: 1, interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(1000)) },\n        remote_fees: Enum('Teleport', XcmV5AssetFilter.Definite([{\n        id: { parents: 1, interior: XcmV3Junctions.Here() },\n        fun: XcmV3MultiassetFungibility.Fungible(remoteFeeAmount),\n        }])),\n        preserve_origin: false,\n        assets: [Enum('Teleport', XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)))],\n        remote_xcm: [\n        XcmV5Instruction.DepositAsset({\n            assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n            beneficiary: {\n            parents: 0,\n            interior: XcmV3Junctions.X1(XcmV3Junction.AccountId32({\n                id: beneficiaryId,\n                network: undefined,\n            })),\n            },\n        }),\n        ],\n    }),\n    ]);\n\n    const tx = api.tx.PolkadotXcm.execute({\n    message: xcm,\n    max_weight: calculatedWeight,\n    });\n    ```"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 7, "depth": 3, "title": "Example 2: Multi-Asset Transfer and a Transact", "anchor": "example-2-multi-asset-transfer-and-a-transact", "start_char": 9768, "end_char": 10773, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "### Example 2: Multi-Asset Transfer and a Transact\n\nThis example shows how XCM V5 enables combining multiple asset transfers with different transfer types while executing calls on the destination chain.\n\n- **New in XCM V5 - No XCM V4 equivalent**:\n\n    ```typescript\n    // This pattern wasn't possible in v4\n    XcmV5Instruction.InitiateTransfer({\n    destination: destination,\n    remote_fees: Enum('ReserveDeposit', ethFees), // Fee with different transfer type\n    assets: [\n        Enum('Teleport', dotAssets),           // Teleport DOT\n        Enum('ReserveDeposit', usdtAssets),    // Reserve transfer USDT\n        Enum('ReserveDeposit', usdcAssets),    // Reserve transfer USDC\n    ],\n    preserve_origin: true, // Enable cross-chain calls\n    remote_xcm: [\n        // Can now call functions on destination!\n        XcmV5Instruction.Transact({\n        origin_kind: XcmV2OriginKind.SovereignAccount(),\n        call: encodedCall,\n        fallback_max_weight: ...,\n        }),\n    ],\n    })\n    ```"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 8, "depth": 2, "title": "Breaking Changes to Watch Out For", "anchor": "breaking-changes-to-watch-out-for", "start_char": 10773, "end_char": 10811, "estimated_token_count": 8, "token_estimator": "heuristic-v1", "text": "## Breaking Changes to Watch Out For"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 9, "depth": 3, "title": "`fallback_max_weight` in `Transact`", "anchor": "fallback_max_weight-in-transact", "start_char": 10811, "end_char": 12377, "estimated_token_count": 292, "token_estimator": "heuristic-v1", "text": "### `fallback_max_weight` in `Transact`\n\nThe `Transact` instruction has been updated in XCM V5 to reduce the likelihood of bugs when executing calls on remote chains.\n\nThe `Transact` instruction looked like this in XCM V4:\n\n- **XCM V4:**\n\n    ```typescript\n    XcmV4Instruction.Transact({\n    call: encodedCall,\n    origin_kind: XcmV2OriginKind.SovereignAccount(),\n    require_weight_at_most: { ref_time: 1_000_000_000, proof_size: 100_000 }, // Required.\n    });\n    ```\n\n- **XCM V5:**\n\n    ```typescript\n    XcmV5Instruction.Transact({\n        call: encodedCall,\n        origin_kind: XcmV2OriginKind.SovereignAccount(),\n        fallback_max_weight: { ref_time: 1_000_000_000, proof_size: 100_000 }, // Optional.\n    });\n    ```\n\nThe old `require_weight_at_most` parameter caused frequent failures:\n\n- Runtime upgrades broke XCMs: When destination chains updated their runtime weights, existing XCMs would fail.\n- Hard to estimate correctly: Developers had to guess call weights for remote chains.\n- Maintenance burden: Weight values needed constant updates across chain upgrades.\n\nNew behavior:\n\n- Automatic weight calculation: XCM V5-compatible chains calculate call weights automatically when decoding the message.\n- Fallback compatibility: The optional `fallback_max_weight` is only used when the destination chain hasn't upgraded to XCM V5 yet.\n- Fail-safe design: If weight calculation fails, the fallback value is used.\n\nThis change makes `Transact` more reliable and reduces the maintenance burden of keeping weight values current across runtime upgrades."}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 10, "depth": 3, "title": "Network IDs Cleanup", "anchor": "network-ids-cleanup", "start_char": 12377, "end_char": 13310, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "### Network IDs Cleanup\n\nThis change affects how testnet networks are referenced in XCM.\n\nThe network IDs, used in the `GlobalConsensus` junction, for `Rococo` and `Westend` were removed. Instead, the generic `ByGenesis` network ID should be used for referencing testnets. This change was made because testnets come and go, as was shown by the [removal of Rococo](https://forum.polkadot.network/t/rococo-to-be-deprecated-in-october/8702) and [appearance of Paseo](https://forum.polkadot.network/t/the-new-polkadot-community-testnet/4956). From now on, only mainnets will have an explicit network ID; testnets should always be referenced with `ByGenesis`.\n\nIf storing these network IDs, they must be migrated to `ByGenesis`. These are the genesis hashes for the migration:\n\n- Westend: `0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e`\n- Rococo: `0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e`"}
{"page_id": "develop-interoperability-versions-v5-migration-guide", "page_title": "Migration Guide (XCM V4 → XCM V5)", "index": 11, "depth": 2, "title": "Next Steps", "anchor": "next-steps", "start_char": 13310, "end_char": 13459, "estimated_token_count": 25, "token_estimator": "heuristic-v1", "text": "## Next Steps\n\nOnce migrated, unique XCM V5 features become available:\n\n- Origin preservation\n- Transferring multiple assets\n- Better asset claiming"}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 0, "depth": 2, "title": "Changes from V4", "anchor": "changes-from-v4", "start_char": 339, "end_char": 464, "estimated_token_count": 20, "token_estimator": "heuristic-v1", "text": "## Changes from V4\n\nXCM V5 improves weight handling by making weight specification optional to reduce transaction failures."}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 1, "depth": 3, "title": "Weight Parameter Evolution", "anchor": "weight-parameter-evolution", "start_char": 464, "end_char": 1098, "estimated_token_count": 108, "token_estimator": "heuristic-v1", "text": "### Weight Parameter Evolution\n\n- **Previous Versions:**\n\n    ```typescript\n    // Required explicit weight specification\n    XcmV4Instruction.Transact({\n    origin_kind: XcmV2OriginKind.SovereignAccount(),\n    require_weight_at_most: {\n        ref_time: 1000000000n,\n        proof_size: 100000n\n    },\n    call: encodedCall\n    })\n    ```\n\n- **XCM V5:**\n\n    ```typescript\n    // Optional weight specification with fallback\n    XcmV5Instruction.Transact({\n        origin_kind: XcmV2OriginKind.SovereignAccount(),\n        fallback_max_weight: undefined, // or weight object for compatibility\n        call: encodedCall\n    })\n    ```"}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 2, "depth": 2, "title": "The `fallback_max_weight` Parameter", "anchor": "the-fallback_max_weight-parameter", "start_char": 1098, "end_char": 1138, "estimated_token_count": 7, "token_estimator": "heuristic-v1", "text": "## The `fallback_max_weight` Parameter"}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 3, "depth": 3, "title": "When to Use `undefined`", "anchor": "when-to-use-undefined", "start_char": 1138, "end_char": 1590, "estimated_token_count": 79, "token_estimator": "heuristic-v1", "text": "### When to Use `undefined`\n\nUse `fallback_max_weight: undefined` when:\n\n- The destination chain supports XCM V5.\n- You want automatic weight calculation.\n- You prefer simplified, more reliable execution.\n\n    ```typescript\n    // Preferred approach for v5-compatible destinations\n    XcmV5Instruction.Transact({\n        origin_kind: XcmV2OriginKind.SovereignAccount(),\n        fallback_max_weight: undefined,\n        call: encodedCall\n    })\n    ```"}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 4, "depth": 3, "title": "When to Specify Weight", "anchor": "when-to-specify-weight", "start_char": 1590, "end_char": 2109, "estimated_token_count": 94, "token_estimator": "heuristic-v1", "text": "### When to Specify Weight\n\nUse `fallback_max_weight: { ref_time: ..., proof_size: ... }` when:\n\n- The destination chain doesn't support XCM V5 yet.\n- You need backward compatibility.\n- You want explicit weight control.\n\n    ```typescript\n    // Backward compatibility approach\n    XcmV5Instruction.Transact({\n        origin_kind: XcmV2OriginKind.SovereignAccount(), \n        fallback_max_weight: {\n            ref_time: 1000000000n,\n            proof_size: 100000n\n        },\n        call: encodedCall\n    })\n    ```"}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 5, "depth": 2, "title": "Benefits of the New Approach", "anchor": "benefits-of-the-new-approach", "start_char": 2109, "end_char": 2142, "estimated_token_count": 7, "token_estimator": "heuristic-v1", "text": "## Benefits of the New Approach"}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 6, "depth": 3, "title": "Problems Solved", "anchor": "problems-solved", "start_char": 2142, "end_char": 2457, "estimated_token_count": 62, "token_estimator": "heuristic-v1", "text": "### Problems Solved\n\nThe previous mandatory weight specification created:\n\n- **Brittle implementations**: Weight requirements changed with runtime upgrades.\n- **Over/under-estimation**: Incorrect weight estimates that led to failures or waste.\n- **Maintenance overhead**: Constant monitoring and updates required."}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 7, "depth": 3, "title": "XCM V5 Improvements", "anchor": "xcm-v5-improvements", "start_char": 2457, "end_char": 2845, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "### XCM V5 Improvements\n\n- **Automatic weight handling**: Destination chains calculate appropriate weights when `fallback_max_weight` is `undefined`.\n- **Backward compatibility**: Legacy chains still work with specified weights.\n- **Flexibility**: Choose the approach based on destination chain capabilities.\n- **Reduced brittleness**: Less prone to failures from weight miscalculation."}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 8, "depth": 2, "title": "Migration Strategy", "anchor": "migration-strategy", "start_char": 2845, "end_char": 3190, "estimated_token_count": 75, "token_estimator": "heuristic-v1", "text": "## Migration Strategy\n\nWhen migrating from XCM V4 to XCM V5:\n\n- **For V5-compatible destinations**: Replace `require_weight_at_most` with `fallback_max_weight: undefined`.\n- **For mixed environments**: Keep weight specification for non-v5 chains.\n- **Gradual transition**: Start with explicit weights and move to `undefined` as chains upgrade."}
{"page_id": "develop-interoperability-versions-v5-transact", "page_title": "Transact", "index": 9, "depth": 2, "title": "Fee Implications", "anchor": "fee-implications", "start_char": 3190, "end_char": 3637, "estimated_token_count": 79, "token_estimator": "heuristic-v1", "text": "## Fee Implications\n\nFees are still required for `Transact` execution:\n\n- Use `PayFees` or `BuyExecution` before the instruction.\n- With `fallback_max_weight: undefined`, fees are deducted based on actual execution weight.\n- Fee estimation becomes more predictable without manual weight calculations.\n\nThis change makes `Transact` both more developer-friendly and backward-compatible while maintaining powerful cross-chain execution capabilities."}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 0, "depth": 2, "title": "Changes from v4", "anchor": "changes-from-v4", "start_char": 289, "end_char": 309, "estimated_token_count": 5, "token_estimator": "heuristic-v1", "text": "## Changes from v4"}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 1, "depth": 3, "title": "Instruction Consolidation", "anchor": "instruction-consolidation", "start_char": 309, "end_char": 787, "estimated_token_count": 83, "token_estimator": "heuristic-v1", "text": "### Instruction Consolidation\n\n- **Previous versions:**\n\n    - `InitiateTeleport`: For teleport transfers.\n    - `InitiateReserveWithdraw`: For reserve withdrawals.  \n    - `DepositReserveAsset`: For reserve deposits.\n    - Separate instructions for different transfer types.\n\n- **XCM V5:**\n\n    - Single `InitiateTransfer` instruction for all transfer types.\n    - Transfer type specified within the instruction parameters.\n    - Unified interface with enhanced capabilities."}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 2, "depth": 3, "title": "Enhanced Transfer Specification", "anchor": "enhanced-transfer-specification", "start_char": 787, "end_char": 1510, "estimated_token_count": 154, "token_estimator": "heuristic-v1", "text": "### Enhanced Transfer Specification\n\n- **Previous approach:**\n\n    ```typescript\n    // Separate instructions for different transfer types\n    XcmV4Instruction.InitiateTeleport({ /* teleport params */ })\n    XcmV4Instruction.InitiateReserveWithdraw({ /* reserve params */ })\n    ```\n\n- **XCM V5 approach:**\n\n    ```typescript\n    // Unified instruction with transfer type specification\n    XcmV5Instruction.InitiateTransfer({\n    destination: /* location */,\n    remote_fees: Enum('ReserveDeposit', /* fee asset */),\n    preserve_origin: false,\n    assets: [\n        Enum('Teleport', /* teleport assets */),\n        Enum('ReserveDeposit', /* reserve assets */)\n    ],\n    remote_xcm: /* remote execution */\n    })\n    ```"}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 3, "depth": 2, "title": "Key Enhancements", "anchor": "key-enhancements", "start_char": 1510, "end_char": 1531, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Key Enhancements"}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 4, "depth": 3, "title": "Mixed Transfer Types", "anchor": "mixed-transfer-types", "start_char": 1531, "end_char": 1798, "estimated_token_count": 49, "token_estimator": "heuristic-v1", "text": "### Mixed Transfer Types\n\nXCM V5 allows mixing different transfer types in a single transaction:\n\n- Teleport some assets while reserve-transferring others.\n- Use different transfer types for fees vs. main assets.\n- More flexible asset handling in complex scenarios."}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 5, "depth": 3, "title": "Origin Preservation", "anchor": "origin-preservation", "start_char": 1798, "end_char": 2373, "estimated_token_count": 105, "token_estimator": "heuristic-v1", "text": "### Origin Preservation\n\nThe new `preserve_origin` parameter enables:\n\n- Maintaining the original sender's identity on destination chains.\n- Executing transactions (`Transact`) on behalf of the origin.\n- More sophisticated cross-chain operations.\n\n!!! note \"Important\"\n\n    Origin preservation requires a specific configuration on the destination chain.\n    If the destination chain doesn't support it, transfers with `preserve_origin: true` will fail.\n    Setting `preserve_origin: false` will continue to work as before, regardless of the destination chain configuration."}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 6, "depth": 3, "title": "Integrated Fee Handling", "anchor": "integrated-fee-handling", "start_char": 2373, "end_char": 2585, "estimated_token_count": 39, "token_estimator": "heuristic-v1", "text": "### Integrated Fee Handling\n\nBuilt-in `remote_fees` parameter:\n\n- Automatic `PayFees` instruction insertion on destination.\n- Cleaner fee specification with transfer type.\n- Better fee management across chains."}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 7, "depth": 2, "title": "Backward Compatibility", "anchor": "backward-compatibility", "start_char": 2585, "end_char": 2897, "estimated_token_count": 49, "token_estimator": "heuristic-v1", "text": "## Backward Compatibility\n\nXCM V5 maintains full backward compatibility:\n\n- Previous transfer instructions `InitiateTeleport`, `InitiateReserveWithdraw`, `DepositReserveAsset` remain available.\n- Existing XCM programs continue to work without modification.\n- Gradual migration path to the new unified approach."}
{"page_id": "develop-interoperability-versions-v5-transfers", "page_title": "Transfers", "index": 8, "depth": 2, "title": "Migration Benefits", "anchor": "migration-benefits", "start_char": 2897, "end_char": 3243, "estimated_token_count": 70, "token_estimator": "heuristic-v1", "text": "## Migration Benefits\n\nMoving to `InitiateTransfer` provides:\n\n- **Simplified development**: Single instruction for all transfer scenarios.\n- **Enhanced flexibility**: Mix transfer types and preserve origins.\n- **Better maintainability**: Fewer instruction types to manage.\n- **Future-proofing**: Foundation for additional transfer enhancements."}
{"page_id": "develop-interoperability-versions-v5-writing-xcm-programs", "page_title": "Writing XCM Programs", "index": 0, "depth": 2, "title": "The Paradigm Shift", "anchor": "the-paradigm-shift", "start_char": 154, "end_char": 177, "estimated_token_count": 5, "token_estimator": "heuristic-v1", "text": "## The Paradigm Shift"}
{"page_id": "develop-interoperability-versions-v5-writing-xcm-programs", "page_title": "Writing XCM Programs", "index": 1, "depth": 3, "title": "Previous Approach", "anchor": "previous-approach", "start_char": 177, "end_char": 560, "estimated_token_count": 70, "token_estimator": "heuristic-v1", "text": "### Previous Approach\n\nThe previous approach was to use specialized extrinsics in `pallet-xcm` and `xtokens` for different operations:\n\n- Used specialized extrinsics in `pallet-xcm` and `xtokens`.\n- Separate functions for different operations:\n    - `limited_teleport_assets`\n    - `limited_reserve_transfer_assets`\n    - `claim_assets`\n\nEach new use case required a new extrinsic."}
{"page_id": "develop-interoperability-versions-v5-writing-xcm-programs", "page_title": "Writing XCM Programs", "index": 2, "depth": 3, "title": "XCM V5 Recommendation", "anchor": "xcm-v5-recommendation", "start_char": 560, "end_char": 757, "estimated_token_count": 42, "token_estimator": "heuristic-v1", "text": "### XCM V5 Recommendation\n\n- Craft raw XCM programs directly.\n- Use `pallet_xcm::execute()` for execution.\n- Compose instructions within programs.\n- No new extrinsics needed for custom use cases."}
{"page_id": "develop-interoperability-versions-v5-writing-xcm-programs", "page_title": "Writing XCM Programs", "index": 3, "depth": 2, "title": "Execution Approach", "anchor": "execution-approach", "start_char": 757, "end_char": 1274, "estimated_token_count": 120, "token_estimator": "heuristic-v1", "text": "## Execution Approach\n\nXCM V5 promotes using `execute()` directly:\n\n```typescript\n// XCM V5 recommended approach\nconst tx = api.tx.PolkadotXcm.execute({\n  message: xcm, // The XCM program\n  max_weight: weight, // Weight limit for execution\n})\n```\n\nThis provides more flexibility than calling specialized extrinsics:\n\n```typescript\n// Previous approach - specialized extrinsics\napi.tx.PolkadotXcm.limitedTeleportAssets(...)\napi.tx.PolkadotXcm.limitedReserveTransferAssets(...)\napi.tx.PolkadotXcm.claimAssets(...)\n```"}
{"page_id": "develop-interoperability-versions-v5-writing-xcm-programs", "page_title": "Writing XCM Programs", "index": 4, "depth": 2, "title": "Benefits of Direct Execution", "anchor": "benefits-of-direct-execution", "start_char": 1274, "end_char": 1572, "estimated_token_count": 66, "token_estimator": "heuristic-v1", "text": "## Benefits of Direct Execution\n\n1. **Flexibility**: Full control over XCM instruction sequences.\n2. **Composability**: Combine multiple operations in a single program.\n3. **Extensibility**: Custom use cases without new extrinsics.\n4. **Maintainability**: Fewer specialized functions to maintain."}
{"page_id": "develop-interoperability-versions-v5-writing-xcm-programs", "page_title": "Writing XCM Programs", "index": 5, "depth": 2, "title": "Migration Considerations", "anchor": "migration-considerations", "start_char": 1572, "end_char": 1830, "estimated_token_count": 45, "token_estimator": "heuristic-v1", "text": "## Migration Considerations\n\n- Existing dedicated extrinsics continue to work.\n- No breaking changes to existing programs.\n- New development should prefer `execute()` for better flexibility.\n- A gradual migration path is available for existing applications."}
{"page_id": "develop-interoperability-xcm-channels", "page_title": "XCM Channels", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 16, "end_char": 1386, "estimated_token_count": 294, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPolkadot is designed to enable interoperability between its connected parachains. At the core of this interoperability is the [Cross-Consensus Message Format (XCM)](/develop/interoperability/intro-to-xcm/){target=\\_blank}, a standard language that allows parachains to communicate and interact with each other.\n\nThe network-layer protocol responsible for delivering XCM-formatted messages between parachains is the [Cross-Chain Message Passing (XCMP)](https://wiki.polkadot.com/learn/learn-xcm-transport/#xcmp-cross-chain-message-passing){target=\\_blank} protocol. XCMP maintains messaging queues on the relay chain, serving as a bridge to facilitate cross-chain interactions.\n\nAs XCMP is still under development, Polkadot has implemented a temporary alternative called [Horizontal Relay-routed Message Passing (HRMP)](https://wiki.polkadot.com/learn/learn-xcm-transport/#hrmp-xcmp-lite){target=\\_blank}. HRMP offers the same interface and functionality as the planned XCMP but it has a crucial difference, it stores all messages directly in the relay chain's storage, which is more resource-intensive.\n\nOnce XCMP is fully implemented, HRMP will be deprecated in favor of the native XCMP protocol. XCMP will offer a more efficient and scalable solution for cross-chain message passing, as it will not require the relay chain to store all the messages."}
{"page_id": "develop-interoperability-xcm-channels", "page_title": "XCM Channels", "index": 1, "depth": 2, "title": "Establishing HRMP Channels", "anchor": "establishing-hrmp-channels", "start_char": 1386, "end_char": 2076, "estimated_token_count": 118, "token_estimator": "heuristic-v1", "text": "## Establishing HRMP Channels\n\nTo enable communication between parachains using the HRMP protocol, the parachains must explicitly establish communication channels by registering them on the relay chain.\n\nDownward and upward channels from and to the relay chain are implicitly available, meaning they do not need to be explicitly opened.\n\nOpening an HRMP channel requires the parachains involved to make a deposit on the relay chain. This deposit serves a specific purpose, it covers the costs associated with using the relay chain's storage for the message queues linked to the channel. The amount of this deposit varies based on parameters defined by the specific relay chain being used."}
{"page_id": "develop-interoperability-xcm-channels", "page_title": "XCM Channels", "index": 2, "depth": 3, "title": "Relay Chain Parameters", "anchor": "relay-chain-parameters", "start_char": 2076, "end_char": 3987, "estimated_token_count": 431, "token_estimator": "heuristic-v1", "text": "### Relay Chain Parameters\n\nEach Polkadot relay chain has a set of configurable parameters that control the behavior of the message channels between parachains. These parameters include [`hrmpSenderDeposit`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_sender_deposit){target=\\_blank}, [`hrmpRecipientDeposit`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_recipient_deposit){target=\\_blank}, [`hrmpChannelMaxMessageSize`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_channel_max_message_size){target=\\_blank}, [`hrmpChannelMaxCapacity`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/configuration/struct.HostConfiguration.html#structfield.hrmp_channel_max_capacity){target=\\_blank}, and more.\n\nWhen a parachain wants to open a new channel, it must consider these parameter values to ensure the channel is configured correctly.\n\nTo view the current values of these parameters in the Polkadot network:\n\n1. Visit [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fpolkadot.api.onfinality.io%2Fpublic-ws#/explorer), navigate to the **Developer** dropdown and select the **Chain state** option.\n\n    ![](/images/develop/interoperability/xcm-channels/xcm-channels-1.webp)\n\n2. Query the chain configuration parameters. The result will display the current settings for all the Polkadot network parameters, including the HRMP channel settings.\n\n    1. Select **`configuration`**.\n    2. Choose the **`activeConfig()`** call.\n    3. Click the **+** button to execute the query.\n    4. Check the chain configuration.\n\n        ![](/images/develop/interoperability/xcm-channels/xcm-channels-2.webp)"}
{"page_id": "develop-interoperability-xcm-channels", "page_title": "XCM Channels", "index": 3, "depth": 3, "title": "Dispatching Extrinsics", "anchor": "dispatching-extrinsics", "start_char": 3987, "end_char": 5489, "estimated_token_count": 328, "token_estimator": "heuristic-v1", "text": "### Dispatching Extrinsics\n\nEstablishing new HRMP channels between parachains requires dispatching specific extrinsic calls on the Polkadot Relay Chain from the parachain's origin.\n\nThe most straightforward approach is to implement the channel opening logic off-chain, then use the XCM pallet's [`send`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/dispatchables/fn.send.html){target=\\_blank} extrinsic to submit the necessary instructions to the relay chain. However, the ability to send arbitrary programs through the [`Transact`](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#transact){target=\\_blank} instruction in XCM is typically restricted to privileged origins, such as the [`sudo`](https://paritytech.github.io/polkadot-sdk/master/pallet_sudo/pallet/dispatchables/fn.sudo.html){target=\\_blank} pallet or governance mechanisms.\n\nParachain developers have a few options for triggering the required extrinsic calls from their parachain's origin, depending on the configuration and access controls defined:\n\n- **Sudo**: If the parachain has a `sudo` pallet configured, the sudo key holder can use the sudo extrinsic to dispatch the necessary channel opening calls.\n- **Governance**: The parachain's governance system, such as a council or OpenGov, can be used to authorize the channel opening calls.\n- **Privileged accounts**: The parachain may have other designated privileged accounts that are allowed to dispatch the HRMP channel opening extrinsics."}
{"page_id": "develop-interoperability-xcm-channels", "page_title": "XCM Channels", "index": 4, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 5489, "end_char": 6418, "estimated_token_count": 202, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nExplore the following tutorials for detailed, step-by-step guidance on setting up cross-chain communication channels in Polkadot:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Opening HRMP Channels Between Parachains__\n\n    ---\n\n    Learn how to open HRMP channels between parachains on Polkadot. Discover the step-by-step process for establishing uni- and bidirectional communication.\n\n    [:octicons-arrow-right-24: Reference](/tutorials/interoperability/xcm-channels/para-to-para/)\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Opening HRMP Channels with System Parachains__\n\n    ---\n\n    Learn how to open HRMP channels with Polkadot system parachains. Discover the process for establishing bi-directional communication using a single XCM message.\n\n    [:octicons-arrow-right-24: Reference](/tutorials/interoperability/xcm-channels/para-to-system/)\n\n</div>"}
{"page_id": "develop-interoperability-xcm-config", "page_title": "XCM Config", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 14, "end_char": 1544, "estimated_token_count": 337, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [XCM executor](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/index.html){target=\\_blank} is a crucial component responsible for interpreting and executing XCM messages (XCMs) with Polkadot SDK-based chains. It processes and manages XCM instructions, ensuring they are executed correctly and in sequentially. Adhering to the [Cross-Consensus Virtual Machine (XCVM) specification](https://paritytech.github.io/xcm-docs/overview/xcvm.html#the-xcvm){target=\\_blank}, the XCM executor can be customized or replaced with an alternative that also complies with the [XCVM standards](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#12-the-xcvm){target=\\_blank}.\n\nThe `XcmExecutor` is not a pallet but a struct parameterized by a `Config` trait. The `Config` trait is the inner configuration, parameterizing the outer `XcmExecutor<Config>` struct. Both configurations are set up within the runtime.\n\nThe executor is highly configurable, with the [XCM builder](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/index.html){target=\\_blank} offering building blocks to tailor the configuration to specific needs. While they serve as a foundation, users can easily create custom blocks to suit unique configurations. Users can also create their building blocks to address unique needs. This article examines the XCM configuration process, explains each configurable item, and provides examples of the tools and types available to help customize these settings."}
{"page_id": "develop-interoperability-xcm-config", "page_title": "XCM Config", "index": 1, "depth": 2, "title": "XCM Executor Configuration", "anchor": "xcm-executor-configuration", "start_char": 1544, "end_char": 3822, "estimated_token_count": 390, "token_estimator": "heuristic-v1", "text": "## XCM Executor Configuration\n\nThe `Config` trait defines the XCM executor’s configuration, which requires several associated types. Each type has specific trait bounds that the concrete implementation must fulfill. Some types, such as `RuntimeCall`, come with a default implementation in most cases, while others use the unit type `()` as the default. For many of these types, selecting the appropriate implementation carefully is crucial. Predefined solutions and building blocks can be adapted to your specific needs. These solutions can be found in the [`xcm-builder`](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506-2/polkadot/xcm/xcm-builder){target=\\_blank} folder.\n\nEach type is explained below, along with an overview of some of its implementations:\n\n```rust\npub trait Config {\n    type RuntimeCall: Parameter + Dispatchable<PostInfo = PostDispatchInfo> + GetDispatchInfo;\n    type XcmSender: SendXcm;\n    type AssetTransactor: TransactAsset;\n    type OriginConverter: ConvertOrigin<<Self::RuntimeCall as Dispatchable>::RuntimeOrigin>;\n    type IsReserve: ContainsPair<MultiAsset, MultiLocation>;\n    type IsTeleporter: ContainsPair<MultiAsset, MultiLocation>;\n    type Aliasers: ContainsPair<Location, Location>;\n    type UniversalLocation: Get<InteriorMultiLocation>;\n    type Barrier: ShouldExecute;\n    type Weigher: WeightBounds<Self::RuntimeCall>;\n    type Trader: WeightTrader;\n    type ResponseHandler: OnResponse;\n    type AssetTrap: DropAssets;\n    type AssetClaims: ClaimAssets;\n    type AssetLocker: AssetLock;\n    type AssetExchanger: AssetExchange;\n    type SubscriptionService: VersionChangeNotifier;\n    type PalletInstancesInfo: PalletsInfoAccess;\n    type MaxAssetsIntoHolding: Get<u32>;\n    type FeeManager: FeeManager;\n    type MessageExporter: ExportXcm;\n    type UniversalAliases: Contains<(MultiLocation, Junction)>;\n    type CallDispatcher: CallDispatcher<Self::RuntimeCall>;\n    type SafeCallFilter: Contains<Self::RuntimeCall>;\n    type TransactionalProcessor: ProcessTransaction;\n    type HrmpNewChannelOpenRequestHandler: HandleHrmpNewChannelOpenRequest;\n    type HrmpChannelAcceptedHandler: HandleHrmpChannelAccepted;\n    type HrmpChannelClosingHandler: HandleHrmpChannelClosing;\n    type XcmRecorder: RecordXcm;\n}\n```"}
{"page_id": "develop-interoperability-xcm-config", "page_title": "XCM Config", "index": 2, "depth": 2, "title": "Config Items", "anchor": "config-items", "start_char": 3822, "end_char": 18395, "estimated_token_count": 3491, "token_estimator": "heuristic-v1", "text": "## Config Items\n\nEach configuration item is explained below, detailing the associated type’s purpose and role in the XCM executor. Many of these types have predefined solutions available in the `xcm-builder`. Therefore, the available configuration items are:\n\n- **[`RuntimeCall`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.RuntimeCall){target=\\_blank}**: Defines the runtime's callable functions, created via the [`frame::runtime`](https://paritytech.github.io/polkadot-sdk/master/frame_support/attr.runtime.html){target=\\_blank} macro. It represents an enum listing the callable functions of all implemented pallets.\n\n    ```rust\n    type RuntimeCall: Parameter + Dispatchable<PostInfo = PostDispatchInfo> + GetDispatchInfo\n    ```\n   The associated traits signify:\n\n    - **`Parameter`**: Ensures the type is encodable, decodable, and usable as a parameter.\n    - **`Dispatchable`**: Indicates it can be executed in the runtime.\n    - **`GetDispatchInfo`**: Provides weight details, determining how long execution takes.\n\n- **[`XcmSender`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.XcmSender){target=\\_blank}**: Implements the [`SendXcm`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v4/trait.SendXcm.html){target=\\_blank} trait, specifying how the executor sends XCMs using transport layers (e.g., UMP for relay chains or XCMP for sibling chains). If a runtime lacks certain transport layers, such as [HRMP](https://wiki.polkadot.com/learn/learn-xcm-transport/#hrmp-xcmp-lite){target=\\_blank} (or [XCMP](https://wiki.polkadot.com/learn/learn-xcm-transport/#xcmp-cross-consensus-message-passing-design-summary){target=\\_blank}).\n\n    ```rust\n    type XcmSender: SendXcm;\n    ```\n\n- **[`AssetTransactor`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetTransactor){target=\\_blank}**: Implements the [`TransactAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.TransactAsset.html){target=\\_blank} trait, handling the conversion and transfer of MultiAssets between accounts or registers. It can be configured to support native tokens, fungibles, and non-fungibles or multiple tokens using pre-defined adapters like [`FungibleAdapter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.FungibleAdapter.html){target=\\_blank} or custom solutions.\n\n    ```rust\n    type AssetTransactor: TransactAsset;\n    ```\n\n- **[`OriginConverter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.OriginConverter){target=\\_blank}**: Implements the [`ConvertOrigin`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ConvertOrigin.html){target=\\_blank} trait to map `MultiLocation` origins to `RuntimeOrigin`. Multiple implementations can be combined, and [`OriginKind`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/test_utils/enum.OriginKind.html){target=\\_blank} is used to resolve conflicts. Pre-defined converters like [`SovereignSignedViaLocation`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.SovereignSignedViaLocation.html){target=\\_blank} and [`SignedAccountId32AsNative`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.SignedAccountId32AsNative.html){target=\\_blank} handle sovereign and local accounts respectively.\n\n    ```rust\n    type OriginConverter: ConvertOrigin<<Self::RuntimeCall as Dispatchable>::RuntimeOrigin>;\n    ```\n\n- **[`IsReserve`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.IsReserve){target=\\_blank}**: Specifies trusted `<MultiAsset, MultiLocation>` pairs for depositing reserve assets. Using the unit type `()` blocks reserve deposits. The [`NativeAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.NativeAsset.html){target=\\_blank} struct is an example of a reserve implementation.\n\n    ```rust\n    type IsReserve: ContainsPair<MultiAsset, MultiLocation>;\n    ```\n\n- **[`IsTeleporter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.IsTeleporter){target=\\_blank}**: Defines trusted `<MultiAsset, MultiLocation>` pairs for teleporting assets to the chain. Using `()` blocks the [`ReceiveTeleportedAssets`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/test_utils/enum.Instruction.html#variant.ReceiveTeleportedAsset){target=\\_blank} instruction. The [`NativeAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.NativeAsset.html){target=\\_blank} struct can act as an implementation.\n\n    ```rust\n    type IsTeleporter: ContainsPair<MultiAsset, MultiLocation>;\n    ```\n\n- **[`Aliasers`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Aliasers){target=\\_blank}**: A list of `(Origin, Target)` pairs enabling each `Origin` to be replaced with its corresponding `Target`.\n\n    ```rust\n    type Aliasers: ContainsPair<Location, Location>;\n    ```\n\n- **[`UniversalLocation`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.UniversalLocation){target=\\_blank}**: Specifies the runtime's location in the consensus universe.\n\n    ```rust\n    type UniversalLocation: Get<InteriorMultiLocation>;\n    ```\n\n    - Some examples are:\n        - `X1(GlobalConsensus(NetworkId::Polkadot))` for Polkadot\n        - `X1(GlobalConsensus(NetworkId::Kusama))` for Kusama\n        - `X2(GlobalConsensus(NetworkId::Polkadot), Parachain(1000))` for Statemint\n\n- **[`Barrier`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Barrier){target=\\_blank}**: Implements the [`ShouldExecute`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ShouldExecute.html){target=\\_blank} trait, functioning as a firewall for XCM execution. Multiple barriers can be combined in a tuple, where execution halts if one succeeds.\n\n    ```rust\n    type Barrier: ShouldExecute;\n    ```\n\n- **[`Weigher`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Weigher){target=\\_blank}**: Calculates the weight of XCMs and instructions, enforcing limits and refunding unused weight. Common solutions include [`FixedWeightBounds`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.FixedWeightBounds.html){target=\\_blank}, which uses a base weight and limits on instructions.\n\n    ```rust\n    type Weigher: WeightBounds<Self::RuntimeCall>;\n    ```\n\n- **[`Trader`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.Trader){target=\\_blank}**: Manages asset-based weight purchases and refunds for `BuyExecution` instructions. The [`UsingComponents`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_builder/struct.UsingComponents.html){target=\\_blank} trader is a common implementation.\n\n    ```rust\n    type Trader: WeightTrader;\n    ```\n\n- **[`ResponseHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.ResponseHandler){target=\\_blank}**: Handles `QueryResponse` instructions, implementing the [`OnResponse`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.OnResponse.html){target=\\_blank} trait. FRAME systems typically use the pallet-xcm implementation.\n\n    ```rust\n    type ResponseHandler: OnResponse;\n    ```\n\n- **[`AssetTrap`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetTrap){target=\\_blank}**: Handles leftover assets in the holding register after XCM execution, allowing them to be claimed via `ClaimAsset`. If unsupported, assets are burned.\n\n    ```rust\n    type AssetTrap: DropAssets;\n    ```\n\n- **[`AssetClaims`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetClaims){target=\\_blank}**: Facilitates the claiming of trapped assets during the execution of the `ClaimAsset` instruction. Commonly implemented via pallet-xcm.\n\n    ```rust\n    type AssetClaims: ClaimAssets;\n    ```\n\n- **[`AssetLocker`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetLocker){target=\\_blank}**: Handles the locking and unlocking of assets. Can be omitted using `()` if asset locking is unnecessary.\n\n    ```rust\n    type AssetLocker: AssetLock;\n    ```\n\n- **[`AssetExchanger`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.AssetExchanger){target=\\_blank}**: Implements the [`AssetExchange`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.AssetExchange.html){target=\\_blank} trait to manage asset exchanges during the `ExchangeAsset` instruction. The unit type `()` disables this functionality.\n\n    ```rust\n    type AssetExchanger: AssetExchange;\n    ```\n\n- **[`SubscriptionService`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.SubscriptionService){target=\\_blank}**: Manages `(Un)SubscribeVersion` instructions and returns the XCM version via `QueryResponse`. Typically implemented by pallet-xcm.\n\n    ```rust\n    type SubscriptionService: VersionChangeNotifier;\n    ```\n\n- **[`PalletInstancesInfo`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.PalletInstancesInfo){target=\\_blank}**: Provides runtime pallet information for `QueryPallet` and `ExpectPallet` instructions. FRAME-specific systems often use this, or it can be disabled with `()`.\n\n    ```rust\n    type PalletInstancesInfo: PalletsInfoAccess;\n    ```\n\n \n- [**`MaxAssetsIntoHolding`**](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.MaxAssetsIntoHolding){target=\\_blank}: Limits the number of assets in the [Holding register](https://wiki.polkadot.com/learn/learn-xcm/#holding-register){target=\\_blank}. At most, twice this limit can be held under worst-case conditions.\n    ```rust\n    type MaxAssetsIntoHolding: Get<u32>;\n    ```\n\n- **[`FeeManager`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.FeeManager){target=\\_blank}**: Manages fees for XCM instructions, determining whether fees should be paid, waived, or handled in specific ways. Fees can be waived entirely using `()`.\n\n    ```rust\n    type FeeManager: FeeManager;\n    ```\n\n- **[`MessageExporter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.MessageExporter){target=\\_blank}**: Implements the [`ExportXcm`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ExportXcm.html){target=\\_blank} trait, enabling XCMs export to other consensus systems. It can spoof origins for use in bridges. Use `()` to disable exporting.\n\n    ```rust\n    type MessageExporter: ExportXcm;\n    ```\n\n- **[`UniversalAliases`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.UniversalAliases){target=\\_blank}**: Lists origin locations and universal junctions allowed to elevate themselves in the `UniversalOrigin` instruction. Using `Nothing` prevents origin aliasing.\n\n    ```rust\n    type UniversalAliases: Contains<(MultiLocation, Junction)>;\n    ```\n\n- **[`CallDispatcher`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.CallDispatcher){target=\\_blank}**: Dispatches calls from the `Transact` instruction, adapting the origin or modifying the call as needed. Can default to `RuntimeCall`.\n\n    ```rust\n    type CallDispatcher: CallDispatcher<Self::RuntimeCall>;\n    ```\n\n- **[`SafeCallFilter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.SafeCallFilter){target=\\_blank}**: Whitelists calls permitted in the `Transact` instruction. Using `Everything` allows all calls, though this is temporary until proof size weights are accounted for.\n\n    ```rust\n    type SafeCallFilter: Contains<Self::RuntimeCall>;\n    ```\n\n- **[`TransactionalProcessor`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.TransactionalProcessor){target=\\_blank}**: Implements the [`ProccessTransaction`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/traits/trait.ProcessTransaction.html){target=\\_blank} trait. It ensures that XCM instructions are executed atomically, meaning they either fully succeed or fully fail without any partial effects. This type allows for non-transactional XCM instruction processing by setting the `()` type.\n\n    ```rust\n    type TransactionalProcessor: ProcessTransaction;\n    ```\n\n- **[`HrmpNewChannelOpenRequestHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.HrmpNewChannelOpenRequestHandler){target=\\_blank}**: Enables optional logic execution in response to the `HrmpNewChannelOpenRequest` XCM notification.\n\n    ```rust\n    type HrmpNewChannelOpenRequestHandler: HandleHrmpNewChannelOpenRequest;\n    ```\n\n- **[`HrmpChannelAcceptedHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.HrmpChannelAcceptedHandler){target=\\_blank}**: Enables optional logic execution in response to the `HrmpChannelAccepted` XCM notification.\n\n    ```rust\n    type HrmpChannelAcceptedHandler: HandleHrmpChannelAccepted;\n    ```\n\n- **[`HrmpChannelClosingHandler`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.HrmpChannelClosingHandler){target=\\_blank}**: Enables optional logic execution in response to the `HrmpChannelClosing` XCM notification.\n\n    ```rust\n    type HrmpChannelClosingHandler: HandleHrmpChannelClosing;\n    ```\n\n- **[`XcmRecorder`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/trait.Config.html#associatedtype.XcmRecorder){target=\\_blank}**: Allows tracking of the most recently executed XCM, primarily for use with dry-run runtime APIs.\n\n    ```rust\n    type XcmRecorder: RecordXcm;\n    ```"}
{"page_id": "develop-interoperability-xcm-config", "page_title": "XCM Config", "index": 3, "depth": 3, "title": "Inner Config", "anchor": "inner-config", "start_char": 18395, "end_char": 20069, "estimated_token_count": 420, "token_estimator": "heuristic-v1", "text": "### Inner Config\n\nThe `Config` trait underpins the `XcmExecutor`, defining its core behavior through associated types for asset handling, XCM processing, and permission management. These types are categorized as follows:\n\n- **Handlers**: Manage XCMs sending, asset transactions, and special notifications.\n- **Filters**: Define trusted combinations, origin substitutions, and execution barriers.\n- **Converters**: Handle origin conversion for call execution.\n- **Accessors**: Provide weight determination and pallet information.\n- **Constants**: Specify universal locations and asset limits.\n- **Common Configs**: Include shared settings like `RuntimeCall`.\n\nThe following diagram outlines this categorization:\n\n```mermaid\nflowchart LR\n    A[Inner Config] --> B[Handlers]\n    A --> C[Filters]\n    A --> D[Converters]\n    A --> E[Accessors]\n    A --> F[Constants]\n    A --> G[Common Configs]\n\n    B --> H[XcmSender]\n    B --> I[AssetTransactor]\n    B --> J[Trader]\n    B --> K[ResponseHandler]\n    B --> L[AssetTrap]\n    B --> M[AssetLocker]\n    B --> N[AssetExchanger]\n    B --> O[AssetClaims]\n    B --> P[SubscriptionService]\n    B --> Q[FeeManager]\n    B --> R[MessageExporter]\n    B --> S[CallDispatcher]\n    B --> T[HrmpNewChannelOpenRequestHandler]\n    B --> U[HrmpChannelAcceptedHandler]\n    B --> V[HrmpChannelClosingHandler]\n\n    C --> W[IsReserve]\n    C --> X[IsTeleporter]\n    C --> Y[Aliasers]\n    C --> Z[Barrier]\n    C --> AA[UniversalAliases]\n    C --> AB[SafeCallFilter]\n\n    D --> AC[OriginConverter]\n\n    E --> AD[Weigher]\n    E --> AE[PalletInstancesInfo]\n\n    F --> AF[UniversalLocation]\n    F --> AG[MaxAssetsIntoHolding]\n\n    G --> AH[RuntimeCall]\n```"}
{"page_id": "develop-interoperability-xcm-config", "page_title": "XCM Config", "index": 4, "depth": 3, "title": "Outer Config", "anchor": "outer-config", "start_char": 20069, "end_char": 20484, "estimated_token_count": 93, "token_estimator": "heuristic-v1", "text": "### Outer Config\n\nThe `XcmExecutor<Config>` struct extends the functionality of the inner config by introducing fields for execution context, asset handling, error tracking, and operational management. For further details, see the documentation for [`XcmExecutor<Config>`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm_executor/struct.XcmExecutor.html#impl-XcmExecutor%3CConfig%3E){target=\\_blank}."}
{"page_id": "develop-interoperability-xcm-config", "page_title": "XCM Config", "index": 5, "depth": 2, "title": "Multiple Implementations", "anchor": "multiple-implementations", "start_char": 20484, "end_char": 21710, "estimated_token_count": 248, "token_estimator": "heuristic-v1", "text": "## Multiple Implementations\n\nSome associated types in the `Config` trait are highly configurable and may have multiple implementations (e.g., Barrier). These implementations are organized into a tuple `(impl_1, impl_2, ..., impl_n)`, and the execution follows a sequential order. Each item in the tuple is evaluated individually, each being checked to see if it fails. If an item passes (e.g., returns `Ok` or `true`), the execution stops, and the remaining items are not evaluated. The following example of the `Barrier` type demonstrates how this grouping operates (understanding each item in the tuple is unnecessary for this explanation).\n\nIn the following example, the system will first check the `TakeWeightCredit` type when evaluating the barrier. If it fails, it will check `AllowTopLevelPaidExecutionFrom`, and so on, until one of them returns a positive result. If all checks fail, a Barrier error will be triggered.\n\n```rust\npub type Barrier = (\n    TakeWeightCredit,\n    AllowTopLevelPaidExecutionFrom<Everything>,\n    AllowKnownQueryResponses<XcmPallet>,\n    AllowSubscriptionsFrom<Everything>,\n);\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n    ...\n    type Barrier = Barrier;\n    ...\n}\n```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 27, "end_char": 374, "estimated_token_count": 62, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nWhen XCM execution fails or succeeds, leftover assets can become \"trapped\" on the destination chain. These assets are held by the system but are not accessible through normal means. XCM provides mechanisms to claim these trapped assets and recover them.\nThis guide details the process and required steps to claim trapped assets."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 1, "depth": 2, "title": "Trapped Assets Causes", "anchor": "trapped-assets-causes", "start_char": 374, "end_char": 1135, "estimated_token_count": 147, "token_estimator": "heuristic-v1", "text": "## Trapped Assets Causes\n\nAssets become trapped whenever execution halts and there are leftover assets. This can happen for example if:\n\n- An XCM execution throws an error in any instruction when assets are in holding such as:\n    - `DepositAsset` can't deposit because the account doesn't exist.\n    - `Transact` can't execute the call because it doesn't exist.\n    - `PayFees` not enough funds or not paying enough for execution.\n\n- XCM execution finishes successfully but not all assets were deposited:\n    - Funds were withdrawn but some were not deposited.\n    - `Transact` overestimated the weight and `RefundSurplus` got some funds into holding that were never deposited\n    - Fees in `PayFees` were overestimated and some were kept there until the end"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 2, "depth": 2, "title": "The `ClaimAsset` Instruction", "anchor": "the-claimasset-instruction", "start_char": 1135, "end_char": 1637, "estimated_token_count": 125, "token_estimator": "heuristic-v1", "text": "## The `ClaimAsset` Instruction\n\nThe [`ClaimAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.ClaimAsset){target=\\_blank} instruction allows retrieving assets trapped on a chain:\n\n```typescript\nXcmV5Instruction.ClaimAsset({\n    assets: /* Exact assets to claim, these must match those in the `AssetsTrapped` event */,\n    ticket: /* Additional information about the trapped assets, e.g. the XCM version that was in use at the time */\n});\n```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 3, "depth": 3, "title": "Parameters", "anchor": "parameters", "start_char": 1637, "end_char": 2349, "estimated_token_count": 159, "token_estimator": "heuristic-v1", "text": "### Parameters\n\n- **`assets`**: The trapped assets that want to be claimed. These must be exactly the same as the ones that appear\nin the [`AssetsTrapped`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/enum.Event.html#variant.AssetsTrapped){target=\\_blank} event.\n\n- **`ticket`**: Additional information about the trapped assets. Currently only specifies the XCM version used when the assets got trapped. Must be of the form:\n    ```typescript\n    { \n        parents: 0, \n        interior: XcmV5Junctions.X1(XcmV5Junction.GeneralIndex(INSERT_XCM_VERSION_HERE))\n    }\n    ```\n\n    Ensure to replace the `INSERT_XCM_VERSION_HERE` with the actual XCM version used when the assets got trapped."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 4, "depth": 3, "title": "Basic Claiming Process", "anchor": "basic-claiming-process", "start_char": 2349, "end_char": 4500, "estimated_token_count": 492, "token_estimator": "heuristic-v1", "text": "### Basic Claiming Process\n\nWhen assets are trapped you'll see the `AssetsTrapped` event:\n\n![](/images/develop/interoperability/guides/from-apps/claiming-trapped-assets/assets-trapped-event.webp)\n\nTo claim these assets, a message like the following needs to be sent from the origin:\n\n```typescript\nconst claimAssetsXcm = XcmVersionedXcm.V5([\n  // Claim trapped DOT.\n  XcmV5Instruction.ClaimAsset({\n    assets: [{\n      // USDC.\n      id: {\n        parents: 0,\n        interior: XcmV5Junctions.X2([\n          XcmV5Junction.PalletInstance(50),\n          XcmV5Junction.GeneralIndex(1337n),\n        ]),\n      },\n      fun: XcmV3MultiassetFungibility.Fungible(49_334n) // 0.049334 units.\n    }],\n    // Version 5.\n    ticket: { parents: 0, interior: XcmV5Junctions.X1(XcmV5Junction.GeneralIndex(5n)) }\n  }),\n  XcmV5Instruction.PayFees(/* Pay for fees */),\n  XcmV5Instruction.DepositAsset(/* Deposit everything to an account */),\n]);\n```\n\nNote that this example uses the claimed USDC assets to pay for the execution fees of the claiming message. If the trapped asset cannot be used for fee payment on the destination chain, you need a different approach: first `WithdrawAsset` (with fee-eligible assets), then `PayFees`, then `ClaimAsset`, and finally `DepositAsset`.\n\nIn this case, the origin is a local account so the `execute()` transaction needs to be submitted by that same account. The origin could be another chain, in which case the governance of that chain would need to get involved, or an account on another chain, in which case the `execute()` transaction would need to be submitted on that other chain and a message sent to the chain with trapped funds.\n\nMultiple assets can be claimed with the same message. This is useful when governance needs to get involved.\n\n```typescript\nconst claimAssetsXcm = XcmVersionedXcm.V5([\n  // Claim trapped DOT.\n  XcmV5Instruction.ClaimAsset(/* ... */),\n  XcmV5Instruction.PayFees(/* Pay for fees */),\n  XcmV5Instruction.ClaimAsset(/* ... */),\n  XcmV5Instruction.ClaimAsset(/* ... */),\n  XcmV5Instruction.ClaimAsset(/* ... */),\n  XcmV5Instruction.DepositAsset(/* Deposit everything to an account */),\n]);\n```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 5, "depth": 2, "title": "The `AssetClaimer` Hint", "anchor": "the-assetclaimer-hint", "start_char": 4500, "end_char": 8239, "estimated_token_count": 673, "token_estimator": "heuristic-v1", "text": "## The `AssetClaimer` Hint\n\nThe [`AssetClaimer`](https://paritytech.github.io/polkadot-sdk/master/cumulus_primitives_core/enum.Hint.html#variant.AssetClaimer){target=\\_blank} execution hint allows setting a specific location that can claim trapped assets, making the claiming process easier. This is set after withdrawing assets and before anything else:\n\n```typescript\nconst failingXcm = XcmVersionedXcm.V5([\n  // Withdraw 1 DOT (10 decimals).\n  XcmV5Instruction.WithdrawAsset([\n    {\n      id: { parents: 1, interior: XcmV5Junctions.Here() },\n      fun: XcmV3MultiassetFungibility.Fungible(10_000_000_000n),\n    },\n  ]),\n  // Set the asset claimer.\n  XcmV5Instruction.SetHints({\n    hints: [\n      Enum(\n        'AssetClaimer',\n        {\n          location: {\n            parents: 0,\n            interior: XcmV5Junctions.X1(XcmV5Junction.AccountId32({\n              id: FixedSizeBinary.fromAccountId32(SS58_ACCOUNT),\n              network: undefined,\n            })),\n          }\n        }\n      )\n    ]\n  }),\n  // Pay fees.\n  XcmV5Instruction.PayFees({\n    asset: {\n      id: { parents: 1, interior: XcmV5Junctions.Here() },\n      fun: XcmV3MultiassetFungibility.Fungible(1_000_000_000n),\n    },\n  }),\n  // Explicitly trap. Alternatively, doing nothing would still result in the assets getting trapped.\n  XcmV5Instruction.Trap(0n),\n]);\n```\n\nThis allows this other `SS58_ACCOUNT` to claim the trapped assets. This could also be done before a transfer.\n\n??? code \"Teleport with custom asset claimer example\"\n\n    ```typescript\n    const setAssetClaimerRemotely = XcmVersionedXcm.V5([\n      // Withdraw 1 DOT (10 decimals).\n      XcmV5Instruction.WithdrawAsset([\n        {\n          id: { parents: 1, interior: XcmV5Junctions.Here() },\n          fun: XcmV3MultiassetFungibility.Fungible(10_000_000_000n),\n        },\n      ]),\n      // Pay fees.\n      XcmV5Instruction.PayFees({\n        asset: {\n          id: { parents: 1, interior: XcmV5Junctions.Here() },\n          fun: XcmV3MultiassetFungibility.Fungible(1_000_000_000n),\n        },\n      }),\n      // Cross-chain transfer.\n      XcmV5Instruction.InitiateTransfer({\n        destination: { parents: 1, interior: XcmV5Junctions.X1(XcmV5Junction.Parachain(1000)) },\n        remote_fees: Enum(\n          'Teleport',\n          XcmV5AssetFilter.Definite([\n            {\n              id: { parents: 1, interior: XcmV5Junctions.Here() },\n              fun: XcmV3MultiassetFungibility.Fungible(1_000_000_000n),\n            },\n          ])\n        ),\n        preserve_origin: false,\n        assets: [\n          Enum(\n            'Teleport',\n            XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1))\n          ),\n        ],\n        remote_xcm: [\n          // Set the asset claimer on the destination chain.\n          // If any asset gets trapped, this account will be able to claim them.\n          XcmV5Instruction.SetHints({\n            hints: [\n              Enum(\n                'AssetClaimer',\n                {\n                  location: {\n                    parents: 0,\n                    interior: XcmV5Junctions.X1(XcmV5Junction.AccountId32({\n                      id: FixedSizeBinary.fromAccountId32(SS58_ACCOUNT),\n                      network: undefined,\n                    })),\n                  }\n                }\n              )\n            ]\n          }),\n          XcmV5Instruction.DepositAsset({\n            assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n            beneficiary: {\n              parents: 1, interior: XcmV5Junctions.X1(XcmV5Junction.AccountId32({\n                id: FixedSizeBinary.fromAccountId32(SS58_ACCOUNT),\n                network: undefined,\n              })),\n            }\n          }),\n        ],\n      }),\n    ]);\n    ```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-claiming-trapped-assets", "page_title": "Claiming Trapped Assets", "index": 6, "depth": 2, "title": "Best practices", "anchor": "best-practices", "start_char": 8239, "end_char": 8821, "estimated_token_count": 123, "token_estimator": "heuristic-v1", "text": "## Best practices\n\n1. **Always set a claimer**: Include `SetAssetClaimer` in XCMs with valuable assets.\n2. **Use accessible locations**: Ensure the claimer location is controlled by someone who can act.\n3. **Monitor for failures**: Track XCM execution to detect when claiming is needed.\n4. **Test claiming flows**: Verify your claiming logic works in test environments.\n5. **Document recovery procedures**: Maintain clear instructions for asset recovery.\n\nSetting a custom asset claimer is a good practice for recovering trapped assets without the need for governance intervention."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-fees", "page_title": "Fees", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 8, "end_char": 1091, "estimated_token_count": 233, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nIn blockchain systems, fees are crucial. They prevent malicious actors from exhausting the results of the network, making such attacks expensive. The XCM subsystem has its own way of dealing with fees, flexible enough to allow feeless execution in situations that warrant it.\n\nIt's important to distinguish between **transaction fees** and **XCM fees**. Transaction fees are paid when submitting extrinsics to a blockchain. XCM fees, on the other hand, are charged for processing XCM instructions and consist of execution fees (computational costs) and delivery fees (message transport costs). While a transaction can include XCM fees, as happens with [`palletXcm.execute()`](https://paritytech.github.io/polkadot-sdk/master/pallet_xcm/pallet/struct.Pallet.html#method.execute){target=\\_blank} extrinsic, they are separate fee systems. When a chain receives and processes an XCM message, it charges XCM fees but no transaction fees, since no extrinsic is being submitted.\n\nThere are two main types of fees in XCM: [execution](#execution) and [delivery](#delivery)."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-fees", "page_title": "Fees", "index": 1, "depth": 2, "title": "Execution", "anchor": "execution", "start_char": 1091, "end_char": 1661, "estimated_token_count": 127, "token_estimator": "heuristic-v1", "text": "## Execution\n\nAll XCMs have a weight associated with them. Each XCM instruction is benchmarked for a particular system (blockchain), which assigns them a weight. The weight of an XCM is the sum of the weight of all instructions. It's important to correctly benchmark this with the worst case so that your system is safe from [Denial-of-Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack){target=\\_blank} attacks.\n\nThis generated weight represents how much time, and space, is needed for executing the XCM. It directly translates to _execution fees_."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-fees", "page_title": "Fees", "index": 2, "depth": 2, "title": "Delivery", "anchor": "delivery", "start_char": 1661, "end_char": 1954, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "## Delivery\n\nXCMs, although capable of performing tasks locally, are meant to be sent to other consensus systems, i.e. blockchains.\n_Delivery fees_ are charged when a message is sent to a destination. The delivery fee amount depends on the size of the message, in bytes, and the destination."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-fees", "page_title": "Fees", "index": 3, "depth": 2, "title": "PayFees", "anchor": "payfees", "start_char": 1954, "end_char": 3856, "estimated_token_count": 409, "token_estimator": "heuristic-v1", "text": "## PayFees\n\nIn order to keep things simpler, these two fees are dealt in the same way. The user is asked to input the maximum amount they want to dedicate for fees. This amount is used _only_ for fees.\n\nThe amount is specified using the [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.PayFees){target=\\_blank} instruction:\n\n```typescript\nXcmV5Instruction.PayFees({\n  asset: {\n    id: // Asset id.\n    fun: // Fungibility. Specify the amount if fungible or the instance if NFT.\n  },\n})\n```\n\nThis mechanism is simple and flexible. The user requires no knowledge of the different types of fees. New fees might arise in the future and they'll be taken using this same mechanism, without the need for any modification.\n\nWhich assets can be used for fee payment depends on the destination chain's configuration. For example, on [Asset Hub](/polkadot-protocol/architecture/system-chains/asset-hub/){target=\\_blank}, fees can be paid with any asset that has a liquidity pool with DOT, allowing the chain to automatically convert the fee asset to DOT for actual fee payment. Other chains may have different fee payment policies, so it's important to understand the specific requirements of the destination chain before selecting fee assets.\n\n!!! note \"Sufficient assets vs fee payment assets\"\n\n    It's important to distinguish between \"sufficient\" assets and assets eligible for fee payment. Sufficient assets can be used to satisfy the [Existential Deposit](/polkadot-protocol/glossary/#existential-deposit){target=\\_blank} requirement for account creation and maintenance, but this doesn't automatically make them eligible for fee payment. While sufficient assets are generally also usable for fee payment, this isn't guaranteed and depends on the chain's specific configuration. The terms are related but serve different purposes in system."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-fees", "page_title": "Fees", "index": 4, "depth": 2, "title": "Estimations", "anchor": "estimations", "start_char": 3856, "end_char": 6304, "estimated_token_count": 620, "token_estimator": "heuristic-v1", "text": "## Estimations\n\nThe entirety of the asset passed to [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.PayFees){target=\\_blank} will be taken from the effective assets and used only for fees. This means if you overestimate the fees required, you'll be losing efficiency.\n\nIt's necessary to have a mechanism to accurately estimate the fee needed so it can be put into [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.PayFees){target=\\_blank}. This is more complicated than it sounds since the process involves execution and delivery fees, potentially in multiple hops.\n\nImagine a scenario where parachain A sends a message to B which forwards another message to C:\n\n``` mermaid\nflowchart LR\n  A(Parachain A) --sends message--> B(Parachain B)\n  B --forwards message--> C(Parachain C)\n```\n\n1. Execution fees need to be paid on A.\n2. Delivery fees need to be paid from A to B.\n3. Execution occurs on B.\n4. Delivery from B to C.\n5. Execution occurs on C.\n\nAn XCM that does this might look like so:\n\n```typescript\nconst xcm = XcmVersionedXcm.V5([\n  XcmV5Instruction.WithdrawAsset(/* some assets */),\n  XcmV5Instruction.PayFees(/* execution + delivery on A */),\n  XcmV5Instruction.InitiateTransfer({\n    // ...\n    remote_fees: /* execution + delivery on B */,\n    remote_xcm: [\n      XcmV5Instruction.InitiateTransfer({\n        // ...\n        remote_fees: /* execution on C */,\n        // ...\n      }),\n    ],\n    // ...\n  }),\n])\n```\n\nPaying fees on a remote system is so common that the [`InitiateTransfer`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.InitiateTransfer){target=\\_blank} instruction provides the [`remote_fees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.InitiateTransfer.field.remote_fees){target=\\_blank} parameter for this purpose. When `remote_fees` is specified, it automatically generates a [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.PayFees){target=\\_blank} instruction on the destination chain using the specified fees, eliminating the need to manually add [`PayFees`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.PayFees){target=\\_blank} to the `remote_xcm` parameter."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transact", "page_title": "Transact", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 12, "end_char": 2141, "estimated_token_count": 525, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [`Transact`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.Transact){target=\\_blank} instruction enables arbitrary cross-chain execution of pallet calls or smart contract functions. It's one of the most powerful XCM instructions because it allows you to perform any operation that would normally be done locally on a remote chain. However, it requires knowing the implementation details of the destination chain.\n\nThe basic structure of the [`Transact`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.Transact){target=\\_blank} instruction is as follows:\n\n```typescript\nXcmV5Instruction.Transact({\n  call: /* The encoded call to execute */,\n  origin_kind: /* OriginKind specifying how to treat the origin */,\n  fallback_max_weight: /* Optional weight limit for non-v5 destinations */,\n})\n```\n\nThe parameters are as follows:\n\n- **`call`**: The encoded runtime call to execute on the destination chain.\n- **`origin_kind`**: Specifies how the origin should be interpreted on the destination chain:\n    - [`Native`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v3/enum.OriginKind.html#variant.Native){target=\\_blank}: Execute as the native account of the origin.\n    - [`SovereignAccount`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v3/enum.OriginKind.html#variant.SovereignAccount){target=\\_blank}: Execute as the sovereign account of the origin.\n    - [`Superuser`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v3/enum.OriginKind.html#variant.Superuser){target=\\_blank}: Execute with root privileges (requires special configuration).\n    - [`Xcm`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v3/enum.OriginKind.html#variant.Xcm){target=\\_blank}: Execute as a generic XCM origin.\n- **`fallback_max_weight`**: Optional weight limit for execution:\n    - `None`: Let the destination chain calculate weight automatically (requires XCMv5 support).\n    - `Some(weight)`: Specify maximum weight for backward compatibility with pre-v5 chains."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transact", "page_title": "Transact", "index": 1, "depth": 2, "title": "Chain-Specific Knowledge Required", "anchor": "chain-specific-knowledge-required", "start_char": 2141, "end_char": 2730, "estimated_token_count": 158, "token_estimator": "heuristic-v1", "text": "## Chain-Specific Knowledge Required\n\nUnlike other XCM instructions like [`DepositAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.DepositAsset){target=\\_blank} or [`WithdrawAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.WithdrawAsset){target=\\_blank}, which are generic, [`Transact`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.Transact){target=\\_blank} requires detailed knowledge of the destination chain:"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transact", "page_title": "Transact", "index": 2, "depth": 3, "title": "Required Knowledge", "anchor": "required-knowledge", "start_char": 2730, "end_char": 3026, "estimated_token_count": 67, "token_estimator": "heuristic-v1", "text": "### Required Knowledge\n\n1. **Runtime metadata**: The specific pallets, calls, and their parameters available on the destination chain.\n2. **Call encoding**: How to properly encode the call data for the destination runtime.\n3. **Permissions**: What origins are allowed to execute specific calls."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transact", "page_title": "Transact", "index": 3, "depth": 3, "title": "Examples of Chain-Specific Requirements", "anchor": "examples-of-chain-specific-requirements", "start_char": 3026, "end_char": 3483, "estimated_token_count": 99, "token_estimator": "heuristic-v1", "text": "### Examples of Chain-Specific Requirements\n\n```typescript\n// Example: Different chains have different ways to represent the same operation\n\n// Asset Hub - using pallet_assets\nconst assetHubCall = api.tx.Assets.transfer({\n  id: 1984, // USDT\n  target: beneficiary,\n  amount: 1_000_000n\n})\n\n// Hydration - using pallet_currencies\nconst hydrationCall = api.tx.Currencies.transfer({\n  dest: beneficiary,\n  currency_id: 10, // USDT\n  amount: 1_000_000n\n})\n```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transact", "page_title": "Transact", "index": 4, "depth": 2, "title": "Origin Considerations", "anchor": "origin-considerations", "start_char": 3483, "end_char": 4444, "estimated_token_count": 233, "token_estimator": "heuristic-v1", "text": "## Origin Considerations\n\nThe choice of [`origin_kind`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.Transact.field.origin_kind){target=\\_blank} significantly affects what operations are permitted:\n\n- Use [`SovereignAccount`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v3/enum.OriginKind.html#variant.SovereignAccount){target=\\_blank} for most application use cases.\n- [`Superuser`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v3/enum.OriginKind.html#variant.Superuser){target=\\_blank} requires special trust relationships and configuration.\n- Consider how the destination chain interprets different origin kinds.\n\nThe [`Transact`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/opaque/type.Instruction.html#variant.Transact){target=\\_blank} instruction is powerful but requires careful consideration of the trade-offs between flexibility and maintainability."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transfers", "page_title": "Transfers", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 13, "end_char": 789, "estimated_token_count": 164, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [`InitiateTransfer`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.InitiateTransfer){target=\\_blank} instruction is the primary mechanism for cross-chain transfers in XCM. It provides a unified interface for different types of transfers and brings additional functionalities not possible with previous instruction versions.\n\n```typescript\nXcmV5Instruction.InitiateTransfer({\n  destination: /* location of recipient */,\n  remote_fees: /* fees for recipient */,\n  preserve_origin: /* whether or not the original origin should be preserved */,\n  assets: /* the assets being transferred and the type of transfer */,\n  remote_xcm: /* xcm to be executed in the recipient after transferring the assets */,\n})\n```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transfers", "page_title": "Transfers", "index": 1, "depth": 2, "title": "Transfer Types", "anchor": "transfer-types", "start_char": 789, "end_char": 3447, "estimated_token_count": 625, "token_estimator": "heuristic-v1", "text": "## Transfer Types\n\nThe `remote_fees` parameter only takes one asset, while `assets` can list multiple. Both must specify a **transfer type** — either:\n\n- [**Teleport**](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.AssetTransferFilter.html#variant.Teleport){target=\\_blank} – Moves assets by effectively \"destroying\" them on the source chain and \"creating\" them on the destination. Useful when both chains trust each other for that asset.\n- [**Reserve Deposit**](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.AssetTransferFilter.html#variant.ReserveDeposit){target=\\_blank} – A reserve transfer where _your chain is the reserve_ for the asset. The asset stays locked on your chain, and a representation is minted on the destination.\n- [**Reserve Withdraw**](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.AssetTransferFilter.html#variant.ReserveWithdraw){target=\\_blank} – A reserve transfer where _the destination chain is the reserve_. Assets are withdrawn from their reserve location and credited to the recipient.\n\nThese types come from the [`AssetTransferFilter`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.AssetTransferFilter.html){target=\\_blank} enum in XCM.\n\nFor example, to transfer 50 DOT via a teleport, the transfer type must be specified as a teleport. This also requires using an [Asset Filter](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.AssetFilter.html){target=\\_blank}.\n\nInstead of this:\n\n```typescript\nconst assets = [\n  XcmV5AssetFilter.Definite([\n    {\n      id: DOT,\n      fun: XcmV3MultiassetFungibility.Fungible(50n * DOT_UNITS),\n    },\n  ]),\n];\n```\n\nThe correct approach is:\n\n```typescript\nconst assets = [\n  Enum(\n    'Teleport',\n    XcmV5AssetFilter.Definite([\n      {\n        id: DOT,\n        fun: XcmV3MultiassetFungibility.Fungible(50n * DOT_UNITS),\n      },\n    ]),\n  ),\n];\n```\n\nThis allows specifying multiple assets with multiple different transfer types. It also allows sending the remote fees with a different transfer type. For example:\n\n```typescript\nconst remoteFees = Enum(\n  'ReserveDeposit',\n  XcmV5AssetFilter.Definite([\n    {\n      id: ETH,\n      fun: ...,\n    },\n  ]),\n);\nconst assets = [\n  Enum(\n    'Teleport',\n    XcmV5AssetFilter.Definite([\n      {\n        id: DOT,\n        fun: XcmV3MultiassetFungibility.Fungible(50n * DOT_UNITS),\n      },\n    ]),\n  ),\n  Enum(\n    'ReserveDeposit',\n    XcmV5AssetFilter.Definite([\n      {\n        id: USDT,\n        fun: ...,\n      },\n      {\n        id: USDC,\n        fun: ...,\n      },\n    ]),\n  ),\n];\n```\n\nNote that `remoteFees` takes only one asset."}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transfers", "page_title": "Transfers", "index": 2, "depth": 2, "title": "Remote Fees", "anchor": "remote-fees", "start_char": 3447, "end_char": 11158, "estimated_token_count": 1536, "token_estimator": "heuristic-v1", "text": "## Remote Fees\n\nPaying fees on the remote chain is such a common operation that [`InitiateTransfer`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.InitiateTransfer){target=\\_blank} has a parameter for it.\nJust by specifying the assets that go here, the XCM on the destination will include a `PayFees` instruction.\nAs mentioned before, you need to specify the transfer type.\n\n!!! note \"Do I have to specify remote fees all the time?\"\n\n    Yes. Fees are important for decentralized systems to prevent spam. Although it is possible to not specify remote fees, this is most likely not what you want when developing applications. Omitting the remote fees will append an [`UnpaidExecution`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.UnpaidExecution){target=\\_blank} instruction to the remote XCM. This instruction signals to the destination system that there is a reason execution is allowed a message without paying for fees.\n\n    This usually means you're a privileged origin, like `Root` or the `Fellowship` origin. It's mostly used from the runtime of the Polkadot SDK-based chains instead of from applications.\n\n??? code \"Teleport Example\"\n\n    This example creates an XCM program that teleports DOT from Asset Hub to People. The following code uses the PAPI library, check out the [PAPI guide](/develop/toolkit/api-libraries/papi/){target=\\_blank} for more information.\n\n    The setup for this script is [installing PAPI](/develop/toolkit/api-libraries/papi#get-started){target=\\_blank} and generating descriptors for Asset Hub:\n    `bun papi add ahp -n polkadot_asset_hub`\n\n    ```typescript title=\"teleport-example.ts\"\n    // `ahp` is the name given to `npx papi add`\n    import {\n      ahp,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3MultiassetFungibility,\n      XcmV5AssetFilter,\n      XcmV5Instruction,\n      XcmV5Junction,\n      XcmV5Junctions,\n      XcmV5WildAsset,\n      XcmVersionedXcm,\n    } from '@polkadot-api/descriptors';\n    import { createClient, Enum, FixedSizeBinary } from 'polkadot-api';\n    // import from \"polkadot-api/ws-provider/node\"\n    // if running in a NodeJS environment\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import { sr25519CreateDerive } from '@polkadot-labs/hdkd';\n    import {\n      DEV_PHRASE,\n      entropyToMiniSecret,\n      mnemonicToEntropy,\n    } from '@polkadot-labs/hdkd-helpers';\n    import { getPolkadotSigner } from 'polkadot-api/signer';\n\n    const entropy = mnemonicToEntropy(DEV_PHRASE);\n    const miniSecret = entropyToMiniSecret(entropy);\n    const derive = sr25519CreateDerive(miniSecret);\n    const keyPair = derive('//Alice');\n\n    const polkadotSigner = getPolkadotSigner(\n      keyPair.publicKey,\n      'Sr25519',\n      keyPair.sign\n    );\n\n    // Connect to Polkadot Asset Hub.\n    // Pointing to localhost since this example uses chopsticks.\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('ws://localhost:8000'))\n    );\n\n    // Get the typed API, a typesafe API for interacting with the chain.\n    const ahpApi = client.getTypedApi(ahp);\n\n    const PEOPLE_PARA_ID = 1004;\n    // The identifier for DOT is the location of the Polkadot Relay Chain,\n    // which is 1 up relative to any parachain.\n    const DOT = {\n      parents: 1,\n      interior: XcmV3Junctions.Here(),\n    };\n    // DOT has 10 decimals.\n    const DOT_UNITS = 10_000_000_000n;\n\n    // The DOT to withdraw for both fees and transfer.\n    const dotToWithdraw = {\n      id: DOT,\n      fun: XcmV3MultiassetFungibility.Fungible(10n * DOT_UNITS),\n    };\n    // The DOT to use for local fee payment.\n    const dotToPayFees = {\n      id: DOT,\n      fun: XcmV3MultiassetFungibility.Fungible(1n * DOT_UNITS),\n    };\n    // The location of the People Chain from Asset Hub.\n    const destination = {\n      parents: 1,\n      interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(PEOPLE_PARA_ID)),\n    };\n    // Pay for fees on the People Chain with teleported DOT.\n    // This is specified independently of the transferred assets since they're used\n    // exclusively for fees. Also because fees can be paid in a different\n    // asset from the transferred assets.\n    const remoteFees = Enum(\n      'Teleport',\n      XcmV5AssetFilter.Definite([\n        {\n          id: DOT,\n          fun: XcmV3MultiassetFungibility.Fungible(1n * DOT_UNITS),\n        },\n      ])\n    );\n    // No need to preserve origin for this example.\n    const preserveOrigin = false;\n    // The assets to transfer are whatever remains in the\n    // holding register at the time of executing the `InitiateTransfer`\n    // instruction. DOT in this case, teleported.\n    const assets = [\n      Enum('Teleport', XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1))),\n    ];\n    // The beneficiary is the same account but on the People Chain.\n    // This is a very common pattern for one public/private key pair\n    // to hold assets on multiple chains.\n    const beneficiary = FixedSizeBinary.fromBytes(keyPair.publicKey);\n    // The XCM to be executed on the destination chain.\n    // It's basically depositing everything to the beneficiary.\n    const remoteXcm = [\n      XcmV5Instruction.DepositAsset({\n        assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV5Junctions.X1(\n            XcmV5Junction.AccountId32({\n              id: beneficiary,\n              network: undefined,\n            })\n          ),\n        },\n      }),\n    ];\n\n    // The message assembles all the previously defined parameters.\n    const xcm = XcmVersionedXcm.V5([\n      XcmV5Instruction.WithdrawAsset([dotToWithdraw]),\n      XcmV5Instruction.PayFees({ asset: dotToPayFees }),\n      XcmV5Instruction.InitiateTransfer({\n        destination,\n        remote_fees: remoteFees,\n        preserve_origin: preserveOrigin,\n        assets,\n        remote_xcm: remoteXcm,\n      }),\n      // Return any leftover fees from the fees register back to holding.\n      XcmV5Instruction.RefundSurplus(),\n      // Deposit remaining assets (refunded fees) to the originating account.\n      // Using AllCounted(1) since only one asset type (DOT) remains - a minor optimization.\n      XcmV5Instruction.DepositAsset({\n        assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV5Junctions.X1(\n            XcmV5Junction.AccountId32({\n              id: beneficiary, // The originating account.\n              network: undefined,\n            })\n          ),\n        },\n      }),\n    ]);\n\n    // The XCM weight is needed to set the `max_weight` parameter\n    // on the actual `PolkadotXcm.execute()` call.\n    const weightResult = await ahpApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n\n    if (weightResult.success) {\n      const weight = weightResult.success\n        ? weightResult.value\n        : { ref_time: 0n, proof_size: 0n };\n\n      console.dir(weight);\n\n      // The actual transaction to submit.\n      // This tells Asset Hub to execute the XCM.\n      const tx = ahpApi.tx.PolkadotXcm.execute({\n        message: xcm,\n        max_weight: weight,\n      });\n\n      // Sign and propagate to the network.\n      const result = await tx.signAndSubmit(polkadotSigner);\n      console.log(stringify(result));\n    }\n\n    client.destroy();\n\n    // A helper function to print numbers inside of the result.\n    function stringify(obj: any) {\n      return JSON.stringify(\n        obj,\n        (_, v) => (typeof v === 'bigint' ? v.toString() : v),\n        2\n      );\n    }\n\n    ```"}
{"page_id": "develop-interoperability-xcm-guides-from-apps-transfers", "page_title": "Transfers", "index": 3, "depth": 2, "title": "Origin Preservation", "anchor": "origin-preservation", "start_char": 11158, "end_char": 20278, "estimated_token_count": 1857, "token_estimator": "heuristic-v1", "text": "## Origin Preservation\n\nIn previous versions of XCM, doing cross-chain transfers meant losing the origin. The XCM on the destination chain would have access to the transferred assets, but not to the origin. This means any instruction which uses assets but not the origin could be executed, that's enough to call [`DepositAsset`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.DepositAsset){target=\\_blank} for example and complete the transfer, but not to call [`Transact`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.Transact){target=\\_blank} and execute a call.\n\nIn XCMv5, [`InitiateTransfer`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.InitiateTransfer){target=\\_blank} allows **preserving the origin**, enabling more use-cases such as executing a call on the destination chain via [`Transact`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.Transact){target=\\_blank}.\nTo enable this feature, the [`preserve_origin`](https://paritytech.github.io/polkadot-sdk/master/staging_xcm/v5/enum.Instruction.html#variant.InitiateTransfer.field.preserve_origin){target=\\_blank} parameter must be set to `true`.\n\n!!! note \"Why isn't preserving the origin the default?\"\n\n    Preserving the origin requires a specific configuration on the underlying chain executing the XCM. Some chains have the right configuration, for example all system chains, but not every chain has it. If you make a transfer with `preserve_origin: true` to a chain configured incorrectly, the transfer will fail.\n\n    However, if you set `preserve_origin: false` then there is no problem. Because of this, origin preservation is not the default, and likely never will be.\n\n??? code \"Teleport and Transact Example\"\n\n    This example creates an XCM program that teleports DOT from Asset Hub to People and executes a call there. The whole script is almost the same as the one for a simple teleport above, most changes are in the `remoteXcm` variable.\n\n    The setup for this script is [installing PAPI](/develop/toolkit/api-libraries/papi#get-started){target=\\_blank} and generating descriptors for both Asset Hub and People:\n    `bun papi add ahp -n polkadot_asset_hub && bun papi add people -n polkadot_people`\n\n    ```typescript title=\"teleport-and-transact.ts\"\n    // `ahp` is the name given to `npx papi add`\n    import {\n      ahp,\n      people,\n      XcmV2OriginKind,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3MultiassetFungibility,\n      XcmV5AssetFilter,\n      XcmV5Instruction,\n      XcmV5Junction,\n      XcmV5Junctions,\n      XcmV5WildAsset,\n      XcmVersionedXcm,\n    } from '@polkadot-api/descriptors';\n    import { Binary, createClient, Enum, FixedSizeBinary } from 'polkadot-api';\n    // import from \"polkadot-api/ws-provider/node\"\n    // if running in a NodeJS environment\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import { sr25519CreateDerive } from '@polkadot-labs/hdkd';\n    import {\n      DEV_PHRASE,\n      entropyToMiniSecret,\n      mnemonicToEntropy,\n      ss58Address,\n    } from '@polkadot-labs/hdkd-helpers';\n    import { getPolkadotSigner } from 'polkadot-api/signer';\n\n    const entropy = mnemonicToEntropy(DEV_PHRASE);\n    const miniSecret = entropyToMiniSecret(entropy);\n    const derive = sr25519CreateDerive(miniSecret);\n    const keyPair = derive('//Alice');\n\n    const polkadotSigner = getPolkadotSigner(\n      keyPair.publicKey,\n      'Sr25519',\n      keyPair.sign\n    );\n\n    // Connect to Polkadot Asset Hub.\n    // Pointing to localhost since this example uses chopsticks.\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('ws://localhost:8000'))\n    );\n\n    // Get the typed API, a typesafe API for interacting with the chain.\n    const ahpApi = client.getTypedApi(ahp);\n\n    const PEOPLE_PARA_ID = 1004;\n    // The identifier for DOT is the location of the Polkadot Relay Chain,\n    // which is 1 up relative to any parachain.\n    const DOT = {\n      parents: 1,\n      interior: XcmV3Junctions.Here(),\n    };\n    // DOT has 10 decimals.\n    const DOT_UNITS = 10_000_000_000n;\n\n    // The DOT to withdraw for both fees and transfer.\n    const dotToWithdraw = {\n      id: DOT,\n      fun: XcmV3MultiassetFungibility.Fungible(10n * DOT_UNITS),\n    };\n    // The DOT to use for local fee payment.\n    const dotToPayFees = {\n      id: DOT,\n      fun: XcmV3MultiassetFungibility.Fungible(1n * DOT_UNITS),\n    };\n    // The location of the People Chain from Asset Hub.\n    const destination = {\n      parents: 1,\n      interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(PEOPLE_PARA_ID)),\n    };\n    // Pay for fees on the People Chain with teleported DOT.\n    // This is specified independently of the transferred assets since they're used\n    // exclusively for fees. Also because fees can be paid in a different\n    // asset from the transferred assets.\n    const remoteFees = Enum(\n      'Teleport',\n      XcmV5AssetFilter.Definite([\n        {\n          id: DOT,\n          fun: XcmV3MultiassetFungibility.Fungible(1n * DOT_UNITS),\n        },\n      ])\n    );\n    // No need to preserve origin for this example.\n    const preserveOrigin = false;\n    // The assets to transfer are whatever remains in the\n    // holding register at the time of executing the `InitiateTransfer`\n    // instruction. DOT in this case, teleported.\n    const assets = [\n      Enum('Teleport', XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1))),\n    ];\n    // The beneficiary is the same account but on the People Chain.\n    // This is a very common pattern for one public/private key pair\n    // to hold assets on multiple chains.\n    const beneficiary = FixedSizeBinary.fromBytes(keyPair.publicKey);\n    // The call to be executed on the destination chain.\n    // It's a simple remark with an event.\n    // Create the call on Asset Hub since the system pallet is present in\n    // every runtime, but if using any other pallet, connect to\n    // the destination chain and create the call there.\n    const remark = Binary.fromText('Hello, cross-chain!');\n    const call = await ahpApi.tx.System.remark_with_event({\n      remark,\n    }).getEncodedData();\n    // The XCM to be executed on the destination chain.\n    // It's basically depositing everything to the beneficiary.\n    const remoteXcm = [\n      XcmV5Instruction.Transact({\n        origin_kind: XcmV2OriginKind.SovereignAccount(),\n        fallback_max_weight: undefined,\n        call,\n      }),\n      XcmV5Instruction.RefundSurplus(),\n      XcmV5Instruction.DepositAsset({\n        assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV5Junctions.X1(\n            XcmV5Junction.AccountId32({\n              id: beneficiary,\n              network: undefined,\n            })\n          ),\n        },\n      }),\n    ];\n\n    // The message assembles all the previously defined parameters.\n    const xcm = XcmVersionedXcm.V5([\n      XcmV5Instruction.WithdrawAsset([dotToWithdraw]),\n      XcmV5Instruction.PayFees({ asset: dotToPayFees }),\n      XcmV5Instruction.InitiateTransfer({\n        destination,\n        remote_fees: remoteFees,\n        preserve_origin: preserveOrigin,\n        assets,\n        remote_xcm: remoteXcm,\n      }),\n      // Return any leftover fees from the fees register back to holding.\n      XcmV5Instruction.RefundSurplus(),\n      // Deposit remaining assets (refunded fees) to the originating account.\n      // Using AllCounted(1) since only one asset type (DOT) remains - a minor optimization.\n      XcmV5Instruction.DepositAsset({\n        assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV5Junctions.X1(\n            XcmV5Junction.AccountId32({\n              id: beneficiary, // The originating account.\n              network: undefined,\n            })\n          ),\n        },\n      }),\n    ]);\n\n    // The XCM weight is needed to set the `max_weight` parameter\n    // on the actual `PolkadotXcm.execute()` call.\n    const weightResult = await ahpApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n\n    if (weightResult.success) {\n      const weight = weightResult.success\n        ? weightResult.value\n        : { ref_time: 0n, proof_size: 0n };\n\n      console.dir(weight);\n\n      // The actual transaction to submit.\n      // This tells Asset Hub to execute the XCM.\n      const tx = ahpApi.tx.PolkadotXcm.execute({\n        message: xcm,\n        max_weight: weight,\n      });\n\n      // Sign and propagate to the network.\n      const result = await tx.signAndSubmit(polkadotSigner);\n      console.log(stringify(result));\n    }\n\n    client.destroy();\n\n    // A helper function to print numbers inside of the result.\n    function stringify(obj: any) {\n      return JSON.stringify(\n        obj,\n        (_, v) => (typeof v === 'bigint' ? v.toString() : v),\n        2\n      );\n    }\n\n    ```"}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 20, "end_char": 932, "estimated_token_count": 159, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nRuntime APIs allow node-side code to extract information from the runtime state. While simple storage access retrieves stored values directly, runtime APIs enable arbitrary computation, making them a powerful tool for interacting with the chain's state.\n\nUnlike direct storage access, runtime APIs can derive values from storage based on arguments or perform computations that don't require storage access. For example, a runtime API might expose a formula for fee calculation, using only the provided arguments as inputs rather than fetching data from storage.\n\nIn general, runtime APIs are used for:\n\n- Accessing a storage item.\n- Retrieving a bundle of related storage items.\n- Deriving a value from storage based on arguments.\n- Exposing formulas for complex computational calculations.\n\nThis section will teach you about specific runtime APIs that support XCM processing and manipulation."}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 1, "depth": 2, "title": "Dry Run API", "anchor": "dry-run-api", "start_char": 932, "end_char": 1492, "estimated_token_count": 140, "token_estimator": "heuristic-v1", "text": "## Dry Run API\n\nThe [Dry-run API](https://paritytech.github.io/polkadot-sdk/master/xcm_runtime_apis/dry_run/trait.DryRunApi.html){target=\\_blank}, given an extrinsic, or an XCM program, returns its effects:\n\n- Execution result\n- Local XCM (in the case of an extrinsic)\n- Forwarded XCMs\n- List of events\n\nThis API can be used independently for dry-running, double-checking, or testing. However, it mainly shines when used with the [Xcm Payment API](#xcm-payment-api), given that it only estimates fees if you know the specific XCM you want to execute or send."}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 2, "depth": 3, "title": "Dry Run Call", "anchor": "dry-run-call", "start_char": 1492, "end_char": 26453, "estimated_token_count": 3671, "token_estimator": "heuristic-v1", "text": "### Dry Run Call\n\nThis API allows a dry-run of any extrinsic and obtaining the outcome if it fails or succeeds, as well as the local xcm and remote xcm messages sent to other chains.\n\n```rust\nfn dry_run_call(origin: OriginCaller, call: Call, result_xcms_version: XcmVersion) -> Result<CallDryRunEffects<Event>, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `origin` ++\"OriginCaller\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The origin used for executing the transaction.\n\n    ---\n\n    `call` ++\"Call\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    The extrinsic to be executed.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<CallDryRunEffects<Event>, Error>\"++\n\n    Effects of dry-running an extrinsic. If an error occurs, it is returned instead of the effects.\n\n    ??? child \"Type `CallDryRunEffects<Event>`\"\n\n        `execution_result` ++\"DispatchResultWithPostInfo\"++\n\n        The result of executing the extrinsic.\n\n        ---\n\n        `emitted_events` ++\"Vec<Event>\"++\n\n        The list of events fired by the extrinsic.\n\n        ---\n\n        `local_xcm` ++\"Option<VersionedXcm<()>>\"++\n\n        The local XCM that was attempted to be executed, if any.\n\n        ---\n\n        `forwarded_xcms` ++\"Vec<(VersionedLocation, Vec<VersionedXcm<()>>)>\"++\n\n        The list of XCMs that were queued for sending.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n\n??? interface \"Example\"\n\n    This example demonstrates how to simulate a cross-chain asset transfer from the Paseo network to the Pop Network using a [reserve transfer](https://wiki.polkadot.com/learn/learn-xcm-usecases/#reserve-asset-transfer){target=\\_blank} mechanism. Instead of executing the actual transfer, the code shows how to test and verify the transaction's behavior through a dry run before performing it on the live network.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n    ***Usage with PAPI***\n\n    ```js\n    import { paseo } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import {\n      PolkadotRuntimeOriginCaller,\n      XcmVersionedLocation,\n      XcmVersionedAssets,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3WeightLimit,\n      XcmV3MultiassetFungibility,\n      XcmV3MultiassetAssetId,\n    } from '@polkadot-api/descriptors';\n    import { DispatchRawOrigin } from '@polkadot-api/descriptors';\n    import { Binary } from 'polkadot-api';\n    import { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n    // Connect to the Paseo relay chain\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('wss://paseo-rpc.dwellir.com')),\n    );\n\n    const paseoApi = client.getTypedApi(paseo);\n\n    const popParaID = 4001;\n    const userAddress = 'INSERT_USER_ADDRESS';\n    const userPublicKey = ss58Decode(userAddress)[0];\n    const idBeneficiary = Binary.fromBytes(userPublicKey);\n\n    // Define the origin caller\n    // This is a regular signed account owned by a user\n    let origin = PolkadotRuntimeOriginCaller.system(\n      DispatchRawOrigin.Signed(userAddress),\n    );\n\n    // Define a transaction to transfer assets from Polkadot to Pop Network using a Reserve Transfer\n    const tx = paseoApi.tx.XcmPallet.limited_reserve_transfer_assets({\n      dest: XcmVersionedLocation.V3({\n        parents: 0,\n        interior: XcmV3Junctions.X1(\n          XcmV3Junction.Parachain(popParaID), // Destination is the Pop Network parachain\n        ),\n      }),\n      beneficiary: XcmVersionedLocation.V3({\n        parents: 0,\n        interior: XcmV3Junctions.X1(\n          XcmV3Junction.AccountId32({\n            // Beneficiary address on Pop Network\n            network: undefined,\n            id: idBeneficiary,\n          }),\n        ),\n      }),\n      assets: XcmVersionedAssets.V3([\n        {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 0,\n            interior: XcmV3Junctions.Here(), // Native asset from the sender. In this case PAS\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(120000000000n), // Asset amount to transfer\n        },\n      ]),\n      fee_asset_item: 0, // Asset used to pay transaction fees\n      weight_limit: XcmV3WeightLimit.Unlimited(), // No weight limit on transaction\n    });\n\n    // Execute the dry run call to simulate the transaction\n    const dryRunResult = await paseoApi.apis.DryRunApi.dry_run_call(\n      origin,\n      tx.decodedCall,\n    );\n\n    // Extract the data from the dry run result\n    const {\n      execution_result: executionResult,\n      emitted_events: emmittedEvents,\n      local_xcm: localXcm,\n      forwarded_xcms: forwardedXcms,\n    } = dryRunResult.value;\n\n    // Extract the XCM generated by this call\n    const xcmsToPop = forwardedXcms.find(\n      ([location, _]) =>\n        location.type === 'V4' &&\n        location.value.parents === 0 &&\n        location.value.interior.type === 'X1' &&\n        location.value.interior.value.type === 'Parachain' &&\n        location.value.interior.value.value === popParaID, // Pop network's ParaID\n    );\n    const destination = xcmsToPop[0];\n    const remoteXcm = xcmsToPop[1][0];\n\n    // Print the results\n    const resultObject = {\n      execution_result: executionResult,\n      emitted_events: emmittedEvents,\n      local_xcm: localXcm,\n      destination: destination,\n      remote_xcm: remoteXcm,\n    };\n\n    console.dir(resultObject, { depth: null });\n\n    client.destroy();\n\n    ```\n\n    ***Output***\n\n    <div id=\"termynal\" data-termynal>\n      <pre>\n        {\n          execution_result: {\n            success: true,\n            value: {\n              actual_weight: undefined,\n              pays_fee: { type: 'Yes', value: undefined }\n            }\n          },\n          emitted_events: [\n            {\n              type: 'Balances',\n              value: {\n                type: 'Transfer',\n                value: {\n                  from: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n                  to: '13YMK2ePPKQeW7ynqLozB65WYjMnNgffQ9uR4AzyGmqnKeLq',\n                  amount: 120000000000n\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: { type: 'Issued', value: { amount: 0n } }\n            },\n            {\n              type: 'XcmPallet',\n              value: {\n                type: 'Attempted',\n                value: {\n                  outcome: {\n                    type: 'Complete',\n                    value: { used: { ref_time: 251861000n, proof_size: 6196n } }\n                  }\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Burned',\n                value: {\n                  who: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n                  amount: 397000000n\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Minted',\n                value: {\n                  who: '13UVJyLnbVp9RBZYFwFGyDvVd1y27Tt8tkntv6Q7JVPhFsTB',\n                  amount: 397000000n\n                }\n              }\n            },\n            {\n              type: 'XcmPallet',\n              value: {\n                type: 'FeesPaid',\n                value: {\n                  paying: {\n                    parents: 0,\n                    interior: {\n                      type: 'X1',\n                      value: {\n                        type: 'AccountId32',\n                        value: {\n                          network: { type: 'Polkadot', value: undefined },\n                          id: FixedSizeBinary {\n                            asText: [Function (anonymous)],\n                            asHex: [Function (anonymous)],\n                            asOpaqueHex: [Function (anonymous)],\n                            asBytes: [Function (anonymous)],\n                            asOpaqueBytes: [Function (anonymous)]\n                          }\n                        }\n                      }\n                    }\n                  },\n                  fees: [\n                    {\n                      id: {\n                        parents: 0,\n                        interior: { type: 'Here', value: undefined }\n                      },\n                      fun: { type: 'Fungible', value: 397000000n }\n                    }\n                  ]\n                }\n              }\n            },\n            {\n              type: 'XcmPallet',\n              value: {\n                type: 'Sent',\n                value: {\n                  origin: {\n                    parents: 0,\n                    interior: {\n                      type: 'X1',\n                      value: {\n                        type: 'AccountId32',\n                        value: {\n                          network: { type: 'Polkadot', value: undefined },\n                          id: FixedSizeBinary {\n                            asText: [Function (anonymous)],\n                            asHex: [Function (anonymous)],\n                            asOpaqueHex: [Function (anonymous)],\n                            asBytes: [Function (anonymous)],\n                            asOpaqueBytes: [Function (anonymous)]\n                          }\n                        }\n                      }\n                    }\n                  },\n                  destination: {\n                    parents: 0,\n                    interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n                  },\n                  message: [\n                    {\n                      type: 'ReserveAssetDeposited',\n                      value: [\n                        {\n                          id: {\n                            parents: 1,\n                            interior: { type: 'Here', value: undefined }\n                          },\n                          fun: { type: 'Fungible', value: 120000000000n }\n                        }\n                      ]\n                    },\n                    { type: 'ClearOrigin', value: undefined },\n                    {\n                      type: 'BuyExecution',\n                      value: {\n                        fees: {\n                          id: {\n                            parents: 1,\n                            interior: { type: 'Here', value: undefined }\n                          },\n                          fun: { type: 'Fungible', value: 120000000000n }\n                        },\n                        weight_limit: { type: 'Unlimited', value: undefined }\n                      }\n                    },\n                    {\n                      type: 'DepositAsset',\n                      value: {\n                        assets: {\n                          type: 'Wild',\n                          value: { type: 'AllCounted', value: 1 }\n                        },\n                        beneficiary: {\n                          parents: 0,\n                          interior: {\n                            type: 'X1',\n                            value: {\n                              type: 'AccountId32',\n                              value: {\n                                network: undefined,\n                                id: FixedSizeBinary {\n                                  asText: [Function (anonymous)],\n                                  asHex: [Function (anonymous)],\n                                  asOpaqueHex: [Function (anonymous)],\n                                  asBytes: [Function (anonymous)],\n                                  asOpaqueBytes: [Function (anonymous)]\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  ],\n                  message_id: FixedSizeBinary {\n                    asText: [Function (anonymous)],\n                    asHex: [Function (anonymous)],\n                    asOpaqueHex: [Function (anonymous)],\n                    asBytes: [Function (anonymous)],\n                    asOpaqueBytes: [Function (anonymous)]\n                  }\n                }\n              }\n            }\n          ],\n          local_xcm: undefined,\n          destination: {\n            type: 'V4',\n            value: {\n              parents: 0,\n              interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n            }\n          },\n          remote_xcm: {\n            type: 'V3',\n            value: [\n              {\n                type: 'ReserveAssetDeposited',\n                value: [\n                  {\n                    id: {\n                      type: 'Concrete',\n                      value: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      }\n                    },\n                    fun: { type: 'Fungible', value: 120000000000n }\n                  }\n                ]\n              },\n              { type: 'ClearOrigin', value: undefined },\n              {\n                type: 'BuyExecution',\n                value: {\n                  fees: {\n                    id: {\n                      type: 'Concrete',\n                      value: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      }\n                    },\n                    fun: { type: 'Fungible', value: 120000000000n }\n                  },\n                  weight_limit: { type: 'Unlimited', value: undefined }\n                }\n              },\n              {\n                type: 'DepositAsset',\n                value: {\n                  assets: { type: 'Wild', value: { type: 'AllCounted', value: 1 } },\n                  beneficiary: {\n                    parents: 0,\n                    interior: {\n                      type: 'X1',\n                      value: {\n                        type: 'AccountId32',\n                        value: {\n                          network: undefined,\n                          id: FixedSizeBinary {\n                            asText: [Function (anonymous)],\n                            asHex: [Function (anonymous)],\n                            asOpaqueHex: [Function (anonymous)],\n                            asBytes: [Function (anonymous)],\n                            asOpaqueBytes: [Function (anonymous)]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              },\n              {\n                type: 'SetTopic',\n                value: FixedSizeBinary {\n                  asText: [Function (anonymous)],\n                  asHex: [Function (anonymous)],\n                  asOpaqueHex: [Function (anonymous)],\n                  asBytes: [Function (anonymous)],\n                  asOpaqueBytes: [Function (anonymous)]\n                }\n              }\n            ]\n          }\n        }      \n      </pre>\n    </div>\n\n                ...\n    <div id=\"termynal\" data-termynal>\n      <pre>\n        {\n          execution_result: {\n            success: true,\n            value: {\n              actual_weight: undefined,\n              pays_fee: { type: 'Yes', value: undefined }\n            }\n          },\n          emitted_events: [\n            {\n              type: 'Balances',\n              value: {\n                type: 'Transfer',\n                value: {\n                  from: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n                  to: '13YMK2ePPKQeW7ynqLozB65WYjMnNgffQ9uR4AzyGmqnKeLq',\n                  amount: 120000000000n\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: { type: 'Issued', value: { amount: 0n } }\n            },\n            {\n              type: 'XcmPallet',\n              value: {\n                type: 'Attempted',\n                value: {\n                  outcome: {\n                    type: 'Complete',\n                    value: { used: { ref_time: 251861000n, proof_size: 6196n } }\n                  }\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Burned',\n                value: {\n                  who: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n                  amount: 397000000n\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Minted',\n                value: {\n                  who: '13UVJyLnbVp9RBZYFwFGyDvVd1y27Tt8tkntv6Q7JVPhFsTB',\n                  amount: 397000000n\n                }\n              }\n            },\n            {\n              type: 'XcmPallet',\n              value: {\n                type: 'FeesPaid',\n                value: {\n                  paying: {\n                    parents: 0,\n                    interior: {\n                      type: 'X1',\n                      value: {\n                        type: 'AccountId32',\n                        value: {\n                          network: { type: 'Polkadot', value: undefined },\n                          id: FixedSizeBinary {\n                            asText: [Function (anonymous)],\n                            asHex: [Function (anonymous)],\n                            asOpaqueHex: [Function (anonymous)],\n                            asBytes: [Function (anonymous)],\n                            asOpaqueBytes: [Function (anonymous)]\n                          }\n                        }\n                      }\n                    }\n                  },\n                  fees: [\n                    {\n                      id: {\n                        parents: 0,\n                        interior: { type: 'Here', value: undefined }\n                      },\n                      fun: { type: 'Fungible', value: 397000000n }\n                    }\n                  ]\n                }\n              }\n            },\n            {\n              type: 'XcmPallet',\n              value: {\n                type: 'Sent',\n                value: {\n                  origin: {\n                    parents: 0,\n                    interior: {\n                      type: 'X1',\n                      value: {\n                        type: 'AccountId32',\n                        value: {\n                          network: { type: 'Polkadot', value: undefined },\n                          id: FixedSizeBinary {\n                            asText: [Function (anonymous)],\n                            asHex: [Function (anonymous)],\n                            asOpaqueHex: [Function (anonymous)],\n                            asBytes: [Function (anonymous)],\n                            asOpaqueBytes: [Function (anonymous)]\n                          }\n                        }\n                      }\n                    }\n                  },\n                  destination: {\n                    parents: 0,\n                    interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n                  },\n                  message: [\n                    {\n                      type: 'ReserveAssetDeposited',\n                      value: [\n                        {\n                          id: {\n                            parents: 1,\n                            interior: { type: 'Here', value: undefined }\n                          },\n                          fun: { type: 'Fungible', value: 120000000000n }\n                        }\n                      ]\n                    },\n                    { type: 'ClearOrigin', value: undefined },\n                    {\n                      type: 'BuyExecution',\n                      value: {\n                        fees: {\n                          id: {\n                            parents: 1,\n                            interior: { type: 'Here', value: undefined }\n                          },\n                          fun: { type: 'Fungible', value: 120000000000n }\n                        },\n                        weight_limit: { type: 'Unlimited', value: undefined }\n                      }\n                    },\n                    {\n                      type: 'DepositAsset',\n                      value: {\n                        assets: {\n                          type: 'Wild',\n                          value: { type: 'AllCounted', value: 1 }\n                        },\n                        beneficiary: {\n                          parents: 0,\n                          interior: {\n                            type: 'X1',\n                            value: {\n                              type: 'AccountId32',\n                              value: {\n                                network: undefined,\n                                id: FixedSizeBinary {\n                                  asText: [Function (anonymous)],\n                                  asHex: [Function (anonymous)],\n                                  asOpaqueHex: [Function (anonymous)],\n                                  asBytes: [Function (anonymous)],\n                                  asOpaqueBytes: [Function (anonymous)]\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  ],\n                  message_id: FixedSizeBinary {\n                    asText: [Function (anonymous)],\n                    asHex: [Function (anonymous)],\n                    asOpaqueHex: [Function (anonymous)],\n                    asBytes: [Function (anonymous)],\n                    asOpaqueBytes: [Function (anonymous)]\n                  }\n                }\n              }\n            }\n          ],\n          local_xcm: undefined,\n          destination: {\n            type: 'V4',\n            value: {\n              parents: 0,\n              interior: { type: 'X1', value: { type: 'Parachain', value: 4001 } }\n            }\n          },\n          remote_xcm: {\n            type: 'V3',\n            value: [\n              {\n                type: 'ReserveAssetDeposited',\n                value: [\n                  {\n                    id: {\n                      type: 'Concrete',\n                      value: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      }\n                    },\n                    fun: { type: 'Fungible', value: 120000000000n }\n                  }\n                ]\n              },\n              { type: 'ClearOrigin', value: undefined },\n              {\n                type: 'BuyExecution',\n                value: {\n                  fees: {\n                    id: {\n                      type: 'Concrete',\n                      value: {\n                        parents: 1,\n                        interior: { type: 'Here', value: undefined }\n                      }\n                    },\n                    fun: { type: 'Fungible', value: 120000000000n }\n                  },\n                  weight_limit: { type: 'Unlimited', value: undefined }\n                }\n              },\n              {\n                type: 'DepositAsset',\n                value: {\n                  assets: { type: 'Wild', value: { type: 'AllCounted', value: 1 } },\n                  beneficiary: {\n                    parents: 0,\n                    interior: {\n                      type: 'X1',\n                      value: {\n                        type: 'AccountId32',\n                        value: {\n                          network: undefined,\n                          id: FixedSizeBinary {\n                            asText: [Function (anonymous)],\n                            asHex: [Function (anonymous)],\n                            asOpaqueHex: [Function (anonymous)],\n                            asBytes: [Function (anonymous)],\n                            asOpaqueBytes: [Function (anonymous)]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              },\n              {\n                type: 'SetTopic',\n                value: FixedSizeBinary {\n                  asText: [Function (anonymous)],\n                  asHex: [Function (anonymous)],\n                  asOpaqueHex: [Function (anonymous)],\n                  asBytes: [Function (anonymous)],\n                  asOpaqueBytes: [Function (anonymous)]\n                }\n              }\n            ]\n          }\n        }      \n      </pre>\n    </div>\n\n    ---"}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 3, "depth": 3, "title": "Dry Run XCM", "anchor": "dry-run-xcm", "start_char": 26453, "end_char": 32859, "estimated_token_count": 1176, "token_estimator": "heuristic-v1", "text": "### Dry Run XCM\n\nThis API allows the direct dry-run of an xcm message instead of an extrinsic one, checks if it will execute successfully, and determines what other xcm messages will be forwarded to other chains.\n\n```rust\nfn dry_run_xcm(origin_location: VersionedLocation, xcm: VersionedXcm<Call>) -> Result<XcmDryRunEffects<Event>, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `origin_location` ++\"VersionedLocation\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    The location of the origin that will execute the xcm message.\n\n    ---\n\n    `xcm` ++\"VersionedXcm<Call>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    A versioned XCM message.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<XcmDryRunEffects<Event>, Error>\"++\n\n    Effects of dry-running an extrinsic. If an error occurs, it is returned instead of the effects.\n\n    ??? child \"Type `XcmDryRunEffects<Event>`\"\n\n        `execution_result` ++\"DispatchResultWithPostInfo\"++\n\n        The result of executing the extrinsic.\n\n        ---\n\n        `emitted_events` ++\"Vec<Event>\"++\n\n        The list of events fired by the extrinsic.\n\n        ---\n\n        `forwarded_xcms` ++\"Vec<(VersionedLocation, Vec<VersionedXcm<()>>)>\"++\n\n        The list of XCMs that were queued for sending.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to simulate a [teleport asset transfer](https://wiki.polkadot.com/learn/learn-xcm-usecases/#asset-teleportation){target=\\_blank} from the Paseo network to the Paseo Asset Hub parachain. The code shows how to test and verify the received XCM message's behavior in the destination chain through a dry run on the live network.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n     ***Usage with PAPI***\n\n    ```js\n    import { createClient } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import {\n      XcmVersionedXcm,\n      paseoAssetHub,\n      XcmVersionedLocation,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3WeightLimit,\n      XcmV3MultiassetFungibility,\n      XcmV3MultiassetAssetId,\n      XcmV3Instruction,\n      XcmV3MultiassetMultiAssetFilter,\n      XcmV3MultiassetWildMultiAsset,\n    } from '@polkadot-api/descriptors';\n    import { Binary } from 'polkadot-api';\n    import { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n    // Connect to Paseo Asset Hub\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n    );\n\n    const paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\n    const userAddress = 'INSERT_USER_ADDRESS';\n    const userPublicKey = ss58Decode(userAddress)[0];\n    const idBeneficiary = Binary.fromBytes(userPublicKey);\n\n    // Define the origin\n    const origin = XcmVersionedLocation.V3({\n      parents: 1,\n      interior: XcmV3Junctions.Here(),\n    });\n\n    // Define a xcm message comming from the Paseo relay chain to Asset Hub to Teleport some tokens\n    const xcm = XcmVersionedXcm.V3([\n      XcmV3Instruction.ReceiveTeleportedAsset([\n        {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 1,\n            interior: XcmV3Junctions.Here(),\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(12000000000n),\n        },\n      ]),\n      XcmV3Instruction.ClearOrigin(),\n      XcmV3Instruction.BuyExecution({\n        fees: {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 1,\n            interior: XcmV3Junctions.Here(),\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(BigInt(12000000000n)),\n        },\n        weight_limit: XcmV3WeightLimit.Unlimited(),\n      }),\n      XcmV3Instruction.DepositAsset({\n        assets: XcmV3MultiassetMultiAssetFilter.Wild(\n          XcmV3MultiassetWildMultiAsset.All(),\n        ),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV3Junctions.X1(\n            XcmV3Junction.AccountId32({\n              network: undefined,\n              id: idBeneficiary,\n            }),\n          ),\n        },\n      }),\n    ]);\n\n    // Execute dry run xcm\n    const dryRunResult = await paseoAssetHubApi.apis.DryRunApi.dry_run_xcm(\n      origin,\n      xcm,\n    );\n\n    // Print the results\n    console.dir(dryRunResult.value, { depth: null });\n\n    client.destroy();\n\n    ```\n\n    ***Output***\n\n    <div id=\"termynal\" data-termynal>\n      <pre>\n        {\n          execution_result: {\n            type: 'Complete',\n            value: { used: { ref_time: 15574200000n, proof_size: 359300n } }\n          },\n          emitted_events: [\n            {\n              type: 'System',\n              value: {\n                type: 'NewAccount',\n                value: { account: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET' }\n              }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Endowed',\n                value: {\n                  account: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n                  free_balance: 10203500000n\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Minted',\n                value: {\n                  who: '12pGtwHPL4tUAUcyeCoJ783NKRspztpWmXv4uxYRwiEnYNET',\n                  amount: 10203500000n\n                }\n              }\n            },\n            {\n              type: 'Balances',\n              value: { type: 'Issued', value: { amount: 1796500000n } }\n            },\n            {\n              type: 'Balances',\n              value: {\n                type: 'Deposit',\n                value: {\n                  who: '13UVJyLgBASGhE2ok3TvxUfaQBGUt88JCcdYjHvUhvQkFTTx',\n                  amount: 1796500000n\n                }\n              }\n            }\n          ],\n          forwarded_xcms: [\n            [\n              {\n                type: 'V4',\n                value: { parents: 1, interior: { type: 'Here', value: undefined } }\n              },\n              []\n            ]\n          ]\n        }\n      </pre>\n    </div>\n\n    ---"}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 4, "depth": 2, "title": "XCM Payment API", "anchor": "xcm-payment-api", "start_char": 32859, "end_char": 33945, "estimated_token_count": 222, "token_estimator": "heuristic-v1", "text": "## XCM Payment API\n\nThe [XCM Payment API](https://paritytech.github.io/polkadot-sdk/master/xcm_runtime_apis/fees/trait.XcmPaymentApi.html){target=\\_blank} provides a standardized way to determine the costs and payment options for executing XCM messages. Specifically, it enables clients to:\n\n- Retrieve the [weight](/polkadot-protocol/glossary/#weight) required to execute an XCM message.\n- Obtain a list of acceptable `AssetIds` for paying execution fees.\n- Calculate the cost of the weight in a specified `AssetId`.\n- Estimate the fees for XCM message delivery.\n\nThis API eliminates the need for clients to guess execution fees or identify acceptable assets manually. Instead, clients can query the list of supported asset IDs formatted according to the XCM version they understand. With this information, they can weigh the XCM program they intend to execute and convert the computed weight into its cost using one of the acceptable assets.\n\nTo use the API effectively, the client must already know the XCM program to be executed and the chains involved in the program's execution."}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 5, "depth": 3, "title": "Query Acceptable Payment Assets", "anchor": "query-acceptable-payment-assets", "start_char": 33945, "end_char": 36591, "estimated_token_count": 582, "token_estimator": "heuristic-v1", "text": "### Query Acceptable Payment Assets\n\nRetrieves the list of assets that are acceptable for paying fees when using a specific XCM version\n\n```rust\nfn query_acceptable_payment_assets(xcm_version: Version) -> Result<Vec<VersionedAssetId>, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `xcm_version` ++\"Version\"++ <span class=\"required\" markdown>++\"required\"++</span>\n\n    Specifies the XCM version that will be used to send the XCM message.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<Vec<VersionedAssetId>, Error>\"++\n\n    A list of acceptable payment assets. Each asset is provided in a versioned format (`VersionedAssetId`) that matches the specified XCM version. If an error occurs, it is returned instead of the asset list.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to query the acceptable payment assets for executing XCM messages on the Paseo Asset Hub network using XCM version 3.\n\n    ***Usage with PAPI***\n\n    ```js\n    import { paseoAssetHub } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n\n    // Connect to the polkadot relay chain\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n    );\n\n    const paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\n    // Define the xcm version to use\n    const xcmVersion = 3;\n\n    // Execute the runtime call to query the assets\n    const result =\n      await paseoAssetHubApi.apis.XcmPaymentApi.query_acceptable_payment_assets(\n        xcmVersion,\n      );\n\n    // Print the assets\n    console.dir(result.value, { depth: null });\n\n    client.destroy();\n\n    ```\n\n    ***Output***\n\n    <div id=\"termynal\" data-termynal>\n      <pre>\n        [\n          {\n            type: 'V3',\n            value: {\n              type: 'Concrete',\n              value: { parents: 1, interior: { type: 'Here', value: undefined } }\n            }\n          }\n        ]\n      </pre>\n    </div>\n\n    ---"}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 6, "depth": 3, "title": "Query XCM Weight", "anchor": "query-xcm-weight", "start_char": 36591, "end_char": 41192, "estimated_token_count": 922, "token_estimator": "heuristic-v1", "text": "### Query XCM Weight\n\nCalculates the weight required to execute a given XCM message. It is useful for estimating the execution cost of a cross-chain message in the destination chain before sending it.\n\n```rust\nfn query_xcm_weight(message: VersionedXcm<()>) -> Result<Weight, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `message` ++\"VersionedXcm<()>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    A versioned XCM message whose execution weight is being queried.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<Weight, Error>\"++\n    \n    The calculated weight required to execute the provided XCM message. If the calculation fails, an error is returned instead.\n\n    ??? child \"Type `Weight`\"\n\n        `ref_time` ++\"u64\"++\n\n        The weight of computational time used based on some reference hardware.\n\n        ---\n\n        `proof_size` ++\"u64\"++\n\n        The weight of storage space used by proof of validity.\n\n        ---\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to calculate the weight needed to execute a [teleport transfer](https://wiki.polkadot.com/learn/learn-xcm-usecases/#asset-teleportation){target=\\_blank} from the Paseo network to the Paseo Asset Hub parachain using the XCM Payment API. The result shows the required weight in terms of reference time and proof size needed in the destination chain.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n    ***Usage with PAPI***\n\n    ```js\n    import { createClient } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import {\n      XcmVersionedXcm,\n      paseoAssetHub,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3WeightLimit,\n      XcmV3MultiassetFungibility,\n      XcmV3MultiassetAssetId,\n      XcmV3Instruction,\n      XcmV3MultiassetMultiAssetFilter,\n      XcmV3MultiassetWildMultiAsset,\n    } from '@polkadot-api/descriptors';\n    import { Binary } from 'polkadot-api';\n    import { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n    // Connect to Paseo Asset Hub\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n    );\n\n    const paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\n    const userAddress = 'INSERT_USER_ADDRESS';\n    const userPublicKey = ss58Decode(userAddress)[0];\n    const idBeneficiary = Binary.fromBytes(userPublicKey);\n\n    // Define a xcm message comming from the Paseo relay chain to Asset Hub to Teleport some tokens\n    const xcm = XcmVersionedXcm.V3([\n      XcmV3Instruction.ReceiveTeleportedAsset([\n        {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 1,\n            interior: XcmV3Junctions.Here(),\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(12000000000n),\n        },\n      ]),\n      XcmV3Instruction.ClearOrigin(),\n      XcmV3Instruction.BuyExecution({\n        fees: {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 1,\n            interior: XcmV3Junctions.Here(),\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(BigInt(12000000000n)),\n        },\n        weight_limit: XcmV3WeightLimit.Unlimited(),\n      }),\n      XcmV3Instruction.DepositAsset({\n        assets: XcmV3MultiassetMultiAssetFilter.Wild(\n          XcmV3MultiassetWildMultiAsset.All(),\n        ),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV3Junctions.X1(\n            XcmV3Junction.AccountId32({\n              network: undefined,\n              id: idBeneficiary,\n            }),\n          ),\n        },\n      }),\n    ]);\n\n    // Execute the query weight runtime call\n    const result = await paseoAssetHubApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n\n    // Print the results\n    console.dir(result.value, { depth: null });\n\n    client.destroy();\n\n    ```\n\n    ***Output***\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty>{ ref_time: 15574200000n, proof_size: 359300n }</span>\n    </div>\n\n    ---"}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 7, "depth": 3, "title": "Query Weight to Asset Fee", "anchor": "query-weight-to-asset-fee", "start_char": 41192, "end_char": 44234, "estimated_token_count": 699, "token_estimator": "heuristic-v1", "text": "### Query Weight to Asset Fee\n\nConverts a given weight into the corresponding fee for a specified `AssetId`. It allows clients to determine the cost of execution in terms of the desired asset.\n\n```rust\nfn query_weight_to_asset_fee(weight: Weight, asset: VersionedAssetId) -> Result<u128, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `weight` ++\"Weight\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The execution weight to be converted into a fee.\n\n    ??? child \"Type `Weight`\"\n\n        `ref_time` ++\"u64\"++\n\n        The weight of computational time used based on some reference hardware.\n\n        ---\n\n        `proof_size` ++\"u64\"++\n\n        The weight of storage space used by proof of validity.\n\n        ---\n\n    ---\n\n    `asset` ++\"VersionedAssetId\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The asset in which the fee will be calculated. This must be a versioned asset ID compatible with the runtime.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<u128, Error>\"++\n    \n    The fee needed to pay for the execution for the given `AssetId.`\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to calculate the fee for a given execution weight using a specific versioned asset ID (PAS token) on Paseo Asset Hub.\n\n    ***Usage with PAPI***\n\n    ```js\n    import { paseoAssetHub } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n\n    // Connect to the polkadot relay chain\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('wss://asset-hub-paseo-rpc.dwellir.com')),\n    );\n\n    const paseoAssetHubApi = client.getTypedApi(paseoAssetHub);\n\n    // Define the weight to convert to fee\n    const weight = { ref_time: 15574200000n, proof_size: 359300n };\n\n    // Define the versioned asset id\n    const versionedAssetId = {\n      type: 'V4',\n      value: { parents: 1, interior: { type: 'Here', value: undefined } },\n    };\n\n    // Execute the runtime call to convert the weight to fee\n    const result =\n      await paseoAssetHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n        weight,\n        versionedAssetId,\n      );\n\n    // Print the fee\n    console.dir(result.value, { depth: null });\n\n    client.destroy();\n\n    ```\n\n    ***Output***\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty>1796500000n</span>\n    </div>\n\n    ---"}
{"page_id": "develop-interoperability-xcm-runtime-apis", "page_title": "XCM Runtime APIs", "index": 8, "depth": 3, "title": "Query Delivery Fees", "anchor": "query-delivery-fees", "start_char": 44234, "end_char": 49208, "estimated_token_count": 965, "token_estimator": "heuristic-v1", "text": "### Query Delivery Fees\n\nRetrieves the delivery fees for sending a specific XCM message to a designated destination. The fees are always returned in a specific asset defined by the destination chain.\n\n```rust\nfn query_delivery_fees(destination: VersionedLocation, message: VersionedXcm<()>) -> Result<VersionedAssets, Error>;\n```\n\n??? interface \"Input parameters\"\n\n    `destination` ++\"VersionedLocation\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The target location where the message will be sent. Fees may vary depending on the destination, as different destinations often have unique fee structures and sender mechanisms.\n\n    ---\n\n    `message` ++\"VersionedXcm<()>\"++ <span class=\"required\" markdown>++\"required\"++</span>\n    \n    The XCM message to be sent. The delivery fees are calculated based on the message's content and size, which can influence the cost.\n\n    ---\n\n??? interface \"Output parameters\"\n\n    ++\"Result<VersionedAssets, Error>\"++\n    \n    The calculated delivery fees expressed in a specific asset supported by the destination chain. If an error occurs during the query, it returns an error instead.\n\n    ??? child \"Type `Error`\"\n\n        Enum:\n\n        - **`Unimplemented`**: An API part is unsupported.\n        - **`VersionedConversionFailed`**: Converting a versioned data structure from one version to another failed.\n        - **`WeightNotComputable`**: XCM message weight calculation failed.\n        - **`UnhandledXcmVersion`**: XCM version not able to be handled.\n        - **`AssetNotFound`**: The given asset is not handled as a fee asset.\n        - **`Unroutable`**: Destination is known to be unroutable.\n\n    ---\n\n??? interface \"Example\"\n\n    This example demonstrates how to query the delivery fees for sending an XCM message from Paseo to Paseo Asset Hub.\n\n    Replace `INSERT_USER_ADDRESS` with your SS58 address before running the script.\n\n    ***Usage with PAPI***\n\n    ```js\n    import { createClient } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import {\n      XcmVersionedXcm,\n      paseo,\n      XcmVersionedLocation,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3WeightLimit,\n      XcmV3MultiassetFungibility,\n      XcmV3MultiassetAssetId,\n      XcmV3Instruction,\n      XcmV3MultiassetMultiAssetFilter,\n      XcmV3MultiassetWildMultiAsset,\n    } from '@polkadot-api/descriptors';\n    import { Binary } from 'polkadot-api';\n    import { ss58Decode } from '@polkadot-labs/hdkd-helpers';\n\n    const client = createClient(\n      withPolkadotSdkCompat(getWsProvider('wss://paseo-rpc.dwellir.com')),\n    );\n\n    const paseoApi = client.getTypedApi(paseo);\n\n    const paseoAssetHubParaID = 1000;\n    const userAddress = 'INSERT_USER_ADDRESS';\n    const userPublicKey = ss58Decode(userAddress)[0];\n    const idBeneficiary = Binary.fromBytes(userPublicKey);\n\n    // Define the destination\n    const destination = XcmVersionedLocation.V3({\n      parents: 0,\n      interior: XcmV3Junctions.X1(XcmV3Junction.Parachain(paseoAssetHubParaID)),\n    });\n\n    // Define the xcm message that will be sent to the destination\n    const xcm = XcmVersionedXcm.V3([\n      XcmV3Instruction.ReceiveTeleportedAsset([\n        {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 1,\n            interior: XcmV3Junctions.Here(),\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(12000000000n),\n        },\n      ]),\n      XcmV3Instruction.ClearOrigin(),\n      XcmV3Instruction.BuyExecution({\n        fees: {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 1,\n            interior: XcmV3Junctions.Here(),\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(BigInt(12000000000n)),\n        },\n        weight_limit: XcmV3WeightLimit.Unlimited(),\n      }),\n      XcmV3Instruction.DepositAsset({\n        assets: XcmV3MultiassetMultiAssetFilter.Wild(\n          XcmV3MultiassetWildMultiAsset.All(),\n        ),\n        beneficiary: {\n          parents: 0,\n          interior: XcmV3Junctions.X1(\n            XcmV3Junction.AccountId32({\n              network: undefined,\n              id: idBeneficiary,\n            }),\n          ),\n        },\n      }),\n    ]);\n\n    // Execute the query delivery fees runtime call\n    const result = await paseoApi.apis.XcmPaymentApi.query_delivery_fees(\n      destination,\n      xcm,\n    );\n\n    // Print the results\n    console.dir(result.value, { depth: null });\n\n    client.destroy();\n\n    ```\n\n    ***Output***\n\n    <div id=\"termynal\" data-termynal>\n      <pre>\n        {\n          type: 'V3',\n          value: [\n            {\n              id: {\n                type: 'Concrete',\n                value: { parents: 0, interior: { type: 'Here', value: undefined } }\n              },\n              fun: { type: 'Fungible', value: 396000000n }\n            }\n          ]\n        }\n      </pre>\n    </div>\n\n    ---"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 12, "end_char": 513, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe Polkadot ecosystem consists of multiple networks designed to support different stages of blockchain development, from main networks to test networks. Each network serves a unique purpose, providing developers with flexible environments for building, testing, and deploying blockchain applications.\n\nThis section includes essential network information such as RPC endpoints, currency symbols and decimals, and how to acquire TestNet tokens for the Polkadot ecosystem of networks."}
{"page_id": "develop-networks", "page_title": "Networks", "index": 1, "depth": 2, "title": "Production Networks", "anchor": "production-networks", "start_char": 513, "end_char": 537, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Production Networks"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 2, "depth": 3, "title": "Polkadot", "anchor": "polkadot", "start_char": 537, "end_char": 1992, "estimated_token_count": 382, "token_estimator": "heuristic-v1", "text": "### Polkadot\n\nPolkadot is the primary production blockchain network for high-stakes, enterprise-grade applications. Polkadot MainNet has been running since May 2020 and has implementations in various programming languages ranging from Rust to JavaScript.\n\n=== \"Network Details\"\n\n    **Currency symbol**: `DOT`\n\n    ---\n    \n    **Currency decimals**: 10\n\n    ---\n\n    **Block explorer**: [Polkadot Subscan](https://polkadot.subscan.io/){target=\\_blank}\n\n=== \"RPC Endpoints\"\n\n    Blockops\n\n    ```\n    wss://polkadot-public-rpc.blockops.network/ws\n    ```\n\n    ---\n\n    Dwellir\n\n    ```\n    wss://polkadot-rpc.dwellir.com\n    ```\n\n    ---\n\n    Dwellir Tunisia\n\n    ```\n    wss://polkadot-rpc-tn.dwellir.com\n    ```\n\n    ---\n\n    IBP1\n\n    ```\n    wss://rpc.ibp.network/polkadot\n    ```\n\n    ---\n\n    IBP2\n\n    ```\n    wss://polkadot.dotters.network\n    ```\n\n    ---\n\n    LuckyFriday\n\n    ```\n    wss://rpc-polkadot.luckyfriday.io\n    ```\n\n    ---\n\n    OnFinality\n\n    ```\n    wss://polkadot.api.onfinality.io/public-ws\n    ```\n\n    ---\n\n    RadiumBlock\n\n    ```\n    wss://polkadot.public.curie.radiumblock.co/ws\n    ```\n\n    ---\n\n    RockX\n\n    ```\n    wss://rockx-dot.w3node.com/polka-public-dot/ws\n    ```\n\n    ---\n\n    Stakeworld\n\n    ```\n    wss://dot-rpc.stakeworld.io\n    ```\n\n    ---\n\n    SubQuery\n\n    ```\n    wss://polkadot.rpc.subquery.network/public/ws\n    ```\n\n    ---\n\n    Light client\n\n    ```\n    light://substrate-connect/polkadot\n    ```"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 3, "depth": 3, "title": "Kusama", "anchor": "kusama", "start_char": 1992, "end_char": 3486, "estimated_token_count": 391, "token_estimator": "heuristic-v1", "text": "### Kusama\n\nKusama is a network built as a risk-taking, fast-moving \"canary in the coal mine\" for its cousin Polkadot. As it is built on top of the same infrastructure, Kusama often acts as a final testing ground for new features before they are launched on Polkadot. Unlike true TestNets, however, the Kusama KSM native token does have economic value. This incentive encourages participants to maintain this robust and performant structure for the benefit of the community.\n\n=== \"Network Details\"\n\n    **Currency symbol**: `KSM`\n\n    ---\n\n    **Currency decimals**: 12\n\n    ---\n    \n    **Block explorer**: [Kusama Subscan](https://kusama.subscan.io/){target=\\_blank}\n\n=== \"RPC Endpoints\"\n\n    Dwellir\n\n    ```\n    wss://kusama-rpc.dwellir.com\n    ```\n\n    ---\n\n    Dwellir Tunisia\n\n    ```\n    wss://kusama-rpc-tn.dwellir.com\n    ```\n\n    ---\n\n    IBP1\n\n    ```\n    wss://rpc.ibp.network/kusama\n    ```\n\n    ---\n\n    IBP2\n\n    ```\n    wss://kusama.dotters.network\n    ```\n\n    ---\n\n    LuckyFriday\n\n    ```\n    wss://rpc-kusama.luckyfriday.io\n    ```\n\n    ---\n\n    OnFinality\n\n    ```\n    wss://kusama.api.onfinality.io/public-ws\n    ```\n\n    ---\n\n    RadiumBlock\n\n    ```\n    wss://kusama.public.curie.radiumblock.co/ws\n    ```\n\n    ---\n\n    RockX\n\n    ```\n    wss://rockx-ksm.w3node.com/polka-public-ksm/ws\n    ```\n\n    ---\n\n    Stakeworld\n\n    ```\n    wss://rockx-ksm.w3node.com/polka-public-ksm/ws\n    ```\n\n    ---\n\n    Light client\n\n    ```\n    light://substrate-connect/kusama\n    ```"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 4, "depth": 2, "title": "Test Networks", "anchor": "test-networks", "start_char": 3486, "end_char": 3504, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Test Networks"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 5, "depth": 3, "title": "Westend", "anchor": "westend", "start_char": 3504, "end_char": 4650, "estimated_token_count": 301, "token_estimator": "heuristic-v1", "text": "### Westend\n\nWestend is the primary test network that mirrors Polkadot's functionality for protocol-level feature development. As a true TestNet, the WND native token intentionally does not have any economic value. Use the faucet information in the following section to obtain WND tokens.\n\n=== \"Network Information\"\n\n    **Currency symbol**: `WND`\n\n    ---\n\n    **Currency decimals**: 12\n\n    ---\n    \n    **Block explorer**: [Westend Subscan](https://westend.subscan.io/){target=\\_blank}\n\n    ---\n\n    **Faucet**: [Official Westend faucet](https://faucet.polkadot.io/westend){target=\\_blank}\n\n\n=== \"RPC Endpoints\"\n\n    Dwellir\n\n    ```\n    wss://westend-rpc.dwellir.com\n    ```\n\n    ---\n\n    Dwellir Tunisia\n\n    ```\n    wss://westend-rpc-tn.dwellir.com\n    ```\n\n    ---\n\n    IBP1\n\n    ```\n    wss://rpc.ibp.network/westend\n    ```\n\n    ---\n\n    IBP2\n\n    ```\n    wss://westend.dotters.network\n    ```\n\n    ---\n\n    OnFinality\n\n    ```\n    wss://westend.api.onfinality.io/public-ws\n    ```\n\n    ---\n\n    Parity\n\n    ```\n    wss://westend-rpc.polkadot.io\n    ```\n\n    ---\n\n    Light client\n\n    ```\n    light://substrate-connect/westend\n    ```"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 6, "depth": 3, "title": "Paseo", "anchor": "paseo", "start_char": 4650, "end_char": 5723, "estimated_token_count": 268, "token_estimator": "heuristic-v1", "text": "### Paseo\n\nPaseo is a decentralised, community run, stable testnet for parachain and dapp developers to build and test their applications. Unlike Westend, Paseo is not intended for protocol-level testing. As a true TestNet, the PAS native token intentionally does not have any economic value. Use the faucet information in the following section to obtain PAS tokens.\n\n=== \"Network Information\"\n\n    **Currency symbol**: `PAS`\n\n    ---\n\n    **Currency decimals**: 10\n\n    ---\n    \n    **Block explorer**: [Paseo Subscan](https://paseo.subscan.io/){target=\\_blank}\n\n    ---\n\n    **Faucet**: [Official Paseo faucet](https://faucet.polkadot.io/){target=\\_blank}\n\n=== \"RPC Endpoints\"\n\n    Amforc\n    \n    ```\n    wss://paseo.rpc.amforc.com\n    ```\n    \n    ---\n    \n    Dwellir\n    \n    ```\n    wss://paseo-rpc.dwellir.com\n    ```\n    \n    ---\n    \n    IBP1\n    \n    ```\n    wss://rpc.ibp.network/paseo\n    ```\n    \n    ---\n    \n    IBP2\n    \n    ```\n    wss://paseo.dotters.network\n    ```\n    \n    ---\n    \n    StakeWorld\n    \n    ```\n    wss://pas-rpc.stakeworld.io\n    ```"}
{"page_id": "develop-networks", "page_title": "Networks", "index": 7, "depth": 2, "title": "Additional Resources", "anchor": "additional-resources", "start_char": 5723, "end_char": 6097, "estimated_token_count": 93, "token_estimator": "heuristic-v1", "text": "## Additional Resources\n\n- [**Polkadot Fellowship runtimes repository**](https://github.com/polkadot-fellows/runtimes){target=\\_blank}: Find a collection of runtimes for Polkadot, Kusama, and their system-parachains as maintained by the community via the [Polkadot Technical Fellowship](https://wiki.polkadot.com/learn/learn-polkadot-technical-fellowship/){target=\\_blank}."}
{"page_id": "develop-smart-contracts-connect-to-kusama", "page_title": "Connect to Kusama", "index": 0, "depth": 2, "title": "Networks Details", "anchor": "networks-details", "start_char": 1210, "end_char": 1843, "estimated_token_count": 138, "token_estimator": "heuristic-v1", "text": "## Networks Details\n\nDevelopers can leverage smart contracts on Kusama Hub for live production deployments. This section outlines the network specifications and connection details.\n\n=== \"Kusama Hub\"\n\n    Network name\n\n    ```text\n    Kusama Hub\n    ```\n\n    ---\n    \n    Currency symbol\n    \n    ```text\n    KSM\n    ```\n    \n    ---\n    \n    Chain ID\n    \n    ```text\n    420420418\n    ```\n    \n    ---\n    \n    RPC URL\n    \n    ```text\n    https://kusama-asset-hub-eth-rpc.polkadot.io\n    ```\n    ---\n    \n    Block explorer URL\n    \n    ```text\n    https://blockscout-kusama-asset-hub.parity-chains-scw.parity.io/\n    ```\n    ---"}
{"page_id": "develop-smart-contracts-connect-to-kusama", "page_title": "Connect to Kusama", "index": 1, "depth": 2, "title": "Important Deployment Considerations", "anchor": "important-deployment-considerations", "start_char": 1843, "end_char": 2717, "estimated_token_count": 177, "token_estimator": "heuristic-v1", "text": "## Important Deployment Considerations\n\nWhile the compatibility with regular EVM codebases is still being maximized, some recommendations include:\n    \n- Leverage [Hardhat](/develop/smart-contracts/dev-environments/hardhat){target=\\_blank} to compile, deploy, and interact with your contract.\n- Use MetaMask to interact with your dApp (note that using MetaMask can sometimes lead to `Invalid transaction` errors. This is actively being worked on and will be fixed soon).\n- Avoid Remix for deployment as MetaMask enforces a 48kb size limit when using the [Remix IDE](/develop/smart-contracts/dev-environments/remix){target=\\_blank}, which is why Hardhat Polkadot is recommended for deployment.\n\nKusama Hub is a live environment. Ensure your contracts are thoroughly tested before deployment, as transactions on Kusama Hub involve real KSM tokens and **cannot be reversed**."}
{"page_id": "develop-smart-contracts-connect-to-kusama", "page_title": "Connect to Kusama", "index": 2, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 2717, "end_char": 3590, "estimated_token_count": 193, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nFor your next steps, explore the various smart contract guides demonstrating how to use and integrate different tools and development environments into your workflow.\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> **Deploy your first contract with Hardhat**\n    \n    ---\n    \n    Explore the recommended smart contract development and deployment process on Kusama Hub using Hardhat.\n    \n    [:octicons-arrow-right-24: Build with HardHat](/develop/smart-contracts/dev-environments/hardhat/)\n\n-   <span class=\"badge guide\">Guide</span> **Interact with the blockchain using viem**\n    \n    ---\n    \n    Use viem for interacting with Ethereum-compatible chains to deploy and interact with smart contracts on Kusama Hub.\n    \n    [:octicons-arrow-right-24: Build with viem](/develop/smart-contracts/libraries/viem/)\n\n</div>"}
{"page_id": "develop-smart-contracts-connect-to-polkadot", "page_title": "Connect to Polkadot", "index": 0, "depth": 2, "title": "Networks Details", "anchor": "networks-details", "start_char": 946, "end_char": 1599, "estimated_token_count": 137, "token_estimator": "heuristic-v1", "text": "## Networks Details\n\nDevelopers can leverage smart contracts across diverse networks, from TestNets to MainNet. This section outlines the network specifications and connection details for each environment.\n\n=== \"Polkadot Hub TestNet\"\n\n    Network name\n\n    ```text\n    Polkadot Hub TestNet\n    ```\n\n    ---\n\n    Currency symbol\n    \n    ```text\n    PAS\n    ```\n\n    ---\n    \n    Chain ID\n    \n    ```text\n    420420422\n    ```\n\n    ---\n    \n    RPC URL\n    \n    ```text\n    https://testnet-passet-hub-eth-rpc.polkadot.io\n    ```\n\n    ---\n    \n    Block explorer URL\n    \n    ```text\n    https://blockscout-passet-hub.parity-testnet.parity.io/\n    ```"}
{"page_id": "develop-smart-contracts-connect-to-polkadot", "page_title": "Connect to Polkadot", "index": 1, "depth": 2, "title": "Test Tokens", "anchor": "test-tokens", "start_char": 1599, "end_char": 2651, "estimated_token_count": 245, "token_estimator": "heuristic-v1", "text": "## Test Tokens\n\nYou will need testnet tokens to perform transactions and engage with smart contracts on any chain. Here's how to obtain Paseo (PAS) tokens for testing purposes:\n\n1. Navigate to the [Polkadot Faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}. If the desired network is not already selected, choose it from the Network drop-down.\n\n2. Copy your address linked to the TestNet and paste it into the designated field.\n\n    ![](/images/develop/smart-contracts/connect-to-polkadot/connect-to-polkadot-1.webp)\n\n3. Click the **Get Some PASs** button to request free test PAS tokens. These tokens will be sent to your wallet shortly.\n\n    ![](/images/develop/smart-contracts/connect-to-polkadot/connect-to-polkadot-2.webp)\n\nNow that you have obtained PAS tokens in your wallet, you’re ready to deploy and interact with smart contracts on Polkadot Hub TestNet! These tokens will allow you to pay for gas fees when executing transactions, deploying contracts, and testing your dApp functionality in a secure testnet environment."}
{"page_id": "develop-smart-contracts-connect-to-polkadot", "page_title": "Connect to Polkadot", "index": 2, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 2651, "end_char": 3496, "estimated_token_count": 188, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nFor your next steps, explore the various smart contract guides demonstrating how to use and integrate different tools and development environments into your workflow.\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> __Deploy your first contract with Remix__\n\n    ---\n\n    Explore the smart contract development and deployment process on Polkadot Hub using the Remix IDE.\n\n    [:octicons-arrow-right-24: Build with Remix IDE](/develop/smart-contracts/dev-environments/remix/)\n\n-   <span class=\"badge guide\">Guide</span> __Interact with the blockchain with viem__\n\n    ---\n\n    Use viem for interacting with Ethereum-compatible chains, to deploy and interact with smart contracts on Polkadot Hub.\n\n    [:octicons-arrow-right-24: Build with viem](/develop/smart-contracts/libraries/viem/)\n\n</div>"}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 0, "depth": 2, "title": "Overview", "anchor": "overview", "start_char": 182, "end_char": 918, "estimated_token_count": 145, "token_estimator": "heuristic-v1", "text": "## Overview\n\nFoundry is a fast, modular, and extensible toolkit for Ethereum application development written in Rust. It provides a suite of command-line tools, including `forge` for compiling, testing, and deploying smart contracts and `cast` for interacting with blockchains.\n\n[`foundry-polkadot`](https://github.com/paritytech/foundry-polkadot/){target=\\_blank} is an adaptation explicitly engineered for the Polkadot Hub, tailored for developers already familiar with Foundry who seek to leverage its capabilities within the Polkadot ecosystem. Additionally, this guide offers detailed information on the `forge` and `cast` commands supported within `foundry-polkadot`, complete with simple, runnable examples for quick reference."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 1, "depth": 2, "title": "Installation", "anchor": "installation", "start_char": 918, "end_char": 1764, "estimated_token_count": 175, "token_estimator": "heuristic-v1", "text": "## Installation\n\nThe installation process is tailored for the Polkadot variant:\n\n- `foundry-polkadot` is installed via `foundryup-polkadot`, its dedicated installer. To get started, open your terminal and execute:\n\n    ```bash\n    curl -L https://raw.githubusercontent.com/paritytech/foundry-polkadot/refs/heads/master/foundryup/install | bash\n    ```\n\n    This command starts the installation of `foundryup-polkadot`. After installation, run the following command to download the precompiled `foundry-polkadot` binaries:\n\n    ```bash\n    foundryup-polkadot\n    ```\n\n    This command will install the `forge` and `cast` binaries, which are explained below. Windows users must use a Unix-like terminal environment such as Git BASH or Windows Subsystem for Linux (WSL), as PowerShell and Command Prompt are not currently supported by `foundryup`."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 2, "depth": 2, "title": "Compiler Integration", "anchor": "compiler-integration", "start_char": 1764, "end_char": 3194, "estimated_token_count": 317, "token_estimator": "heuristic-v1", "text": "## Compiler Integration\n\nA core divergence lies in the underlying Solidity compiler.\n\n- `foundry` is built to interface with the `solc` compiler, which targets Ethereum's Ethereum Virtual Machine (EVM).\n- `foundry-polkadot`, in contrast, introduces and primarily utilizes the `resolc` compiler to compile down Solidity contracts into PolkaVM bytecode. \n\n    - **Command-Line Flag**: For commands that involve compilation (e.g., `forge build`), you can use the `--resolc` flag to enable `resolc` compilation. For example:\n\n        ```bash\n        forge build --resolc\n        ```\n\n        This command instructs Forge to use `resolc` instead of `solc`, generating bytecode compatible with PolkaVM.\n\n    - **Configuration File**: Alternatively, you can configure `resolc` usage in the `foundry.toml` file. Add the following:\n\n        ```toml\n        [profile.default.resolc]\n        resolc_compile = true\n        ```\n\n        Setting `resolc_compile = false` reverts to using `solc`, ensuring compatibility with Ethereum projects. By default, `foundry-polkadot` uses `solc` unless `resolc` is explicitly enabled. `resolc` also exposes specific options for fine-tuning the compilation process, such as `--use-resolc <RESOLC_VERSION>` for specifying a compiler version or path, `-O, --resolc-optimizer-mode <LEVEL>` for setting optimization levels, and `--heap-size <SIZE>` and `--stack-size <SIZE>` for configuring contract memory."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 3, "depth": 2, "title": "Command-Line Interface (CLI)", "anchor": "command-line-interface-cli", "start_char": 3194, "end_char": 3571, "estimated_token_count": 85, "token_estimator": "heuristic-v1", "text": "## Command-Line Interface (CLI)\n\n`foundry-polkadot` preserves the familiar `forge` and `cast` subcommand structure. However, it's crucial to note that commands which involve compilation (such as `create`, `bind`, `build`, and `inspect`) will yield different output when `resolc` is utilized, as the generated bytecode is specifically designed for PolkaVM rather than the EVM."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 4, "depth": 2, "title": "Unsupported or Modified Features", "anchor": "unsupported-or-modified-features", "start_char": 3571, "end_char": 4537, "estimated_token_count": 189, "token_estimator": "heuristic-v1", "text": "## Unsupported or Modified Features\n\nNot all functionalities from the original Foundry are present or behave identically in `foundry-polkadot`:\n\n- **Currently unsupported**:\n    - Compilation of Yul code is not yet supported.\n    - Support for factory contracts deployment is a known issue that is currently unresolved.\n- **Broader feature limitations**: Integration with `Anvil` and `Chisel` (Foundry's local blockchain and EVM toolkit, respectively) is not available. This limitation directly impacts the support for several key commands, including `forge test` for running tests, `forge snapshot` for creating blockchain state snapshots, and `forge script` for complex deployment and interaction scripts.\n- **Modified feature**: The most notable modification is in the **compilation output**. When ``resolc`` is employed, the resulting bytecode will fundamentally differ from that generated by ``solc``, reflecting PolkaVM's distinct architectural requirements."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 5, "depth": 2, "title": "Set up a Project", "anchor": "set-up-a-project", "start_char": 4537, "end_char": 5517, "estimated_token_count": 223, "token_estimator": "heuristic-v1", "text": "## Set up a Project\n\nInitialize a new project using `forge init`:\n\n```bash\nforge init my-polkadot-project\ncd my-polkadot-project\n```\n\nThis command creates a complete project structure with the following components:\n\n- **`src/`**: Contains the Solidity smart contracts (includes a sample `Counter.sol` contract by default).\n- **`lib/`**: Houses external dependencies and libraries (`forge-std` testing library is included).\n- **`script/`**: Stores deployment and interaction scripts (includes `Counter.s.sol` deployment script by default).\n- **`test/`**: Contains your contract tests (includes `Counter.t.sol` test file by default).\n- **`foundry.toml`**: Main configuration file for compiler settings, network configurations, and project preferences.\n\nThe default project includes a simple `Counter` contract that demonstrates basic state management through increment and decrement functions, along with corresponding tests and deployment scripts to help you get started quickly."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 6, "depth": 2, "title": "Compile a Project", "anchor": "compile-a-project", "start_char": 5517, "end_char": 6260, "estimated_token_count": 146, "token_estimator": "heuristic-v1", "text": "## Compile a Project\n\nCompile contracts using `forge build`:\n\n```bash\nforge build --resolc\n```\n\n!!!note \n    You can still use `forge build` for compiling to regular EVM bytecode.\n\nPolkaVM bytecode starts with `0x505` prefix. Inspect compiled artifacts with:\n\n```bash\nforge inspect Counter bytecode --resolc\n```\n\nIf successful, you will see the following output:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>forge inspect Counter bytecode --resolc</span>\n  <span data-ty>0x50564d00008213000000000000010700c13000c0008004808f08000000000e0000001c0000002a0000003500000040000000520000005d00000063616c6c5f646174615f636f707963616c6c5f646174615f6c6f616463616c6c5f646174615f73697a65676574...</span>\n</div>"}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 7, "depth": 2, "title": "Deploy a Contract", "anchor": "deploy-a-contract", "start_char": 6260, "end_char": 7390, "estimated_token_count": 329, "token_estimator": "heuristic-v1", "text": "## Deploy a Contract\n\nDeploy contracts using `forge create`:\n\n```bash\nforge create Counter \\\n    --rpc-url <INSERT_RPC_URL> \\\n    --private-key <INSERT_PRIVATE_KEY> \\\n    --resolc\n```\n\nIf the operation completes successfully, you'll see the following output (for example, to deploy to the Passet Hub chain):\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>forge create Counter &bsol;</span>\n  <span data-ty>&nbsp;&nbsp;--rpc-url https://testnet-passet-hub-eth-rpc.polkadot.io &bsol;</span>\n  <span data-ty>&nbsp;&nbsp;--private-key &lt;INSERT_PRIVATE_KEY&gt; &bsol;</span>\n  <span data-ty>&nbsp;&nbsp;--resolc</span>\n  <br />\n  <span data-ty>[:] Compiling...</span>\n  <span data-ty>Compiler run successful!</span>\n</div>\n\nFor contracts with constructor arguments:\n\n```bash\nforge create MyToken \\\n    --rpc-url <INSERT_RPC_URL> \\\n    --private-key <INSERT_PRIVATE_KEY> \\\n    --constructor-args \"MyToken\" \"MTK\" 1000000 \\\n    --resolc\n```\n\n!!! note \"Network Compatibility\"\n    Use the `--resolc` flag when deploying to PolkaVM-compatible networks. Omit it for Ethereum-compatible networks."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 8, "depth": 2, "title": "Supported `foundry-polkadot` Commands", "anchor": "supported-foundry-polkadot-commands", "start_char": 7390, "end_char": 7544, "estimated_token_count": 33, "token_estimator": "heuristic-v1", "text": "## Supported `foundry-polkadot` Commands\n\nThis section provides a detailed breakdown of the `forge` and `cast` commands supported in `foundry-polkadot`."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 9, "depth": 3, "title": "Forge Commands", "anchor": "forge-commands", "start_char": 7544, "end_char": 13032, "estimated_token_count": 1502, "token_estimator": "heuristic-v1", "text": "### Forge Commands\n\n- **`init`**:\n    - **Command**: `forge init <PROJECT_NAME>`.\n    - **Description**: Initializes a new Foundry project in the current directory, setting up the basic project structure and installing standard libraries.\n\n- **`bind`**:\n    - **Command**: `forge bind [--resolc]`.\n    - **Description**: Generates type-safe Rust bindings for your Solidity contracts. Use `--resolc` to ensure compilation with the `resolc` compiler for PolkaVM compatibility.\n\n- **`bind-json`**:\n    - **Command**: `forge bind-json [--resolc]`.\n    - **Description**: Generates JSON bindings for your Solidity contracts. Use `--resolc` for `resolc`-based compilation.\n\n- **`build`**:\n    - **Command**: `forge build [--resolc]`.\n    - **Description**: Compiles all Solidity contracts in your project. Specify `--resolc` to compile for PolkaVM.\n\n- **`cache clean`**:\n    - **Command**: `forge cache clean`.\n    - **Description**: Clears the Foundry cache directory.\n\n- **`cache ls`**:\n    - **Command**: `forge cache ls`.\n    - **Description**: Lists the contents of the Foundry cache.\n\n- **`clean`**:\n    - **Command**: `forge clean`.\n    - **Description**: Removes all build artifacts from the project's `out` directory.\n\n- **`compiler resolve`**:\n    - **Command**: `forge compiler resolve [--resolc]`.\n    - **Description**: Resolves and displays the versions of Solidity compilers Foundry is using. Use `--resolc` to also check for `resolc`.\n\n- **`config`**:\n    - **Command**: `forge config`.\n    - **Description**: Displays the current Foundry project configuration, including settings from `foundry.toml`.\n\n- **`create`**:\n    - **Command**: `forge create [OPTIONS] <CONTRACT>`.\n    - **Required Parameters**: `<CONTRACT>` (the name of the contract to deploy).\n    - **Description**: Deploys a new contract to a specified blockchain network. The `--resolc` flag ensures it's compiled for PolkaVM. You'll typically need to provide an RPC URL, a private key for the deployer account, and potentially constructor arguments.\n\n- **`doc`**:\n    - **Command**: `forge doc`.\n    - **Description**: Generates documentation for your Solidity contracts.\n\n- **`flatten`**:\n    - **Command**: `forge flatten [OPTIONS] <PATH>`.\n    - **Required Parameters**: `<PATH>` (the path to the Solidity file).\n    - **Description**: Combines all imports of a Solidity file into a single file, useful for deployment or verification.\n\n- **`fmt`**:\n    - **Command**: `forge fmt`.\n    - **Description**: Formats Solidity code according to a predefined style.\n\n- **`geiger`**:\n    - **Command**: `forge geiger <PATH>`.\n    - **Required Parameters**: `<PATH>` (the path to the Solidity file).\n    - **Description**: Analyzes Solidity code for potential security vulnerabilities and gas inefficiencies.\n\n- **`generate test`**:\n    - **Command**: `forge generate test --contract-name <CONTRACT_NAME>`.\n    - **Required Parameters**: `--contract-name <CONTRACT_NAME>` (the name of the contract for which to generate a test).\n    - **Description**: Creates a new test file with boilerplate code for a specified contract.\n\n- **`generate-fig-spec`**:\n    - **Command**: `forge generate-fig-spec`.\n    - **Description**: Generates a Fig specification for CLI autocompletion tools.\n\n- **`inspect`**:\n    - **Command**: `forge inspect <CONTRACT_NAME> <ARTIFACT> [--resolc]`.\n    - **Required Parameters**: `<CONTRACT_NAME>` (the contract to inspect), `<ARTIFACT>` (e.g., `bytecode`, `abi`, `methods`, `events`).\n    - **Description**: Displays various artifacts of a compiled contract. Use `--resolc` to inspect `resolc`-compiled artifacts; the bytecode will start with `0x505`.\n\n- **`install`**:\n    - **Command**: `forge install <REPOSITORY>`.\n    - **Description**: Installs a Solidity library or dependency from a Git repository.\n\n- **`update`**:\n    - **Command**: `forge update [<REPOSITORY>]`.\n    - **Description**: Updates installed dependencies. If a repository is specified, only that one is updated.\n\n- **`remappings`**:\n    - **Command**: `forge remappings`.\n    - **Description**: Lists the currently configured Solidity compiler remappings.\n\n- **`remove`**:\n    - **Command**: `forge remove <REPOSITORY>`.\n    - **Description**: Removes an installed Solidity dependency. Use `--force` to remove without confirmation.\n\n- **`selectors upload`**:\n    - **Command**: `forge selectors upload [--all]`.\n    - **Description**: Uploads function selectors from compiled contracts to OpenChain. Use `--all` to upload for all contracts.\n\n- **`selectors list`**:\n    - **Command**: `forge selectors list`.\n    - **Description**: Lists all known function selectors for contracts in the project.\n\n- **`selectors find`**:\n    - **Command**: `forge selectors find <SELECTOR>`.\n    - **Description**: Searches for a function signature given its 4-byte selector.\n\n- **`selectors cache`**:\n    - **Command**: `forge selectors cache`.\n    - **Description**: Caches function selectors for faster lookup.\n\n- **`tree`**:\n    - **Command**: `forge tree`.\n    - **Description**: Displays the dependency tree of your Solidity contracts.\n\n!!!warning \"Non-working Commands\"\n\n    Consider that some foundry commands are not yet supported in `foundry-polkadot`:\n\n    - **`clone`**: This command is not supported in `foundry-polkadot`.\n    - **`coverage`**: Code coverage analysis is not supported.\n    - **`snapshot`**: Creating blockchain state snapshots is not supported.\n    - **`test`**: Running Solidity tests is not supported."}
{"page_id": "develop-smart-contracts-dev-environments-foundry", "page_title": "Use Foundry with Polkadot Hub", "index": 10, "depth": 3, "title": "Cast Commands", "anchor": "cast-commands", "start_char": 13032, "end_char": 23398, "estimated_token_count": 3084, "token_estimator": "heuristic-v1", "text": "### Cast Commands\n\n- **`4byte`**:\n    - **Command**: `cast 4byte [OPTIONS] [TOPIC_0]`.\n    - **Description**: Decodes a 4-byte function selector into its human-readable function signature.\n\n- **`4byte-event`**:\n    - **Command**: `cast 4byte-event [OPTIONS] [TOPIC_0]`.\n    - **Description**: Decodes a 4-byte event topic into its human-readable event signature.\n\n- **`abi-encode`**:\n    - **Command**: `cast abi-encode <SIG> [ARGS]...`.\n    - **Required Parameters**: `<SIG>` (the function signature), `[ARGS]` (arguments to encode).\n    - **Description**: ABI-encodes function arguments according to a given signature.\n\n- **`address-zero`**:\n    - **Command**: `cast address-zero`.\n    - **Description**: Returns the zero address (0x00...00).\n\n- **`age`**:\n    - **Command**: `cast age [OPTIONS] [BLOCK]`.\n    - **Description**: Converts a block number or tag (e.g., `latest`) into its timestamp.\n\n- **`balance`**:\n    - **Command**: `cast balance [OPTIONS] <WHO>`.\n    - **Required Parameters**: `<WHO>` (the address to check).\n    - **Description**: Retrieves the native token balance of a given address on the specified RPC network.\n\n- **`base-fee`**:\n    - **Command**: `cast base-fee [OPTIONS] [BLOCK]`.\n    - **Description**: Retrieves the base fee per gas for a specific block (defaults to `latest`).\n\n- **`block`**:\n    - **Command**: `cast block [OPTIONS] [BLOCK]`.\n    - **Description**: Retrieves comprehensive details about a specific block (defaults to `latest`).\n\n- **`block-number`**:\n    - **Command**: `cast block-number [OPTIONS] [BLOCK]`.\n    - **Description**: Retrieves the number of the latest or a specified block.\n\n- **`call`**:\n    - **Command**: `cast call [OPTIONS] <TO> <SIG> [ARGS]...`.\n    - **Description**: Executes a read-only (constant) function call on a contract. No transaction is sent to the network.\n\n- **`chain`**:\n    - **Command**: `cast chain [OPTIONS]`.\n    - **Description**: Displays the human-readable name of the connected blockchain.\n\n- **`chain-id`**:\n    - **Command**: `cast chain-id [OPTIONS]`.\n    - **Description**: Displays the chain ID of the connected blockchain.\n\n- **`client`**:\n    - **Command**: `cast client [OPTIONS]`.\n    - **Description**: Retrieves information about the connected RPC client (node software).\n\n- **`code`**:\n    - **Command**: `cast code [OPTIONS] <WHO>`.\n    - **Required Parameters**: `<WHO>` (the contract address).\n    - **Description**: Retrieves the bytecode deployed at a given contract address.\n\n- **`codesize`**:\n    - **Command**: `cast codesize [OPTIONS] <WHO>`.\n    - **Required Parameters**: `<WHO>` (the contract address).\n    - **Description**: Retrieves the size of the bytecode deployed at a given contract address.\n\n- **`compute-address`**:\n    - **Command**: `cast compute-address [OPTIONS] <WHO>`.\n    - **Required Parameters**: `<WHO>` (the deployer's address).\n    - **Description**: Computes the predicted contract address based on the deployer's address and nonce.\n\n- **`decode-abi`**:\n    - **Command**: `cast decode-abi <SIG> <CALLDATA>`.\n    - **Required Parameters**: `<SIG>` (the function signature), `<CALLDATA>` (the ABI-encoded data).\n    - **Description**: Decodes ABI-encoded output data from a contract call given its signature.\n\n- **`decode-calldata`**:\n    - **Command**: `cast decode-calldata <SIG> <CALLDATA>`.\n    - **Required Parameters**: `<SIG>` (the function signature), `<CALLDATA>` (the raw calldata).\n    - **Description**: Decodes raw calldata into human-readable arguments using a function signature.\n\n- **`decode-error`**:\n    - **Command**: `cast decode-error <DATA> [--sig <SIGNATURE>]`.\n    - **Required Parameters**: `<DATA>` (the error data).\n    - **Description**: Decodes a custom error message from a transaction revert. You may need to provide the error signature.\n\n- **`decode-event`**:\n    - **Command**: `cast decode-event <DATA> [--sig <SIGNATURE>]`.\n    - **Required Parameters**: `<DATA>` (the event data).\n    - **Description**: Decodes event data from a transaction log.\n\n- **`estimate`**:\n    - **Command**: `cast estimate [OPTIONS] [TO] [SIG] [ARGS]...`.\n    - **Required Parameters**: `[TO]` (the recipient address or contract), `[SIG]` (function signature), `[ARGS]` (arguments).\n    - **Description**: Estimates the gas cost for a transaction or function call.\n\n- **`find-block`**:\n    - **Command**: `cast find-block [OPTIONS] <TIMESTAMP>`.\n    - **Required Parameters**: `<TIMESTAMP>` (a Unix timestamp).\n    - **Description**: Finds the closest block number to a given Unix timestamp.\n\n- **`gas-price`**:\n    - **Command**: `cast gas-price [OPTIONS]`.\n    - **Description**: Retrieves the current average gas price on the network.\n\n- **`generate-fig-spec`**:\n    - **Command**: `cast generate-fig-spec`.\n    - **Description**: Generates a Fig specification for CLI autocompletion.\n\n- **`index-string`**:\n    - **Command**: `cast index-string <STRING> <INDEX>`.\n    - **Description**: Computes the Keccak-256 hash of a string, useful for event topics.\n\n- **`index-erc7201`**:\n    - **Command**: `cast index-erc7201 <VALUE>`.\n    - **Description**: Computes the hash for an ERC-7201 identifier.\n\n- **`logs`**:\n    - **Command**: `cast logs [OPTIONS] [SIG_OR_TOPIC] [TOPICS_OR_ARGS]...`.\n    - **Required Parameters**: `[SIG_OR_TOPIC]` (a signature or topic hash).\n    - **Description**: Filters and displays event logs from transactions.\n\n- **`max-int`**:\n    - **Command**: `cast max-int`.\n    - **Description**: Displays the maximum value for a signed 256-bit integer.\n\n- **`max-uint`**:\n    - **Command**: `cast max-uint`.\n    - **Description**: Displays the maximum value for an unsigned 256-bit integer.\n\n- **`min-int`**:\n    - **Command**: `cast min-int`.\n    - **Description**: Displays the minimum value for a signed 256-bit integer.\n\n- **`mktx`**:\n    - **Command**: `cast mktx [OPTIONS] [TO] [SIG] [ARGS]...`.\n    - **Required Parameters**: `[TO]` (the recipient address or contract).\n    - **Description**: Creates a raw, signed transaction that can be broadcast later.\n\n- **`decode-transaction`**:\n    - **Command**: `cast decode-transaction [OPTIONS] [TX]`.\n    - **Required Parameters**: `[TX]` (the raw transaction hex string).\n    - **Description**: Decodes a raw transaction hex string into its human-readable components.\n\n- **`namehash increment`**:\n    - **Command**: `cast namehash <NAME>`.\n    - **Description**: Computes the ENS (Ethereum Name Service) namehash for a given name.\n\n- **`nonce`**:\n    - **Command**: `cast nonce [OPTIONS] <WHO>`.\n    - **Required Parameters**: `<WHO>` (the address to check).\n    - **Description**: Retrieves the transaction count (nonce) for a given address.\n\n- **`parse-bytes32-address`**:\n    - **Command**: `cast parse-bytes32-address <VALUE>`.\n    - **Description**: Parses a 32-byte hex string (e.g., from `bytes32`) into an Ethereum address.\n\n- **`parse-bytes32-string`**:\n    - **Command**: `cast parse-bytes32-string <VALUE>`.\n    - **Description**: Parses a 32-byte hex string into a human-readable string.\n\n- **`parse-units`**:\n    - **Command**: `cast parse-units <AMOUNT> [UNIT]`.\n    - **Description**: Converts a human-readable amount into its smallest unit (e.g., Ether to Wei). Defaults to `ether`.\n\n- **`pretty-calldata`**:\n    - **Command**: `cast pretty-calldata [OPTIONS] <DATA>`.\n    - **Required Parameters**: `<DATA>` (the calldata hex string).\n    - **Description**: Attempts to pretty-print and decode a raw calldata string into possible function calls.\n\n- **`publish`**:\n    - **Command**: `cast publish [OPTIONS] <RAW_TX>`.\n    - **Description**: Broadcasts a raw, signed transaction to the network.\n\n- **`receipt`**:\n    - **Command**: `cast receipt [OPTIONS] <TX_HASH>`.\n    - **Description**: Retrieves the transaction receipt for a given transaction hash, including status, gas usage, and logs.\n\n- **`rpc`**:\n    - **Command**: `cast rpc [OPTIONS] <METHOD> [PARAMS]...`.\n    - **Required Parameters**: `<METHOD>` (the RPC method to call), `[PARAMS]` (parameters for the method).\n    - **Description**: Makes a direct RPC call to the connected blockchain node.\n\n- **`send`**:\n    - **Command**: `cast send [OPTIONS] <TO> <SIG> [ARGS]...`.\n    - **Required Parameters**: `<TO>` (the recipient address or contract).\n    - **Description**: Sends a transaction to a contract or address, executing a function or transferring value.\n\n- **`sig`**:\n    - **Command**: `cast sig <FUNCTION_SIGNATURE>`.\n    - **Required Parameters**: `<FUNCTION_SIGNATURE>` (the full function signature string).\n    - **Description**: Computes the 4-byte function selector for a given function signature.\n\n- **`sig-event`**:\n    - **Command**: `cast sig-event <EVENT_SIGNATURE>`.\n    - **Required Parameters**: `<EVENT_SIGNATURE>` (the full event signature string).\n    - **Description**: Computes the Keccak-256 hash (topic) for a given event signature.\n\n- **`storage`**:\n    - **Command**: `cast storage [OPTIONS] <ADDRESS> [SLOT]`.\n    - **Required Parameters**: `<ADDRESS>` (the contract address).\n    - **Description**: Retrieves the raw value stored at a specific storage slot of a contract.\n\n- **`tx`**:\n    - **Command**: `cast tx [OPTIONS] <TX_HASH>`.\n    - **Description**: Retrieves comprehensive details about a specific transaction.\n\n- **`upload-signature`**:\n    - **Command**: `cast upload-signature [OPTIONS] <SIGNATURE_STRING>`.\n    - **Required Parameters**: `<SIGNATURE_STRING>` (the function or event signature).\n    - **Description**: Uploads a function or event signature to the OpenChain registry.\n\n- **`wallet`**:\n    - **Command**: `cast wallet new`.\n    - **Description**: Generates a new random Ethereum keypair (private key and address).\n\n- **`wallet new-mnemonic`**:\n    - **Command**: `cast wallet new-mnemonic`.\n    - **Description**: Generates a new BIP-39 mnemonic phrase and derives the first account from it.\n\n- **`wallet address`**:\n    - **Command**: `cast wallet address [OPTIONS]`.\n    - **Description**: Derives and displays the Ethereum address from a private key or mnemonic (if provided).\n\n!!!warning \"Non-working Commands\"\n\n    Consider that some foundry commands are not yet supported in `foundry-polkadot`:\n\n    - **`proof`**: This command, used for generating Merkle proofs, is not supported.\n    - **`storage-root`**: This command, used for retrieving the storage root of a contract, is not supported."}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 0, "depth": 2, "title": "Overview", "anchor": "overview", "start_char": 996, "end_char": 1270, "estimated_token_count": 47, "token_estimator": "heuristic-v1", "text": "## Overview\n\nHardhat is a robust development environment for Ethereum-compatible chains that makes smart contract development more efficient. This guide walks you through the essentials of using Hardhat to create, compile, test, and deploy smart contracts on Polkadot Hub."}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1270, "end_char": 1872, "estimated_token_count": 165, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have:\n\n- [Node.js](https://nodejs.org/){target=\\_blank} (v16.0.0 or later) and npm installed.\n  - Note: Consider using Node.js 22.18+ and npm version 10.9.0+ to avoid issues with the Polkadot plugin.\n- Basic understanding of Solidity programming.\n- Some PAS test tokens to cover transaction fees (easily obtainable from the [Polkadot faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}). To learn how to get test tokens, check out the [Test Tokens](/develop/smart-contracts/connect-to-polkadot#test-tokens){target=\\_blank} section."}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 2, "depth": 2, "title": "Set Up Hardhat", "anchor": "set-up-hardhat", "start_char": 1872, "end_char": 3289, "estimated_token_count": 317, "token_estimator": "heuristic-v1", "text": "## Set Up Hardhat\n\n1. Create a new directory for your project and navigate into it:\n\n    ```bash\n    mkdir hardhat-example\n    cd hardhat-example\n    ```\n\n2. Initialize a new npm project:\n\n    ```bash\n    npm init -y\n    ```\n\n3. To interact with Polkadot, Hardhat requires the following plugin to compile contracts to PolkaVM bytecode and to spawn a local node compatible with PolkaVM:\n\n    ```bash\n    npm install --save-dev @parity/hardhat-polkadot@0.1.9\n    ```\n\n4. Create a Hardhat project:\n\n    ```bash\n    npx hardhat-polkadot init\n    ```\n\n    Select **Create a JavaScript project** when prompted and follow the instructions. After that, your project will be created with three main folders:\n\n    - **`contracts`**: Where your Solidity smart contracts live.\n    - **`test`**: Contains your test files that validate contract functionality.\n    - **`ignition`**: Deployment modules for safely deploying your contracts to various networks.\n\n5. Add the following folder to the `.gitignore` file if it is not already there:\n\n    ```bash\n    echo '/ignition/deployments/' >> .gitignore\n    ```\n\n6. Finish the setup by installing all the dependencies:\n\n    ```bash\n    npm install\n    ```\n\n    !!! note\n        This last step is needed to set up the `hardhat-polkadot` plugin. It will install the `@parity/hardhat-polkadot` package and all its dependencies. In the future, the plugin will handle this automatically."}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 3, "depth": 2, "title": "Compile Your Contract", "anchor": "compile-your-contract", "start_char": 3289, "end_char": 6687, "estimated_token_count": 763, "token_estimator": "heuristic-v1", "text": "## Compile Your Contract\n\nThe plugin will compile your Solidity contracts for Solidity versions `0.8.0` and higher to be PolkaVM compatible. When compiling your contract, there are two ways to configure your compilation process:\n\n- **npm compiler**: Uses library [@parity/resolc](https://www.npmjs.com/package/@parity/resolc){target=\\_blank} for simplicity and ease of use.\n- **Binary compiler**: Uses your local `resolc` binary directly for more control and configuration options.\n\nTo compile your project, follow these instructions:\n\n1. Modify your Hardhat configuration file to specify which compilation process you will be using and activate the `polkavm` flag in the Hardhat network:\n\n    === \"npm Configuration\"\n\n        ```javascript title=\"hardhat.config.js\" hl_lines=\"9-11 14\"\n        // hardhat.config.js\n        require('@nomicfoundation/hardhat-toolbox');\n\n        require('@parity/hardhat-polkadot');\n\n        /** @type import('hardhat/config').HardhatUserConfig */\n        module.exports = {\n          solidity: '0.8.28',\n          resolc: {\n            compilerSource: 'npm',\n          },\n          networks: {\n            hardhat: {\n              polkavm: true,\n            },\n          },\n        };\n        ```\n\n    === \"Binary Configuration\"\n\n        ```javascript title=\"hardhat.config.js\" hl_lines=\"9-14 17\"\n        // hardhat.config.js\n        require('@nomicfoundation/hardhat-toolbox');\n\n        require('@parity/hardhat-polkadot');\n\n        /** @type import('hardhat/config').HardhatUserConfig */\n        module.exports = {\n          solidity: '0.8.28',\n          resolc: {\n            compilerSource: 'binary',\n            settings: {\n              compilerPath: 'INSERT_PATH_TO_RESOLC_COMPILER',\n            },\n          },\n          networks: {\n            hardhat: {\n              polkavm: true,\n            },\n          },\n        };\n        ```\n\n    For the binary configuration, replace `INSERT_PATH_TO_RESOLC_COMPILER` with the proper path to the binary. To obtain the binary, check the [releases](https://github.com/paritytech/revive/releases){target=\\_blank} section of the `resolc` compiler, and download the latest version.\n\n    The default settings used can be found in the [`constants.ts`](https://github.com/paritytech/hardhat-polkadot/blob/v0.1.5/packages/hardhat-polkadot-resolc/src/constants.ts#L8-L23){target=\\_blank} file of the `hardhat-polkadot` source code. You can change them according to your project needs. Generally, the recommended settings for optimized outputs are the following:\n\n    ```javascript title=\"hardhat.config.js\" hl_lines=\"4-10\"\n    resolc: {\n      ...\n      settings: {\n        optimizer: {\n          enabled: true,\n          parameters: 'z',\n          fallbackOz: true,\n          runs: 200,\n        },\n        standardJson: true,\n      },\n      ...\n    }\n    ```\n\n    You can check the [`ResolcConfig`](https://github.com/paritytech/hardhat-polkadot/blob/v0.1.5/packages/hardhat-polkadot-resolc/src/types.ts#L26){target=\\_blank} for more information about compilation settings.\n\n2. Compile the contract with Hardhat:\n\n    ```bash\n    npx hardhat compile\n    ```\n\n3. After successful compilation, you'll see the artifacts generated in the `artifacts-pvm` directory:\n\n    ```bash\n    ls artifacts-pvm/contracts/*.sol/\n    ```\n\n    You should see JSON files containing the contract ABI and bytecode of the contracts you compiled."}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 4, "depth": 2, "title": "Set Up a Testing Environment", "anchor": "set-up-a-testing-environment", "start_char": 6687, "end_char": 10737, "estimated_token_count": 1066, "token_estimator": "heuristic-v1", "text": "## Set Up a Testing Environment\n\nHardhat allows you to spin up a local testing environment to test and validate your smart contract functionalities before deploying to live networks. The `hardhat-polkadot` plugin provides the possibility to spin up a local node with an ETH-RPC adapter for running local tests.\n\nFor complete isolation and control over the testing environment, you can configure Hardhat to work with a fresh local Substrate node. This approach is ideal when you want to test in a clean environment without any existing state or when you need specific node configurations.\n\nConfigure a local node setup by adding the node binary path along with the ETH-RPC adapter path:\n\n```javascript title=\"hardhat.config.js\" hl_lines=\"12-20\"\n// hardhat.config.js\nrequire('@nomicfoundation/hardhat-toolbox');\n\nrequire('@parity/hardhat-polkadot');\n/** @type import('hardhat/config').HardhatUserConfig */\nmodule.exports = {\n    ...\n      networks: {\n        hardhat: {\n          polkavm: true,\n          nodeConfig: {\n            nodeBinaryPath: 'INSERT_PATH_TO_SUBSTRATE_NODE',\n            rpcPort: 8000,\n            dev: true,\n          },\n          adapterConfig: {\n            adapterBinaryPath: 'INSERT_PATH_TO_ETH_RPC_ADAPTER',\n            dev: true,\n          },\n        },\n  },\n};\n```\n\nReplace `INSERT_PATH_TO_SUBSTRATE_NODE` and `INSERT_PATH_TO_ETH_RPC_ADAPTER` with the actual paths to your compiled binaries. The `dev: true` flag configures both the node and adapter for development mode. To obtain these binaries, check the [Installation](/develop/smart-contracts/local-development-node#install-the-substrate-node-and-eth-rpc-adapter){target=\\_blank} section on the Local Development Node page.\n\n!!! warning\n    If you're using the default `hardhat.config.js` created by the `hardhat-polkadot` plugin, it includes a `forking` section pointing to the Polkadot Hub TestNet. When you run `npx hardhat node`, Hardhat will start a fork of that network. To use your local node instead, comment out the `forking` section; otherwise, `npx hardhat node` will continue to use the forked network even if a local node is defined in the configuration.\n\nOnce configured, start your chosen testing environment with:\n\n```bash\nnpx hardhat node\n```\n\nThis command will launch either the forked network or local node (depending on your configuration) along with the ETH-RPC adapter, providing you with a complete testing environment ready for contract deployment and interaction. By default, the Substrate node will be running on `localhost:8000` and the ETH-RPC adapter on `localhost:8545`.\n\nThe output will be something like this:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat node</span>\n  <br />\n  <span data-ty>Starting server at 127.0.0.1:8000</span>\n  <span data-ty>../bin/substrate-node --rpc-port=8000 --dev</span>\n  <span data-ty>Starting the Eth RPC Adapter at 127.0.0.1:8545</span>\n  <span data-ty>../bin/eth-rpc --node-rpc-url=ws://localhost:8000 --dev</span>\n  <span data-ty>2025-05-29 13:00:32 Running in --dev mode, RPC CORS has been disabled.</span>\n  <span data-ty>2025-05-29 13:00:32 Running in --dev mode, RPC CORS has been disabled.</span>\n  <span data-ty>2025-05-29 13:00:32 🌐 Connecting to node at: ws://localhost:8000 ...</span>\n  <span data-ty>2025-05-29 13:00:32 Substrate Node</span>\n  <span data-ty>2025-05-29 13:00:32 ✌️ version 3.0.0-dev-f73c228b7a1</span>\n  <span data-ty>2025-05-29 13:00:32 ❤️ by Parity Technologies &lt;admin@parity.io&gt;, 2017-2025</span>\n  <span data-ty>2025-05-29 13:00:32 📋 Chain specification: Development</span>\n  <span data-ty>2025-05-29 13:00:32 🏷 Node name: electric-activity-4221</span>\n  <span data-ty>2025-05-29 13:00:32 👤 Role: AUTHORITY</span>\n  <span data-ty>2025-05-29 13:00:32 💾 Database: RocksDb at /var/folders/f4/7rdt2m9d7j361dm453cpggbm0000gn/T/substrateOaoecu/chains/dev/db/full</span>\n  <span data-ty>2025-05-29 13:00:36 [0] 💸 generated 1 npos voters, 1 from validators and 0 nominators</span>\n  <span data-ty>...</span>\n</div>"}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 5, "depth": 2, "title": "Test Your Contract", "anchor": "test-your-contract", "start_char": 10737, "end_char": 11636, "estimated_token_count": 224, "token_estimator": "heuristic-v1", "text": "## Test Your Contract\n\nWhen testing your contract, be aware that [`@nomicfoundation/hardhat-toolbox/network-helpers`](https://hardhat.org/hardhat-network-helpers/docs/overview){target=\\_blank} is not fully compatible with Polkadot Hub's available RPCs. Specifically, Hardhat-only helpers like `time` and `loadFixture` may not work due to missing RPC calls in the node. For more details, refer to the [Compatibility](https://github.com/paritytech/hardhat-polkadot/tree/main/packages/hardhat-polkadot-node#compatibility){target=\\_blank} section in the `hardhat-revive` docs. You should avoid using helpers like `time` and `loadFixture` when writing tests.\n\nTo run your test:\n\n1. Update the `hardhat.config.js` file accordingly to the [Set Up a Testing Environment](#set-up-a-testing-environment) section.\n\n2. Execute the following command to run your tests:\n\n    ```bash\n    npx hardhat test\n    ```"}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 6, "depth": 2, "title": "Deploy to a Local Node", "anchor": "deploy-to-a-local-node", "start_char": 11636, "end_char": 12774, "estimated_token_count": 267, "token_estimator": "heuristic-v1", "text": "## Deploy to a Local Node\n\nBefore deploying to a live network, you can deploy your contract to a local node using [Ignition](https://hardhat.org/ignition/docs/getting-started#overview){target=\\_blank} modules:\n\n1. Update the Hardhat configuration file to add the local network as a target for local deployment:\n\n    ```javascript title=\"hardhat.config.js\" hl_lines=\"13-16\"\n    // hardhat.config.js\n    require('@nomicfoundation/hardhat-toolbox');\n\n    require('@parity/hardhat-polkadot');\n    /** @type import('hardhat/config').HardhatUserConfig */\n    module.exports = {\n        ...\n          networks: {\n            hardhat: {\n            ...\n              },\n              localNode: {\n                polkavm: true,\n                url: `http://127.0.0.1:8545`,\n              },\n        },\n      },\n    };\n    ```\n\n2. Start a local node:\n\n    ```bash\n    npx hardhat node\n    ```\n\n    This command will spawn a local Substrate node along with the ETH-RPC adapter.\n\n3. In a new terminal window, deploy the contract using Ignition:\n\n    ```bash\n    npx hardhat ignition deploy ./ignition/modules/MyToken.js --network localNode\n    ```"}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 7, "depth": 2, "title": "Deploying to a Live Network", "anchor": "deploying-to-a-live-network", "start_char": 12774, "end_char": 14990, "estimated_token_count": 489, "token_estimator": "heuristic-v1", "text": "## Deploying to a Live Network\n\nAfter testing your contract locally, you can deploy it to a live network. This guide will use the Polkadot Hub TestNet as the target network. Here's how to configure and deploy:\n\n1. Fund your deployment account with enough tokens to cover gas fees. In this case, the needed tokens are PAS (on Polkadot Hub TestNet). You can use the [Polkadot faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank} to obtain testing tokens.\n\n2. Export your private key and save it in your Hardhat environment:\n\n    ```bash\n    npx hardhat vars set PRIVATE_KEY \"INSERT_PRIVATE_KEY\"\n    ```\n\n    Replace `INSERT_PRIVATE_KEY` with your actual private key. For further details on private key exportation, refer to the article [How to export an account's private key](https://support.metamask.io/configure/accounts/how-to-export-an-accounts-private-key/){target=\\_blank}.\n\n    !!! warning\n        Never reveal your private key, otherwise anyone with access to it can control your wallet and steal your funds. Store it securely and never share it publicly or commit it to version control systems.\n\n3. Check that your private key has been set up successfully by running:\n\n    ```bash\n    npx hardhat vars get PRIVATE_KEY\n    ```\n\n4. Update your Hardhat configuration file with network settings for the Polkadot network you want to target:\n\n    ```javascript title=\"hardhat.config.js\" hl_lines=\"18-22\"\n    // hardhat.config.js\n    require('@nomicfoundation/hardhat-toolbox');\n\n    require('@parity/hardhat-polkadot');\n    const { vars } = require('hardhat/config');\n\n    /** @type import('hardhat/config').HardhatUserConfig */\n    module.exports = {\n        ...\n          networks: {\n            hardhat: {\n            ...\n              },\n              localNode: {\n            ...\n              },\n              polkadotHubTestnet: {\n                polkavm: true,\n                url: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n                accounts: [vars.get('PRIVATE_KEY')],\n              },\n        },\n      },\n    };\n    ```\n\n6. Deploy your contract using Ignition:\n\n    ```bash\n    npx hardhat ignition deploy ./ignition/modules/MyToken.js --network polkadotHubTestnet\n    ```"}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 8, "depth": 2, "title": "Interacting with Your Contract", "anchor": "interacting-with-your-contract", "start_char": 14990, "end_char": 16790, "estimated_token_count": 426, "token_estimator": "heuristic-v1", "text": "## Interacting with Your Contract\n\nOnce deployed, you can create a script to interact with your contract. To do so, create a file called `scripts/interact.js` and add some logic to interact with the contract.\n\nFor example, for the default `MyToken.sol` contract, you can use the following file that connects to the contract at its address and retrieves the `unlockTime`, which represents when funds can be withdrawn. The script converts this timestamp into a readable date and logs it. It then checks the contract's balance and displays it. Finally, it attempts to call the withdrawal function on the contract, but it catches and logs the error message if the withdrawal is not yet allowed (e.g., before `unlockTime`).\n\n```javascript title=\"interact.js\"\nconst hre = require('hardhat');\n\nasync function main() {\n  // Get the contract factory\n  const MyToken = await hre.ethers.getContractFactory('MyToken');\n\n  // Replace with your deployed contract address\n  const contractAddress = 'INSERT_CONTRACT_ADDRESS';\n\n  // Attach to existing contract\n  const token = await MyToken.attach(contractAddress);\n\n  // Get signers\n  const [deployer] = await hre.ethers.getSigners();\n\n  // Read contract state\n  const name = await token.name();\n  const symbol = await token.symbol();\n  const totalSupply = await token.totalSupply();\n  const balance = await token.balanceOf(deployer.address);\n\n  console.log(`Token: ${name} (${symbol})`);\n  console.log(\n    `Total Supply: ${hre.ethers.formatUnits(totalSupply, 18)} tokens`,\n  );\n  console.log(\n    `Deployer Balance: ${hre.ethers.formatUnits(balance, 18)} tokens`,\n  );\n}\n\nmain().catch((error) => {\n  console.error(error);\n  process.exitCode = 1;\n});\n\n```\n\nRun your interaction script:\n\n```bash\nnpx hardhat run scripts/interact.js --network polkadotHubTestnet\n```"}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 9, "depth": 2, "title": "Upgrading the Plugin", "anchor": "upgrading-the-plugin", "start_char": 16790, "end_char": 17450, "estimated_token_count": 176, "token_estimator": "heuristic-v1", "text": "## Upgrading the Plugin\n\nIf you already have a Hardhat Polkadot project and want to upgrade to a newer version of the plugin, to avoid errors (for example, `Cannot find module 'run-container'`), you can clean your dependencies by running the following commands:\n\n```bash\nrm -rf node_modules package-lock.json\n```\n\nAfter that, you can upgrade the plugin to the latest version by running the following commands:\n\n```bash\nnpm install --save-dev @parity/hardhat-polkadot@latest\nnpm install\n```\n\nConsider using [Node.js](https://nodejs.org/){target=\\_blank} 22.18+ and [npm](https://www.npmjs.com/){target=\\_blank} version 10.9.0+ to avoid issues with the plugin."}
{"page_id": "develop-smart-contracts-dev-environments-hardhat", "page_title": "Use Hardhat with Polkadot Hub", "index": 10, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 17450, "end_char": 18530, "estimated_token_count": 249, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nHardhat provides a powerful environment for developing, testing, and deploying smart contracts on Polkadot Hub. Its plugin architecture allows seamless integration with PolkaVM through the `hardhat-resolc` and `hardhat-revive-node` plugins.\n\nExplore more about smart contracts through these resources:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> __Smart Contracts on Polkadot__\n\n    ---\n\n    Dive into advanced smart contract concepts.\n\n    [:octicons-arrow-right-24: Get Started](/develop/smart-contracts/)\n\n-   <span class=\"badge external\">External</span> __Hardhat Documentation__\n\n    ---\n\n    Learn more about Hardhat's advanced features and best practices.\n\n    [:octicons-arrow-right-24: Get Started](https://hardhat.org/docs){target=\\_blank}\n\n-   <span class=\"badge external\">External</span> __OpenZeppelin Contracts__\n\n    ---\n\n    Test your skills by deploying contracts with prebuilt templates.\n\n    [:octicons-arrow-right-24: Get Started](https://www.openzeppelin.com/solidity-contracts){target=\\_blank}\n\n</div>"}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 0, "depth": 2, "title": "Overview", "anchor": "overview", "start_char": 1054, "end_char": 1367, "estimated_token_count": 67, "token_estimator": "heuristic-v1", "text": "## Overview\n\nRemix IDE is a robust browser-based development environment for smart contracts. This guide will walk you through the essentials of the [Polkadot Remix IDE](https://remix.polkadot.io/){target=\\_blank} to understand the processes of compiling, developing, and deploying smart contracts on Asset Hub."}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1367, "end_char": 1731, "estimated_token_count": 88, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have:\n\n- A web browser with [Talisman](https://talisman.xyz/){target=\\_blank} extension installed.\n- Basic understanding of Solidity programming.\n- Some WND test tokens to cover transaction fees (easily obtainable from the [Polkadot faucet](https://faucet.polkadot.io/westend?parachain=1000){target=\\_blank})."}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 2, "depth": 2, "title": "Accessing Remix IDE", "anchor": "accessing-remix-ide", "start_char": 1731, "end_char": 2141, "estimated_token_count": 106, "token_estimator": "heuristic-v1", "text": "## Accessing Remix IDE\n\nNavigate to [https://remix.polkadot.io/](https://remix.polkadot.io/){target=\\_blank}. The interface will load with a default workspace containing sample contracts.\n\n![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-1.webp)\n\nIn this interface, you can access a file explorer, edit your code, interact with various plugins for development, and use a terminal."}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 3, "depth": 2, "title": "Creating a New Contract", "anchor": "creating-a-new-contract", "start_char": 2141, "end_char": 3250, "estimated_token_count": 254, "token_estimator": "heuristic-v1", "text": "## Creating a New Contract\n\nTo create a new contract using the Polkadot Remix IDE, you can follow these steps:\n\n1. Select the **Create a new file** button in the `contracts` folder.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-2.webp)\n\n2. Name your file with a `.sol` extension, in this case, `Counter.sol`.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-3.webp)\n\n3. Write your Solidity code in the editor.\n\n    You can use the following code as an example:\n\n    ???- \"Counter.sol\"\n        \n        ```solidity\n        // SPDX-License-Identifier: MIT\n        pragma solidity ^0.8.0;\n\n        contract Counter {\n            int256 private count;\n\n            function increment() public {\n                count += 1;\n            }\n\n            function decrement() public {\n                count -= 1;\n            }\n\n            function getCount() public view returns (int256) {\n                return count;\n            }\n        }\n        ```\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-4.webp)"}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 4, "depth": 2, "title": "Compiling Your Contract", "anchor": "compiling-your-contract", "start_char": 3250, "end_char": 4016, "estimated_token_count": 192, "token_estimator": "heuristic-v1", "text": "## Compiling Your Contract\n\n1. To compile your contract, you need to:\n\n    1. Navigate to the **Solidity Compiler** tab (third icon in the left sidebar).\n    2. Select **Compile** or use `Ctrl+S`.\n\n        ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-5.webp)\n    \n        !!! note\n            Compilation errors and warnings appear in the terminal panel at the bottom of the screen.\n\n1. After compiling your contract, you can navigate to the **File Explorer** tab (first icon in the left sidebar) and check that:\n    1. The `artifact` folder is present.\n    2. The `Counter_metadata.json` and the `Counter.json` files have been generated.\n\n        ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-6.webp)"}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 5, "depth": 2, "title": "Deploying Contracts", "anchor": "deploying-contracts", "start_char": 4016, "end_char": 5054, "estimated_token_count": 285, "token_estimator": "heuristic-v1", "text": "## Deploying Contracts\n\n1. To deploy your contract, you need to:\n\n    1. Navigate to the **Deploy & Run Transactions** tab (fourth icon in the left sidebar).\n    2. Click the **Environment** dropdown.\n    3. Select **Customize this list**.\n\n        ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-7.webp)\n\n2. Enable the **Injected Provider - Talisman** option.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-8.webp)\n\n4. Click again the **Environment** dropdown and select **Injected Provider - Talisman**.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-9.webp)\n\n4. Click the **Deploy** button and then click **Approve** in the Talisman wallet popup.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-10.webp)\n\n5. Once your contract is deployed successfully, you will see the following output in the Remix terminal:\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-11.webp)"}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 6, "depth": 2, "title": "Interacting with Contracts", "anchor": "interacting-with-contracts", "start_char": 5054, "end_char": 5870, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "## Interacting with Contracts\n\nOnce deployed, your contract appears in the **Deployed/Unpinned Contracts** section:\n\n1. Expand the contract to view available methods.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-12.webp)\n\n    !!! tip\n        Pin your frequently used contracts to the **Pinned Contracts** section for easy access.\n\n2. To interact with the contract, you can select any of the exposed methods.\n\n    ![](/images/develop/smart-contracts/evm-toolkit/dev-environments/remix/remix-13.webp)\n\n    In this way, you can interact with your deployed contract by reading its state or writing to it. The button color indicates the type of interaction available:\n\n    - **Red**: Modifies state and is payable.\n    - **Orange**: Modifies state only.\n    - **Blue**: Reads state."}
{"page_id": "develop-smart-contracts-dev-environments-remix", "page_title": "Use the Polkadot Remix IDE", "index": 7, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 5870, "end_char": 6732, "estimated_token_count": 189, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nThe Polkadot Remix IDE offers an environment for developing, compiling, and deploying smart contracts on Asset Hub. Its intuitive interface allows developers to easily write Solidity code, compile contracts, and interact with them directly in the browser.\n\nExplore more about smart contracts through these resources:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> __Smart Contracts on Polkadot__\n\n    ---\n\n    Dive into advanced smart contract concepts.\n\n    [:octicons-arrow-right-24: Get Started](/develop/smart-contracts/)\n\n-   <span class=\"badge external\">External</span> __OpenZeppelin Contracts__\n\n    ---\n\n    Test your skills by deploying a simple contracts with prebuilt templates.\n\n    [:octicons-arrow-right-24: Get Started](https://www.openzeppelin.com/solidity-contracts){target=\\_blank}\n\n</div>"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 0, "depth": 2, "title": "General Questions", "anchor": "general-questions", "start_char": 452, "end_char": 474, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## General Questions"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 1, "depth": 3, "title": "What are the different types of smart contracts I can build on Polkadot?", "anchor": "what-are-the-different-types-of-smart-contracts-i-can-build-on-polkadot", "start_char": 474, "end_char": 917, "estimated_token_count": 99, "token_estimator": "heuristic-v1", "text": "### What are the different types of smart contracts I can build on Polkadot?\n\nPolkadot supports three main smart contract environments:\n\n1. **PolkaVM contracts**: Available on Polkadot Hub, using a RISC-V-based virtual machine with Solidity compatibility.\n2. **EVM contracts**: Available on parachains like Moonbeam, Astar, and Acala via the Frontier framework.\n3. **Wasm contracts**: Using ink! (Rust-based) or Solidity via Solang compiler."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 2, "depth": 3, "title": "Should I build a smart contract or a parachain?", "anchor": "should-i-build-a-smart-contract-or-a-parachain", "start_char": 917, "end_char": 1464, "estimated_token_count": 101, "token_estimator": "heuristic-v1", "text": "### Should I build a smart contract or a parachain?\n\nChoose smart contracts if:\n\n- You want to deploy quickly without managing consensus.\n- Your application fits within existing chain functionality.\n- You prefer familiar development tools (Ethereum ecosystem).\n- You need to interact with other contracts easily.\n\nChoose a parachain if:\n\n- You need custom logic that doesn't fit smart contract limitations.\n- You want full control over governance and upgrades.\n- You require specialized consensus mechanisms.\n- You need optimized fee structures."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 3, "depth": 3, "title": "What's the difference between Polkadot Hub smart contracts and other EVM chains?", "anchor": "whats-the-difference-between-polkadot-hub-smart-contracts-and-other-evm-chains", "start_char": 1464, "end_char": 2044, "estimated_token_count": 146, "token_estimator": "heuristic-v1", "text": "### What's the difference between Polkadot Hub smart contracts and other EVM chains?\n\nPolkadot Hub contracts run on [PolkaVM](/polkadot-protocol/smart-contract-basics/polkavm-design){target=\\_blank} instead of EVM:\n\n- **Performance**: RISC-V register-based architecture vs. stack-based EVM.\n- **Resource metering**: Three dimensions (`ref_time`, `proof_size`, `storage_deposit`) vs. single gas metric.\n- **Memory management**: Hard memory limits per contract vs. gas-based soft limits.\n- **Account system**: Polkadot's 32-byte accounts with automatic 20-byte address conversion."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 4, "depth": 2, "title": "Development Environment", "anchor": "development-environment", "start_char": 2044, "end_char": 2072, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Development Environment"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 5, "depth": 3, "title": "Can I use my existing Ethereum development tools?", "anchor": "can-i-use-my-existing-ethereum-development-tools", "start_char": 2072, "end_char": 2409, "estimated_token_count": 90, "token_estimator": "heuristic-v1", "text": "### Can I use my existing Ethereum development tools?\n\nYes, check out the [Wallets](/develop/smart-contracts/wallets){target=\\_blank} page, the [Development Environments](/develop/smart-contracts/dev-environments/){target=\\_blank}, and the [Libraries](/develop/smart-contracts/libraries/){target=\\_blank} sections for more information."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 6, "depth": 3, "title": "How do I set up local development?", "anchor": "how-do-i-set-up-local-development", "start_char": 2409, "end_char": 2576, "estimated_token_count": 42, "token_estimator": "heuristic-v1", "text": "### How do I set up local development?\n\nCheck the [Local Development Node](/develop/smart-contracts/local-development-node){target=\\_blank} for further instructions."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 7, "depth": 3, "title": "What networks are available for testing and deployment?", "anchor": "what-networks-are-available-for-testing-and-deployment", "start_char": 2576, "end_char": 2743, "estimated_token_count": 38, "token_estimator": "heuristic-v1", "text": "### What networks are available for testing and deployment?\n\n- **Local Development**: Kitchensink node with Ethereum RPC proxy.\n- **TestNets**: Polkadot Hub TestNet."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 8, "depth": 2, "title": "Technical Implementation", "anchor": "technical-implementation", "start_char": 2743, "end_char": 2772, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Technical Implementation"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 9, "depth": 3, "title": "How do Ethereum addresses work on Polkadot?", "anchor": "how-do-ethereum-addresses-work-on-polkadot", "start_char": 2772, "end_char": 3257, "estimated_token_count": 105, "token_estimator": "heuristic-v1", "text": "### How do Ethereum addresses work on Polkadot?\n\nPolkadot uses a [dual-address system](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm#account-management-comparison){target=\\_blank}:\n\n- _20-byte Ethereum addresses_ are padded with `0xEE` bytes to create 32-byte Polkadot accounts.\n- _32-byte Polkadot accounts_ can register mappings to 20-byte addresses.\n- _Automatic conversion_ happens behind the scenes.\n- _MetaMask compatibility_ is maintained through the mapping system."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 10, "depth": 3, "title": "What are the key differences in the gas model?", "anchor": "what-are-the-key-differences-in-the-gas-model", "start_char": 3257, "end_char": 3763, "estimated_token_count": 108, "token_estimator": "heuristic-v1", "text": "### What are the key differences in the gas model?\n\nPolkaVM uses three resource dimensions:\n\n- **`ref_time`**: Computational time (similar to traditional gas).\n- **`proof_size`**: State proof size for validator verification.\n- **`storage_deposit`**: Refundable deposit for state storage.\n\nKey implications:\n\n- Gas values are dynamically scaled based on performance benchmarks.\n- Cross-contract calls don't respect gas limits (use reentrancy protection).\n- Storage costs are separate from execution costs."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 11, "depth": 3, "title": "How does contract deployment work?", "anchor": "how-does-contract-deployment-work", "start_char": 3763, "end_char": 4095, "estimated_token_count": 63, "token_estimator": "heuristic-v1", "text": "### How does contract deployment work?\n\nPolkaVM deployment differs from EVM:\n\n- _Code must be pre-uploaded_ to the chain before instantiation.\n- _Factory contracts_ need modification to work with pre-uploaded code hashes.\n- _Two-step process_: Upload code, then instantiate contracts.\n- _Runtime code generation_ is not supported."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 12, "depth": 3, "title": "Which Solidity features are not supported?", "anchor": "which-solidity-features-are-not-supported", "start_char": 4095, "end_char": 4504, "estimated_token_count": 104, "token_estimator": "heuristic-v1", "text": "### Which Solidity features are not supported?\n\nLimited support for:\n\n- **`EXTCODECOPY`**: Only works in constructor code.\n- **Runtime code modification**: Use on-chain constructors instead.\n- **Gas stipends**: `address.send()` and `address.transfer()` don't provide reentrancy protection.\n\nUnsupported operations:\n\n- `pc`, `extcodecopy`, `selfdestruct`\n- `blobhash`, `blobbasefee` (blob-related operations)"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 13, "depth": 3, "title": "How do I handle the existential deposit requirement?", "anchor": "how-do-i-handle-the-existential-deposit-requirement", "start_char": 4504, "end_char": 4984, "estimated_token_count": 91, "token_estimator": "heuristic-v1", "text": "### How do I handle the existential deposit requirement?\n\nWhat it means:\n\n- Accounts need a minimum balance, also known as an existential deposit (ED), to remain active.\n- Accounts below this threshold are automatically deleted.\n\nHow it's handled:\n\n- _Balance queries_ via Ethereum RPC automatically deduct the ED.\n- _New account transfers_ automatically include ED with transaction fees.\n- _Contract-to-contract transfers_ draw ED from transaction signer, not sending contract."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 14, "depth": 2, "title": "Migration and Compatibility", "anchor": "migration-and-compatibility", "start_char": 4984, "end_char": 5016, "estimated_token_count": 5, "token_estimator": "heuristic-v1", "text": "## Migration and Compatibility"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 15, "depth": 3, "title": "Can I migrate my existing Ethereum contracts?", "anchor": "can-i-migrate-my-existing-ethereum-contracts", "start_char": 5016, "end_char": 5423, "estimated_token_count": 79, "token_estimator": "heuristic-v1", "text": "### Can I migrate my existing Ethereum contracts?\n\nMost contracts work without changes:\n\n- Standard ERC-20, ERC-721, ERC-1155 tokens.\n- DeFi protocols and DEXs.\n- DAOs and governance contracts.\n\nMay need modifications:\n\n- Factory contracts that create other contracts at runtime.\n- Contracts using `EXTCODECOPY` for runtime code manipulation.\n- Contracts relying on gas stipends for reentrancy protection."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 16, "depth": 2, "title": "Troubleshooting", "anchor": "troubleshooting", "start_char": 5423, "end_char": 5443, "estimated_token_count": 3, "token_estimator": "heuristic-v1", "text": "## Troubleshooting"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 17, "depth": 3, "title": "Why are my gas calculations different?", "anchor": "why-are-my-gas-calculations-different", "start_char": 5443, "end_char": 5705, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "### Why are my gas calculations different?\n\nPolkaVM uses dynamic gas scaling:\n\n- Gas values reflect actual performance benchmarks.\n- Don't hardcode gas values—use flexible calculations.\n- Cross-contract calls ignore gas limits—implement proper access controls."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 18, "depth": 3, "title": "I deployed a contract with MetaMask, and got a `code size` error - why?", "anchor": "i-deployed-a-contract-with-metamask-and-got-a-code-size-error-why", "start_char": 5705, "end_char": 5962, "estimated_token_count": 62, "token_estimator": "heuristic-v1", "text": "### I deployed a contract with MetaMask, and got a `code size` error - why?\n\nThe latest MetaMask update affects the extension’s ability to deploy large contracts. Check the [Wallets](/develop/smart-contracts/wallets){target=\\_blank} page for more details."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 19, "depth": 3, "title": "I found a bug, where can I log it?", "anchor": "i-found-a-bug-where-can-i-log-it", "start_char": 5962, "end_char": 6186, "estimated_token_count": 62, "token_estimator": "heuristic-v1", "text": "### I found a bug, where can I log it?\n\nPlease log any bugs in the [`contracts-issues`](https://github.com/paritytech/contract-issues/issues){target=\\_blank} repository so developers are aware of them and can address them."}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 20, "depth": 2, "title": "Known Issues", "anchor": "known-issues", "start_char": 6186, "end_char": 6203, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Known Issues"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 21, "depth": 3, "title": "Runtime Behavior", "anchor": "runtime-behavior", "start_char": 6203, "end_char": 6831, "estimated_token_count": 166, "token_estimator": "heuristic-v1", "text": "### Runtime Behavior\n\n- **`creationCode` returns hash instead of bytecode**: The Solidity keyword returns a `keccak256` hash rather than the actual creation bytecode.\n    - [Issue #45](https://github.com/paritytech/contract-issues/issues/45){target=\\_blank}\n- **Non-deterministic gas usage**: Gas consumption varies slightly for identical transactions.\n    - [Issue #49](https://github.com/paritytech/contract-issues/issues/49){target=\\_blank}\n- **Precompiles not recognized**: Precompile addresses return `Contract not found` error.\n    - [Issue #111](https://github.com/paritytech/contract-issues/issues/111){target=\\_blank}"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 22, "depth": 3, "title": "Development Tools", "anchor": "development-tools", "start_char": 6831, "end_char": 7061, "estimated_token_count": 61, "token_estimator": "heuristic-v1", "text": "### Development Tools\n\n- **`hardhat-polkadot` plugin compilation issues**: Plugin interferes with standard `npx hardhat compile` command.\n    - [Issue #44](https://github.com/paritytech/contract-issues/issues/44){target=\\_blank}"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 23, "depth": 3, "title": "Contract Patterns", "anchor": "contract-patterns", "start_char": 7061, "end_char": 7281, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "### Contract Patterns\n\n- **Minimal proxy (EIP-1167) deployment fails**: Standard proxy contracts cannot be deployed on PolkaVM.\n    - [Issue #86](https://github.com/paritytech/contract-issues/issues/86){target=\\_blank}"}
{"page_id": "develop-smart-contracts-faqs", "page_title": "Polkadot Hub Smart Contract FAQs", "index": 24, "depth": 3, "title": "Compilation", "anchor": "compilation", "start_char": 7281, "end_char": 7469, "estimated_token_count": 54, "token_estimator": "heuristic-v1", "text": "### Compilation\n\n- **`SDIV` opcode crash**: Compiler crashes with `Unsupported SDIV` assertion failure.\n    - [Issue #342](https://github.com/paritytech/revive/issues/342){target=\\_blank}"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 187, "end_char": 682, "estimated_token_count": 117, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPolkadot Hub provides Ethereum compatibility through its JSON-RPC interface, allowing developers to interact with the chain using familiar Ethereum tooling and methods. This document outlines the supported [Ethereum JSON-RPC methods](https://ethereum.org/en/developers/docs/apis/json-rpc/#json-rpc-methods){target=\\_blank} and provides examples of how to use them.\n\nThis guide uses the Polkadot Hub TestNet endpoint:\n\n```text\nhttps://testnet-passet-hub-eth-rpc.polkadot.io\n```"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 1, "depth": 2, "title": "Available Methods", "anchor": "available-methods", "start_char": 682, "end_char": 704, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Available Methods"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 2, "depth": 3, "title": "eth_accounts", "anchor": "eth_accounts", "start_char": 704, "end_char": 1138, "estimated_token_count": 148, "token_estimator": "heuristic-v1", "text": "### eth_accounts\n\nReturns a list of addresses owned by the client. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_accounts\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_accounts\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 3, "depth": 3, "title": "eth_blockNumber", "anchor": "eth_blocknumber", "start_char": 1138, "end_char": 1580, "estimated_token_count": 147, "token_estimator": "heuristic-v1", "text": "### eth_blockNumber\n\nReturns the number of the most recent block. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_blockNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_blockNumber\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 4, "depth": 3, "title": "eth_call", "anchor": "eth_call", "start_char": 1580, "end_char": 3831, "estimated_token_count": 725, "token_estimator": "heuristic-v1", "text": "### eth_call\n\nExecutes a new message call immediately without creating a transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call){target=\\_blank}.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction call object.\n    - **`to` ++\"string\"++**: Recipient address of the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: Hash of the method signature and encoded parameters. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`from` ++\"string\"++**: (Optional) Sender's address for the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (Optional) Gas limit to execute the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit of gas. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Value in wei to send with the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) Block tag or block number to execute the call at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_call\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_call\",\n    \"params\":[{\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"data\": \"INSERT_ENCODED_CALL\"\n    }, \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_RECIPIENT_ADDRESS`, `INSERT_ENCODED_CALL`, and `INSERT_BLOCK_VALUE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 5, "depth": 3, "title": "eth_chainId", "anchor": "eth_chainid", "start_char": 3831, "end_char": 4264, "estimated_token_count": 147, "token_estimator": "heuristic-v1", "text": "### eth_chainId\n\nReturns the chain ID used for signing transactions. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_chainId\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_chainId\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 6, "depth": 3, "title": "eth_estimateGas", "anchor": "eth_estimategas", "start_char": 4264, "end_char": 6477, "estimated_token_count": 712, "token_estimator": "heuristic-v1", "text": "### eth_estimateGas\n\nEstimates gas required for a transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas){target=\\_blank}.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction call object.\n    - **`to` ++\"string\"++**: Recipient address of the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: Hash of the method signature and encoded parameters. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`from` ++\"string\"++**: (Optional) Sender's address for the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (Optional) Gas limit to execute the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit of gas. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Value in wei to send with the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) Block tag or block number to execute the call at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_estimateGas\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_estimateGas\",\n    \"params\":[{\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"data\": \"INSERT_ENCODED_FUNCTION_CALL\"\n    }],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_RECIPIENT_ADDRESS` and `INSERT_ENCODED_CALL` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 7, "depth": 3, "title": "eth_gasPrice", "anchor": "eth_gasprice", "start_char": 6477, "end_char": 6900, "estimated_token_count": 146, "token_estimator": "heuristic-v1", "text": "### eth_gasPrice\n\nReturns the current gas price in Wei. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_gasPrice\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_gasPrice\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 8, "depth": 3, "title": "eth_getBalance", "anchor": "eth_getbalance", "start_char": 6900, "end_char": 7954, "estimated_token_count": 338, "token_estimator": "heuristic-v1", "text": "### eth_getBalance\n\nReturns the balance of a given address. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Address to query balance. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_getBalance\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBalance\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS` and `INSERT_BLOCK_VALUE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 9, "depth": 3, "title": "eth_getBlockByHash", "anchor": "eth_getblockbyhash", "start_char": 7954, "end_char": 8855, "estimated_token_count": 270, "token_estimator": "heuristic-v1", "text": "### eth_getBlockByHash\n\nReturns information about a block by its hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockHash` ++\"string\"++**: The hash of the block to retrieve. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`fullTransactions` ++\"boolean\"++**: If `true`, returns full transaction details; if `false`, returns only transaction hashes.\n\n**Example**:\n\n```bash title=\"eth_getBlockByHash\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockByHash\",\n    \"params\":[\"INSERT_BLOCK_HASH\", INSERT_BOOLEAN],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_HASH` and `INSERT_BOOLEAN` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 10, "depth": 3, "title": "eth_getBlockByNumber", "anchor": "eth_getblockbynumber", "start_char": 8855, "end_char": 9883, "estimated_token_count": 307, "token_estimator": "heuristic-v1", "text": "### eth_getBlockByNumber\n\nReturns information about a block by its number. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`fullTransactions` ++\"boolean\"++**: If `true`, returns full transaction details; if `false`, returns only transaction hashes.\n\n**Example**:\n\n```bash title=\"eth_getBlockByNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockByNumber\",\n    \"params\":[\"INSERT_BLOCK_VALUE\", INSERT_BOOLEAN],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_VALUE` and `INSERT_BOOLEAN` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 11, "depth": 3, "title": "eth_getBlockTransactionCountByNumber", "anchor": "eth_getblocktransactioncountbynumber", "start_char": 9883, "end_char": 10815, "estimated_token_count": 266, "token_estimator": "heuristic-v1", "text": "### eth_getBlockTransactionCountByNumber\n\nReturns the number of transactions in a block from a block number. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n\n**Example**:\n\n```bash title=\"eth_getBlockTransactionCountByNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockTransactionCountByNumber\",\n    \"params\":[\"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_VALUE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 12, "depth": 3, "title": "eth_getBlockTransactionCountByHash", "anchor": "eth_getblocktransactioncountbyhash", "start_char": 10815, "end_char": 11631, "estimated_token_count": 232, "token_estimator": "heuristic-v1", "text": "### eth_getBlockTransactionCountByHash\n\nReturns the number of transactions in a block from a block hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockHash` ++\"string\"++**: The hash of the block to retrieve. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getBlockTransactionCountByHash\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getBlockTransactionCountByHash\",\n    \"params\":[\"INSERT_BLOCK_HASH\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_HASH` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 13, "depth": 3, "title": "eth_getCode", "anchor": "eth_getcode", "start_char": 11631, "end_char": 12671, "estimated_token_count": 335, "token_estimator": "heuristic-v1", "text": "### eth_getCode\n\nReturns the code at a given address. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Contract or account address to query code. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block).\n\n**Example**:\n\n```bash title=\"eth_getCode\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getCode\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS` and `INSERT_BLOCK_VALUE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 14, "depth": 3, "title": "eth_getLogs", "anchor": "eth_getlogs", "start_char": 12671, "end_char": 14646, "estimated_token_count": 646, "token_estimator": "heuristic-v1", "text": "### eth_getLogs\n\nReturns an array of all logs matching a given filter object. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs){target=\\_blank}.\n\n**Parameters**:\n\n- **`filter` ++\"object\"++**: The filter object.\n    - **`fromBlock` ++\"string\"++**: (Optional) Block number or tag to start from. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n    - **`toBlock` ++\"string\"++**: (Optional) Block number or tag to end at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n    - **`address` ++\"string\" or \"array of strings\"++**: (Optional) Contract address or a list of addresses from which to get logs. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`topics` ++\"array of strings\"++**: (Optional) Array of topics for filtering logs. Each topic can be a single [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string or an array of such strings (meaning OR).\n    - **`blockhash` ++\"string\"++**: (Optional) Hash of a specific block. Cannot be used with `fromBlock` or `toBlock`. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getLogs\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getLogs\",\n    \"params\":[{\n        \"fromBlock\": \"latest\",\n        \"toBlock\": \"latest\"\n    }],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 15, "depth": 3, "title": "eth_getStorageAt", "anchor": "eth_getstorageat", "start_char": 14646, "end_char": 15973, "estimated_token_count": 412, "token_estimator": "heuristic-v1", "text": "### eth_getStorageAt\n\nReturns the value from a storage position at a given address. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Contract or account address to query code. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`storageKey` ++\"string\"++**: Position in storage to retrieve data from. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block).\n\n**Example**:\n\n```bash title=\"eth_getStorageAt\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getStorageAt\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_STORAGE_KEY\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS`, `INSERT_STORAGE_KEY`, and `INSERT_BLOCK_VALUE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 16, "depth": 3, "title": "eth_getTransactionCount", "anchor": "eth_gettransactioncount", "start_char": 15973, "end_char": 17072, "estimated_token_count": 337, "token_estimator": "heuristic-v1", "text": "### eth_getTransactionCount\n\nReturns the number of transactions sent from an address (nonce). [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount){target=\\_blank}.\n\n**Parameters**:\n\n- **`address` ++\"string\"++**: Address to query balance. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block).\n\n**Example**:\n\n```bash title=\"eth_getTransactionCount\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionCount\",\n    \"params\":[\"INSERT_ADDRESS\", \"INSERT_BLOCK_VALUE\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_ADDRESS` and `INSERT_BLOCK_VALUE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 17, "depth": 3, "title": "eth_getTransactionByHash", "anchor": "eth_gettransactionbyhash", "start_char": 17072, "end_char": 17848, "estimated_token_count": 226, "token_estimator": "heuristic-v1", "text": "### eth_getTransactionByHash\n\nReturns information about a transaction by its hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash){target=\\_blank}.\n\n**Parameters**:\n\n- **`transactionHash` ++\"string\"++**: The hash of the transaction. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionByHash\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionByHash\",\n    \"params\":[\"INSERT_TRANSACTION_HASH\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_TRANSACTION_HASH` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 18, "depth": 3, "title": "eth_getTransactionByBlockNumberAndIndex", "anchor": "eth_gettransactionbyblocknumberandindex", "start_char": 17848, "end_char": 19066, "estimated_token_count": 338, "token_estimator": "heuristic-v1", "text": "### eth_getTransactionByBlockNumberAndIndex\n\nReturns information about a transaction by block number and transaction index. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyblocknumberandindex){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: The block value to be fetched. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`transactionIndex` ++\"string\"++**: The index of the transaction in the block. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionByBlockNumberAndIndex\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionByBlockNumberAndIndex\",\n    \"params\":[\"INSERT_BLOCK_VALUE\", \"INSERT_TRANSACTION_INDEX\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_VALUE` and `INSERT_TRANSACTION_INDEX` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 19, "depth": 3, "title": "eth_getTransactionByBlockHashAndIndex", "anchor": "eth_gettransactionbyblockhashandindex", "start_char": 19066, "end_char": 20156, "estimated_token_count": 302, "token_estimator": "heuristic-v1", "text": "### eth_getTransactionByBlockHashAndIndex\n\nReturns information about a transaction by block hash and transaction index. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyblockhashandindex){target=\\_blank}.\n\n**Parameters**:\n\n- **`blockHash` ++\"string\"++**: The hash of the block. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`transactionIndex` ++\"string\"++**: The index of the transaction in the block. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionByBlockHashAndIndex\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionByBlockHashAndIndex\",\n    \"params\":[\"INSERT_BLOCK_HASH\", \"INSERT_TRANSACTION_INDEX\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_BLOCK_HASH` and `INSERT_TRANSACTION_INDEX` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 20, "depth": 3, "title": "eth_getTransactionReceipt", "anchor": "eth_gettransactionreceipt", "start_char": 20156, "end_char": 20941, "estimated_token_count": 227, "token_estimator": "heuristic-v1", "text": "### eth_getTransactionReceipt\n\nReturns the receipt of a transaction by transaction hash. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt){target=\\_blank}.\n\n**Parameters**:\n\n- **`transactionHash` ++\"string\"++**: The hash of the transaction. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_getTransactionReceipt\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_getTransactionReceipt\",\n    \"params\":[\"INSERT_TRANSACTION_HASH\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_TRANSACTION_HASH` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 21, "depth": 3, "title": "eth_maxPriorityFeePerGas", "anchor": "eth_maxpriorityfeepergas", "start_char": 20941, "end_char": 21356, "estimated_token_count": 125, "token_estimator": "heuristic-v1", "text": "### eth_maxPriorityFeePerGas\n\nReturns an estimate of the current priority fee per gas, in Wei, to be included in a block.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_maxPriorityFeePerGas\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_maxPriorityFeePerGas\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 22, "depth": 3, "title": "eth_sendRawTransaction", "anchor": "eth_sendrawtransaction", "start_char": 21356, "end_char": 22065, "estimated_token_count": 218, "token_estimator": "heuristic-v1", "text": "### eth_sendRawTransaction\n\nSubmits a raw transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction){target=\\_blank}.\n\n**Parameters**:\n\n- **`callData` ++\"string\"++**: Signed transaction data. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_sendRawTransaction\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_sendRawTransaction\",\n    \"params\":[\"INSERT_CALL_DATA\"],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_CALL_DATA` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 23, "depth": 3, "title": "eth_sendTransaction", "anchor": "eth_sendtransaction", "start_char": 22065, "end_char": 24444, "estimated_token_count": 730, "token_estimator": "heuristic-v1", "text": "### eth_sendTransaction\n\nCreates and sends a new transaction. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction){target=\\_blank}.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction object.\n    - **`from` ++\"string\"++**: Address sending the transaction. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`to` ++\"string\"++**: (Optional) Recipient address. No need to provide this value when deploying a contract. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (optional, default: `90000`) gas limit for execution. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Amount of Ether to send. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: (Optional) Contract bytecode or encoded method call. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`nonce` ++\"string\"++**: (Optional) Transaction nonce. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n\n**Example**:\n\n```bash title=\"eth_sendTransaction\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_sendTransaction\",\n    \"params\":[{\n        \"from\": \"INSERT_SENDER_ADDRESS\",\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"gas\": \"INSERT_GAS_LIMIT\",\n        \"gasPrice\": \"INSERT_GAS_PRICE\",\n        \"value\": \"INSERT_VALUE\",\n        \"input\": \"INSERT_INPUT_DATA\",\n        \"nonce\": \"INSERT_NONCE\"\n    }],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_SENDER_ADDRESS`, `INSERT_RECIPIENT_ADDRESS`, `INSERT_GAS_LIMIT`, `INSERT_GAS_PRICE`, `INSERT_VALUE`, `INSERT_INPUT_DATA`, and `INSERT_NONCE` with the proper values.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 24, "depth": 3, "title": "eth_syncing", "anchor": "eth_syncing", "start_char": 24444, "end_char": 24888, "estimated_token_count": 152, "token_estimator": "heuristic-v1", "text": "### eth_syncing\n\nReturns an object with syncing data or `false` if not syncing. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_syncing){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"eth_syncing\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"eth_syncing\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 25, "depth": 3, "title": "net_listening", "anchor": "net_listening", "start_char": 24888, "end_char": 25373, "estimated_token_count": 157, "token_estimator": "heuristic-v1", "text": "### net_listening\n\nReturns `true` if the client is currently listening for network connections, otherwise `false`. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#net_listening){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"net_listening\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"net_listening\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 26, "depth": 3, "title": "net_peerCount", "anchor": "net_peercount", "start_char": 25373, "end_char": 25726, "estimated_token_count": 115, "token_estimator": "heuristic-v1", "text": "### net_peerCount\n\nReturns the number of peers currently connected to the client.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"net_peerCount\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"net_peerCount\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 27, "depth": 3, "title": "net_version", "anchor": "net_version", "start_char": 25726, "end_char": 26151, "estimated_token_count": 147, "token_estimator": "heuristic-v1", "text": "### net_version\n\nReturns the current network ID as a string. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#net_version){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"net_version\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"net_version\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 28, "depth": 3, "title": "system_health", "anchor": "system_health", "start_char": 26151, "end_char": 26493, "estimated_token_count": 113, "token_estimator": "heuristic-v1", "text": "### system_health\n\nReturns information about the health of the system.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"system_health\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"system_health\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 29, "depth": 3, "title": "web3_clientVersion", "anchor": "web3_clientversion", "start_char": 26493, "end_char": 26938, "estimated_token_count": 144, "token_estimator": "heuristic-v1", "text": "### web3_clientVersion\n\nReturns the current client version. [Reference](https://ethereum.org/en/developers/docs/apis/json-rpc/#web3_clientversion){target=\\_blank}.\n\n**Parameters**:\n\nNone.\n\n**Example**:\n\n```bash title=\"web3_clientVersion\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"web3_clientVersion\",\n    \"params\":[],\n    \"id\":1\n}'\n```\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 30, "depth": 3, "title": "debug_traceBlockByNumber", "anchor": "debug_traceblockbynumber", "start_char": 26938, "end_char": 28020, "estimated_token_count": 328, "token_estimator": "heuristic-v1", "text": "### debug_traceBlockByNumber \n\nTraces a block's execution by its number and returns a detailed execution trace for each transaction.\n\n**Parameters**:\n\n- **`blockValue` ++\"string\"++**: The block number or tag to trace. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`options` ++\"object\"++**: (Optional) An object containing tracer options.\n    - **`tracer` ++\"string\"++**: The name of the tracer to use (e.g., `\"callTracer\"`, `\"opTracer\"`).\n    - Other tracer-specific options may be supported.\n\n**Example**:\n\n```bash title=\"debug_traceBlockByNumber\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"debug_traceBlockByNumber\",\n    \"params\":[\"INSERT_BLOCK_VALUE\", {\"tracer\": \"callTracer\"}],\n    \"id\":1\n}'\n```\n\nEnsure to replace `INSERT_BLOCK_VALUE` with a proper block number if needed.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 31, "depth": 3, "title": "debug_traceTransaction", "anchor": "debug_tracetransaction", "start_char": 28020, "end_char": 28867, "estimated_token_count": 251, "token_estimator": "heuristic-v1", "text": "### debug_traceTransaction\n\nTraces the execution of a single transaction by its hash and returns a detailed execution trace.\n\n**Parameters**:\n\n- **`transactionHash` ++\"string\"++**: The hash of the transaction to trace. Must be a [32 byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n- **`options` ++\"object\"++**: (Optional) An object containing tracer options (e.g., `tracer: \"callTracer\"`).\n\n**Example**:\n\n```bash title=\"debug_traceTransaction\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"debug_traceTransaction\",\n    \"params\":[\"INSERT_TRANSACTION_HASH\", {\"tracer\": \"callTracer\"}],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_TRANSACTION_HASH` with the proper value.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 32, "depth": 3, "title": "debug_traceCall", "anchor": "debug_tracecall", "start_char": 28867, "end_char": 31324, "estimated_token_count": 767, "token_estimator": "heuristic-v1", "text": "### debug_traceCall\n\nExecutes a new message call and returns a detailed execution trace without creating a transaction on the blockchain.\n\n**Parameters**:\n\n- **`transaction` ++\"object\"++**: The transaction call object, similar to `eth_call` parameters.\n    - **`to` ++\"string\"++**: Recipient address of the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`data` ++\"string\"++**: Hash of the method signature and encoded parameters. Must be a [data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`from` ++\"string\"++**: (Optional) Sender's address for the call. Must be a [20-byte data](https://ethereum.org/en/developers/docs/apis/json-rpc/#unformatted-data-encoding){target=\\_blank} string.\n    - **`gas` ++\"string\"++**: (Optional) Gas limit to execute the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`gasPrice` ++\"string\"++**: (Optional) Gas price per unit of gas. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n    - **`value` ++\"string\"++**: (Optional) Value in wei to send with the call. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string.\n- **`blockValue` ++\"string\"++**: (Optional) Block tag or block number to execute the call at. Must be a [quantity](https://ethereum.org/en/developers/docs/apis/json-rpc/#quantities-encoding){target=\\_blank} string or a [default block parameter](https://ethereum.org/en/developers/docs/apis/json-rpc/#default-block){target=\\_blank}.\n- **`options` ++\"object\"++**: (Optional) An object containing tracer options (e.g., `tracer: \"callTracer\"`).\n\n**Example**:\n\n```bash title=\"debug_traceCall\"\ncurl -X POST https://testnet-passet-hub-eth-rpc.polkadot.io \\\n-H \"Content-Type: application/json\" \\\n--data '{\n    \"jsonrpc\":\"2.0\",\n    \"method\":\"debug_traceCall\",\n    \"params\":[{\n        \"from\": \"INSERT_SENDER_ADDRESS\",\n        \"to\": \"INSERT_RECIPIENT_ADDRESS\",\n        \"data\": \"INSERT_ENCODED_CALL\"\n    }, \"INSERT_BLOCK_VALUE\", {\"tracer\": \"callTracer\"}],\n    \"id\":1\n}'\n```\n\nEnsure to replace the `INSERT_SENDER_ADDRESS`, `INSERT_RECIPIENT_ADDRESS`, `INSERT_ENCODED_CALL`, and `INSERT_BLOCK_VALUE` with the proper value.\n\n---"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 33, "depth": 2, "title": "Response Format", "anchor": "response-format", "start_char": 31324, "end_char": 31507, "estimated_token_count": 57, "token_estimator": "heuristic-v1", "text": "## Response Format\n\nAll responses follow the standard JSON-RPC 2.0 format:\n\n```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"result\": ... // The return value varies by method\n}\n```"}
{"page_id": "develop-smart-contracts-json-rpc-apis", "page_title": "JSON-RPC APIs", "index": 34, "depth": 2, "title": "Error Handling", "anchor": "error-handling", "start_char": 31507, "end_char": 31726, "estimated_token_count": 64, "token_estimator": "heuristic-v1", "text": "## Error Handling\n\nIf an error occurs, the response will include an error object:\n\n```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 1,\n    \"error\": {\n        \"code\": -32000,\n        \"message\": \"Error message here\"\n    }\n}\n```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 183, "end_char": 709, "estimated_token_count": 105, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[Ethers.js](https://docs.ethers.org/v6/){target=\\_blank} is a lightweight library that enables interaction with Ethereum Virtual Machine (EVM)-compatible blockchains through JavaScript. Ethers is widely used as a toolkit to establish connections and read and write blockchain data. This article demonstrates using Ethers.js to interact and deploy smart contracts to Polkadot Hub.\n\nThis guide is intended for developers who are familiar with JavaScript and want to interact with Polkadot Hub using Ethers.js."}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 709, "end_char": 1065, "estimated_token_count": 110, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have the following installed:\n\n- **Node.js**: v22.13.1 or later, check the [Node.js installation guide](https://nodejs.org/en/download/current/){target=\\_blank}.\n- **npm**: v6.13.4 or later (comes bundled with Node.js).\n- **Solidity**: This guide uses Solidity `^0.8.9` for smart contract development."}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 2, "depth": 2, "title": "Project Structure", "anchor": "project-structure", "start_char": 1065, "end_char": 1577, "estimated_token_count": 144, "token_estimator": "heuristic-v1", "text": "## Project Structure\n\nThis project organizes contracts, scripts, and compiled artifacts for easy development and deployment.\n\n```text title=\"Ethers.js Polkadot Hub\"\nethers-project\n├── contracts\n│   ├── Storage.sol\n├── scripts\n│   ├── connectToProvider.js\n│   ├── fetchLastBlock.js\n│   ├── compile.js\n│   ├── deploy.js\n│   ├── checkStorage.js\n├── abis\n│   ├── Storage.json\n├── artifacts\n│   ├── Storage.polkavm\n├── contract-address.json\n├── node_modules/\n├── package.json\n├── package-lock.json\n└── README.md\n```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 3, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 1577, "end_char": 1798, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nTo start working with Ethers.js, create a new folder and initialize your project by running the following commands in your terminal:\n\n```bash\nmkdir ethers-project\ncd ethers-project\nnpm init -y\n```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 4, "depth": 2, "title": "Install Dependencies", "anchor": "install-dependencies", "start_char": 1798, "end_char": 1922, "estimated_token_count": 28, "token_estimator": "heuristic-v1", "text": "## Install Dependencies\n\nNext, run the following command to install the Ethers.js library:\n\n```bash\nnpm install ethers\n```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 5, "depth": 2, "title": "Set Up the Ethers.js Provider", "anchor": "set-up-the-ethersjs-provider", "start_char": 1922, "end_char": 4510, "estimated_token_count": 574, "token_estimator": "heuristic-v1", "text": "## Set Up the Ethers.js Provider\n\nA [`Provider`](https://docs.ethers.org/v6/api/providers/#Provider){target=\\_blank} is an abstraction of a connection to the Ethereum network, allowing you to query blockchain data and send transactions. It serves as a bridge between your application and the blockchain.\n\nTo interact with Polkadot Hub, you must set up an Ethers.js provider. This provider connects to a blockchain node, allowing you to query blockchain data and interact with smart contracts. In the root of your project, create a file named `connectToProvider.js` and add the following code:\n\n```js title=\"scripts/connectToProvider.js\"\nconst { JsonRpcProvider } = require('ethers');\n\nconst createProvider = (rpcUrl, chainId, chainName) => {\n  const provider = new JsonRpcProvider(rpcUrl, {\n    chainId: chainId,\n    name: chainName,\n  });\n\n  return provider;\n};\n\nconst PROVIDER_RPC = {\n  rpc: 'INSERT_RPC_URL',\n  chainId: 'INSERT_CHAIN_ID',\n  name: 'INSERT_CHAIN_NAME',\n};\n\ncreateProvider(PROVIDER_RPC.rpc, PROVIDER_RPC.chainId, PROVIDER_RPC.name);\n\n```\n\n!!! note\n    Replace `INSERT_RPC_URL`, `INSERT_CHAIN_ID`, and `INSERT_CHAIN_NAME` with the appropriate values. For example, to connect to Polkadot Hub TestNet's Ethereum RPC instance, you can use the following parameters:\n\n    ```js\n    const PROVIDER_RPC = {\n        rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n        chainId: 420420422,\n        name: 'polkadot-hub-testnet'\n    };\n    ```\n\nTo connect to the provider, execute:\n\n```bash\nnode connectToProvider\n```\n\nWith the provider set up, you can start querying the blockchain. For instance, to fetch the latest block number:\n\n??? code \"Fetch Last Block code\"\n\n    ```js title=\"scripts/fetchLastBlock.js\"\n    const { JsonRpcProvider } = require('ethers');\n\n    const createProvider = (rpcUrl, chainId, chainName) => {\n      const provider = new JsonRpcProvider(rpcUrl, {\n        chainId: chainId,\n        name: chainName,\n      });\n\n      return provider;\n    };\n\n    const PROVIDER_RPC = {\n      rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n      chainId: 420420422,\n      name: 'polkadot-hub-testnet',\n    };\n\n    const main = async () => {\n      try {\n        const provider = createProvider(\n          PROVIDER_RPC.rpc,\n          PROVIDER_RPC.chainId,\n          PROVIDER_RPC.name,\n        );\n        const latestBlock = await provider.getBlockNumber();\n        console.log(`Latest block: ${latestBlock}`);\n      } catch (error) {\n        console.error('Error connecting to Polkadot Hub TestNet: ' + error.message);\n      }\n    };\n\n    main();\n\n    ```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 6, "depth": 2, "title": "Compile Contracts", "anchor": "compile-contracts", "start_char": 4510, "end_char": 5237, "estimated_token_count": 155, "token_estimator": "heuristic-v1", "text": "## Compile Contracts\n\n!!! note \"Contracts Code Blob Size Disclaimer\"\n    The maximum contract code blob size on Polkadot Hub networks is _100 kilobytes_, significantly larger than Ethereum’s EVM limit of 24 kilobytes.\n\n    For detailed comparisons and migration guidelines, see the [EVM vs. PolkaVM](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm/#current-memory-limits){target=\\_blank} documentation page.\n\nThe `revive` compiler transforms Solidity smart contracts into [PolkaVM](/develop/smart-contracts/overview#native-smart-contracts){target=\\_blank} bytecode for deployment on Polkadot Hub. Revive's Ethereum RPC interface allows you to use familiar tools like Ethers.js and MetaMask to interact with contracts."}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 7, "depth": 3, "title": "Install the Revive Library", "anchor": "install-the-revive-library", "start_char": 5237, "end_char": 5597, "estimated_token_count": 100, "token_estimator": "heuristic-v1", "text": "### Install the Revive Library\n\nThe [`@parity/resolc`](https://www.npmjs.com/package/@parity/resolc){target=\\_blank} library will compile your Solidity code for deployment on Polkadot Hub. Run the following command in your terminal to install the library:\n\n```bash\nnpm install --save-dev @parity/resolc \n```\n\nThis guide uses `@parity/resolc` version `0.2.0`."}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 8, "depth": 3, "title": "Sample Storage Smart Contract", "anchor": "sample-storage-smart-contract", "start_char": 5597, "end_char": 6422, "estimated_token_count": 171, "token_estimator": "heuristic-v1", "text": "### Sample Storage Smart Contract\n\nThis example demonstrates compiling a `Storage.sol` Solidity contract for deployment to Polkadot Hub. The contract's functionality stores a number and permits users to update it with a new value.\n\n```solidity title=\"contracts/Storage.sol\"\n//SPDX-License-Identifier: MIT\n\n// Solidity files have to start with this pragma.\n// It will be used by the Solidity compiler to validate its version.\npragma solidity ^0.8.9;\n\ncontract Storage {\n    // Public state variable to store a number\n    uint256 public storedNumber;\n\n    /**\n    * Updates the stored number.\n    *\n    * The `public` modifier allows anyone to call this function.\n    *\n    * @param _newNumber - The new value to store.\n    */\n    function setNumber(uint256 _newNumber) public {\n        storedNumber = _newNumber;\n    }\n}\n```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 9, "depth": 3, "title": "Compile the Smart Contract", "anchor": "compile-the-smart-contract", "start_char": 6422, "end_char": 8911, "estimated_token_count": 567, "token_estimator": "heuristic-v1", "text": "### Compile the Smart Contract\n\nTo compile this contract, use the following script:\n\n```js title=\"scripts/compile.js\"\nconst { compile } = require('@parity/resolc');\nconst { readFileSync, writeFileSync } = require('fs');\nconst { basename, join } = require('path');\n\nconst compileContract = async (solidityFilePath, outputDir) => {\n  try {\n    // Read the Solidity file\n    const source = readFileSync(solidityFilePath, 'utf8');\n\n    // Construct the input object for the compiler\n    const input = {\n      [basename(solidityFilePath)]: { content: source },\n    };\n\n    console.log(`Compiling contract: ${basename(solidityFilePath)}...`);\n\n    // Compile the contract\n    const out = await compile(input);\n\n    for (const contracts of Object.values(out.contracts)) {\n      for (const [name, contract] of Object.entries(contracts)) {\n        console.log(`Compiled contract: ${name}`);\n\n        // Write the ABI\n        const abiPath = join(outputDir, `${name}.json`);\n        writeFileSync(abiPath, JSON.stringify(contract.abi, null, 2));\n        console.log(`ABI saved to ${abiPath}`);\n\n        // Write the bytecode\n        const bytecodePath = join(outputDir, `${name}.polkavm`);\n        writeFileSync(\n          bytecodePath,\n          Buffer.from(contract.evm.bytecode.object, 'hex'),\n        );\n        console.log(`Bytecode saved to ${bytecodePath}`);\n      }\n    }\n  } catch (error) {\n    console.error('Error compiling contracts:', error);\n  }\n};\n\nconst solidityFilePath = join(__dirname, '../contracts/Storage.sol');\nconst outputDir = join(__dirname, '../contracts');\n\ncompileContract(solidityFilePath, outputDir);\n\n```\n\n!!! note \n     The script above is tailored to the `Storage.sol` contract. It can be adjusted for other contracts by changing the file name or modifying the ABI and bytecode paths.\n\nThe ABI (Application Binary Interface) is a JSON representation of your contract's functions, events, and their parameters. It serves as the interface between your JavaScript code and the deployed smart contract, allowing your application to know how to format function calls and interpret returned data.\n\nExecute the script above by running:\n\n```bash\nnode compile\n```\n\nAfter executing the script, the Solidity contract will be compiled into the required PolkaVM bytecode format. The ABI and bytecode will be saved into files with `.json` and `.polkavm` extensions, respectively. You can now proceed with deploying the contract to Polkadot Hub, as outlined in the next section."}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 10, "depth": 2, "title": "Deploy the Compiled Contract", "anchor": "deploy-the-compiled-contract", "start_char": 8911, "end_char": 16598, "estimated_token_count": 1604, "token_estimator": "heuristic-v1", "text": "## Deploy the Compiled Contract\n\nTo deploy your compiled contract to Polkadot Hub, you'll need a wallet with a private key to sign the deployment transaction.\n\nYou can create a `deploy.js` script in the root of your project to achieve this. The deployment script can be divided into key components:\n\n1. Set up the required imports and utilities:\n\n    ```js title=\"scripts/deploy.js\"\n    // Deploy an EVM-compatible smart contract using ethers.js\n    const { writeFileSync, existsSync, readFileSync } = require('fs');\n    const { join } = require('path');\n    const { ethers, JsonRpcProvider } = require('ethers');\n\n    const codegenDir = join(__dirname);\n    ```\n\n2. Create a provider to connect to Polkadot Hub:\n\n    ```js title=\"scripts/deploy.js\"\n\n    // Creates an Ethereum provider with specified RPC URL and chain details\n    const createProvider = (rpcUrl, chainId, chainName) => {\n      const provider = new JsonRpcProvider(rpcUrl, {\n        chainId: chainId,\n        name: chainName,\n      });\n      return provider;\n    };\n    ```\n \n3. Set up functions to read contract artifacts:\n\n    ```js title=\"scripts/deploy.js\"\n    // Reads and parses the ABI file for a given contract\n    const getAbi = (contractName) => {\n      try {\n        return JSON.parse(\n          readFileSync(join(codegenDir, `${contractName}.json`), 'utf8'),\n        );\n      } catch (error) {\n        console.error(\n          `Could not find ABI for contract ${contractName}:`,\n          error.message,\n        );\n        throw error;\n      }\n    };\n\n    // Reads the compiled bytecode for a given contract\n    const getByteCode = (contractName) => {\n      try {\n        const bytecodePath = join(\n          codegenDir,\n          '../contracts',\n          `${contractName}.polkavm`,\n        );\n        return `0x${readFileSync(bytecodePath).toString('hex')}`;\n      } catch (error) {\n        console.error(\n          `Could not find bytecode for contract ${contractName}:`,\n          error.message,\n        );\n        throw error;\n      }\n    };\n    ```\n\n4. Create the main deployment function:\n\n    ```js title=\"scripts/deploy.js\"\n\n    const deployContract = async (contractName, mnemonic, providerConfig) => {\n      console.log(`Deploying ${contractName}...`);\n\n      try {\n        // Step 1: Set up provider and wallet\n        const provider = createProvider(\n          providerConfig.rpc,\n          providerConfig.chainId,\n          providerConfig.name,\n        );\n        const walletMnemonic = ethers.Wallet.fromPhrase(mnemonic);\n        const wallet = walletMnemonic.connect(provider);\n\n        // Step 2: Create and deploy the contract\n        const factory = new ethers.ContractFactory(\n          getAbi(contractName),\n          getByteCode(contractName),\n          wallet,\n        );\n        const contract = await factory.deploy();\n        await contract.waitForDeployment();\n\n        // Step 3: Save deployment information\n        const address = await contract.getAddress();\n        console.log(`Contract ${contractName} deployed at: ${address}`);\n\n        const addressesFile = join(codegenDir, 'contract-address.json');\n        const addresses = existsSync(addressesFile)\n          ? JSON.parse(readFileSync(addressesFile, 'utf8'))\n          : {};\n        addresses[contractName] = address;\n        writeFileSync(addressesFile, JSON.stringify(addresses, null, 2), 'utf8');\n      } catch (error) {\n        console.error(`Failed to deploy contract ${contractName}:`, error);\n      }\n    };\n    ```\n\n5. Configure and execute the deployment:\n\n    ```js title=\"scripts/deploy.js\"\n    const providerConfig = {\n      rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n      chainId: 420420422,\n      name: 'polkadot-hub-testnet',\n    };\n\n    const mnemonic = 'INSERT_MNEMONIC';\n\n    deployContract('Storage', mnemonic, providerConfig);\n    ```\n\n    !!! note\n        A mnemonic (seed phrase) is a series of words that can generate multiple private keys and their corresponding addresses. It's used here to derive the wallet that will sign and pay for the deployment transaction. **Always keep your mnemonic secure and never share it publicly**.\n\n        Ensure to replace the `INSERT_MNEMONIC` placeholder with your actual mnemonic.\n\n??? code \"View complete script\"\n\n    ```js title=\"scripts/deploy.js\"\n    // Deploy an EVM-compatible smart contract using ethers.js\n    const { writeFileSync, existsSync, readFileSync } = require('fs');\n    const { join } = require('path');\n    const { ethers, JsonRpcProvider } = require('ethers');\n\n    const codegenDir = join(__dirname);\n\n    // Creates an Ethereum provider with specified RPC URL and chain details\n    const createProvider = (rpcUrl, chainId, chainName) => {\n      const provider = new JsonRpcProvider(rpcUrl, {\n        chainId: chainId,\n        name: chainName,\n      });\n      return provider;\n    };\n\n    // Reads and parses the ABI file for a given contract\n    const getAbi = (contractName) => {\n      try {\n        return JSON.parse(\n          readFileSync(join(codegenDir, `${contractName}.json`), 'utf8'),\n        );\n      } catch (error) {\n        console.error(\n          `Could not find ABI for contract ${contractName}:`,\n          error.message,\n        );\n        throw error;\n      }\n    };\n\n    // Reads the compiled bytecode for a given contract\n    const getByteCode = (contractName) => {\n      try {\n        const bytecodePath = join(\n          codegenDir,\n          '../contracts',\n          `${contractName}.polkavm`,\n        );\n        return `0x${readFileSync(bytecodePath).toString('hex')}`;\n      } catch (error) {\n        console.error(\n          `Could not find bytecode for contract ${contractName}:`,\n          error.message,\n        );\n        throw error;\n      }\n    };\n\n    const deployContract = async (contractName, mnemonic, providerConfig) => {\n      console.log(`Deploying ${contractName}...`);\n\n      try {\n        // Step 1: Set up provider and wallet\n        const provider = createProvider(\n          providerConfig.rpc,\n          providerConfig.chainId,\n          providerConfig.name,\n        );\n        const walletMnemonic = ethers.Wallet.fromPhrase(mnemonic);\n        const wallet = walletMnemonic.connect(provider);\n\n        // Step 2: Create and deploy the contract\n        const factory = new ethers.ContractFactory(\n          getAbi(contractName),\n          getByteCode(contractName),\n          wallet,\n        );\n        const contract = await factory.deploy();\n        await contract.waitForDeployment();\n\n        // Step 3: Save deployment information\n        const address = await contract.getAddress();\n        console.log(`Contract ${contractName} deployed at: ${address}`);\n\n        const addressesFile = join(codegenDir, 'contract-address.json');\n        const addresses = existsSync(addressesFile)\n          ? JSON.parse(readFileSync(addressesFile, 'utf8'))\n          : {};\n        addresses[contractName] = address;\n        writeFileSync(addressesFile, JSON.stringify(addresses, null, 2), 'utf8');\n      } catch (error) {\n        console.error(`Failed to deploy contract ${contractName}:`, error);\n      }\n    };\n\n    const providerConfig = {\n      rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n      chainId: 420420422,\n      name: 'polkadot-hub-testnet',\n    };\n\n    const mnemonic = 'INSERT_MNEMONIC';\n\n    deployContract('Storage', mnemonic, providerConfig);\n\n    ```\n\nTo run the script, execute the following command:\n\n```bash\nnode deploy\n```\n\nAfter running this script, your contract will be deployed to Polkadot Hub, and its address will be saved in `contract-address.json` within your project directory. You can use this address for future contract interactions."}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 11, "depth": 2, "title": "Interact with the Contract", "anchor": "interact-with-the-contract", "start_char": 16598, "end_char": 19859, "estimated_token_count": 712, "token_estimator": "heuristic-v1", "text": "## Interact with the Contract\n\nOnce the contract is deployed, you can interact with it by calling its functions. For example, to set a number, read it and then modify that number by its double, you can create a file named `checkStorage.js` in the root of your project and add the following code:\n\n```js title=\"scripts/checkStorage.js\"\nconst { ethers } = require('ethers');\nconst { readFileSync } = require('fs');\nconst { join } = require('path');\n\nconst createProvider = (providerConfig) => {\n  return new ethers.JsonRpcProvider(providerConfig.rpc, {\n    chainId: providerConfig.chainId,\n    name: providerConfig.name,\n  });\n};\n\nconst createWallet = (mnemonic, provider) => {\n  return ethers.Wallet.fromPhrase(mnemonic).connect(provider);\n};\n\nconst loadContractAbi = (contractName, directory = __dirname) => {\n  const contractPath = join(directory, `${contractName}.json`);\n  const contractJson = JSON.parse(readFileSync(contractPath, 'utf8'));\n  return contractJson.abi || contractJson; // Depending on JSON structure\n};\n\nconst createContract = (contractAddress, abi, wallet) => {\n  return new ethers.Contract(contractAddress, abi, wallet);\n};\n\nconst interactWithStorageContract = async (\n  contractName,\n  contractAddress,\n  mnemonic,\n  providerConfig,\n  numberToSet,\n) => {\n  try {\n    console.log(`Setting new number in Storage contract: ${numberToSet}`);\n\n    // Create provider and wallet\n    const provider = createProvider(providerConfig);\n    const wallet = createWallet(mnemonic, provider);\n\n    // Load the contract ABI and create the contract instance\n    const abi = loadContractAbi(contractName);\n    const contract = createContract(contractAddress, abi, wallet);\n\n    // Send a transaction to set the stored number\n    const tx1 = await contract.setNumber(numberToSet);\n    await tx1.wait(); // Wait for the transaction to be mined\n    console.log(`Number successfully set to ${numberToSet}`);\n\n    // Retrieve the updated number\n    const storedNumber = await contract.storedNumber();\n    console.log(`Retrieved stored number:`, storedNumber.toString());\n\n    // Send a transaction to set the stored number\n    const tx2 = await contract.setNumber(numberToSet * 2);\n    await tx2.wait(); // Wait for the transaction to be mined\n    console.log(`Number successfully set to ${numberToSet * 2}`);\n\n    // Retrieve the updated number\n    const updatedNumber = await contract.storedNumber();\n    console.log(`Retrieved stored number:`, updatedNumber.toString());\n  } catch (error) {\n    console.error('Error interacting with Storage contract:', error.message);\n  }\n};\n\nconst providerConfig = {\n  name: 'asset-hub-smart-contracts',\n  rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n  chainId: 420420422,\n};\n\nconst mnemonic = 'INSERT_MNEMONIC';\nconst contractName = 'Storage';\nconst contractAddress = 'INSERT_CONTRACT_ADDRESS';\nconst newNumber = 42;\n\ninteractWithStorageContract(\n  contractName,\n  contractAddress,\n  mnemonic,\n  providerConfig,\n  newNumber,\n);\n\n```\n\nEnsure you replace the `INSERT_MNEMONIC`, `INSERT_CONTRACT_ADDRESS`, and `INSERT_ADDRESS_TO_CHECK` placeholders with actual values. Also, ensure the contract ABI file (`Storage.json`) is correctly referenced.\n\nTo interact with the contract, run:\n\n```bash\nnode checkStorage\n```"}
{"page_id": "develop-smart-contracts-libraries-ethers-js", "page_title": "Deploy Contracts to Polkadot Hub with Ethers.js", "index": 12, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 19859, "end_char": 20464, "estimated_token_count": 155, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you have the foundational knowledge to use Ethers.js with Polkadot Hub, you can:\n\n- **Dive into Ethers.js utilities**: Discover additional Ethers.js features, such as wallet management, signing messages, etc.\n- **Implement batch transactions**: Use Ethers.js to execute batch transactions for efficient multi-step contract interactions.\n- **Build scalable applications**: Combine Ethers.js with frameworks like [`Next.js`](https://nextjs.org/docs){target=\\_blank} or [`Node.js`](https://nodejs.org/en){target=\\_blank} to create full-stack decentralized applications (dApps)."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 178, "end_char": 455, "estimated_token_count": 56, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[viem](https://viem.sh/){target=\\_blank} is a lightweight TypeScript library designed for interacting with Ethereum-compatible blockchains. This comprehensive guide will walk you through using viem to interact with and deploy smart contracts to Polkadot Hub."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 455, "end_char": 811, "estimated_token_count": 110, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have the following installed:\n\n- **Node.js**: v22.13.1 or later, check the [Node.js installation guide](https://nodejs.org/en/download/current/){target=\\_blank}.\n- **npm**: v6.13.4 or later (comes bundled with Node.js).\n- **Solidity**: This guide uses Solidity `^0.8.9` for smart contract development."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 2, "depth": 2, "title": "Project Structure", "anchor": "project-structure", "start_char": 811, "end_char": 1231, "estimated_token_count": 119, "token_estimator": "heuristic-v1", "text": "## Project Structure\n\nThis project organizes contracts, scripts, and compiled artifacts for easy development and deployment.\n\n```text\nviem-project/\n├── package.json\n├── tsconfig.json\n├── src/\n│   ├── chainConfig.ts\n│   ├── createClient.ts\n│   ├── createWallet.ts\n│   ├── compile.ts\n│   ├── deploy.ts\n│   └── interact.ts\n├── contracts/\n│   └── Storage.sol\n└── artifacts/\n    ├── Storage.json\n    └── Storage.polkavm\n```"}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 3, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 1231, "end_char": 1371, "estimated_token_count": 36, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nFirst, create a new folder and initialize your project:\n\n```bash\nmkdir viem-project\ncd viem-project\nnpm init -y\n```"}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 4, "depth": 2, "title": "Install Dependencies", "anchor": "install-dependencies", "start_char": 1371, "end_char": 1863, "estimated_token_count": 121, "token_estimator": "heuristic-v1", "text": "## Install Dependencies\n\nInstall viem along with other necessary dependencies, including [@parity/resolc](https://www.npmjs.com/package/@parity/resolc){target=\\_blank}, which enables to compile smart contracts to [PolkaVM](/polkadot-protocol/smart-contract-basics/polkavm-design/#polkavm){target=\\_blank} bytecode:\n\n```bash\n# Install viem and resolc\nnpm install viem @parity/resolc\n\n# Install TypeScript and development dependencies\nnpm install --save-dev typescript ts-node @types/node\n```"}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 5, "depth": 2, "title": "Initialize Project", "anchor": "initialize-project", "start_char": 1863, "end_char": 2373, "estimated_token_count": 137, "token_estimator": "heuristic-v1", "text": "## Initialize Project\n\nInitialize a TypeScript project by running the following command:\n\n```bash\nnpx tsc --init\n```\n\nAdd the following scripts to your `package.json` file to enable running TypeScript files:\n\n```json\n{\n    \"scripts\": {\n        \"client\": \"ts-node src/createClient.ts\",\n        \"compile\": \"ts-node src/compile.ts\",\n        \"deploy\": \"ts-node src/deploy.ts\",\n        \"interact\": \"ts-node src/interact.ts\"\n    },\n}\n```\n\nCreate a directory for your TypeScript source files:\n\n```bash\nmkdir src\n```"}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 6, "depth": 2, "title": "Set Up the Chain Configuration", "anchor": "set-up-the-chain-configuration", "start_char": 2373, "end_char": 3347, "estimated_token_count": 210, "token_estimator": "heuristic-v1", "text": "## Set Up the Chain Configuration\n\nThe first step is to set up the chain configuration. Create a new file at `src/chainConfig.ts`:\n\n```typescript title=\"src/chainConfig.ts\"\nimport { http } from 'viem';\n\nexport const TRANSPORT = http('INSERT_RPC_URL');\n\n// Configure the Polkadot Hub chain\nexport const POLKADOT_HUB = {\n  id: INSERT_CHAIN_ID,\n  name: 'INSERT_CHAIN_NAME',\n  network: 'INSERT_NETWORK_NAME',\n  nativeCurrency: {\n    decimals: INSERT_CHAIN_DECIMALS,\n    name: 'INSERT_CURRENCY_NAME',\n    symbol: 'INSERT_CURRENCY_SYMBOL',\n  },\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n} as const;\n```\n\nEnsure to replace `INSERT_RPC_URL`, `INSERT_CHAIN_ID`, `INSERT_CHAIN_NAME`, `INSERT_NETWORK_NAME`, `INSERT_CHAIN_DECIMALS`, `INSERT_CURRENCY_NAME`, and `INSERT_CURRENCY_SYMBOL` with the proper values. Check the [Connect to Polkadot](/develop/smart-contracts/connect-to-polkadot){target=\\_blank} page for more information on the possible values."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 7, "depth": 2, "title": "Set Up the viem Client", "anchor": "set-up-the-viem-client", "start_char": 3347, "end_char": 5463, "estimated_token_count": 483, "token_estimator": "heuristic-v1", "text": "## Set Up the viem Client\n\nTo interact with the chain, you need to create a client that is used solely for reading data. To accomplish this, create a new file at `src/createClient.ts`:\n\n```typescript title=\"src/createClient.ts\"\nimport { createPublicClient, createWalletClient, http } from 'viem';\n\nconst transport = http('INSERT_RPC_URL');\n\n// Configure the Polkadot Hub chain\nconst assetHub = {\n  id: INSERT_CHAIN_ID,\n  name: 'INSERT_CHAIN_NAME',\n  network: 'INSERT_NETWORK_NAME',\n  nativeCurrency: {\n    decimals: INSERT_CHAIN_DECIMALS,\n    name: 'INSERT_CURRENCY_NAME',\n    symbol: 'INSERT_CURRENCY_SYMBOL',\n  },\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n} as const;\n\n// Create a public client for reading data\nexport const publicClient = createPublicClient({\n  chain: assetHub,\n  transport,\n});\n\n```\n\nAfter setting up the [Public Client](https://viem.sh/docs/clients/public#public-client){target=\\_blank}, you can begin querying the blockchain. Here's an example of fetching the latest block number:\n\n??? code \"Fetch Last Block code\"\n\n    ```js title=\"src/fetchLastBlock.ts\"\n    import { createPublicClient, http } from 'viem';\n\n    const transport = http('https://testnet-passet-hub-eth-rpc.polkadot.io');\n\n    // Configure the Polkadot Hub chain\n    const polkadotHubTestnet = {\n      id: 420420422,\n      name: 'Polkadot Hub TestNet',\n      network: 'polkadot-hub-testnet',\n      nativeCurrency: {\n        decimals: 18,\n        name: 'PAS',\n        symbol: 'PAS',\n      },\n      rpcUrls: {\n        default: {\n          http: ['https://testnet-passet-hub-eth-rpc.polkadot.io'],\n        },\n      },\n    } as const;\n\n    // Create a public client for reading data\n    export const publicClient = createPublicClient({\n      chain: polkadotHubTestnet,\n      transport,\n    });\n\n    const main = async () => {\n      try {\n        const block = await publicClient.getBlock();\n        console.log('Last block: ' + block.number.toString());\n      } catch (error: unknown) {\n        console.error('Error connecting to Polkadot Hub TestNet: ' + error);\n      }\n    };\n\n    main();\n    ```"}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 8, "depth": 2, "title": "Set Up a Wallet", "anchor": "set-up-a-wallet", "start_char": 5463, "end_char": 6820, "estimated_token_count": 299, "token_estimator": "heuristic-v1", "text": "## Set Up a Wallet\n\nIn case you need to sign transactions, you will need to instantiate a [Wallet Client](https://viem.sh/docs/clients/wallet#wallet-client){target=\\_blank} object within your project. To do so, create `src/createWallet.ts`:\n\n```typescript title=\"src/createWallet.ts\"\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { createWalletClient, http } from 'viem';\n\nconst transport = http('INSERT_RPC_URL');\n\n// Configure the Polkadot Hub chain\nconst assetHub = {\n  id: INSERT_CHAIN_ID,\n  name: 'INSERT_CHAIN_NAME',\n  network: 'INSERT_NETWORK_NAME',\n  nativeCurrency: {\n    decimals: INSERT_CHAIN_DECIMALS,\n    name: 'INSERT_CURRENCY_NAME',\n    symbol: 'INSERT_CURRENCY_SYMBOL',\n  },\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n    public: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n} as const;\n\n// Create a wallet client for writing data\nexport const createWallet = (privateKey: `0x${string}`) => {\n  const account = privateKeyToAccount(privateKey);\n  return createWalletClient({\n    account,\n    chain: assetHub,\n    transport,\n  });\n};\n```\n\n!!!note\n    The wallet you import with your private key must have sufficient funds to pay for transaction fees when deploying contracts or interacting with them. Make sure to fund your wallet with the appropriate native tokens for the network you're connecting to."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 9, "depth": 2, "title": "Sample Smart Contract", "anchor": "sample-smart-contract", "start_char": 6820, "end_char": 7801, "estimated_token_count": 204, "token_estimator": "heuristic-v1", "text": "## Sample Smart Contract\n\nThis example demonstrates compiling a `Storage.sol` Solidity contract for deployment to Polkadot Hub. The contract's functionality stores a number and permits users to update it with a new value.\n\n```bash\nmkdir contracts artifacts\n```\n\nYou can use the following contract to interact with the blockchain. Paste the following contract in `contracts/Storage.sol`:\n\n```solidity title=\"contracts/Storage.sol\"\n//SPDX-License-Identifier: MIT\n\n// Solidity files have to start with this pragma.\n// It will be used by the Solidity compiler to validate its version.\npragma solidity ^0.8.9;\n\ncontract Storage {\n    // Public state variable to store a number\n    uint256 public storedNumber;\n\n    /**\n    * Updates the stored number.\n    *\n    * The `public` modifier allows anyone to call this function.\n    *\n    * @param _newNumber - The new value to store.\n    */\n    function setNumber(uint256 _newNumber) public {\n        storedNumber = _newNumber;\n    }\n}\n```"}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 10, "depth": 2, "title": "Compile the Contract", "anchor": "compile-the-contract", "start_char": 7801, "end_char": 10525, "estimated_token_count": 621, "token_estimator": "heuristic-v1", "text": "## Compile the Contract\n\n!!! note \"Contracts Code Blob Size Disclaimer\"\n    The maximum contract code blob size on Polkadot Hub networks is _100 kilobytes_, significantly larger than Ethereum’s EVM limit of 24 kilobytes.\n\n    For detailed comparisons and migration guidelines, see the [EVM vs. PolkaVM](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm/#current-memory-limits){target=\\_blank} documentation page.\n\nCreate a new file at `src/compile.ts` for handling contract compilation:\n\n```typescript title=\"src/compile.ts\"\nimport { compile } from '@parity/resolc';\nimport { readFileSync, writeFileSync } from 'fs';\nimport { basename, join } from 'path';\n\nconst compileContract = async (\n  solidityFilePath: string,\n  outputDir: string\n): Promise<void> => {\n  try {\n    // Read the Solidity file\n    const source: string = readFileSync(solidityFilePath, 'utf8');\n\n    // Construct the input object for the compiler\n    const input: Record<string, { content: string }> = {\n      [basename(solidityFilePath)]: { content: source },\n    };\n\n    console.log(`Compiling contract: ${basename(solidityFilePath)}...`);\n\n    // Compile the contract\n    const out = await compile(input);\n\n    for (const contracts of Object.values(out.contracts)) {\n      for (const [name, contract] of Object.entries(contracts)) {\n        console.log(`Compiled contract: ${name}`);\n\n        // Write the ABI\n        const abiPath = join(outputDir, `${name}.json`);\n        writeFileSync(abiPath, JSON.stringify(contract.abi, null, 2));\n        console.log(`ABI saved to ${abiPath}`);\n\n        // Write the bytecode\n        if (\n          contract.evm &&\n          contract.evm.bytecode &&\n          contract.evm.bytecode.object\n        ) {\n          const bytecodePath = join(outputDir, `${name}.polkavm`);\n          writeFileSync(\n            bytecodePath,\n            Buffer.from(contract.evm.bytecode.object, 'hex')\n          );\n          console.log(`Bytecode saved to ${bytecodePath}`);\n        } else {\n          console.warn(`No bytecode found for contract: ${name}`);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Error compiling contracts:', error);\n  }\n};\n\nconst solidityFilePath: string = './contracts/Storage.sol';\nconst outputDir: string = './artifacts/';\n\ncompileContract(solidityFilePath, outputDir);\n```\n\nTo compile your contract:\n\n```bash\nnpm run compile\n```\n\nAfter executing this script, you will see the compilation results including the generated `Storage.json` (containing the contract's ABI) and `Storage.polkavm` (containing the compiled bytecode) files in the `artifacts` folder. These files contain all the necessary information for deploying and interacting with your smart contract on Polkadot Hub."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 11, "depth": 2, "title": "Deploy the Contract", "anchor": "deploy-the-contract", "start_char": 10525, "end_char": 12710, "estimated_token_count": 504, "token_estimator": "heuristic-v1", "text": "## Deploy the Contract\n\nCreate a new file at `src/deploy.ts` for handling contract deployment:\n\n```typescript title=\"src/deploy.ts\"\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport { createWallet } from './createWallet';\nimport { publicClient } from './createClient';\n\nconst deployContract = async (\n  contractName: string,\n  privateKey: `0x${string}`\n) => {\n  try {\n    console.log(`Deploying ${contractName}...`);\n\n    // Read contract artifacts\n    const abi = JSON.parse(\n      readFileSync(\n        join(__dirname, '../artifacts', `${contractName}.json`),\n        'utf8'\n      )\n    );\n    const bytecode = `0x${readFileSync(\n      join(__dirname, '../artifacts', `${contractName}.polkavm`)\n    ).toString('hex')}` as `0x${string}`;\n\n    // Create wallet\n    const wallet = createWallet(privateKey);\n\n    // Deploy contract\n    const hash = await wallet.deployContract({\n      abi,\n      bytecode,\n      args: [], // Add constructor arguments if needed\n    });\n\n    // Wait for deployment\n    const receipt = await publicClient.waitForTransactionReceipt({ hash });\n    const contractAddress = receipt.contractAddress;\n\n    console.log(`Contract deployed at: ${contractAddress}`);\n    return contractAddress;\n  } catch (error) {\n    console.error('Deployment failed:', error);\n    throw error;\n  }\n};\n\nconst privateKey = 'INSERT_PRIVATE_KEY';\ndeployContract('Storage', privateKey);\n```\n\nEnsure to replace `INSERT_PRIVATE_KEY` with the proper value. For further details on private key exportation, refer to the article [How to export an account's private key](https://support.metamask.io/configure/accounts/how-to-export-an-accounts-private-key/){target=\\_blank}.\n\n!!! warning\n    Never commit or share your private key. Exposed keys can lead to immediate theft of all associated funds. Use environment variables instead.\n\nTo deploy, run the following command:\n\n```bash\nnpm run deploy\n```\n\nIf everything is successful, you will see the address of your deployed contract displayed in the terminal. This address is unique to your contract on the network you defined in the chain configuration, and you'll need it for any future interactions with your contract."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 12, "depth": 2, "title": "Interact with the Contract", "anchor": "interact-with-the-contract", "start_char": 12710, "end_char": 14876, "estimated_token_count": 455, "token_estimator": "heuristic-v1", "text": "## Interact with the Contract\n\nCreate a new file at `src/interact.ts` for interacting with your deployed contract:\n\n```typescript title=\"src/interact.ts\"\nimport { publicClient } from './createClient';\nimport { createWallet } from './createWallet';\nimport { readFileSync } from 'fs';\n\nconst STORAGE_ABI = JSON.parse(\n  readFileSync('./artifacts/Storage.json', 'utf8')\n);\n\nconst interactWithStorage = async (\n  contractAddress: `0x${string}`,\n  privateKey: `0x${string}`\n) => {\n  try {\n    const wallet = createWallet(privateKey);\n    const currentNumber = await publicClient.readContract({\n      address: contractAddress,\n      abi: STORAGE_ABI,\n      functionName: 'storedNumber',\n      args: [],\n    });\n    console.log(`Stored number: ${currentNumber}`);\n\n    const newNumber = BigInt(42);\n    const { request } = await publicClient.simulateContract({\n      address: contractAddress,\n      abi: STORAGE_ABI,\n      functionName: 'setNumber',\n      args: [newNumber],\n      account: wallet.account,\n    });\n\n    const hash = await wallet.writeContract(request);\n    await publicClient.waitForTransactionReceipt({ hash });\n    console.log(`Number updated to ${newNumber}`);\n\n    const updatedNumber = await publicClient.readContract({\n      address: contractAddress,\n      abi: STORAGE_ABI,\n      functionName: 'storedNumber',\n      args: [],\n    });\n    console.log('Updated stored number:', updatedNumber);\n  } catch (error) {\n    console.error('Interaction failed:', error);\n  }\n};\n\nconst PRIVATE_KEY = 'INSERT_PRIVATE_KEY';\nconst CONTRACT_ADDRESS = 'INSERT_CONTRACT_ADDRESS';\n\ninteractWithStorage(CONTRACT_ADDRESS, PRIVATE_KEY);\n\n```\n\nEnsure to replace `INSERT_PRIVATE_KEY` and `INSERT_CONTRACT_ADDRESS` with the proper values.\n\nTo interact with the contract:\n\n```bash\nnpm run interact\n```\n\nFollowing a successful interaction, you will see the stored value before and after the transaction. The output will show the initial stored number (0 if you haven't modified it yet), confirm when the transaction to set the number to 42 is complete, and then display the updated stored number value. This demonstrates both reading from and writing to your smart contract."}
{"page_id": "develop-smart-contracts-libraries-viem", "page_title": "viem for Polkadot Hub Smart Contracts", "index": 13, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 14876, "end_char": 16645, "estimated_token_count": 545, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you have the foundation for using viem with Polkadot Hub, consider exploring:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge external\">External</span> __Advanced viem Features__\n\n    ---\n    Explore viem's documentation:\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Multi call](https://viem.sh/docs/contract/multicall#multicall){target=\\_blank}</li>\n\n    <li>[:octicons-arrow-right-24: Batch transactions](https://viem.sh/docs/clients/transports/http#batch-json-rpc){target=\\_blank}</li>\n\n    <li>[:octicons-arrow-right-24: Custom actions](https://viem.sh/docs/clients/custom#extending-with-actions-or-configuration){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Test Frameworks__\n\n    ---\n\n    Integrate viem with the following frameworks for comprehensive testing:\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Hardhat](https://hardhat.org/){target=\\_blank}</li>\n\n    <li>[:octicons-arrow-right-24: Foundry](https://getfoundry.sh/){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Event Handling__\n\n    ---\n\n    Learn how to subscribe to and process contract events:\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Event subscription](https://viem.sh/docs/actions/public/watchEvent#watchevent){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Building dApps__\n\n    ---\n\n    Combine viem the following technologies to create full-stack applications:\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Next.js](https://nextjs.org/docs){target=\\_blank}</li>\n\n    <li>[:octicons-arrow-right-24: Node.js](https://nodejs.org/en){target=\\_blank}</li>\n    </ul>\n\n</div>"}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 179, "end_char": 607, "estimated_token_count": 97, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[Wagmi](https://wagmi.sh/){target=\\_blank} is a collection of [React Hooks](https://wagmi.sh/react/api/hooks){target=\\_blank} for interacting with Ethereum-compatible blockchains, focusing on developer experience, feature richness, and reliability.\n\nThis guide demonstrates how to use Wagmi to interact with and deploy smart contracts to Polkadot Hub, providing a seamless frontend integration for your dApps."}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 1, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 607, "end_char": 875, "estimated_token_count": 65, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nTo start working with Wagmi, create a new React project and initialize it by running the following commands in your terminal:\n\n```bash\n# Create a new React project using Next.js\nnpx create-next-app@latest wagmi-asset-hub\ncd wagmi-asset-hub\n```"}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 2, "depth": 2, "title": "Install Dependencies", "anchor": "install-dependencies", "start_char": 875, "end_char": 1037, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Install Dependencies\n\nInstall Wagmi and its peer dependencies:\n\n```bash\n# Install Wagmi and its dependencies\nnpm install wagmi viem @tanstack/react-query\n```"}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 3, "depth": 2, "title": "Configure Wagmi for Polkadot Hub", "anchor": "configure-wagmi-for-polkadot-hub", "start_char": 1037, "end_char": 2725, "estimated_token_count": 381, "token_estimator": "heuristic-v1", "text": "## Configure Wagmi for Polkadot Hub\n\nCreate a configuration file to initialize Wagmi with Polkadot Hub. In your project, create a file named `src/lib/wagmi.ts` and add the code below. Be sure to replace `INSERT_RPC_URL`, `INSERT_CHAIN_ID`, `INSERT_CHAIN_NAME`, `INSERT_NETWORK_NAME`, `INSERT_CHAIN_DECIMALS`, `INSERT_CURRENCY_NAME`, and `INSERT_CURRENCY_SYMBOL` with your specific values.\n\n```typescript title=\"src/lib/wagmi.ts\"\nimport { http, createConfig } from 'wagmi'\n\n// Configure the Polkadot Hub chain\nconst assetHub = {\n  id: INSERT_CHAIN_ID,\n  name: 'INSERT_CHAIN_NAME',\n  network: 'INSERT_NETWORK_NAME',\n  nativeCurrency: {\n    decimals: INSERT_CHAIN_DECIMALS,\n    name: 'INSERT_CURRENCY_NAME',\n    symbol: 'INSERT_CURRENCY_SYMBOL',\n  },\n  rpcUrls: {\n    default: {\n      http: ['INSERT_RPC_URL'],\n    },\n  },\n} as const;\n\n// Create Wagmi config\nexport const config = createConfig({\n  chains: [assetHub],\n  transports: {\n    [assetHub.id]: http(),\n  },\n})\n```\n\n??? code \"Example Polkadot Hub TestNet Configuration\"\n\n    ```typescript title=\"src/lib/wagmi.ts\"\n    import { http, createConfig } from 'wagmi';\n\n    // Configure the Polkadot Hub chain\n    const assetHub = {\n      id: 420420422,\n      name: 'polkadot-hub-testnet',\n      network: 'polkadot-hub-testnet',\n      nativeCurrency: {\n        decimals: 18,\n        name: 'PAS',\n        symbol: 'PAS',\n      },\n      rpcUrls: {\n        default: {\n          http: ['https://testnet-passet-hub-eth-rpc.polkadot.io'],\n        },\n      },\n    } as const;\n\n    // Create wagmi config\n    export const config = createConfig({\n      chains: [assetHub],\n      transports: {\n        [assetHub.id]: http(),\n      },\n    });\n    ```"}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 4, "depth": 2, "title": "Set Up the Wagmi Provider", "anchor": "set-up-the-wagmi-provider", "start_char": 2725, "end_char": 3769, "estimated_token_count": 263, "token_estimator": "heuristic-v1", "text": "## Set Up the Wagmi Provider\n\nTo enable Wagmi in your React application, you need to wrap your app with the [`WagmiProvider`](https://wagmi.sh/react/api/WagmiProvider#wagmiprovider){target=\\_blank}. Update your `app/layout.tsx` file (for Next.js app router) with the following code:\n\n```typescript title=\"app/layout.tsx\"\n// For app router (src/app/layout.tsx)\n\"use client\";\n\nimport { WagmiProvider } from \"wagmi\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { config } from \"./lib/wagmi\";\n\n// Create a query client\nconst queryClient = new QueryClient();\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <WagmiProvider config={config}>\n          <QueryClientProvider client={queryClient}>\n            {children}\n          </QueryClientProvider>\n        </WagmiProvider>\n      </body>\n    </html>\n  );\n}\n\n```\n\n!!!note\n    If you are using a Next.js pages router, you should modify the `src/pages/_app.tsx` instead."}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 5, "depth": 2, "title": "Connect a Wallet", "anchor": "connect-a-wallet", "start_char": 3769, "end_char": 5220, "estimated_token_count": 367, "token_estimator": "heuristic-v1", "text": "## Connect a Wallet\n\nCreate a component to connect wallets to your dApp. Create a file named `app/components/ConnectWallet.tsx`:\n\n```typescript title=\"app/components/ConnectWallet.tsx\"\n\"use client\";\n\nimport React from \"react\";\nimport { useConnect, useAccount, useDisconnect } from \"wagmi\";\nimport { injected } from \"wagmi/connectors\";\n\nexport function ConnectWallet() {\n  const { connect } = useConnect();\n  const { address, isConnected } = useAccount();\n  const { disconnect } = useDisconnect();\n\n  if (isConnected) {\n    return (\n      <div>\n        <div>Connected to {address}</div>\n        <button onClick={() => disconnect()}>Disconnect</button>\n      </div>\n    );\n  }\n\n  return (\n    <button onClick={() => connect({ connector: injected() })}>\n      Connect Wallet\n    </button>\n  );\n}\n\n```\n\nThis component uses the following React hooks:\n\n- **[`useConnect`](https://wagmi.sh/react/api/hooks/useConnect#useconnect){target=\\_blank}**: Provides functions and state for connecting the user's wallet to your dApp. The `connect` function initiates the connection flow with the specified connector.\n- **[`useDisconnect`](https://wagmi.sh/react/api/hooks/useDisconnect#usedisconnect){target=\\_blank}**: Provides a function to disconnect the currently connected wallet.\n- **[`useAccount`](https://wagmi.sh/react/api/hooks/useAccount#useaccount){target=\\_blank}**: Returns data about the connected account, including the address and connection status."}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 6, "depth": 2, "title": "Fetch Blockchain Data", "anchor": "fetch-blockchain-data", "start_char": 5220, "end_char": 6700, "estimated_token_count": 359, "token_estimator": "heuristic-v1", "text": "## Fetch Blockchain Data\n\nWagmi provides various hooks to fetch blockchain data. Here's an example component that demonstrates some of these hooks:\n\n```typescript title=\"app/components/BlockchainInfo.tsx\"\n\"use client\";\n\nimport { useBlockNumber, useBalance, useAccount } from \"wagmi\";\n\nexport function BlockchainInfo() {\n  const { address } = useAccount();\n  // Get the latest block number\n  const { data: blockNumber } = useBlockNumber({ watch: true });\n\n  // Get balance for the connected wallet\n  const { data: balance } = useBalance({\n    address,\n  });\n\n  return (\n    <div>\n      <h2>Blockchain Information</h2>\n      <div>\n        <p>Current Block: {blockNumber?.toString() || \"Loading...\"}</p>\n\n        {address && balance && (\n          <p>\n            Balance:{\" \"}\n            {(\n              BigInt(balance.value) / BigInt(10 ** balance.decimals)\n            ).toLocaleString()}{\" \"}\n            {balance.symbol}\n          </p>\n        )}\n      </div>\n    </div>\n  );\n}\n\n```\n\nThis component uses the following React hooks:\n\n- **[`useBlockNumber`](https://wagmi.sh/react/api/hooks/useBlockNumber#useBlockNumber){target=\\_blank}**: Fetches the current block number of the connected chain. The `watch` parameter enables real-time updates when new blocks are mined.\n- **[`useBalance`](https://wagmi.sh/react/api/hooks/useBalance#useBalance){target=\\_blank}**: Retrieves the native token balance for a specified address, including value, symbol, and decimals information."}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 7, "depth": 2, "title": "Interact with Deployed Contract", "anchor": "interact-with-deployed-contract", "start_char": 6700, "end_char": 11209, "estimated_token_count": 989, "token_estimator": "heuristic-v1", "text": "## Interact with Deployed Contract\n\nThis guide uses a simple Storage contract already deployed to the Polkadot Hub TestNet (`0x58053f0e8ede1a47a1af53e43368cd04ddcaf66f`). The code of that contract is:\n\n??? code \"Storage.sol\"\n\n    ```solidity title=\"Storage.sol\"\n    //SPDX-License-Identifier: MIT\n\n    // Solidity files have to start with this pragma.\n    // It will be used by the Solidity compiler to validate its version.\n    pragma solidity ^0.8.9;\n\n    contract Storage {\n        // Public state variable to store a number\n        uint256 public storedNumber;\n\n        /**\n        * Updates the stored number.\n        *\n        * The `public` modifier allows anyone to call this function.\n        *\n        * @param _newNumber - The new value to store.\n        */\n        function setNumber(uint256 _newNumber) public {\n            storedNumber = _newNumber;\n        }\n    }\n    ```\n\nCreate a component to interact with your deployed contract. Create a file named `app/components/StorageContract.tsx`:\n\n```typescript title=\"app/components/StorageContract.tsx\"\n\"use client\";\n\nimport { useState } from \"react\";\nimport {\n  useReadContract,\n  useWriteContract,\n  useWaitForTransactionReceipt,\n} from \"wagmi\";\n\nconst CONTRACT_ADDRESS =\n  \"0xabBd46Ef74b88E8B1CDa49BeFb5057710443Fd29\" as `0x${string}`;\n\nexport function StorageContract() {\n  const [number, setNumber] = useState<string>(\"42\");\n\n  // Contract ABI (should match your compiled contract)\n  const abi = [\n    {\n      inputs: [],\n      name: \"storedNumber\",\n      outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n      stateMutability: \"view\",\n      type: \"function\",\n    },\n    {\n      inputs: [\n        { internalType: \"uint256\", name: \"_newNumber\", type: \"uint256\" },\n      ],\n      name: \"setNumber\",\n      outputs: [],\n      stateMutability: \"nonpayable\",\n      type: \"function\",\n    },\n  ];\n\n  // Read the current stored number\n  const { data: storedNumber, refetch } = useReadContract({\n    address: CONTRACT_ADDRESS,\n    abi,\n    functionName: \"storedNumber\",\n  });\n\n  // Write to the contract\n  const { writeContract, data: hash, error, isPending } = useWriteContract();\n\n  // Wait for transaction to be mined\n  const { isLoading: isConfirming, isSuccess: isConfirmed } =\n    useWaitForTransactionReceipt({\n      hash,\n    });\n\n  const handleSetNumber = () => {\n    writeContract({\n      address: CONTRACT_ADDRESS,\n      abi,\n      functionName: \"setNumber\",\n      args: [BigInt(number)],\n    });\n  };\n\n  return (\n    <div>\n      <h2>Storage Contract Interaction</h2>\n      <div>\n        <p>Contract Address: {CONTRACT_ADDRESS}</p>\n        <p>Current Stored Number: {storedNumber?.toString() || \"Loading...\"}</p>\n      </div>\n\n      <div>\n        <input\n          type=\"number\"\n          value={number}\n          onChange={(e) => setNumber(e.target.value)}\n          disabled={isPending || isConfirming}\n        />\n        <button onClick={handleSetNumber} disabled={isPending || isConfirming}>\n          {isPending\n            ? \"Waiting for approval...\"\n            : isConfirming\n            ? \"Confirming...\"\n            : \"Set Number\"}\n        </button>\n      </div>\n\n      {error && <div className=\"error-message\">Error: {error.message}</div>}\n\n      {isConfirmed && (\n        <div className=\"success-message\">\n          Successfully updated!{\" \"}\n          <button onClick={() => refetch()}>Refresh</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\n```\n\nThis component demonstrates how to interact with a smart contract using Wagmi's hooks:\n\n- **[`useReadContract`](https://wagmi.sh/react/api/hooks/useReadContract#useReadContract){target=\\_blank}**: Calls a read-only function on your smart contract to retrieve data without modifying the blockchain state.\n- **[`useWriteContract`](https://wagmi.sh/react/api/hooks/useWriteContract#useWriteContract){target=\\_blank}**: Calls a state-modifying function on your smart contract, which requires a transaction to be signed and sent.\n- **[`useWaitForTransactionReceipt`](https://wagmi.sh/react/api/hooks/useWaitForTransactionReceipt#useWaitForTransactionReceipt){target=\\_blank}**: Tracks the status of a transaction after it's been submitted, allowing you to know when it's been confirmed.\n\nThe component also includes proper state handling to:\n\n- Show the current value stored in the contract.\n- Allow users to input a new value.\n- Display transaction status (pending, confirming, or completed).\n- Handle errors.\n- Provide feedback when a transaction is successful."}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 8, "depth": 2, "title": "Integrate Components", "anchor": "integrate-components", "start_char": 11209, "end_char": 11961, "estimated_token_count": 183, "token_estimator": "heuristic-v1", "text": "## Integrate Components\n\nUpdate your main page to combine all the components. Create or update the file `src/app/page.tsx`:\n\n```typescript title=\"src/app/page.tsx\"\n\"use client\";\n\nimport { BlockchainInfo } from \"./components/BlockchainInfo\";\nimport { ConnectWallet } from \"./components/ConnectWallet\";\nimport { StorageContract } from \"./components/StorageContract\";\nimport { useAccount } from \"wagmi\";\n\nexport default function Home() {\n  const { isConnected } = useAccount();\n\n  return (\n    <main>\n      <h1>Wagmi - Polkadot Hub Smart Contracts</h1>\n      <ConnectWallet />\n      {isConnected ? <BlockchainInfo /> : <span>Connect your wallet</span>}\n      {isConnected ? <StorageContract /> : <span>Connect your wallet</span>}\n    </main>\n  );\n}\n\n```"}
{"page_id": "develop-smart-contracts-libraries-wagmi", "page_title": "Wagmi for Polkadot Hub Smart Contracts", "index": 9, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 11961, "end_char": 13604, "estimated_token_count": 512, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you have the foundational knowledge to use Wagmi with Polkadot Hub, consider exploring:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge external\">External</span> __Advanced Wagmi__\n\n    ---\n\n    Explore Wagmi's advanced features:\n\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Watch Contract Events](https://wagmi.sh/core/api/actions/watchContractEvent#eventname){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Different Transports](https://wagmi.sh/react/api/transports){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Actions](https://wagmi.sh/react/api/actions){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Wallet Integration__\n\n    ---\n\n    Connect your dApp with popular wallet providers:\n\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: MetaMask](https://wagmi.sh/core/api/connectors/metaMask){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: WalletConnect](https://wagmi.sh/core/api/connectors/walletConnect){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Coinbase Wallet](https://wagmi.sh/core/api/connectors/coinbaseWallet){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Testing & Development__\n\n    ---\n\n    Enhance your development workflow:\n\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Test Suite](https://wagmi.sh/dev/contributing#_6-running-the-test-suite){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Dev Playground](https://wagmi.sh/dev/contributing#_5-running-the-dev-playgrounds){target=\\_blank}</li>\n    </ul>\n</div>"}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 537, "end_char": 1096, "estimated_token_count": 102, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nInteracting with blockchains typically requires an interface between your application and the network. [Web3.js](https://web3js.readthedocs.io/){target=\\_blank} offers this interface through a comprehensive collection of libraries, facilitating seamless interaction with the nodes using HTTP or WebSocket protocols. This guide illustrates how to utilize Web3.js specifically for interactions with Polkadot Hub.\n\nThis guide is intended for developers who are familiar with JavaScript and want to interact with the Polkadot Hub using Web3.js."}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1096, "end_char": 1452, "estimated_token_count": 110, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have the following installed:\n\n- **Node.js**: v22.13.1 or later, check the [Node.js installation guide](https://nodejs.org/en/download/current/){target=\\_blank}.\n- **npm**: v6.13.4 or later (comes bundled with Node.js).\n- **Solidity**: This guide uses Solidity `^0.8.9` for smart contract development."}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 2, "depth": 2, "title": "Project Structure", "anchor": "project-structure", "start_char": 1452, "end_char": 1937, "estimated_token_count": 136, "token_estimator": "heuristic-v1", "text": "## Project Structure\n\nThis project organizes contracts, scripts, and compiled artifacts for easy development and deployment.\n\n```text title=\"Web3.js Polkadot Hub\"\nweb3js-project\n├── contracts\n│   ├── Storage.sol\n├── scripts\n│   ├── connectToProvider.js\n│   ├── fetchLastBlock.js\n│   ├── compile.js\n│   ├── deploy.js\n│   ├── updateStorage.js\n├── abis\n│   ├── Storage.json\n├── artifacts\n│   ├── Storage.polkavm\n├── node_modules/\n├── package.json\n├── package-lock.json\n└── README.md\n```"}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 3, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 1937, "end_char": 2053, "estimated_token_count": 31, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nTo start working with Web3.js, begin by initializing your project:\n\n```bash\nnpm init -y\n```"}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 4, "depth": 2, "title": "Install Dependencies", "anchor": "install-dependencies", "start_char": 2053, "end_char": 2186, "estimated_token_count": 38, "token_estimator": "heuristic-v1", "text": "## Install Dependencies\n\nNext, install the Web3.js library:\n\n```bash\nnpm install web3\n```\n\nThis guide uses `web3` version `4.16.0`."}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 5, "depth": 2, "title": "Set Up the Web3 Provider", "anchor": "set-up-the-web3-provider", "start_char": 2186, "end_char": 4019, "estimated_token_count": 425, "token_estimator": "heuristic-v1", "text": "## Set Up the Web3 Provider\n\nThe provider configuration is the foundation of any Web3.js application. The following example establishes a connection to Polkadot Hub. To use the example script, replace `INSERT_RPC_URL`, `INSERT_CHAIN_ID`, and `INSERT_CHAIN_NAME` with the appropriate values. The provider connection script should look something like this:\n\n```javascript title=\"scripts/connectToProvider.js\"\nconst { Web3 } = require('web3');\n\nconst createProvider = (rpcUrl) => {\n  const web3 = new Web3(rpcUrl);\n  return web3;\n};\n\nconst PROVIDER_RPC = {\n  rpc: 'INSERT_RPC_URL',\n  chainId: 'INSERT_CHAIN_ID',\n  name: 'INSERT_CHAIN_NAME',\n};\n\ncreateProvider(PROVIDER_RPC.rpc);\n\n```\n\nFor example, for the Polkadot Hub TestNet, use these specific connection parameters:\n\n```js\nconst PROVIDER_RPC = {\n  rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n  chainId: 420420422,\n  name: 'polkadot-hub-testnet'\n};\n```\n\nWith the Web3 provider set up, you can start querying the blockchain.\n\nFor instance, to fetch the latest block number of the chain, you can use the following code snippet:\n\n???+ code \"View complete script\"\n\n    ```javascript title=\"scripts/fetchLastBlock.js\"\n    const { Web3 } = require('web3');\n\n    const createProvider = (rpcUrl) => {\n      const web3 = new Web3(rpcUrl);\n      return web3;\n    };\n\n    const PROVIDER_RPC = {\n      rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n      chainId: 420420422,\n      name: 'polkadot-hub-testnet',\n    };\n\n    const main = async () => {\n      try {\n        const web3 = createProvider(PROVIDER_RPC.rpc);\n        const latestBlock = await web3.eth.getBlockNumber();\n        console.log('Last block: ' + latestBlock);\n      } catch (error) {\n        console.error('Error connecting to Polkadot Hub TestNet: ' + error.message);\n      }\n    };\n\n    main();\n\n    ```"}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 6, "depth": 2, "title": "Compile Contracts", "anchor": "compile-contracts", "start_char": 4019, "end_char": 7512, "estimated_token_count": 838, "token_estimator": "heuristic-v1", "text": "## Compile Contracts\n\n!!! note \"Contracts Code Blob Size Disclaimer\"\n    The maximum contract code blob size on Polkadot Hub networks is _100 kilobytes_, significantly larger than Ethereum’s EVM limit of 24 kilobytes.\n\n    For detailed comparisons and migration guidelines, see the [EVM vs. PolkaVM](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm/#current-memory-limits){target=\\_blank} documentation page.\n\nPolkadot Hub requires contracts to be compiled to [PolkaVM](/polkadot-protocol/smart-contract-basics/polkavm-design/){target=\\_blank} bytecode. This is achieved using the [`revive`](https://github.com/paritytech/revive/tree/v0.2.0/js/resolc){target=\\_blank} compiler. Install the [`@parity/resolc`](https://github.com/paritytech/revive){target=\\_blank} library as a development dependency:\n\n```bash\nnpm install --save-dev @parity/resolc\n```\n\nThis guide uses `@parity/resolc` version `0.2.0`.\n\nHere's a simple storage contract that you can use to follow the process:\n\n```solidity title=\"contracts/Storage.sol\"\n//SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ncontract Storage {\n    // Public state variable to store a number\n    uint256 public storedNumber;\n\n    /**\n    * Updates the stored number.\n    *\n    * The `public` modifier allows anyone to call this function.\n    *\n    * @param _newNumber - The new value to store.\n    */\n    function setNumber(uint256 _newNumber) public {\n        storedNumber = _newNumber;\n    }\n}\n```\n\nWith that, you can now create a `compile.js` snippet that transforms your solidity code into PolkaVM bytecode:\n\n```javascript title=\"scripts/compile.js\"\nconst { compile } = require('@parity/resolc');\nconst { readFileSync, writeFileSync } = require('fs');\nconst { basename, join } = require('path');\n\nconst compileContract = async (solidityFilePath, outputDir) => {\n  try {\n    // Read the Solidity file\n    const source = readFileSync(solidityFilePath, 'utf8');\n\n    // Construct the input object for the compiler\n    const input = {\n      [basename(solidityFilePath)]: { content: source },\n    };\n\n    console.log(`Compiling contract: ${basename(solidityFilePath)}...`);\n\n    // Compile the contract\n    const out = await compile(input);\n\n    for (const contracts of Object.values(out.contracts)) {\n      for (const [name, contract] of Object.entries(contracts)) {\n        console.log(`Compiled contract: ${name}`);\n\n        // Write the ABI\n        const abiPath = join(outputDir, `${name}.json`);\n        writeFileSync(abiPath, JSON.stringify(contract.abi, null, 2));\n        console.log(`ABI saved to ${abiPath}`);\n\n        // Write the bytecode\n        const bytecodePath = join(outputDir, `${name}.polkavm`);\n        writeFileSync(\n          bytecodePath,\n          Buffer.from(contract.evm.bytecode.object, 'hex'),\n        );\n        console.log(`Bytecode saved to ${bytecodePath}`);\n      }\n    }\n  } catch (error) {\n    console.error('Error compiling contracts:', error);\n  }\n};\n\nconst solidityFilePath = './Storage.sol';\nconst outputDir = '.';\n\ncompileContract(solidityFilePath, outputDir);\n\n```\n\nTo compile your contract, simply run the following command:\n\n```bash\nnode compile\n```\n\nAfter compilation, you'll have two key files: an ABI (`.json`) file, which provides a JSON interface describing the contract's functions and how to interact with it, and a bytecode (`.polkavm`) file, which contains the low-level machine code executable on PolkaVM that represents the compiled smart contract ready for blockchain deployment."}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 7, "depth": 2, "title": "Contract Deployment", "anchor": "contract-deployment", "start_char": 7512, "end_char": 10455, "estimated_token_count": 674, "token_estimator": "heuristic-v1", "text": "## Contract Deployment\n\nTo deploy your compiled contract to Polkadot Hub using Web3.js, you'll need an account with a private key to sign the deployment transaction. The deployment process is exactly the same as for any Ethereum-compatible chain, involving creating a contract instance, estimating gas, and sending a deployment transaction. Here's how to deploy the contract, ensure replacing the `INSERT_RPC_URL`, `INSERT_PRIVATE_KEY`, and `INSERT_CONTRACT_NAME` with the appropriate values:\n\n```javascript title=\"scripts/deploy.js\"\nimport { readFileSync } from 'fs';\nimport { Web3 } from 'web3';\n\nconst getAbi = (contractName) => {\n  try {\n    return JSON.parse(readFileSync(`${contractName}.json`), 'utf8');\n  } catch (error) {\n    console.error(\n      `❌ Could not find ABI for contract ${contractName}:`,\n      error.message\n    );\n    throw error;\n  }\n};\n\nconst getByteCode = (contractName) => {\n  try {\n    return `0x${readFileSync(`${contractName}.polkavm`).toString('hex')}`;\n  } catch (error) {\n    console.error(\n      `❌ Could not find bytecode for contract ${contractName}:`,\n      error.message\n    );\n    throw error;\n  }\n};\n\nexport const deploy = async (config) => {\n  try {\n    // Initialize Web3 with RPC URL\n    const web3 = new Web3(config.rpcUrl);\n\n    // Prepare account\n    const account = web3.eth.accounts.privateKeyToAccount(config.privateKey);\n    web3.eth.accounts.wallet.add(account);\n\n    // Load abi\n    const abi = getAbi('Storage');\n\n    // Create contract instance\n    const contract = new web3.eth.Contract(abi);\n\n    // Prepare deployment\n    const deployTransaction = contract.deploy({\n      data: getByteCode('Storage'),\n      arguments: [], // Add constructor arguments if needed\n    });\n\n    // Estimate gas\n    const gasEstimate = await deployTransaction.estimateGas({\n      from: account.address,\n    });\n\n    // Get current gas price\n    const gasPrice = await web3.eth.getGasPrice();\n\n    // Send deployment transaction\n    const deployedContract = await deployTransaction.send({\n      from: account.address,\n      gas: gasEstimate,\n      gasPrice: gasPrice,\n    });\n\n    // Log and return contract details\n    console.log(`Contract deployed at: ${deployedContract.options.address}`);\n    return deployedContract;\n  } catch (error) {\n    console.error('Deployment failed:', error);\n    throw error;\n  }\n};\n\n// Example usage\nconst deploymentConfig = {\n  rpcUrl: 'INSERT_RPC_URL',\n  privateKey: 'INSERT_PRIVATE_KEY',\n  contractName: 'INSERT_CONTRACT_NAME',\n};\n\ndeploy(deploymentConfig)\n  .then((contract) => console.log('Deployment successful'))\n  .catch((error) => console.error('Deployment error'));\n\n```\n\nFor further details on private key exportation, refer to the article [How to export an account's private key](https://support.metamask.io/configure/accounts/how-to-export-an-accounts-private-key/){target=\\_blank}.\n\nTo deploy your contract, run the following command:\n\n```bash\nnode deploy\n```"}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 8, "depth": 2, "title": "Interact with the Contract", "anchor": "interact-with-the-contract", "start_char": 10455, "end_char": 12838, "estimated_token_count": 548, "token_estimator": "heuristic-v1", "text": "## Interact with the Contract\n\nOnce deployed, you can interact with your contract using Web3.js methods. Here's how to set a number and read it back, ensure replacing `INSERT_RPC_URL`, `INSERT_PRIVATE_KEY`, and `INSERT_CONTRACT_ADDRESS` with the appropriate values:\n\n```javascript title=\"scripts/updateStorage.js\"\nimport { readFileSync } from 'fs';\nimport { Web3 } from 'web3';\n\nconst getAbi = (contractName) => {\n  try {\n    return JSON.parse(readFileSync(`${contractName}.json`), 'utf8');\n  } catch (error) {\n    console.error(\n      `❌ Could not find ABI for contract ${contractName}:`,\n      error.message\n    );\n    throw error;\n  }\n};\n\nconst updateStorage = async (config) => {\n  try {\n    // Initialize Web3 with RPC URL\n    const web3 = new Web3(config.rpcUrl);\n\n    // Prepare account\n    const account = web3.eth.accounts.privateKeyToAccount(config.privateKey);\n    web3.eth.accounts.wallet.add(account);\n\n    // Load abi\n    const abi = getAbi('Storage');\n\n    // Create contract instance\n    const contract = new web3.eth.Contract(abi, config.contractAddress);\n\n    // Get initial value\n    const initialValue = await contract.methods.storedNumber().call();\n    console.log('Current stored value:', initialValue);\n\n    // Prepare transaction\n    const updateTransaction = contract.methods.setNumber(1);\n\n    // Estimate gas\n    const gasEstimate = await updateTransaction.estimateGas({\n      from: account.address,\n    });\n\n    // Get current gas price\n    const gasPrice = await web3.eth.getGasPrice();\n\n    // Send update transaction\n    const receipt = await updateTransaction.send({\n      from: account.address,\n      gas: gasEstimate,\n      gasPrice: gasPrice,\n    });\n\n    // Log transaction details\n    console.log(`Transaction hash: ${receipt.transactionHash}`);\n\n    // Get updated value\n    const newValue = await contract.methods.storedNumber().call();\n    console.log('New stored value:', newValue);\n\n    return receipt;\n  } catch (error) {\n    console.error('Update failed:', error);\n    throw error;\n  }\n};\n\n// Example usage\nconst config = {\n  rpcUrl: 'INSERT_RPC_URL',\n  privateKey: 'INSERT_PRIVATE_KEY',\n  contractAddress: 'INSERT_CONTRACT_ADDRESS',\n};\n\nupdateStorage(config)\n  .then((receipt) => console.log('Update successful'))\n  .catch((error) => console.error('Update error'));\n\n```\n\nTo execute the logic above, run:\n\n```bash\nnode updateStorage\n```"}
{"page_id": "develop-smart-contracts-libraries-web3-js", "page_title": "Web3.js", "index": 9, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 12838, "end_char": 13347, "estimated_token_count": 131, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you’ve learned how to use Web3.js with Polkadot Hub, explore more advanced topics:\n\n- **Utilize Web3.js utilities**: Learn about additional [Web3.js](https://docs.web3js.org/){target=\\_blank} features such as signing transactions, managing wallets, and subscribing to events.\n- **Build full-stack dApps**: [integrate Web3.js](https://docs.web3js.org/guides/dapps/intermediate-dapp){target=\\_blank} with different libraries and frameworks to build decentralized web applications."}
{"page_id": "develop-smart-contracts-libraries-web3-py", "page_title": "Web3.py", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 181, "end_char": 605, "estimated_token_count": 83, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nInteracting with blockchains typically requires an interface between your application and the network. [Web3.py](https://web3py.readthedocs.io/en/stable/index.html){target=\\_blank} offers this interface through a collection of libraries, facilitating seamless interaction with the nodes using HTTP or WebSocket protocols. \n\nThis guide illustrates how to utilize Web3.py for interactions with Polkadot Hub."}
{"page_id": "develop-smart-contracts-libraries-web3-py", "page_title": "Web3.py", "index": 1, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 605, "end_char": 986, "estimated_token_count": 88, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\n1. To start working with Web3.py, begin by initializing your project:\n\n    ```bash\n    mkdir web3py-project\n    cd web3py-project\n    ```\n\n2. Create and activate a virtual environment for your project:\n\n    ```bash\n    python -m venv venv\n    source venv/bin/activate\n    ```\n\n3. Next, install the Web3.py library:\n\n    ```bash\n    pip install web3\n    ```"}
{"page_id": "develop-smart-contracts-libraries-web3-py", "page_title": "Web3.py", "index": 2, "depth": 2, "title": "Set Up the Web3 Provider", "anchor": "set-up-the-web3-provider", "start_char": 986, "end_char": 3080, "estimated_token_count": 423, "token_estimator": "heuristic-v1", "text": "## Set Up the Web3 Provider\n\nThe [provider](https://web3py.readthedocs.io/en/stable/providers.html){target=\\_blank} configuration is the foundation of any Web3.py application. The following example establishes a connection to Polkadot Hub. Follow these steps to use the provider configuration:\n\n1. Replace `INSERT_RPC_URL` with the appropriate value. For instance, to connect to Polkadot Hub TestNet, use the following parameter:\n\n    ```python\n    PROVIDER_RPC = 'https://testnet-passet-hub-eth-rpc.polkadot.io'\n    ```\n\n    The provider connection script should look something like this:\n\n    ```python title=\"connect_to_provider.py\"\n    from web3 import Web3\n\n    def create_provider(rpc_url):\n        web3 = Web3(Web3.HTTPProvider(rpc_url))\n        return web3\n\n    PROVIDER_RPC = 'INSERT_RPC_URL'\n\n    create_provider(PROVIDER_RPC)\n    ```\n\n1. With the Web3 provider set up, start querying the blockchain. For instance, you can use the following code snippet to fetch the latest block number of the chain:\n\n    ```python title=\"fetch_last_block.py\"\n    def main():\n        try:\n            web3 = create_provider(PROVIDER_RPC)\n            latest_block = web3.eth.block_number\n            print('Last block: ' + str(latest_block))\n        except Exception as error:\n            print('Error connecting to Polkadot Hub TestNet: ' + str(error))\n\n    if __name__ == \"__main__\":\n        main()\n    ```\n\n    ??? code \"View complete script\"\n\n        ```python title=\"fetch_last_block.py\"\n        from web3 import Web3\n\n        def create_provider(rpc_url):\n            web3 = Web3(Web3.HTTPProvider(rpc_url))\n            return web3\n\n        PROVIDER_RPC = 'https://testnet-passet-hub-eth-rpc.polkadot.io'\n\n        def main():\n            try:\n                web3 = create_provider(PROVIDER_RPC)\n                latest_block = web3.eth.block_number\n                print('Last block: ' + str(latest_block))\n            except Exception as error:\n                print('Error connecting to Polkadot Hub TestNet: ' + str(error))\n\n        if __name__ == \"__main__\":\n            main()\n        ```"}
{"page_id": "develop-smart-contracts-libraries-web3-py", "page_title": "Web3.py", "index": 3, "depth": 2, "title": "Contract Deployment", "anchor": "contract-deployment", "start_char": 3080, "end_char": 7221, "estimated_token_count": 826, "token_estimator": "heuristic-v1", "text": "## Contract Deployment\n\nBefore deploying your contracts, make sure you've compiled them and obtained two key files:\n\n- An ABI (.json) file, which provides a JSON interface describing the contract's functions and how to interact with it.\n- A bytecode (.polkavm) file, which contains the low-level machine code executable on [PolkaVM](/polkadot-protocol/smart-contract-basics/polkavm-design#polkavm){target=\\_blank} that represents the compiled smart contract ready for blockchain deployment.\n\nTo follow this guide, you can use the following solidity contract as an example:\n\n```solidity title=\"Storage.sol\"\n//SPDX-License-Identifier: MIT\n\n// Solidity files have to start with this pragma.\n// It will be used by the Solidity compiler to validate its version.\npragma solidity ^0.8.9;\n\ncontract Storage {\n    // Public state variable to store a number\n    uint256 public storedNumber;\n\n    /**\n    * Updates the stored number.\n    *\n    * The `public` modifier allows anyone to call this function.\n    *\n    * @param _newNumber - The new value to store.\n    */\n    function setNumber(uint256 _newNumber) public {\n        storedNumber = _newNumber;\n    }\n}\n```\n\nTo deploy your compiled contract to Polkadot Hub using Web3.py, you'll need an account with a private key to sign the deployment transaction. The deployment process is exactly the same as for any Ethereum-compatible chain, involving creating a contract instance, estimating gas, and sending a deployment transaction. Here's how to deploy the contract. Replace `INSERT_RPC_URL` and `INSERT_PRIVATE_KEY` with the appropriate values:\n\n```python title=\"deploy.py\"\nfrom web3 import Web3\nimport json\n\ndef get_abi(contract_name):\n    try:\n        with open(f\"{contract_name}.json\", 'r') as file:\n            return json.load(file)\n    except Exception as error:\n        print(f\"❌ Could not find ABI for contract {contract_name}: {error}\")\n        raise error\n\ndef get_bytecode(contract_name):\n    try:\n        with open(f\"{contract_name}.polkavm\", 'rb') as file:\n            return '0x' + file.read().hex()\n    except Exception as error:\n        print(f\"❌ Could not find bytecode for contract {contract_name}: {error}\")\n        raise error\n\nasync def deploy(config):\n    try:\n        # Initialize Web3 with RPC URL\n        web3 = Web3(Web3.HTTPProvider(config[\"rpc_url\"]))\n        \n        # Prepare account\n        account = web3.eth.account.from_key(config[\"private_key\"])\n        print(f\"address: {account.address}\")\n        \n        # Load ABI\n        abi = get_abi('Storage')\n        \n        # Create contract instance\n        contract = web3.eth.contract(abi=abi, bytecode=get_bytecode('Storage'))\n        \n        # Get current nonce\n        nonce = web3.eth.get_transaction_count(account.address)\n        \n        # Prepare deployment transaction\n        transaction = {\n            'from': account.address,\n            'nonce': nonce,\n        }\n        \n        # Build and sign transaction\n        construct_txn = contract.constructor().build_transaction(transaction)\n        signed_txn = web3.eth.account.sign_transaction(construct_txn, private_key=config[\"private_key\"])\n        \n        # Send transaction\n        tx_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n        print(f\"Transaction hash: {tx_hash.hex()}\")\n        \n        # Wait for transaction receipt\n        tx_receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n        contract_address = tx_receipt.contractAddress\n        \n        # Log and return contract details\n        print(f\"Contract deployed at: {contract_address}\")\n        return web3.eth.contract(address=contract_address, abi=abi)\n    \n    except Exception as error:\n        print('Deployment failed:', error)\n        raise error\n\nif __name__ == \"__main__\":\n    # Example usage\n    import asyncio\n    \n    deployment_config = {\n        \"rpc_url\": \"INSERT_RPC_URL\",\n        \"private_key\": \"INSERT_PRIVATE_KEY\",\n    }\n    \n    asyncio.run(deploy(deployment_config))\n```\n\n!!!warning\n    Never commit or share your private key. Exposed keys can lead to immediate theft of all associated funds. Use environment variables instead."}
{"page_id": "develop-smart-contracts-libraries-web3-py", "page_title": "Web3.py", "index": 4, "depth": 2, "title": "Interact with the Contract", "anchor": "interact-with-the-contract", "start_char": 7221, "end_char": 9678, "estimated_token_count": 464, "token_estimator": "heuristic-v1", "text": "## Interact with the Contract\n\nAfter deployment, interact with your contract using Web3.py methods. The example below demonstrates how to set and retrieve a number. Be sure to replace the `INSERT_RPC_URL`, `INSERT_PRIVATE_KEY`, and `INSERT_CONTRACT_ADDRESS` placeholders with your specific values:\n\n```python title=\"update_storage.py\"\nfrom web3 import Web3\nimport json\n\ndef get_abi(contract_name):\n    try:\n        with open(f\"{contract_name}.json\", 'r') as file:\n            return json.load(file)\n    except Exception as error:\n        print(f\"❌ Could not find ABI for contract {contract_name}: {error}\")\n        raise error\n\nasync def update_storage(config):\n    try:\n        # Initialize Web3 with RPC URL\n        web3 = Web3(Web3.HTTPProvider(config[\"rpc_url\"]))\n        \n        # Prepare account\n        account = web3.eth.account.from_key(config[\"private_key\"])\n        \n        # Load ABI\n        abi = get_abi('Storage')\n        \n        # Create contract instance\n        contract = web3.eth.contract(address=config[\"contract_address\"], abi=abi)\n        \n        # Get initial value\n        initial_value = contract.functions.storedNumber().call()\n        print('Current stored value:', initial_value)\n        \n        # Get current nonce\n        nonce = web3.eth.get_transaction_count(account.address)\n        \n        # Prepare transaction\n        transaction = contract.functions.setNumber(1).build_transaction({\n            'from': account.address,\n            'nonce': nonce\n        })\n        \n        # Sign transaction\n        signed_txn = web3.eth.account.sign_transaction(transaction, private_key=config[\"private_key\"])\n        \n        # Send transaction\n        tx_hash = web3.eth.send_raw_transaction(signed_txn.raw_transaction)\n        print(f\"Transaction hash: {tx_hash.hex()}\")\n        \n        # Wait for receipt\n        receipt = web3.eth.wait_for_transaction_receipt(tx_hash)\n        \n        # Get updated value\n        new_value = contract.functions.storedNumber().call()\n        print('New stored value:', new_value)\n        \n        return receipt\n    \n    except Exception as error:\n        print('Update failed:', error)\n        raise error\n\nif __name__ == \"__main__\":\n    # Example usage\n    import asyncio\n    \n    config = {\n        \"rpc_url\": \"INSERT_RPC_URL\",\n        \"private_key\": \"INSERT_PRIVATE_KEY\",\n        \"contract_address\": \"INSERT_CONTRACT_ADDRESS\",\n    }\n    \n    asyncio.run(update_storage(config))\n```"}
{"page_id": "develop-smart-contracts-libraries-web3-py", "page_title": "Web3.py", "index": 5, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 9678, "end_char": 11652, "estimated_token_count": 628, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you have the foundation for using Web3.py with Polkadot Hub, consider exploring:\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge external\">External</span> __Advanced Web3.py Features__\n  \n    ---\n    Explore Web3.py's documentation:\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Middleware](https://web3py.readthedocs.io/en/stable/middleware.html){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Filters & Events](https://web3py.readthedocs.io/en/stable/filters.html){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: ENS](https://web3py.readthedocs.io/en/stable/ens_overview.html){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Testing Frameworks__\n\n    ---\n    Integrate Web3.py with Python testing frameworks:\n\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Pytest](https://docs.pytest.org/){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Brownie](https://eth-brownie.readthedocs.io/){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Transaction Management__\n\n    ---\n    Learn advanced transaction handling:\n\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Gas Strategies](https://web3py.readthedocs.io/en/stable/gas_price.html){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Account Management](https://web3py.readthedocs.io/en/stable/web3.eth.account.html){target=\\_blank}</li>\n    </ul>\n\n-   <span class=\"badge external\">External</span> __Building dApps__\n\n    ---\n    Combine Web3.py with these frameworks to create full-stack applications:\n\n    <ul class=\"card-list\">\n    <li>[:octicons-arrow-right-24: Flask](https://flask.palletsprojects.com/){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: Django](https://www.djangoproject.com/){target=\\_blank}</li>\n    <li>[:octicons-arrow-right-24: FastAPI](https://fastapi.tiangolo.com/){target=\\_blank}</li>\n    </ul>\n\n</div>"}
{"page_id": "develop-smart-contracts-local-development-node", "page_title": "Local Development Node", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 196, "end_char": 699, "estimated_token_count": 97, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nA local development node provides an isolated blockchain environment where you can deploy, test, and debug smart contracts without incurring network fees or waiting for block confirmations. This guide demonstrates how to set up a local Polkadot SDK-based node with smart contract capabilities.\n\nBy the end of this guide, you'll have:\n\n- A running node with smart contract support.\n- An ETH-RPC adapter for Ethereum-compatible tooling integration accessible at `http://localhost:8545`."}
{"page_id": "develop-smart-contracts-local-development-node", "page_title": "Local Development Node", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 699, "end_char": 1040, "estimated_token_count": 80, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have done the following:\n\n- Completed the [Install Polkadot SDK Dependencies](/develop/parachains/install-polkadot-sdk/){target=\\_blank} guide and successfully installed [Rust](https://www.rust-lang.org/){target=\\_blank} and the required packages to set up your development environment."}
{"page_id": "develop-smart-contracts-local-development-node", "page_title": "Local Development Node", "index": 2, "depth": 2, "title": "Install the Revive Dev Node and ETH-RPC Adapter", "anchor": "install-the-revive-dev-node-and-eth-rpc-adapter", "start_char": 1040, "end_char": 2573, "estimated_token_count": 343, "token_estimator": "heuristic-v1", "text": "## Install the Revive Dev Node and ETH-RPC Adapter\n\nThe Polkadot SDK repository contains both the [Revive Dev node](https://github.com/paritytech/polkadot-sdk/tree/8e2b6f742a38bb13688e12abacded0aab2dbbb23/substrate/frame/revive/dev-node){target=\\_blank} implementation and the [ETH-RPC adapter](https://github.com/paritytech/polkadot-sdk/tree/8e2b6f742a38bb13688e12abacded0aab2dbbb23/substrate/frame/revive/rpc){target=\\_blank} required for Ethereum compatibility. Start by cloning the repository and navigating to the project directory:\n\n```bash\ngit clone https://github.com/paritytech/polkadot-sdk.git\ncd polkadot-sdk\ngit checkout 8e2b6f742a38bb13688e12abacded0aab2dbbb23\n```\n\nNext, you need to compile the two essential components for your development environment. The Substrate node provides the core blockchain runtime with smart contract support, while the ETH-RPC adapter enables Ethereum JSON-RPC compatibility for existing tooling:\n\n```bash\ncargo build -p revive-dev-node --bin revive-dev-node --release\ncargo build -p pallet-revive-eth-rpc --bin eth-rpc --release\n```\n\nThe compilation process may take some time depending on your system specifications, potentially up to 30 minutes. Release builds are optimized for performance but take longer to compile than debug builds. After successful compilation, you can verify the binaries are available in the `target/release` directory:\n\n- **Revive Dev node path**: `polkadot-sdk/target/release/revive-dev-node`\n- **ETH-RPC adapter path**: `polkadot-sdk/target/release/eth-rpc`"}
{"page_id": "develop-smart-contracts-local-development-node", "page_title": "Local Development Node", "index": 3, "depth": 2, "title": "Run the Local Node", "anchor": "run-the-local-node", "start_char": 2573, "end_char": 9064, "estimated_token_count": 1912, "token_estimator": "heuristic-v1", "text": "## Run the Local Node\n\nWith the binaries compiled, you can now start your local development environment. The setup requires running two processes.\n\nStart the node first, which will initialize a local blockchain with the `dev` chain specification. This configuration includes `pallet-revive` for smart contract functionality and uses pre-funded development accounts for testing:\n\n```bash\n./target/release/revive-dev-node --dev\n```\n\nThe node will begin producing blocks immediately and display initialization logs:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>./target/release/revive-dev-node --dev</span>\n  <br />\n  <span data-ty>2025-05-29 10:42:35 Substrate Node</span>\n  <span data-ty>2025-05-29 10:42:35 ✌️ version 3.0.0-dev-38b7581fc04</span>\n  <span data-ty>2025-05-29 10:42:35 ❤️ by Parity Technologies &lt;admin@parity.io&gt;, 2017-2025</span>\n  <span data-ty>2025-05-29 10:42:35 📋 Chain specification: Development</span>\n  <span data-ty>2025-05-29 10:42:35 🏷 Node name: annoyed-aunt-3163</span>\n  <span data-ty>2025-05-29 10:42:35 👤 Role: AUTHORITY</span>\n  <span data-ty>2025-05-29 10:42:35 💾 Database: RocksDb at /var/folders/x0/xl_kjddj3ql3bx7752yr09hc0000gn/T/substrate2P85EF/chains/dev/db/full</span>\n  <span data-ty>2025-05-29 10:42:40 🔨 Initializing Genesis block/state (state: 0xfc05…482e, header-hash: 0x1ae1…b8b4)</span>\n  <span data-ty>2025-05-29 10:42:40 Creating transaction pool txpool_type=SingleState ready=Limit { count: 8192, total_bytes: 20971520 } future=Limit { count: 819, total_bytes: 2097152 }</span>\n  <span data-ty>2025-05-29 10:42:40 👴 Loading GRANDPA authority set from genesis on what appears to be first startup.</span>\n  <span data-ty>2025-05-29 10:42:40 👶 Creating empty BABE epoch changes on what appears to be first startup.</span>\n  <span data-ty>2025-05-29 10:42:40 Using default protocol ID \"sup\" because none is configured in the chain specs</span>\n  <span data-ty>2025-05-29 10:42:40 🏷 Local node identity is: 12D3KooWAH8fgJv3hce7Yv4yKG4YXQiRqESFu6755DBnfZQU8Znm</span>\n  <span data-ty>2025-05-29 10:42:40 Running libp2p network backend</span>\n  <span data-ty>2025-05-29 10:42:40 local_peer_id=12D3KooWAH8fgJv3hce7Yv4yKG4YXQiRqESFu6755DBnfZQU8Znm</span>\n  <span data-ty>2025-05-29 10:42:40 💻 Operating system: macos</span>\n  <span data-ty>2025-05-29 10:42:40 💻 CPU architecture: aarch64</span>\n  <span data-ty>2025-05-29 10:42:40 📦 Highest known block at #0</span>\n  <span data-ty>2025-05-29 10:42:40 Error binding to '127.0.0.1:9615': Os { code: 48, kind: AddrInUse, message: \"Address already in use\" }</span>\n  <span data-ty>2025-05-29 10:42:40 Running JSON-RPC server: addr=127.0.0.1:63333,[::1]:63334</span>\n  <span data-ty>2025-05-29 10:42:40 🏁 CPU single core score: 1.24 GiBs, parallelism score: 1.08 GiBs with expected cores: 8</span>\n  <span data-ty>2025-05-29 10:42:40 🏁 Memory score: 49.42 GiBs</span>\n  <span data-ty>2025-05-29 10:42:40 🏁 Disk score (seq. writes): 1.91 GiBs</span>\n  <span data-ty>2025-05-29 10:42:40 🏁 Disk score (rand. writes): 529.02 MiBs</span>\n  <span data-ty>2025-05-29 10:42:40 👶 Starting BABE Authorship worker</span>\n  <span data-ty>2025-05-29 10:42:40 🥩 BEEFY gadget waiting for BEEFY pallet to become available...</span>\n  <span data-ty>2025-05-29 10:42:40 Failed to trigger bootstrap: No known peers.</span>\n  <span data-ty>2025-05-29 10:42:42 🙌 Starting consensus session on top of parent 0x1ae19030b13592b5e6fd326f26efc7b31a4f588303d348ef89ae9ebca613b8b4 (#0)</span>\n  <span data-ty>2025-05-29 10:42:42 🎁 Prepared block for proposing at 1 (5 ms) hash: 0xe046f22307fba58a3bd0cc21b1a057843d4342da8876fd44aba206f124528df0; parent_hash: 0x1ae1…b8b4; end: NoMoreTransactions; extrinsics_count: 2</span>\n  <span data-ty>2025-05-29 10:42:42 🔖 Pre-sealed block for proposal at 1. Hash now 0xa88d36087e7bf8ee59c1b17e0003092accf131ff8353a620410d7283657ce36a, previously 0xe046f22307fba58a3bd0cc21b1a057843d4342da8876fd44aba206f124528df0.</span>\n  <span data-ty>2025-05-29 10:42:42 👶 New epoch 0 launching at block 0xa88d…e36a (block slot 582842054 >= start slot 582842054).</span>\n  <span data-ty>2025-05-29 10:42:42 👶 Next epoch starts at slot 582842254</span>\n  <span data-ty>2025-05-29 10:42:42 🏆 Imported #1 (0x1ae1…b8b4 → 0xa88d…e36a)</span>\n</div>\n\nFor debugging purposes or to monitor low-level operations, you can enable detailed logging by setting environment variables before running the command:\n\n```bash\nRUST_LOG=\"error,evm=debug,sc_rpc_server=info,runtime::revive=debug\" ./target/release/revive-dev-node --dev\n```\n\nOnce the node is running, open a new terminal window and start the ETH-RPC adapter. This component translates Ethereum JSON-RPC calls into Substrate-compatible requests, allowing you to use familiar Ethereum tools like MetaMask, Hardhat, or Ethers.js:\n\n```bash\n./target/release/eth-rpc --dev\n```\n\nYou should see logs indicating that the adapter is ready to accept connections:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>./target/release/eth-rpc --dev</span>\n  <br />\n  <span data-ty>2025-05-29 10:48:48 Running in --dev mode, RPC CORS has been disabled.</span>\n  <span data-ty>2025-05-29 10:48:48 Running in --dev mode, RPC CORS has been disabled.</span>\n  <span data-ty>2025-05-29 10:48:48 🌐 Connecting to node at: ws://127.0.0.1:9944 ...</span>\n  <span data-ty>2025-05-29 10:48:48 🌟 Connected to node at: ws://127.0.0.1:9944</span>\n  <span data-ty>2025-05-29 10:48:48 💾 Using in-memory database, keeping only 256 blocks in memory</span>\n  <span data-ty>2025-05-29 10:48:48 〽️ Prometheus exporter started at 127.0.0.1:9616</span>\n  <span data-ty>2025-05-29 10:48:48 Running JSON-RPC server: addr=127.0.0.1:8545,[::1]:8545</span>\n  <span data-ty>2025-05-29 10:48:48 🔌 Subscribing to new blocks (BestBlocks)</span>\n  <span data-ty>2025-05-29 10:48:48 🔌 Subscribing to new blocks (FinalizedBlocks)</span>\n</div>\n\nSimilar to the Revive Dev node, you can enable detailed logging for the ETH-RPC adapter to troubleshoot issues:\n\n```bash\nRUST_LOG=\"info,eth-rpc=debug\" ./target/release/eth-rpc --dev\n```\n\nYour local development environment is now active and accessible at `http://localhost:8545`. This endpoint accepts standard Ethereum JSON-RPC requests, enabling seamless integration with existing Ethereum development tools and workflows. \n\nYou can connect wallets, deploy contracts using Remix or Hardhat, and interact with your smart contracts as you would on any Ethereum-compatible network."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 201, "end_char": 1423, "estimated_token_count": 238, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPolkadot offers developers multiple approaches to building and deploying smart contracts within its ecosystem. As a multi-chain network designed for interoperability, Polkadot provides various environments optimized for different developer preferences and application requirements. From native smart contract support on Polkadot Hub to specialized parachain environments, developers can choose the platform that best suits their technical needs while benefiting from Polkadot's shared security model and cross-chain messaging capabilities.\n\nWhether you're looking for Ethereum compatibility through EVM-based parachains like [Moonbeam](https://docs.moonbeam.network/){target=\\_blank}, [Astar](https://docs.astar.network/){target=\\_blank}, and [Acala](https://evmdocs.acala.network/){target=\\_blank} or prefer PolkaVM-based development with [ink!](https://use.ink/docs/v6/){target=\\_blank}, the Polkadot ecosystem accommodates a range of diverse developers.\n\nThese guides explore the diverse smart contract options available in the Polkadot ecosystem, helping developers understand the unique advantages of each approach and make informed decisions about where to deploy their decentralized applications."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 1, "depth": 2, "title": "Native Smart Contracts", "anchor": "native-smart-contracts", "start_char": 1423, "end_char": 1450, "estimated_token_count": 5, "token_estimator": "heuristic-v1", "text": "## Native Smart Contracts"}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 2, "depth": 3, "title": "Introduction", "anchor": "introduction-2", "start_char": 1450, "end_char": 1811, "estimated_token_count": 54, "token_estimator": "heuristic-v1", "text": "### Introduction\n\nPolkadot Hub enables smart contract deployment and execution through PolkaVM, a cutting-edge virtual machine designed specifically for the Polkadot ecosystem. This native integration allows developers to deploy smart contracts directly on Polkadot's system chain while maintaining compatibility with Ethereum development tools and workflows."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 3, "depth": 3, "title": "Smart Contract Development", "anchor": "smart-contract-development", "start_char": 1811, "end_char": 2438, "estimated_token_count": 90, "token_estimator": "heuristic-v1", "text": "### Smart Contract Development\n\nThe smart contract platform on Polkadot Hub combines _Polkadot's robust security and scalability_ with the extensive Ethereum development ecosystem. Developers can utilize familiar Ethereum libraries for contract interactions and leverage industry-standard development environments for writing and testing smart contracts.\n\nPolkadot Hub provides _full Ethereum JSON-RPC API compatibility_, ensuring seamless integration with existing development tools and services. This compatibility enables developers to maintain their preferred workflows while building on Polkadot's native infrastructure."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 4, "depth": 3, "title": "Technical Architecture", "anchor": "technical-architecture", "start_char": 2438, "end_char": 2846, "estimated_token_count": 67, "token_estimator": "heuristic-v1", "text": "### Technical Architecture\n\nPolkaVM, the underlying virtual machine, utilizes a RISC-V-based register architecture _optimized for the Polkadot ecosystem_. This design choice offers several advantages:\n\n- Enhanced performance for smart contract execution.\n- Improved gas efficiency for complex operations.\n- Native compatibility with Polkadot's runtime environment.\n- Optimized storage and state management."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 5, "depth": 3, "title": "Development Tools and Resources", "anchor": "development-tools-and-resources", "start_char": 2846, "end_char": 3386, "estimated_token_count": 82, "token_estimator": "heuristic-v1", "text": "### Development Tools and Resources\n\nPolkadot Hub supports a comprehensive suite of development tools familiar to Ethereum developers. The platform integrates with popular development frameworks, testing environments, and deployment tools. Key features include:\n\n- Contract development in Solidity or Rust.\n- Support for standard Ethereum development libraries.\n- Integration with widely used development environments.\n- Access to blockchain explorers and indexing solutions.\n- Compatibility with contract monitoring and management tools."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 6, "depth": 3, "title": "Cross-Chain Capabilities", "anchor": "cross-chain-capabilities", "start_char": 3386, "end_char": 3878, "estimated_token_count": 99, "token_estimator": "heuristic-v1", "text": "### Cross-Chain Capabilities\n\nSmart contracts deployed on Polkadot Hub can leverage Polkadot's [cross-consensus messaging (XCM) protocol](/develop/interoperability/intro-to-xcm/){target=\\_blank} protocol to seamlessly _transfer tokens and call functions on other blockchain networks_ within the Polkadot ecosystem, all without complex bridging infrastructure or third-party solutions. For further references, check the [Interoperability](/develop/interoperability/){target=\\_blank} section."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 7, "depth": 3, "title": "Use Cases", "anchor": "use-cases", "start_char": 3878, "end_char": 4221, "estimated_token_count": 62, "token_estimator": "heuristic-v1", "text": "### Use Cases\n\nPolkadot Hub's smart contract platform is suitable for a wide range of applications:\n\n- DeFi protocols leveraging _cross-chain capabilities_.\n- NFT platforms utilizing Polkadot's native token standards.\n- Governance systems integrated with Polkadot's democracy mechanisms.\n- Cross-chain bridges and asset management solutions."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 8, "depth": 2, "title": "Other Smart Contract Environments", "anchor": "other-smart-contract-environments", "start_char": 4221, "end_char": 5344, "estimated_token_count": 227, "token_estimator": "heuristic-v1", "text": "## Other Smart Contract Environments\n\nBeyond Polkadot Hub's native PolkaVM support, the ecosystem offers two main alternatives for smart contract development:\n\n- **EVM-compatible parachains**: Provide access to Ethereum's extensive developer ecosystem, smart contract portability, and established tooling like Hardhat, Remix, Foundry, and OpenZeppelin. The main options include Moonbeam (the first full Ethereum-compatible parachain serving as an interoperability hub), Astar (featuring dual VM support for both EVM and WebAssembly contracts), and Acala (DeFi-focused with enhanced Acala EVM+ offering advanced DeFi primitives).\n\n- **Rust (ink!)**: ink! is a Rust-based framework that can compile to PolkaVM. It uses [`#[ink(...)]`](https://use.ink/docs/v6/macros-attributes/){target=\\_blank} attribute macros to create Polkadot SDK-compatible PolkaVM bytecode, offering strong memory safety from Rust, an advanced type system, high-performance PolkaVM execution, and platform independence with sandboxed security.\n\n\nEach environment provides unique advantages based on developer preferences and application requirements."}
{"page_id": "develop-smart-contracts-overview", "page_title": "Smart Contracts Overview", "index": 9, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 5344, "end_char": 6294, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nDevelopers can use their existing Ethereum development tools and connect to Polkadot Hub's RPC endpoints. The platform's Ethereum compatibility layer ensures a smooth transition for teams already building on Ethereum-compatible chains.\n\nSubsequent sections of this guide provide detailed information about specific development tools, advanced features, and best practices for building on Polkadot Hub.\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> __Libraries__\n\n    ---\n\n    Explore essential libraries to optimize smart contract development and interaction.\n\n    [:octicons-arrow-right-24: Reference](/develop/smart-contracts/libraries/)\n\n-   <span class=\"badge guide\">Guide</span> __Dev Environments__\n\n    ---\n\n    Set up your development environment for seamless contract deployment and testing.\n\n    [:octicons-arrow-right-24: Reference](/develop/smart-contracts/dev-environments/)\n\n</div>"}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 199, "end_char": 721, "estimated_token_count": 78, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPrecompiles offer Polkadot Hub developers access to high-performance native functions directly from their smart contracts. Each precompile has a specific address and accepts a particular input data format. When called correctly, they execute optimized, native implementations of commonly used functions much more efficiently than equivalent contract-based implementations.\n\nThis guide demonstrates how to interact with each standard precompile available in Polkadot Hub through Solidity smart contracts."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 1, "depth": 2, "title": "Basic Precompile Interaction Pattern", "anchor": "basic-precompile-interaction-pattern", "start_char": 721, "end_char": 1661, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "## Basic Precompile Interaction Pattern\n\nAll precompiles follow a similar interaction pattern:\n\n```solidity\n// Generic pattern for calling precompiles\nfunction callPrecompile(address precompileAddress, bytes memory input)\n    internal\n    returns (bool success, bytes memory result)\n{\n    // Direct low-level call to the precompile address\n    (success, result) = precompileAddress.call(input);\n\n    // Ensure the call was successful\n    require(success, \"Precompile call failed\");\n\n    return (success, result);\n}\n```\n\nFeel free to check the [`precompiles-hardhat`](https://github.com/polkadot-developers/polkavm-hardhat-examples/tree/v0.0.3/precompiles-hardhat){target=\\_blank} repository to check all the precompiles examples. The repository contains a set of example contracts and test files demonstrating how to interact with each precompile in Polkadot Hub.\n\nNow, you'll explore how to use each precompile available in Polkadot Hub."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 2, "depth": 2, "title": "ECRecover (0x01)", "anchor": "ecrecover-0x01", "start_char": 1661, "end_char": 3161, "estimated_token_count": 325, "token_estimator": "heuristic-v1", "text": "## ECRecover (0x01)\n\nECRecover recovers an Ethereum address associated with the public key used to sign a message.\n\n```solidity title=\"ECRecover.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ECRecoverExample {\n    event ECRecovered(bytes result);\n\n    // Address of the ECRecover precompile\n    address constant EC_RECOVER_ADDRESS = address(0x01);\n    bytes public result;\n\n    function callECRecover(bytes calldata input) public {\n        bool success;\n        bytes memory resultInMemory;\n\n        (success, resultInMemory) = EC_RECOVER_ADDRESS.call{value: 0}(input);\n\n        if (success) {\n            emit ECRecovered(resultInMemory);\n        }\n\n        result = resultInMemory;\n    }\n\n    function getRecoveredAddress() public view returns (address) {\n        require(result.length == 32, \"Invalid result length\");\n        return address(uint160(uint256(bytes32(result))));\n    }\n}\n```\n\nTo interact with the ECRecover precompile, you can deploy the `ECRecoverExample` contract in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment. The `callECRecover` function takes a 128-byte input combining the message `hash`, `v`, `r`, and `s` signature values. Check this [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/ECRecover.js){target=\\_blank} that shows how to format this input and verify that the recovered address matches the expected result."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 3, "depth": 2, "title": "SHA-256 (0x02)", "anchor": "sha-256-0x02", "start_char": 3161, "end_char": 4399, "estimated_token_count": 294, "token_estimator": "heuristic-v1", "text": "## SHA-256 (0x02)\n\nThe SHA-256 precompile computes the SHA-256 hash of the input data.\n\n```solidity title=\"SHA256.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SHA256Example {\n    event SHA256Called(bytes result);\n\n    // Address of the SHA256 precompile\n    address constant SHA256_PRECOMPILE = address(0x02);\n\n    bytes public result;\n\n    function callH256(bytes calldata input) public {\n        bool success;\n        bytes memory resultInMemory;\n\n        (success, resultInMemory) = SHA256_PRECOMPILE.call{value: 0}(input);\n\n        if (success) {\n            emit SHA256Called(resultInMemory);\n        }\n\n        result = resultInMemory;\n    }\n}\n```\n\nTo use it, you can deploy the `SHA256Example` contract in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call callH256 with arbitrary bytes. Check out this [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/SHA256.js){target=\\_blank} shows how to pass a UTF-8 string, hash it using the precompile, and compare it with the expected hash from Node.js's [crypto](https://www.npmjs.com/package/crypto-js){target=\\_blank} module."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 4, "depth": 2, "title": "RIPEMD-160 (0x03)", "anchor": "ripemd-160-0x03", "start_char": 4399, "end_char": 5788, "estimated_token_count": 299, "token_estimator": "heuristic-v1", "text": "## RIPEMD-160 (0x03)\n\nThe RIPEMD-160 precompile computes the RIPEMD-160 hash of the input data.\n\n```solidity title=\"RIPEMD160.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract RIPEMD160Example {\n    // RIPEMD-160 precompile address\n    address constant RIPEMD160_PRECOMPILE = address(0x03);\n\n    bytes32 public result;\n\n    event RIPEMD160Called(bytes32 result);\n\n    function calculateRIPEMD160(bytes calldata input) public returns (bytes32) {\n        (bool success, bytes memory returnData) = RIPEMD160_PRECOMPILE.call(\n            input\n        );\n        require(success, \"RIPEMD-160 precompile call failed\");\n        // return full 32 bytes, no assembly extraction\n        bytes32 fullHash;\n        assembly {\n            fullHash := mload(add(returnData, 32))\n        }\n        result = fullHash;\n        emit RIPEMD160Called(fullHash);\n        return fullHash;\n    }\n}\n```\n\nTo use it, you can deploy the `RIPEMD160Example` contract in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call `calculateRIPEMD160` with arbitrary bytes. This [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/RIPEMD160.js){target=\\_blank} shows how to hash a UTF-8 string, pad the 20-byte result to 32 bytes, and verify it against the expected output."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 5, "depth": 2, "title": "Identity (Data Copy) (0x04)", "anchor": "identity-data-copy-0x04", "start_char": 5788, "end_char": 7024, "estimated_token_count": 259, "token_estimator": "heuristic-v1", "text": "## Identity (Data Copy) (0x04)\n\nThe Identity precompile simply returns the input data as output. While seemingly trivial, it can be useful for testing and certain specialized scenarios.\n\n```solidity title=\"Identity.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract IdentityExample {\n    event IdentityCalled(bytes result);\n\n    // Address of the Identity precompile\n    address constant IDENTITY_PRECOMPILE = address(0x04);\n\n    bytes public result;\n\n    function callIdentity(bytes calldata input) public {\n        bool success;\n        bytes memory resultInMemory;\n\n        (success, resultInMemory) = IDENTITY_PRECOMPILE.call(input);\n\n        if (success) {\n            emit IdentityCalled(resultInMemory);\n        }\n\n        result = resultInMemory;\n    }\n}\n```\n\nTo use it, you can deploy the `IdentityExample` contract in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call `callIdentity` with arbitrary bytes. This [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/Identity.js){target=\\_blank} shows how to pass input data and verify that the precompile returns it unchanged."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 6, "depth": 2, "title": "Modular Exponentiation (0x05)", "anchor": "modular-exponentiation-0x05", "start_char": 7024, "end_char": 8506, "estimated_token_count": 309, "token_estimator": "heuristic-v1", "text": "## Modular Exponentiation (0x05)\n\nThe ModExp precompile performs modular exponentiation, which is an operation commonly needed in cryptographic algorithms.\n\n```solidity title=\"ModExp.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract ModExpExample {\n    address constant MODEXP_ADDRESS = address(0x05);\n\n    function modularExponentiation(\n        bytes memory base,\n        bytes memory exponent,\n        bytes memory modulus\n    ) public view returns (bytes memory) {\n        bytes memory input = abi.encodePacked(\n            toBytes32(base.length),\n            toBytes32(exponent.length),\n            toBytes32(modulus.length),\n            base,\n            exponent,\n            modulus\n        );\n\n        (bool success, bytes memory result) = MODEXP_ADDRESS.staticcall(input);\n        require(success, \"ModExp precompile call failed\");\n\n        return result;\n    }\n\n    function toBytes32(uint256 value) internal pure returns (bytes32) {\n        return bytes32(value);\n    }\n}\n```\n\nTo use it, you can deploy the `ModExpExample` contract in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call `modularExponentiation` with encoded `base`, `exponent`, and `modulus` bytes. This [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/ModExp.js){target=\\_blank} shows how to test modular exponentiation like (4 ** 13) % 497 = 445."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 7, "depth": 2, "title": "BN128 Addition (0x06)", "anchor": "bn128-addition-0x06", "start_char": 8506, "end_char": 10020, "estimated_token_count": 343, "token_estimator": "heuristic-v1", "text": "## BN128 Addition (0x06)\n\nThe BN128Add precompile performs addition on the alt_bn128 elliptic curve, which is essential for zk-SNARK operations.\n\n```solidity title=\"BN128Add.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract BN128AddExample {\n    address constant BN128_ADD_PRECOMPILE = address(0x06);\n\n    event BN128Added(uint256 x3, uint256 y3);\n\n    uint256 public resultX;\n    uint256 public resultY;\n\n    function callBN128Add(uint256 x1, uint256 y1, uint256 x2, uint256 y2) public {\n        bytes memory input = abi.encodePacked(\n            bytes32(x1), bytes32(y1), bytes32(x2), bytes32(y2)\n        );\n\n        bool success;\n        bytes memory output;\n\n        (success, output) = BN128_ADD_PRECOMPILE.call{value: 0}(input);\n\n        require(success, \"BN128Add precompile call failed\");\n        require(output.length == 64, \"Invalid output length\");\n\n        (uint256 x3, uint256 y3) = abi.decode(output, (uint256, uint256));\n\n        resultX = x3;\n        resultY = y3;\n\n        emit BN128Added(x3, y3);\n    }\n}\n```\n\nTo use it, you can deploy the `BN128AddExample` contract in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call `callBN128Add` with valid `alt_bn128` points. This [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/BN128Add.js){target=\\_blank} demonstrates a valid curve addition and checks the result against known expected values."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 8, "depth": 2, "title": "BN128 Scalar Multiplication (0x07)", "anchor": "bn128-scalar-multiplication-0x07", "start_char": 10020, "end_char": 11756, "estimated_token_count": 369, "token_estimator": "heuristic-v1", "text": "## BN128 Scalar Multiplication (0x07)\n\nThe BN128Mul precompile performs scalar multiplication on the alt_bn128 curve.\n\n```solidity title=\"BN128Mul.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract BN128MulExample {\n    // Precompile address for BN128Mul\n    address constant BN128_MUL_ADDRESS = address(0x07);\n\n    bytes public result;\n\n    // Performs scalar multiplication of a point on the alt_bn128 curve\n    function bn128ScalarMul(uint256 x1, uint256 y1, uint256 scalar) public {\n        // Format: [x, y, scalar] - each 32 bytes\n        bytes memory input = abi.encodePacked(\n            bytes32(x1),\n            bytes32(y1),\n            bytes32(scalar)\n        );\n\n        (bool success, bytes memory resultInMemory) = BN128_MUL_ADDRESS.call{\n            value: 0\n        }(input);\n        require(success, \"BN128Mul precompile call failed\");\n\n        result = resultInMemory;\n    }\n\n    // Helper to decode result from `result` storage\n    function getResult() public view returns (uint256 x2, uint256 y2) {\n        bytes memory tempResult = result;\n        require(tempResult.length >= 64, \"Invalid result length\");\n        assembly {\n            x2 := mload(add(tempResult, 32))\n            y2 := mload(add(tempResult, 64))\n        }\n    }\n}\n```\n\nTo use it, deploy `BN128MulExample` in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call `bn128ScalarMul` with a valid point and scalar. This [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/BN128Mul.js){target=\\_blank} shows how to test the operation and verify the expected scalar multiplication result on `alt_bn128`."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 9, "depth": 2, "title": "BN128 Pairing Check (0x08)", "anchor": "bn128-pairing-check-0x08", "start_char": 11756, "end_char": 13264, "estimated_token_count": 313, "token_estimator": "heuristic-v1", "text": "## BN128 Pairing Check (0x08)\n\nThe BN128Pairing precompile verifies a pairing equation on the alt_bn128 curve, which is critical for zk-SNARK verification.\n\n```solidity title=\"BN128Pairing.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract BN128PairingExample {\n    // Precompile address for BN128Pairing\n    address constant BN128_PAIRING_ADDRESS = address(0x08);\n\n    bytes public result;\n\n    // Performs a pairing check on the alt_bn128 curve\n    function bn128Pairing(bytes memory input) public {\n        // Call the precompile\n        (bool success, bytes memory resultInMemory) = BN128_PAIRING_ADDRESS\n            .call{value: 0}(input);\n        require(success, \"BN128Pairing precompile call failed\");\n\n        result = resultInMemory;\n    }\n\n    // Helper function to decode the result from `result` storage\n    function getResult() public view returns (bool isValid) {\n        bytes memory tempResult = result;\n        require(tempResult.length == 32, \"Invalid result length\");\n\n        uint256 output;\n        assembly {\n            output := mload(add(tempResult, 32))\n        }\n\n        isValid = (output == 1);\n    }\n}\n```\n\nYou can deploy `BN128PairingExample` in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or your preferred environment. Check out this [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/BN128Pairing.js){target=\\_blank} contains these tests with working examples."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 10, "depth": 2, "title": "Blake2F (0x09)", "anchor": "blake2f-0x09", "start_char": 13264, "end_char": 17391, "estimated_token_count": 945, "token_estimator": "heuristic-v1", "text": "## Blake2F (0x09)\n\nThe Blake2F precompile performs the Blake2 compression function F, which is the core of the Blake2 hash function.\n\n```solidity title=\"Blake2F.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Blake2FExample {\n    // Precompile address for Blake2F\n    address constant BLAKE2F_ADDRESS = address(0x09);\n\n    bytes public result;\n\n    function blake2F(bytes memory input) public {\n        // Input must be exactly 213 bytes\n        require(input.length == 213, \"Invalid input length - must be 213 bytes\");\n\n        // Call the precompile\n        (bool success, bytes memory resultInMemory) = BLAKE2F_ADDRESS.call{\n            value: 0\n        }(input);\n        require(success, \"Blake2F precompile call failed\");\n\n        result = resultInMemory;\n    }\n\n    // Helper function to decode the result from `result` storage\n    function getResult() public view returns (bytes32[8] memory output) {\n        bytes memory tempResult = result;\n        require(tempResult.length == 64, \"Invalid result length\");\n\n        for (uint i = 0; i < 8; i++) {\n            assembly {\n                mstore(add(output, mul(32, i)), mload(add(add(tempResult, 32), mul(32, i))))\n            }\n        }\n    }\n\n\n    // Helper function to create Blake2F input from parameters\n    function createBlake2FInput(\n        uint32 rounds,\n        bytes32[8] memory h,\n        bytes32[16] memory m,\n        bytes8[2] memory t,\n        bool f\n    ) public pure returns (bytes memory) {\n        // Start with rounds (4 bytes, big-endian)\n        bytes memory input = abi.encodePacked(rounds);\n\n        // Add state vector h (8 * 32 = 256 bytes)\n        for (uint i = 0; i < 8; i++) {\n            input = abi.encodePacked(input, h[i]);\n        }\n\n        // Add message block m (16 * 32 = 512 bytes, but we need to convert to 16 * 8 = 128 bytes)\n        // Blake2F expects 64-bit words in little-endian format\n        for (uint i = 0; i < 16; i++) {\n            // Take only the first 8 bytes of each bytes32 and reverse for little-endian\n            bytes8 word = bytes8(m[i]);\n            input = abi.encodePacked(input, word);\n        }\n\n        // Add offset counters t (2 * 8 = 16 bytes)\n        input = abi.encodePacked(input, t[0], t[1]);\n\n        // Add final block flag (1 byte)\n        input = abi.encodePacked(input, f ? bytes1(0x01) : bytes1(0x00));\n\n        return input;\n    }\n\n    // Simplified function that works with raw hex input\n    function blake2FFromHex(string memory hexInput) public {\n        bytes memory input = hexStringToBytes(hexInput);\n        blake2F(input);\n    }\n\n    // Helper function to convert hex string to bytes\n    function hexStringToBytes(string memory hexString) public pure returns (bytes memory) {\n        bytes memory hexBytes = bytes(hexString);\n        require(hexBytes.length % 2 == 0, \"Invalid hex string length\");\n        \n        bytes memory result = new bytes(hexBytes.length / 2);\n        \n        for (uint i = 0; i < hexBytes.length / 2; i++) {\n            result[i] = bytes1(\n                (hexCharToByte(hexBytes[2 * i]) << 4) | \n                hexCharToByte(hexBytes[2 * i + 1])\n            );\n        }\n        \n        return result;\n    }\n\n    function hexCharToByte(bytes1 char) internal pure returns (uint8) {\n        uint8 c = uint8(char);\n        if (c >= 48 && c <= 57) return c - 48;      // 0-9\n        if (c >= 65 && c <= 70) return c - 55;      // A-F\n        if (c >= 97 && c <= 102) return c - 87;     // a-f\n        revert(\"Invalid hex character\");\n    }\n}\n```\n\nTo use it, deploy `Blake2FExample` in [Remix](/develop/smart-contracts/dev-environments/remix){target=\\_blank} or any Solidity-compatible environment and call `callBlake2F` with the properly formatted input parameters for rounds, state vector, message block, offset counters, and final block flag. This [test file](https://github.com/polkadot-developers/polkavm-hardhat-examples/blob/v0.0.3/precompiles-hardhat/test/Blake2.js){target=\\_blank} demonstrates how to perform Blake2 compression with different rounds and verify the correctness of the output against known test vectors."}
{"page_id": "develop-smart-contracts-precompiles-interact-with-precompiles", "page_title": "Interact with Precompiles", "index": 11, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 17391, "end_char": 18009, "estimated_token_count": 92, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nPrecompiles in Polkadot Hub provide efficient, native implementations of cryptographic functions and other commonly used operations. By understanding how to interact with these precompiles from your Solidity contracts, you can build more efficient and feature-rich applications on the Polkadot ecosystem.\n\nThe examples provided in this guide demonstrate the basic patterns for interacting with each precompile. Developers can adapt these patterns to their specific use cases, leveraging the performance benefits of native implementations while maintaining the flexibility of smart contract development."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 18, "end_char": 913, "estimated_token_count": 191, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [XCM (Cross-Consensus Message)](/develop/interoperability/intro-to-xcm){target=\\_blank} precompile enables Polkadot Hub developers to access XCM functionality directly from their smart contracts using a Solidity interface.\n\nLocated at the fixed address `0x00000000000000000000000000000000000a0000`, the XCM precompile offers three primary functions:\n\n- **`execute`**: For local XCM execution.\n- **`send`**: For cross-chain message transmission.\n- **`weighMessage`**: For cost estimation.\n\nThis guide demonstrates how to interact with the XCM precompile through Solidity smart contracts using [Remix IDE](/develop/smart-contracts/dev-environments/remix){target=\\_blank}.\n\n!!!note\n    The XCM precompile provides the barebones XCM functionality. While it provides a lot of flexibility, it doesn't provide abstractions to hide away XCM details. These have to be built on top."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 1, "depth": 2, "title": "Precompile Interface", "anchor": "precompile-interface", "start_char": 913, "end_char": 4064, "estimated_token_count": 708, "token_estimator": "heuristic-v1", "text": "## Precompile Interface\n\nThe XCM precompile implements the `IXcm` interface, which defines the structure for interacting with XCM functionality. The source code for the interface is as follows:\n\n```solidity title=\"IXcm.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @dev The on-chain address of the XCM (Cross-Consensus Messaging) precompile.\naddress constant XCM_PRECOMPILE_ADDRESS = address(0xA0000);\n\n/// @title XCM Precompile Interface\n/// @notice A low-level interface for interacting with `pallet_xcm`.\n/// It forwards calls directly to the corresponding dispatchable functions,\n/// providing access to XCM execution and message passing.\n/// @dev Documentation:\n/// @dev - XCM: https://docs.polkadot.com/develop/interoperability\n/// @dev - SCALE codec: https://docs.polkadot.com/polkadot-protocol/parachain-basics/data-encoding\n/// @dev - Weights: https://docs.polkadot.com/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/#transactions-weights-and-fees\ninterface IXcm {\n    /// @notice Weight v2 used for measurement for an XCM execution\n    struct Weight {\n        /// @custom:property The computational time used to execute some logic based on reference hardware.\n        uint64 refTime;\n        /// @custom:property The size of the proof needed to execute some logic.\n        uint64 proofSize;\n    }\n\n    /// @notice Executes an XCM message locally on the current chain with the caller's origin.\n    /// @dev Internally calls `pallet_xcm::execute`.\n    /// @param message A SCALE-encoded Versioned XCM message.\n    /// @param weight The maximum allowed `Weight` for execution.\n    /// @dev Call @custom:function weighMessage(message) to ensure sufficient weight allocation.\n    function execute(bytes calldata message, Weight calldata weight) external;\n\n    /// @notice Sends an XCM message to another parachain or consensus system.\n    /// @dev Internally calls `pallet_xcm::send`.\n    /// @param destination SCALE-encoded destination MultiLocation.\n    /// @param message SCALE-encoded Versioned XCM message.\n    function send(bytes calldata destination, bytes calldata message) external;\n\n    /// @notice Estimates the `Weight` required to execute a given XCM message.\n    /// @param message SCALE-encoded Versioned XCM message to analyze.\n    /// @return weight Struct containing estimated `refTime` and `proofSize`.\n    function weighMessage(bytes calldata message) external view returns (Weight memory weight);\n}\n```\n\nThe interface defines a `Weight` struct that represents the computational cost of XCM operations. Weight has two components: \n\n- **`refTime`**: Computational time on reference hardware.\n- **`proofSize`**: The size of the proof required for execution.\n\nAll XCM messages must be encoded using the [SCALE codec](/polkadot-protocol/parachain-basics/data-encoding/#data-encoding){target=\\_blank}, Polkadot's standard serialization format.\n\nFor further information, check the [`precompiles/IXCM.sol`](https://github.com/paritytech/polkadot-sdk/blob/cb629d46ebf00aa65624013a61f9c69ebf02b0b4/polkadot/xcm/pallet-xcm/src/precompiles/IXcm.sol){target=\\_blank} file present in `pallet-xcm`."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 2, "depth": 2, "title": "Interact with the XCM Precompile", "anchor": "interact-with-the-xcm-precompile", "start_char": 4064, "end_char": 5303, "estimated_token_count": 306, "token_estimator": "heuristic-v1", "text": "## Interact with the XCM Precompile\n\nTo interact with the XCM precompile, you can use the precompile interface directly in [Remix IDE](/develop/smart-contracts/dev-environments/remix/){target=\\_blank}:\n\n1. Create a new file called `IXcm.sol` in Remix.\n2. Copy and paste the `IXcm` interface code into the file.\n3. Compile the interface by selecting the button or using **Ctrl +S** keys:\n\n    ![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-01.webp)\n\n4. In the **Deploy & Run Transactions** tab, select the `IXcm` interface from the contract dropdown.\n5. Enter the precompile address `0x00000000000000000000000000000000000a0000` in the **At Address** input field.\n6. Select the **At Address** button to connect to the precompile.\n\n    ![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-02.webp)\n\n7. Once connected, you can use the Remix interface to interact with the XCM precompile's  `execute`, `send`, and `weighMessage` functions.\n\n    ![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-03.webp)\n\nThe main entrypoint of the precompile is the `execute` function. However, it's necessary to first call `weighMessage` to fill in the required parameters."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 3, "depth": 3, "title": "Weigh a Message", "anchor": "weigh-a-message", "start_char": 5303, "end_char": 7542, "estimated_token_count": 485, "token_estimator": "heuristic-v1", "text": "### Weigh a Message\n\nThe `weighMessage` function estimates the computational cost required to execute an XCM message. This estimate is crucial for understanding the resources needed before actually executing or sending a message.\n\nTo test this functionality in Remix, you can call `callWeighMessage` with a SCALE-encoded XCM message. For example, for testing, you can use the following encoded XCM message:\n\n```text title=\"encoded-xcm-message-example\"\n0x050c000401000003008c86471301000003008c8647000d010101000000010100368e8759910dab756d344995f1d3c79374ca8f70066d3a709e48029f6bf0ee7e\n```\n\n![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-04.webp)\n\nThis encoded message represents a sequence of XCM instructions:\n\n- **[Withdraw Asset](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#withdrawasset){target=\\_blank}**: This instruction removes assets from the local chain's sovereign account or the caller's account, making them available for use in subsequent XCM instructions.\n- **[Buy Execution](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#buyexecution){target=\\_blank}**: This instruction purchases execution time on the destination chain using the withdrawn assets, ensuring the message can be processed.\n- **[Deposit Asset](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#depositasset){target=\\_blank}**: This instruction deposits the remaining assets into a specified account on the destination chain after execution costs have been deducted.\n\nThis encoded message is provided as an example. You can craft your own XCM message tailored to your specific use case as needed.\n\nThe function returns a `Weight` struct containing `refTime` and `proofSize` values, which indicate the estimated computational cost of executing this message. If successful, after calling the `callWeighMessage` function, you should see the `refTime` and `proofSize` of the message:\n\n![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-05.webp)\n\n!!!note\n    You can find many more examples of XCMs in this [gist](https://gist.github.com/franciscoaguirre/a6dea0c55e81faba65bedf700033a1a2){target=\\_blank}, which connects to the Polkadot Hub TestNet."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 4, "depth": 3, "title": "Execute a Message", "anchor": "execute-a-message", "start_char": 7542, "end_char": 9048, "estimated_token_count": 315, "token_estimator": "heuristic-v1", "text": "### Execute a Message\n\nThe `execute` function runs an XCM message locally using the caller's origin.\nThis function is the main entrypoint to cross-chain interactions.\n\nFollow these steps to execute a message:\n\n1. Call `weighMessage` with your message to get the required weight.\n2. Pass the same message bytes and the weight obtained from the previous step to `execute`.\nFor example, using the same message from the weighing example, you would call `execute` with:\n\n    - **`message`**: The encoded XCM message bytes.\n    - **`weight`**: The `Weight` struct returned from `weighMessage`.\n\n    You can use the [papi console](https://dev.papi.how/extrinsics#networkId=localhost&endpoint=wss%3A%2F%2Ftestnet-passet-hub.polkadot.io&data=0x1f03050c000401000003008c86471301000003008c8647000d010101000000010100368e8759910dab756d344995f1d3c79374ca8f70066d3a709e48029f6bf0ee7e0750c61e2901daad0600){target=\\_blank} to examine the complete extrinsic structure for this operation.\n\n3. On Remix, click on the **Transact** button to execute the XCM message:\n  \n    ![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-06.webp)\n\n    If successful, you will see the following output in the Remix terminal:\n\n    ![](/images/develop/smart-contracts/precompiles/xcm-precompile/xcm-precompile-07.webp)\n\nAdditionally, you can verify that the execution of this specific message was successful by checking that the beneficiary account associated with the XCM message has received the funds accordingly."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 5, "depth": 3, "title": "Send a Message", "anchor": "send-a-message", "start_char": 9048, "end_char": 9774, "estimated_token_count": 143, "token_estimator": "heuristic-v1", "text": "### Send a Message\n\nWhile most cross-chain operations can be performed via `execute`, `send` is sometimes necessary, for example, when opening HRMP channels.\n\nTo send a message:\n\n1. Prepare your destination location encoded in XCM format.\n2. Prepare your XCM message (similar to the execute example).\n3. Call `send` with both parameters.\n\nThe destination parameter must be encoded according to XCM's location format, specifying the target parachain or consensus system. The message parameter contains the XCM instructions to be executed on the destination chain.\n\nUnlike `execute`, the `send` function doesn't require a weight parameter since the destination chain will handle execution costs according to its fee structure."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 6, "depth": 2, "title": "Cross Contract Calls", "anchor": "cross-contract-calls", "start_char": 9774, "end_char": 10272, "estimated_token_count": 83, "token_estimator": "heuristic-v1", "text": "## Cross Contract Calls\n\nBeyond direct interaction and wrapper contracts, you can integrate XCM functionality directly into your existing smart contracts by inheriting from or importing the `IXcm` interface. This approach enables you to embed cross-chain capabilities into your application logic seamlessly.\n\nWhether you're building DeFi protocols, governance systems, or any application requiring cross-chain coordination, you can incorporate XCM calls directly within your contract's functions."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 7, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 10272, "end_char": 10579, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nThe XCM precompile provides a simple yet powerful interface for cross-chain interactions within the Polkadot ecosystem and beyond.\nBy building and executing XCM programs, developers can build cross-chain applications that leverage the full potential of Polkadot's interoperability features."}
{"page_id": "develop-smart-contracts-precompiles-xcm-precompile", "page_title": "Interact with the XCM Precompile", "index": 8, "depth": 2, "title": "Next steps", "anchor": "next-steps", "start_char": 10579, "end_char": 10769, "estimated_token_count": 36, "token_estimator": "heuristic-v1", "text": "## Next steps\n\nHead to the Polkadot Hub TestNet and start playing around with the precompile using Hardhat or Foundry.\n\nYou can use PAPI to build XCM programs and test them with Chopsticks."}
{"page_id": "develop-smart-contracts-wallets", "page_title": "Wallets for Polkadot Hub", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 198, "end_char": 665, "estimated_token_count": 75, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nConnecting a compatible wallet is the first essential step for interacting with the Polkadot Hub ecosystem. This guide explores wallet options that support both Substrate and Ethereum compatible layers, enabling transactions and smart contract interactions. Whether you're a developer testing on Polkadot Hub or a user accessing the MainNet, understanding wallet configuration is crucial for accessing the full range of Polkadot Hub's capabilities."}
{"page_id": "develop-smart-contracts-wallets", "page_title": "Wallets for Polkadot Hub", "index": 1, "depth": 2, "title": "Connect Your Wallet", "anchor": "connect-your-wallet", "start_char": 665, "end_char": 689, "estimated_token_count": 5, "token_estimator": "heuristic-v1", "text": "## Connect Your Wallet"}
{"page_id": "develop-smart-contracts-wallets", "page_title": "Wallets for Polkadot Hub", "index": 2, "depth": 3, "title": "MetaMask", "anchor": "metamask", "start_char": 689, "end_char": 2382, "estimated_token_count": 408, "token_estimator": "heuristic-v1", "text": "### MetaMask\n\n[MetaMask](https://metamask.io/){target=\\_blank} is a popular wallet for interacting with Ethereum-compatible chains. It allows users to connect to test networks that support Ethereum-based smart contracts. However, it's important to emphasize that MetaMask primarily facilitates interactions with smart contracts, giving users access to various chain functionalities. \n\nTo get started with MetaMask, you need to install the [MetaMask extension](https://metamask.io/download/){target=\\_blank} and add it to the browser. Once you install MetaMask, you can set up a new wallet and securely store your seed phrase. This phrase is crucial for recovery in case you lose access.\n\nFor example, to connect to the Polkadot Hub TestNet via MetaMask, you need to follow these steps:\n\n1. Open the MetaMask extension and click on the network icon to switch to the Polkadot Hub TestNet.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-1.webp){: .browser-extension}\n\n2. Click on the **Add a custom network** button.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-2.webp){: .browser-extension}\n\n3. Complete the necessary fields, then click the **Save** button (refer to the [Networks](/develop/smart-contracts/connect-to-polkadot#networks-details){target=\\_blank} section for copy and paste parameters).\n\n    ![](/images/develop/smart-contracts/wallets/wallets-3.webp){: .browser-extension}\n\n4. Click on **Polkadot Hub TestNet** to switch the network.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-4.webp){: .browser-extension}\n\nThe steps in the preceding section can be used to connect to any chain by modifying the network specification and endpoint parameters."}
{"page_id": "develop-smart-contracts-wallets", "page_title": "Wallets for Polkadot Hub", "index": 3, "depth": 3, "title": "SubWallet", "anchor": "subwallet", "start_char": 2382, "end_char": 4963, "estimated_token_count": 619, "token_estimator": "heuristic-v1", "text": "### SubWallet\n\n[SubWallet](https://www.subwallet.app/){target=\\_blank} is a popular non-custodial wallet solution for Polkadot and Ethereum ecosystems. It offers seamless integration with Polkadot SDK-based networks while maintaining Ethereum compatibility, making the wallet an ideal choice for users and developers to interact with Polkadot Hub.\n\nSubWallet now fully supports the [Polkadot Hub TestNet](/polkadot-protocol/smart-contract-basics/networks/#test-networks){target=\\_blank} where developers can deploy and interact with Ethereum-compatible, Solidity smart contracts.\n\nYou can easily view and manage your Paseo native token (PAS) using the Ethereum RPC endpoint (Passet Hub EVM) or the Substrate node RPC endpoint (passet-hub).\n\n??? code \"Polkadot Hub TestNet\"\n    You can see support here for Polkadot Hub's TestNet. The **Passet Hub EVM** network uses an ETH RPC endpoint, and the **passet-hub** uses a Substrate endpoint.\n    The ETH RPC endpoint will let you send transactions that follow an ETH format, while the Substrate endpoint will follow a Substrate transaction format.\n    Note the PAS token, which is the native token of the Polkadot Hub TestNet.\n\n    ![](/images/develop/smart-contracts/wallets/subwallet-PAS.webp){: .browser-extension}\n\nTo connect to Polkadot Hub TestNet using SubWallet, follow these steps:\n\n1. Install the [SubWallet browser extension](https://chromewebstore.google.com/detail/subwallet-polkadot-wallet/onhogfjeacnfoofkfgppdlbmlmnplgbn?hl=en){target=\\_blank} and set up your wallet by following the on-screen instructions, or refer to our [step-by-step guide](https://docs.subwallet.app/main/extension-user-guide/getting-started/install-subwallet){target=\\_blank} for assistance.\n\n2. After setting up your wallet, click the List icon at the top left corner of the extension window to open **Settings**.\n\n    ![](/images/develop/smart-contracts/wallets/subwallet-01.webp){: .browser-extension}\n\n3. Scroll down and select **Manage networks**.\n\n    ![](/images/develop/smart-contracts/wallets/subwallet-02.webp){: .browser-extension}\n\n4. In the Manage network screen, either scroll down or type in the search bar to find the networks. Once done, enable the toggle next to the network name.\n\n    ![](/images/develop/smart-contracts/wallets/subwallet-03.webp){: .browser-extension}\n\n   You are now ready to use SubWallet to interact with [Polkadot Hub TestNet](/develop/smart-contracts/connect-to-polkadot/#networks-details){target=\\_blank} seamlessly!\n\n![](/images/develop/smart-contracts/wallets/subwallet-04.webp){: .browser-extension}"}
{"page_id": "develop-smart-contracts-wallets", "page_title": "Wallets for Polkadot Hub", "index": 4, "depth": 3, "title": "Talisman", "anchor": "talisman", "start_char": 4963, "end_char": 6675, "estimated_token_count": 431, "token_estimator": "heuristic-v1", "text": "### Talisman\n\n[Talisman](https://talisman.xyz/){target=\\_blank} is a specialized wallet for the Polkadot ecosystem that supports both Substrate and EVM accounts, making it an excellent choice for Polkadot Hub interactions. Talisman offers a more integrated experience for Polkadot-based chains while still providing Ethereum compatibility.\n\nTo use Talisman with Polkadot Hub TestNet:\n\n1. Install the [Talisman extension](https://talisman.xyz/download){target=\\_blank} and set up your wallet by following the on-screen instructions.\n\n2. Once installed, click on the Talisman icon in your browser extensions and click on the **Settings** button.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-5.webp){: .browser-extension}\n\n3. Click the button **All settings**.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-6.webp){: .browser-extension}\n\n4. Go to the **Networks & Tokens** section.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-7.webp)\n\n5. Click the **Manage networks** button.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-8.webp)\n\n6. Click the **+ Add network** button.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-9.webp)\n\n7. Fill in the form with the required parameters and click the **Add network** button.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-10.webp)\n\n8. After that, you can switch to the Polkadot Hub TestNet by clicking on the network icon and selecting **Polkadot Hub TestNet**.\n\n    ![](/images/develop/smart-contracts/wallets/wallets-11.webp)\n\nAfter selecting the network, Talisman will automatically configure the necessary RPC URL and chain ID for you. You can now use Talisman to interact with the Polkadot Hub TestNet."}
{"page_id": "develop-smart-contracts-wallets", "page_title": "Wallets for Polkadot Hub", "index": 5, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 6675, "end_char": 7299, "estimated_token_count": 100, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nChoosing the right wallet for Polkadot Hub interactions depends on your specific requirements and familiarity with different interfaces. MetaMask provides a familiar entry point for developers with Ethereum experience, while Talisman offers deeper integration with Polkadot's unique features and native support for both EVM and Substrate accounts. By properly configuring your wallet connection, you gain access to the full spectrum of Polkadot Hub's capabilities.\n\n!!!info\n    Remember to always verify network parameters when connecting to ensure a secure and reliable connection to the Polkadot ecosystem."}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 9, "end_char": 445, "estimated_token_count": 99, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[Dedot](https://github.com/dedotdev/dedot){target=\\_blank} is a next-generation JavaScript client for Polkadot and Polkadot SDK-based blockchains. Designed to elevate the dApp development experience, Dedot is built and optimized to be lightweight and tree-shakable, offering precise types and APIs suggestions for individual Polkadot SDK-based blockchains and [ink! smart contracts](https://use.ink/){target=\\_blank}."}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 1, "depth": 3, "title": "Key Features", "anchor": "key-features", "start_char": 445, "end_char": 1529, "estimated_token_count": 298, "token_estimator": "heuristic-v1", "text": "### Key Features\n\n- **Lightweight and tree-shakable**: No more bn.js or WebAssembly blobs, optimized for dapps bundle size.\n- **Fully typed API**: Comprehensive TypeScript support for seamless on-chain interaction and ink! smart contract integration.\n- **Multi-version JSON-RPC support**: Compatible with both [legacy](https://github.com/w3f/PSPs/blob/master/PSPs/drafts/psp-6.md){target=\\_blank} and [new](https://paritytech.github.io/json-rpc-interface-spec/introduction.html){target=\\_blank} JSON-RPC APIs for broad ecosystem interoperability.\n- **Light client support**: Designed to work with light clients such as [Smoldot](https://github.com/smol-dot/smoldot){target=\\_blank}.\n- **Native TypeScript for scale codec**: Implements scale codec parsing directly in TypeScript without relying on custom wrappers.\n- **Wallet integration**: Works out-of-the-box with [@polkadot/extension-based](https://github.com/polkadot-js/extension?tab=readme-ov-file#api-interface){target=\\_blank} wallets.\n- **Familiar API design**: Similar API style to Polkadot.js for easy and fast migration."}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 2, "depth": 2, "title": "Installation", "anchor": "installation", "start_char": 1529, "end_char": 2152, "estimated_token_count": 177, "token_estimator": "heuristic-v1", "text": "## Installation\n\nTo add Dedot to your project, use the following command:\n\n=== \"npm\"\n\n    ```bash\n    npm i dedot\n    ```\n\n=== \"pnpm\"\n\n    ```bash\n    pnpm add dedot\n    ```\n\n=== \"yarn\"\n\n    ```bash\n    yarn add dedot\n    ```\n\nTo enable auto-completion/IntelliSense for individual chains, install the [`@dedot/chaintypes`](https://www.npmjs.com/package/@dedot/chaintypes){target=\\_blank} package as a development dependency:\n\n=== \"npm\"\n\n    ```bash\n    npm i -D @dedot/chaintypes\n    ```\n\n=== \"pnpm\"\n\n    ```bash\n    pnpm add -D @dedot/chaintypes\n    ```\n\n=== \"yarn\"\n\n    ```bash\n    yarn add -D @dedot/chaintypes\n    ```"}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 3, "depth": 2, "title": "Get Started", "anchor": "get-started", "start_char": 2152, "end_char": 2168, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Get Started"}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 4, "depth": 3, "title": "Initialize a Client Instance", "anchor": "initialize-a-client-instance", "start_char": 2168, "end_char": 4242, "estimated_token_count": 522, "token_estimator": "heuristic-v1", "text": "### Initialize a Client Instance\n\nTo connect to and interact with different networks, Dedot provides two client options depending on your needs:\n\n- **[`DedotClient`](https://docs.dedot.dev/clients-and-providers/clients#dedotclient){target=\\_blank}**: Interacts with chains via the [new JSON-RPC APIs](https://paritytech.github.io/json-rpc-interface-spec/introduction.html){target=\\_blank}.\n- **[`LegacyClient`](https://docs.dedot.dev/clients-and-providers/clients#legacyclient){target=\\_blank}**: Interacts with chains via the [legacy JSON-RPC APIs](https://github.com/w3f/PSPs/blob/master/PSPs/drafts/psp-6.md){target=\\_blank}.\n\nUse the following snippets to connect to Polkadot using `DedotClient`:\n\n=== \"WebSocket\"\n\n    ```typescript\n    import { DedotClient, WsProvider } from 'dedot';\n    import type { PolkadotApi } from '@dedot/chaintypes';\n\n    // Initialize providers & clients\n    const provider = new WsProvider('wss://rpc.polkadot.io');\n    const client = await DedotClient.new<PolkadotApi>(provider);\n\n    ```\n\n=== \"Light Client (Smoldot)\"\n\n    ```typescript\n    import { DedotClient, SmoldotProvider } from 'dedot';\n    import type { PolkadotApi } from '@dedot/chaintypes';\n    import * as smoldot from 'smoldot';\n\n    // import `polkadot` chain spec to connect to Polkadot\n    import { polkadot } from '@substrate/connect-known-chains';\n\n    // Start smoldot instance & initialize a chain\n    const client = smoldot.start();\n    const chain = await client.addChain({ chainSpec: polkadot });\n\n    // Initialize providers & clients\n    const provider = new SmoldotProvider(chain);\n    const client = await DedotClient.new<PolkadotApi>(provider);\n\n    ```\n\nIf the node doesn't support new JSON-RPC APIs yet, you can connect to the network using the `LegacyClient`, which is built on top of the legacy JSON-RPC APIs.\n\n```typescript\nimport { LegacyClient, WsProvider } from 'dedot';\nimport type { PolkadotApi } from '@dedot/chaintypes';\n\nconst provider = new WsProvider('wss://rpc.polkadot.io');\nconst client = await LegacyClient.new<PolkadotApi>(provider);\n\n```"}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 5, "depth": 3, "title": "Enable Type and API Suggestions", "anchor": "enable-type-and-api-suggestions", "start_char": 4242, "end_char": 5662, "estimated_token_count": 377, "token_estimator": "heuristic-v1", "text": "### Enable Type and API Suggestions\n\nIt is recommended to specify the `ChainApi` interface (e.g., `PolkadotApi` in the example in the previous section) of the chain you want to interact with. This enables type and API suggestions/autocompletion for that particular chain (via IntelliSense). If you don't specify a `ChainApi` interface, a default `SubstrateApi` interface will be used.\n\n```typescript\nimport { DedotClient, WsProvider } from 'dedot';\nimport type { PolkadotApi, KusamaApi } from '@dedot/chaintypes';\n\nconst polkadotClient = await DedotClient.new<PolkadotApi>(\n  new WsProvider('wss://rpc.polkadot.io')\n);\nconst kusamaClient = await DedotClient.new<KusamaApi>(\n  new WsProvider('wss://kusama-rpc.polkadot.io')\n);\nconst genericClient = await DedotClient.new(\n  new WsProvider('ws://localhost:9944')\n);\n\n```\n\nIf you don't find the `ChainApi` for the network you're working with in [the list](https://github.com/dedotdev/chaintypes?tab=readme-ov-file#supported-networks){target=\\_blank}, you can generate the `ChainApi` (types and APIs) using the built-in [`dedot` cli](https://docs.dedot.dev/cli){target=\\_blank}.\n\n```bash\n# Generate ChainApi interface for Polkadot network via rpc endpoint: wss://rpc.polkadot.io\nnpx dedot chaintypes -w wss://rpc.polkadot.io\n```\n\nOr open a pull request to add your favorite network to the [`@dedot/chaintypes`](https://github.com/dedotdev/chaintypes){target=\\_blank} repo."}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 6, "depth": 3, "title": "Read On-Chain Data", "anchor": "read-on-chain-data", "start_char": 5662, "end_char": 6993, "estimated_token_count": 348, "token_estimator": "heuristic-v1", "text": "### Read On-Chain Data\n\nDedot provides several ways to read data from the chain:\n\n- **Access runtime constants**: Use the syntax `client.consts.<pallet>.<constantName>` to inspect runtime constants (parameter types).\n\n    ```typescript\n    const ss58Prefix = client.consts.system.ss58Prefix;\n    console.log('Polkadot ss58Prefix:', ss58Prefix);\n\n    ```\n\n- **Storage queries**: Use the syntax `client.query.<pallet>.<storgeEntry>` to query on-chain storage.\n\n    ```typescript\n    const balance = await client.query.system.account('INSERT_ADDRESS');\n    console.log('Balance:', balance.data.free);\n\n    ```\n\n- **Subscribe to storage changes**:\n\n    ```typescript\n    const unsub = await client.query.system.number((blockNumber) => {\n      console.log(`Current block number: ${blockNumber}`);\n    });\n\n    ```\n\n- **Call Runtime APIs**: Use the syntax `client.call.<runtimeApi>.<methodName>` to execute Runtime APIs.\n\n    ```typescript\n    const metadata = await client.call.metadata.metadataAtVersion(15);\n    console.log('Metadata V15', metadata);\n\n    ```\n\n- **Watch on-chain events**: Use the syntax `client.events.<pallet>.<eventName>` to access pallet events.\n    \n    ```typescript\n    const unsub = await client.events.system.NewAccount.watch((events) => {\n      console.log('New Account Created', events);\n    });\n\n    ```"}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 7, "depth": 3, "title": "Sign and Send Transactions", "anchor": "sign-and-send-transactions", "start_char": 6993, "end_char": 8719, "estimated_token_count": 439, "token_estimator": "heuristic-v1", "text": "### Sign and Send Transactions\n\nSign the transaction using `IKeyringPair` from Keyring ([`@polkadot/keyring`](https://polkadot.js.org/docs/keyring/start/sign-verify/){target=\\_blank}) and send the transaction.\n\n```typescript\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Keyring } from '@polkadot/keyring';\n// Setup keyring\nawait cryptoWaitReady();\nconst keyring = new Keyring({ type: 'sr25519' });\nconst alice = keyring.addFromUri('//Alice');\n// Send transaction\nconst unsub = await client.tx.balances\n  .transferKeepAlive('INSERT_DEST_ADDRESS', 2_000_000_000_000n)\n  .signAndSend(alice, async ({ status }) => {\n    console.log('Transaction status', status.type);\n    if (status.type === 'BestChainBlockIncluded') {\n      console.log(`Transaction is included in best block`);\n    }\n    if (status.type === 'Finalized') {\n      console.log(\n        `Transaction completed at block hash ${status.value.blockHash}`\n      );\n      await unsub();\n    }\n  });\n\n```\n\nYou can also use `Signer` from wallet extensions:\n\n```typescript\nconst injected = await window.injectedWeb3['polkadot-js'].enable('My dApp');\nconst account = (await injected.accounts.get())[0];\nconst signer = injected.signer;\nconst unsub = await client.tx.balances\n  .transferKeepAlive('INSERT_DEST_ADDRESS', 2_000_000_000_000n)\n  .signAndSend(account.address, { signer }, async ({ status }) => {\n    console.log('Transaction status', status.type);\n    if (status.type === 'BestChainBlockIncluded') {\n      console.log(`Transaction is included in best block`);\n    }\n    if (status.type === 'Finalized') {\n      console.log(\n        `Transaction completed at block hash ${status.value.blockHash}`\n      );\n      await unsub();\n    }\n  });\n\n```"}
{"page_id": "develop-toolkit-api-libraries-dedot", "page_title": "Dedot", "index": 8, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 8719, "end_char": 8855, "estimated_token_count": 36, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nFor more detailed information about Dedot, check the [official documentation](https://dedot.dev/){target=\\_blank}."}
{"page_id": "develop-toolkit-api-libraries-papi", "page_title": "Polkadot-API", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 16, "end_char": 1133, "estimated_token_count": 207, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[Polkadot-API](https://github.com/polkadot-api/polkadot-api){target=\\_blank} (PAPI) is a set of libraries built to be modular, composable, and grounded in a “light-client first” approach. Its primary aim is to equip dApp developers with an extensive toolkit for building fully decentralized applications.\n\nPAPI is optimized for light-client functionality, using the new JSON-RPC spec to support decentralized interactions fully. It provides strong TypeScript support with types and documentation generated directly from on-chain metadata, and it offers seamless access to storage reads, constants, transactions, events, and runtime calls. Developers can connect to multiple chains simultaneously and prepare for runtime updates through multi-descriptor generation and compatibility checks. PAPI is lightweight and performant, leveraging native BigInt, dynamic imports, and modular subpaths to avoid bundling unnecessary assets. It supports promise-based and observable-based APIs, integrates easily with Polkadot.js extensions, and offers signing options through browser extensions or private keys."}
{"page_id": "develop-toolkit-api-libraries-papi", "page_title": "Polkadot-API", "index": 1, "depth": 2, "title": "Get Started", "anchor": "get-started", "start_char": 1133, "end_char": 1149, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Get Started"}
{"page_id": "develop-toolkit-api-libraries-papi", "page_title": "Polkadot-API", "index": 2, "depth": 3, "title": "API Instantiation", "anchor": "api-instantiation", "start_char": 1149, "end_char": 6190, "estimated_token_count": 1162, "token_estimator": "heuristic-v1", "text": "### API Instantiation\n\nTo instantiate the API, you can install the package by using the following command:\n\n=== \"npm\"\n\n    ```bash\n    npm i polkadot-api@1.17.2\n    ```\n\n=== \"pnpm\"\n\n    ```bash\n    pnpm add polkadot-api@1.17.2\n    ```\n\n=== \"yarn\"\n\n    ```bash\n    yarn add polkadot-api@1.17.2\n    ```\n\nThen, obtain the latest metadata from the target chain and generate the necessary types:\n\n```bash\n# Add the target chain\nnpx papi add dot -n polkadot\n```\n\nThe `papi add` command initializes the library by generating the corresponding types needed for the chain used. It assigns the chain a custom name and specifies downloading metadata from the Polkadot chain. You can replace `dot` with the name you prefer or with another chain if you want to add a different one. Once the latest metadata is downloaded, generate the required types:\n\n```bash\n# Generate the necessary types\nnpx papi\n```\n\nYou can now set up a [`PolkadotClient`](https://github.com/polkadot-api/polkadot-api/blob/main/packages/client/src/types.ts#L153){target=\\_blank} with your chosen provider to begin interacting with the API. Choose from Smoldot via WebWorker, Node.js, or direct usage, or connect through the WSS provider. The examples below show how to configure each option for your setup.\n\n=== \"Smoldot (WebWorker)\"\n\n    ```typescript\n    // `dot` is the identifier assigned during `npx papi add`\n    import { dot } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { getSmProvider } from 'polkadot-api/sm-provider';\n    import { chainSpec } from 'polkadot-api/chains/polkadot';\n    import { startFromWorker } from 'polkadot-api/smoldot/from-worker';\n    import SmWorker from 'polkadot-api/smoldot/worker?worker';\n\n    const worker = new SmWorker();\n    const smoldot = startFromWorker(worker);\n    const chain = await smoldot.addChain({ chainSpec });\n\n    // Establish connection to the Polkadot relay chain\n    const client = createClient(getSmProvider(chain));\n\n    // To interact with the chain, obtain the `TypedApi`, which provides\n    // the necessary types for every API call on this chain\n    const dotApi = client.getTypedApi(dot);\n\n    ```\n\n=== \"Smoldot (Node.js)\"\n\n    ```typescript\n    // `dot` is the alias assigned during `npx papi add`\n    import { dot } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { getSmProvider } from 'polkadot-api/sm-provider';\n    import { chainSpec } from 'polkadot-api/chains/polkadot';\n    import { startFromWorker } from 'polkadot-api/smoldot/from-node-worker';\n    import { fileURLToPath } from 'url';\n    import { Worker } from 'worker_threads';\n\n    // Get the path for the worker file in ESM\n    const workerPath = fileURLToPath(\n      import.meta.resolve('polkadot-api/smoldot/node-worker'),\n    );\n\n    const worker = new Worker(workerPath);\n    const smoldot = startFromWorker(worker);\n    const chain = await smoldot.addChain({ chainSpec });\n\n    // Set up a client to connect to the Polkadot relay chain\n    const client = createClient(getSmProvider(chain));\n\n    // To interact with the chain's API, use `TypedApi` for access to\n    // all the necessary types and calls associated with this chain\n    const dotApi = client.getTypedApi(dot);\n\n    ```\n\n=== \"Smoldot\"\n\n    ```typescript\n    // `dot` is the alias assigned when running `npx papi add`\n    import { dot } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { getSmProvider } from 'polkadot-api/sm-provider';\n    import { chainSpec } from 'polkadot-api/chains/polkadot';\n    import { start } from 'polkadot-api/smoldot';\n\n    // Initialize Smoldot client\n    const smoldot = start();\n    const chain = await smoldot.addChain({ chainSpec });\n\n    // Set up a client to connect to the Polkadot relay chain\n    const client = createClient(getSmProvider(chain));\n\n    // Access the `TypedApi` to interact with all available chain calls and types\n    const dotApi = client.getTypedApi(dot);\n\n    ```\n\n=== \"WSS\"\n\n    ```typescript\n    // `dot` is the identifier assigned when executing `npx papi add`\n    import { dot } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    // Use this import for Node.js environments\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n\n    // Establish a connection to the Polkadot relay chain\n    const client = createClient(\n      // The Polkadot SDK nodes may have compatibility issues; using this enhancer is recommended.\n      // Refer to the Requirements page for additional details\n      withPolkadotSdkCompat(getWsProvider('wss://dot-rpc.stakeworld.io')),\n    );\n\n    // To interact with the chain, obtain the `TypedApi`, which provides\n    // the types for all available calls in that chain\n    const dotApi = client.getTypedApi(dot);\n\n    ```\n\nNow that you have set up the client, you can interact with the chain by reading and sending transactions."}
{"page_id": "develop-toolkit-api-libraries-papi", "page_title": "Polkadot-API", "index": 3, "depth": 3, "title": "Reading Chain Data", "anchor": "reading-chain-data", "start_char": 6190, "end_char": 7140, "estimated_token_count": 216, "token_estimator": "heuristic-v1", "text": "### Reading Chain Data\n\nThe `TypedApi` provides a streamlined way to read blockchain data through three main interfaces, each designed for specific data access patterns:\n\n- **Constants**: Access fixed values or configurations on the blockchain using the `constants` interface.\n\n    ```typescript\n    const version = await typedApi.constants.System.Version();\n    ```\n\n- **Storage queries**: Retrieve stored values by querying the blockchain’s storage via the `query` interface.\n\n    ```typescript\n    const asset = await api.query.ForeignAssets.Asset.getValue(\n      token.location,\n      { at: 'best' },\n    );\n    ```\n\n- **Runtime APIs**: Interact directly with runtime APIs using the `apis` interface.\n\n    ```typescript\n    const metadata = await typedApi.apis.Metadata.metadata();\n    ```\n\nTo learn more about the different actions you can perform with the `TypedApi`, refer to the [TypedApi reference](https://papi.how/typed){target=\\_blank}."}
{"page_id": "develop-toolkit-api-libraries-papi", "page_title": "Polkadot-API", "index": 4, "depth": 3, "title": "Sending Transactions", "anchor": "sending-transactions", "start_char": 7140, "end_char": 8815, "estimated_token_count": 355, "token_estimator": "heuristic-v1", "text": "### Sending Transactions\n\nIn PAPI, the `TypedApi` provides the `tx` and `txFromCallData` methods to send transactions. \n\n- The `tx` method allows you to directly send a transaction with the specified parameters by using the `typedApi.tx.Pallet.Call` pattern:\n\n    ```typescript\n    const tx: Transaction = typedApi.tx.Pallet.Call({arg1, arg2, arg3});\n    ``` \n\n    For instance, to execute the `balances.transferKeepAlive` call, you can use the following snippet:\n\n    ```typescript\n    import { MultiAddress } from '@polkadot-api/descriptors';\n\n    const tx: Transaction = typedApi.tx.Balances.transfer_keep_alive({\n      dest: MultiAddress.Id('INSERT_DESTINATION_ADDRESS'),\n      value: BigInt(INSERT_VALUE),\n    });\n\n    ```\n\n    Ensure you replace `INSERT_DESTINATION_ADDRESS` and `INSERT_VALUE` with the actual destination address and value, respectively.\n\n- The `txFromCallData` method allows you to send a transaction using the call data. This option accepts binary call data and constructs the transaction from it. It validates the input upon creation and will throw an error if invalid data is provided. The pattern is as follows:\n\n    ```typescript\n    const callData = Binary.fromHex('0x...');\n    const tx: Transaction = typedApi.txFromCallData(callData);\n    ``` \n\n    For instance, to execute a transaction using the call data, you can use the following snippet:\n\n    ```typescript\n    const callData = Binary.fromHex('0x00002470617065726d6f6f6e');\n    const tx: Transaction = typedApi.txFromCallData(callData);\n    ```\n\nFor more information about sending transactions, refer to the [Transactions](https://papi.how/typed/tx#transactions){target=\\_blank} page."}
{"page_id": "develop-toolkit-api-libraries-papi", "page_title": "Polkadot-API", "index": 5, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 8815, "end_char": 8957, "estimated_token_count": 43, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nFor an in-depth guide on how to use PAPI, refer to the official [PAPI](https://papi.how/){target=\\_blank} documentation."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 385, "end_char": 669, "estimated_token_count": 68, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [Polkadot.js API](https://github.com/polkadot-js/api){target=\\_blank} uses JavaScript/TypeScript to interact with Polkadot SDK-based chains. It allows you to query nodes, read chain state, and submit transactions through a dynamic, auto-generated API interface."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 1, "depth": 3, "title": "Dynamic API Generation", "anchor": "dynamic-api-generation", "start_char": 669, "end_char": 1033, "estimated_token_count": 85, "token_estimator": "heuristic-v1", "text": "### Dynamic API Generation\n\nUnlike traditional static APIs, the Polkadot.js API generates its interfaces automatically when connecting to a node. Here's what happens when you connect:\n\n1. The API connects to your node.\n2. It retrieves the chain's metadata.\n3. Based on this metadata, it creates specific endpoints in this format: `api.<type>.<module>.<section>`."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 2, "depth": 3, "title": "Available API Categories", "anchor": "available-api-categories", "start_char": 1033, "end_char": 1888, "estimated_token_count": 248, "token_estimator": "heuristic-v1", "text": "### Available API Categories\n\nYou can access three main categories of chain interactions:\n\n- **[Runtime constants](https://polkadot.js.org/docs/api/start/api.consts){target=\\_blank}** (`api.consts`):\n\n    - Access runtime constants directly.\n    - Returns values immediately without function calls.\n    - **Example**: `api.consts.balances.existentialDeposit`\n\n- **[State queries](https://polkadot.js.org/docs/api/start/api.query/){target=\\_blank}** (`api.query`):\n\n    - Read chain state.\n    - **Example**: `api.query.system.account(accountId)`\n\n- **[Transactions](https://polkadot.js.org/docs/api/start/api.tx/){target=\\_blank}** (`api.tx`):\n    - Submit extrinsics (transactions).\n    - **Example**: `api.tx.balances.transfer(accountId, value)`\n\nThe available methods and interfaces will automatically reflect what's possible on your connected chain."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 3, "depth": 2, "title": "Installation", "anchor": "installation", "start_char": 1888, "end_char": 2441, "estimated_token_count": 161, "token_estimator": "heuristic-v1", "text": "## Installation\n\nTo add the Polkadot.js API to your project, use the following command to install the version `16.4.7` which supports any Polkadot SDK-based chain:\n\n=== \"npm\"\n    ```bash\n    npm i @polkadot/api@16.4.7\n    ```\n\n=== \"pnpm\"\n    ```bash\n    pnpm add @polkadot/api@16.4.7\n    ```\n\n=== \"yarn\"\n    ```bash\n    yarn add @polkadot/api@16.4.7\n    ```\n\nFor more detailed information about installation, see the [Installation](https://polkadot.js.org/docs/api/start/install/){target=\\_blank} section in the official Polkadot.js API documentation."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 4, "depth": 2, "title": "Get Started", "anchor": "get-started", "start_char": 2441, "end_char": 2457, "estimated_token_count": 4, "token_estimator": "heuristic-v1", "text": "## Get Started"}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 5, "depth": 3, "title": "Creating an API Instance", "anchor": "creating-an-api-instance", "start_char": 2457, "end_char": 3226, "estimated_token_count": 175, "token_estimator": "heuristic-v1", "text": "### Creating an API Instance\n\nTo interact with a Polkadot SDK-based chain, you must establish a connection through an API instance. The API provides methods for querying chain state, sending transactions, and subscribing to updates.\n\nTo create an API connection:\n\n```js\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\n// Create a WebSocket provider\nconst wsProvider = new WsProvider('wss://rpc.polkadot.io');\n\n// Initialize the API\nconst api = await ApiPromise.create({ provider: wsProvider });\n\n// Verify the connection by getting the chain's genesis hash\nconsole.log('Genesis Hash:', api.genesisHash.toHex());\n\n```\n\n!!!warning\n    All `await` operations must be wrapped in an async function or block since the API uses promises for asynchronous operations."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 6, "depth": 3, "title": "Reading Chain Data", "anchor": "reading-chain-data", "start_char": 3226, "end_char": 4066, "estimated_token_count": 187, "token_estimator": "heuristic-v1", "text": "### Reading Chain Data\n\nThe API provides several ways to read data from the chain. You can access:\n\n- **Constants**: Values that are fixed in the runtime and don't change without a runtime upgrade.\n\n    ```js\n    // Get the minimum balance required for a new account\n    const minBalance = api.consts.balances.existentialDeposit.toNumber();\n\n    ```\n\n- **State**: Current chain state that updates with each block.\n\n    ```js\n    // Example address\n    const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFabHE';\n\n    // Get current timestamp\n    const timestamp = await api.query.timestamp.now();\n\n    // Get account information\n    const { nonce, data: balance } = await api.query.system.account(address);\n\n    console.log(`\n      Timestamp: ${timestamp}\n      Free Balance: ${balance.free}\n      Nonce: ${nonce}\n    `);\n\n    ```"}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 7, "depth": 3, "title": "Sending Transactions", "anchor": "sending-transactions", "start_char": 4066, "end_char": 4881, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "### Sending Transactions\n\nTransactions (also called extrinsics) modify the chain state. Before sending a transaction, you need:\n\n- A funded account with sufficient balance to pay transaction fees.\n- The account's keypair for signing.\n\nTo make a transfer:\n\n```js\n// Assuming you have an `alice` keypair from the Keyring\nconst recipient = 'INSERT_RECIPIENT_ADDRESS';\nconst amount = 'INSERT_VALUE'; // Amount in the smallest unit (e.g., Planck for DOT)\n\n// Sign and send a transfer\nconst txHash = await api.tx.balances\n  .transfer(recipient, amount)\n  .signAndSend(alice);\n\nconsole.log('Transaction Hash:', txHash);\n\n```\n\nThe `alice` keypair in the example comes from a `Keyring` object. For more details about managing keypairs, see the [Keyring documentation](https://polkadot.js.org/docs/keyring){target=\\_blank}."}
{"page_id": "develop-toolkit-api-libraries-polkadot-js-api", "page_title": "Polkadot.js API", "index": 8, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 4881, "end_char": 5042, "estimated_token_count": 44, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nFor more detailed information about the Polkadot.js API, check the [official documentation](https://polkadot.js.org/docs/){target=\\_blank}."}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 30, "end_char": 484, "estimated_token_count": 87, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [Python Substrate Interface](https://github.com/polkascan/py-substrate-interface){target=\\_blank} is a powerful library that enables interaction with Polkadot SDK-based chains. It provides essential functionality for:\n\n- Querying on-chain storage.\n- Composing and submitting extrinsics.\n- SCALE encoding/decoding.\n- Interacting with Substrate runtime metadata.\n- Managing blockchain interactions through convenient utility methods."}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 1, "depth": 2, "title": "Installation", "anchor": "installation", "start_char": 484, "end_char": 791, "estimated_token_count": 72, "token_estimator": "heuristic-v1", "text": "## Installation\n\nInstall the library using `pip`:\n\n```py\npip install substrate-interface\n```\n\nFor more installation details, see the [Installation](https://jamdottech.github.io/py-polkadot-sdk/getting-started/installation/){target=\\_blank} section in the official Python Substrate Interface documentation."}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 2, "depth": 2, "title": "Get Started", "anchor": "get-started", "start_char": 791, "end_char": 971, "estimated_token_count": 32, "token_estimator": "heuristic-v1", "text": "## Get Started\n\nThis guide will walk you through the basic operations with the Python Substrate Interface: connecting to a node, reading chain state, and submitting transactions."}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 3, "depth": 3, "title": "Establishing Connection", "anchor": "establishing-connection", "start_char": 971, "end_char": 1488, "estimated_token_count": 130, "token_estimator": "heuristic-v1", "text": "### Establishing Connection\n\nThe first step is to establish a connection to a Polkadot SDK-based node. You can connect to either a local or remote node:\n\n```py\nfrom substrateinterface import SubstrateInterface\n\n# Connect to a node using websocket\nsubstrate = SubstrateInterface(\n    # For local node: \"ws://127.0.0.1:9944\"\n    # For Polkadot: \"wss://rpc.polkadot.io\"\n    # For Kusama: \"wss://kusama-rpc.polkadot.io\"\n    url=\"INSERT_WS_URL\"\n)\n\n# Verify connection\nprint(f\"Connected to chain: {substrate.chain}\")\n\n```"}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 4, "depth": 3, "title": "Reading Chain State", "anchor": "reading-chain-state", "start_char": 1488, "end_char": 2506, "estimated_token_count": 242, "token_estimator": "heuristic-v1", "text": "### Reading Chain State\n\nYou can query various on-chain storage items. To retrieve data, you need to specify three key pieces of information:\n\n- **Pallet name**: Module or pallet that contains the storage item you want to access.\n- **Storage item**: Specific storage entry you want to query within the pallet.\n- **Required parameters**: Any parameters needed to retrieve the desired data.\n\nHere's an example of how to check an account's balance and other details:\n\n```py\n# ...\n\n# Query account balance and info\naccount_info = substrate.query(\n    module=\"System\",  # The pallet name\n    storage_function=\"Account\",  # The storage item\n    params=[\"INSERT_ADDRESS\"],  # Account address in SS58 format\n)\n\n# Access account details from the result\nfree_balance = account_info.value[\"data\"][\"free\"]\nreserved = account_info.value[\"data\"][\"reserved\"]\nnonce = account_info.value[\"nonce\"]\n\nprint(\n    f\"\"\"\n    Account Details:\n    - Free Balance: {free_balance}\n    - Reserved: {reserved} \n    - Nonce: {nonce}\n    \"\"\"\n)\n\n```"}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 5, "depth": 3, "title": "Submitting Transactions", "anchor": "submitting-transactions", "start_char": 2506, "end_char": 3899, "estimated_token_count": 294, "token_estimator": "heuristic-v1", "text": "### Submitting Transactions\n\nTo modify the chain state, you need to submit transactions (extrinsics). Before proceeding, ensure you have:\n\n- A funded account with sufficient balance to pay transaction fees.\n- Access to the account's keypair.\n\nHere's how to create and submit a balance transfer:\n\n```py\n#...\n\n# Compose the transfer call\ncall = substrate.compose_call(\n    call_module=\"Balances\",  # The pallet name\n    call_function=\"transfer_keep_alive\",  # The extrinsic function\n    call_params={\n        'dest': 'INSERT_ADDRESS',  # Recipient's address\n        'value': 'INSERT_VALUE'  # Amount in smallest unit (e.g., Planck for DOT)\n    }\n)\n\n# Create a signed extrinsic\nextrinsic = substrate.create_signed_extrinsic(\n    call=call, keypair=keypair  # Your keypair for signing\n)\n\n# Submit and wait for inclusion\nreceipt = substrate.submit_extrinsic(\n    extrinsic, wait_for_inclusion=True  # Wait until the transaction is in a block\n)\n\nif receipt.is_success:\n    print(\n        f\"\"\"\n        Transaction successful:\n        - Extrinsic Hash: {receipt.extrinsic_hash}\n        - Block Hash: {receipt.block_hash}\n        \"\"\"\n    )\nelse:\n    print(f\"Transaction failed: {receipt.error_message}\")\n\n```\n\nThe `keypair` object is essential for signing transactions. See the [Keypair](https://jamdottech.github.io/py-polkadot-sdk/reference/keypair/){target=\\_blank} documentation for more details."}
{"page_id": "develop-toolkit-api-libraries-py-substrate-interface", "page_title": "Python Substrate Interface", "index": 6, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 3899, "end_char": 4302, "estimated_token_count": 85, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you understand the basics, you can:\n\n- Explore more complex queries and transactions.\n- Learn about batch transactions and utility functions.\n- Discover how to work with custom pallets and types.\n\nFor comprehensive reference materials and advanced features, see the [Python Substrate Interface](https://jamdottech.github.io/py-polkadot-sdk/){target=\\_blank} documentation."}
{"page_id": "develop-toolkit-api-libraries-sidecar", "page_title": "Sidecar Rest API", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 15, "end_char": 1185, "estimated_token_count": 228, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe [Sidecar Rest API](https://github.com/paritytech/substrate-api-sidecar){target=\\_blank} is a service that provides a REST interface for interacting with Polkadot SDK-based blockchains. With this API, developers can easily access a broad range of endpoints for nodes, accounts, transactions, parachains, and more.\n\nSidecar functions as a caching layer between your application and a Polkadot SDK-based node, offering standardized REST endpoints that simplify interactions without requiring complex, direct RPC calls. This approach is especially valuable for developers who prefer REST APIs or build applications in languages with limited WebSocket support.\n\nSome of the key features of the Sidecar API include:\n\n- **REST API interface**: Provides a familiar REST API interface for interacting with Polkadot SDK-based chains.\n- **Standardized endpoints**: Offers consistent endpoint formats across different chain implementations.\n- **Caching layer**: Acts as a caching layer to improve performance and reduce direct node requests.\n- **Multiple chain support**: Works with any Polkadot SDK-based chain, including Polkadot, Kusama, and custom chains."}
{"page_id": "develop-toolkit-api-libraries-sidecar", "page_title": "Sidecar Rest API", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1185, "end_char": 1484, "estimated_token_count": 80, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nSidecar API requires Node.js version 18.14 LTS or higher. Verify your Node.js version:\n\n```bash\nnode --version\n```\n\nIf you need to install or update Node.js, visit the [official Node.js website](https://nodejs.org/){target=\\_blank} to download and install the latest LTS version."}
{"page_id": "develop-toolkit-api-libraries-sidecar", "page_title": "Sidecar Rest API", "index": 2, "depth": 2, "title": "Installation", "anchor": "installation", "start_char": 1484, "end_char": 2137, "estimated_token_count": 171, "token_estimator": "heuristic-v1", "text": "## Installation\n\nTo install Substrate API Sidecar, use one of the following commands:\n\n=== \"npm\"\n\n    ```bash\n    npm install -g @substrate/api-sidecar\n    ```\n\n=== \"pnpm\"\n\n    ```bash\n    pnpm install -g @substrate/api-sidecar\n    ```\n\n=== \"yarn\"\n\n    ```bash\n    yarn global add @substrate/api-sidecar\n    ```\n\nYou can confirm the installation by running:\n\n```bash\nsubstrate-api-sidecar --version\n```\n\nFor more information about the Sidecar API installation, see the [installation and usage](https://github.com/paritytech/substrate-api-sidecar?tab=readme-ov-file#npm-package-installation-and-usage){target=\\_blank} section of the Sidecar API README."}
{"page_id": "develop-toolkit-api-libraries-sidecar", "page_title": "Sidecar Rest API", "index": 3, "depth": 2, "title": "Usage", "anchor": "usage", "start_char": 2137, "end_char": 5688, "estimated_token_count": 1005, "token_estimator": "heuristic-v1", "text": "## Usage\n\nTo use the Sidecar API, you have two options:\n\n- **Local node**: Run a node locally, which Sidecar will connect to by default, requiring no additional configuration. To start, run the following:\n\n    ```bash\n    substrate-api-sidecar\n    ```\n\n- **Remote node**: Connect Sidecar to a remote node by specifying the RPC endpoint for that chain. For example, to gain access to the Polkadot Asset Hub associated endpoints.\n\n    ```bash\n    SAS_SUBSTRATE_URL=wss://polkadot-asset-hub-rpc.polkadot.io substrate-api-sidecar\n    ```\n\n    For more configuration details, see the [Configuration](https://github.com/paritytech/substrate-api-sidecar?tab=readme-ov-file#configuration){target=\\_blank} section of the Sidecar API documentation.\n\nOnce the Sidecar API is running, you’ll see output similar to this:\n\n<div id=\"termynal\" data-termynal>\n    <span data-ty='input'><span class='file-path'></span>SAS_SUBSTRATE_URL=wss://polkadot-asset-hub-rpc.polkadot.io substrate-api-sidecar</span>\n    <br>\n    <span data-ty>SAS:</span>\n    <span data-ty>📦 LOG:</span>\n    <span data-ty>   ✅ LEVEL: \"info\"</span>\n    <span data-ty>   ✅ JSON: false</span>\n    <span data-ty>   ✅ FILTER_RPC: false</span>\n    <span data-ty>   ✅ STRIP_ANSI: false</span>\n    <span data-ty>   ✅ WRITE: false</span>\n    <span data-ty>   ✅ WRITE_PATH: \"/opt/homebrew/lib/node_modules/@substrate/api-sidecar/build/src/logs\"</span>\n    <span data-ty>   ✅ WRITE_MAX_FILE_SIZE: 5242880</span>\n    <span data-ty>   ✅ WRITE_MAX_FILES: 5</span>\n    <span data-ty>📦 SUBSTRATE:</span>\n    <span data-ty>   ✅ URL: \"wss://polkadot-asset-hub-rpc.polkadot.io\"</span>\n    <span data-ty>   ✅ TYPES_BUNDLE: undefined</span>\n    <span data-ty>   ✅ TYPES_CHAIN: undefined</span>\n    <span data-ty>   ✅ TYPES_SPEC: undefined</span>\n    <span data-ty>   ✅ TYPES: undefined</span>\n    <span data-ty>   ✅ CACHE_CAPACITY: undefined</span>\n    <span data-ty>📦 EXPRESS:</span>\n    <span data-ty>   ✅ BIND_HOST: \"127.0.0.1\"</span>\n    <span data-ty>   ✅ PORT: 8080</span>\n    <span data-ty>   ✅ KEEP_ALIVE_TIMEOUT: 5000</span>\n    <span data-ty>📦 METRICS:</span>\n    <span data-ty>   ✅ ENABLED: false</span>\n    <span data-ty>   ✅ PROM_HOST: \"127.0.0.1\"</span>\n    <span data-ty>   ✅ PROM_PORT: 9100</span>\n    <span data-ty>   ✅ LOKI_HOST: \"127.0.0.1\"</span>\n    <span data-ty>   ✅ LOKI_PORT: 3100</span>\n    <span data-ty>   ✅ INCLUDE_QUERYPARAMS: false</span>\n    <br>\n    <span data-ty>2024-11-06 08:06:01 info: Version: 19.3.0</span>\n    <span data-ty>2024-11-06 08:06:02 warn: API/INIT: RPC methods not decorated: chainHead_v1_body, chainHead_v1_call, chainHead_v1_continue, chainHead_v1_follow, chainHead_v1_header, chainHead_v1_stopOperation, chainHead_v1_storage, chainHead_v1_unfollow, chainHead_v1_unpin, chainSpec_v1_chainName, chainSpec_v1_genesisHash, chainSpec_v1_properties, transactionWatch_v1_submitAndWatch, transactionWatch_v1_unwatch, transaction_v1_broadcast, transaction_v1_stop</span>\n    <span data-ty>2024-11-06 08:06:02 info: Connected to chain Polkadot Asset Hub on the statemint client at wss://polkadot-asset-hub-rpc.polkadot.io</span>\n    <span data-ty>2024-11-06 08:06:02 info: Listening on http://127.0.0.1:8080/</span>\n    <span data-ty>2024-11-06 08:06:02 info: Check the root endpoint (http://127.0.0.1:8080/) to see the available endpoints for the current node</span>\n</div>\nWith Sidecar running, you can access the exposed endpoints via a browser, [`Postman`](https://www.postman.com/){target=\\_blank}, [`curl`](https://curl.se/){target=\\_blank}, or your preferred tool."}
{"page_id": "develop-toolkit-api-libraries-sidecar", "page_title": "Sidecar Rest API", "index": 4, "depth": 3, "title": "Endpoints", "anchor": "endpoints", "start_char": 5688, "end_char": 7028, "estimated_token_count": 394, "token_estimator": "heuristic-v1", "text": "### Endpoints\n\nSidecar API provides a set of REST endpoints that allow you to query different aspects of the chain, including blocks, accounts, and transactions. Each endpoint offers specific insights into the chain’s state and activities.\n\nFor example, to retrieve the version of the node, use the `/node/version` endpoint:\n\n```bash\ncurl -X 'GET' \\\n  'http://127.0.0.1:8080/node/version' \\\n  -H 'accept: application/json'\n```\n\nAlternatively, you can access `http://127.0.0.1:8080/node/version` directly in a browser since it’s a `GET` request.\n\nIn response, you’ll see output similar to this (assuming you’re connected to Polkadot Asset Hub):\n\n<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\"><span class=\"file-path\"></span>curl -X 'GET' 'http://127.0.0.1:8080/node/version' -H 'accept: application/json'</span>\n    <br>\n    <span data-ty>{</span>\n    <span data-ty>    \"clientVersion\": \"1.16.1-835e0767fe8\",</span>\n    <span data-ty>    \"clientImplName\": \"statemint\",</span>\n    <span data-ty>    \"chain\": \"Polkadot Asset Hub\"</span>\n    <span data-ty>}</span>\n</div>\nFor a complete list of available endpoints and their documentation, visit the [Sidecar API list endpoints](https://paritytech.github.io/substrate-api-sidecar/dist/){target=\\_blank}. You can learn about the endpoints and how to use them in your applications."}
{"page_id": "develop-toolkit-api-libraries-sidecar", "page_title": "Sidecar Rest API", "index": 5, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 7028, "end_char": 7309, "estimated_token_count": 67, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nTo dive deeper, refer to the [official Sidecar documentation](https://github.com/paritytech/substrate-api-sidecar?tab=readme-ov-file#substrateapi-sidecar){target=\\_blank}. This provides a comprehensive guide to the available configurations and advanced usage."}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 18, "end_char": 403, "estimated_token_count": 68, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nSubxt is a Rust library designed to interact with Polkadot SDK-based blockchains. It provides a type-safe interface for submitting transactions, querying on-chain state, and performing other blockchain interactions. By leveraging Rust's strong type system, subxt ensures that your code is validated at compile time, reducing runtime errors and improving reliability."}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 403, "end_char": 734, "estimated_token_count": 80, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore using subxt, ensure you have the following requirements:\n\n- Rust and Cargo installed on your system. You can install them using [Rustup](https://rustup.rs/){target=\\_blank}.\n- A Rust project initialized. If you don't have one, create it with:\n    ```bash\n    cargo new my_project && cd my_project\n    ```"}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 2, "depth": 2, "title": "Installation", "anchor": "installation", "start_char": 734, "end_char": 2796, "estimated_token_count": 510, "token_estimator": "heuristic-v1", "text": "## Installation\n\nTo use subxt in your project, you must install the necessary dependencies. Each plays a specific role in enabling interaction with the blockchain:\n\n1. **Install the subxt CLI**: [`subxt-cli`](https://crates.io/crates/subxt-cli){target=\\_blank} is a command-line tool that provides utilities for working with Polkadot SDK metadata. In the context of subxt, it is essential to download chain metadata, which is required to generate type-safe Rust interfaces for interacting with the blockchain. Install it using the following:\n\n    ```bash\n    cargo install subxt-cli@0.44.0\n    ```\n\n2. **Add core dependencies**: These dependencies are essential for interacting with the blockchain.\n\n    - **[subxt](https://crates.io/crates/subxt){target=\\_blank}**: The main library for communicating with Polkadot SDK nodes. It handles RPC requests, encoding/decoding, and type generation.\n\n        ```bash\n        cargo add subxt@0.44.0\n        ```\n\n    - **[subxt-signer](https://crates.io/crates/subxt-signer){target=\\_blank}**: Provides cryptographic functionality for signing transactions. Without this, you can only read data but cannot submit transactions.\n\n        ```bash\n        cargo add subxt-signer@0.44.0\n        ```\n\n    - **[tokio](https://crates.io/crates/tokio){target=\\_blank}**: An asynchronous runtime for Rust. Since blockchain operations are async, Tokio enables the efficient handling of network requests. The `rt` feature enables Tokio's runtime, including the current-thread single-threaded scheduler, which is necessary for async execution. The `macros` feature provides procedural macros like `#[tokio::main]` to simplify runtime setup.\n\n        ```bash\n        cargo add tokio@1.44.2 --features rt,macros\n        ```\n\n    After adding the dependencies, your `Cargo.toml` should look like this:\n\n    ```toml\n    [package]\n    name = \"my_project\"\n    version = \"0.1.0\"\n    edition = \"2021\"\n\n    [dependencies]\n    subxt = \"0.41.0\"\n    subxt-signer = \"0.41.0\"\n    tokio = { version = \"1.44.2\", features = [\"rt\", \"macros\"] }\n\n    ```"}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 3, "depth": 2, "title": "Get Started", "anchor": "get-started", "start_char": 2796, "end_char": 2973, "estimated_token_count": 29, "token_estimator": "heuristic-v1", "text": "## Get Started\n\nThis guide will walk you through the fundamental operations of subxt, from setting up your environment to executing transactions and querying blockchain state."}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 4, "depth": 3, "title": "Download Chain Metadata", "anchor": "download-chain-metadata", "start_char": 2973, "end_char": 3364, "estimated_token_count": 78, "token_estimator": "heuristic-v1", "text": "### Download Chain Metadata\n\nBefore interacting with a blockchain, you need to retrieve its metadata. This metadata defines storage structures, extrinsics, and other runtime details. Use the `subxt-cli` tool to download the metadata, replacing `INSERT_NODE_URL` with the URL of the node you want to interact with:\n\n```bash\nsubxt metadata --url INSERT_NODE_URL > polkadot_metadata.scale\n```"}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 5, "depth": 3, "title": "Generate Type-Safe Interfaces", "anchor": "generate-type-safe-interfaces", "start_char": 3364, "end_char": 5229, "estimated_token_count": 529, "token_estimator": "heuristic-v1", "text": "### Generate Type-Safe Interfaces\n\nUse the `#[subxt::subxt]` macro to generate a type-safe Rust interface from the downloaded metadata:\n\n```rust\n// Generate an interface that we can use from the node's metadata.\n#[subxt::subxt(runtime_metadata_path = \"./polkadot_metadata.scale\")]\npub mod polkadot {}\n```\n\nOnce subxt interfaces are generated, you can interact with your node in the following ways. You can use the links below to view the related subxt documentation:\n\n- **[Transactions](https://docs.rs/subxt/latest/subxt/book/usage/transactions/index.html){target=\\_blank}**: Builds and submits transactions, monitors their inclusion in blocks, and retrieves associated events.\n- **[Storage](https://docs.rs/subxt/latest/subxt/book/usage/storage/index.html){target=\\_blank}**: Enables querying of node storage data.\n- **[Events](https://docs.rs/subxt/latest/subxt/book/usage/events/index.html){target=\\_blank}**: Retrieves events emitted from recent blocks.\n- **[Constants](https://docs.rs/subxt/latest/subxt/book/usage/constants/index.html){target=\\_blank}**: Accesses constant values stored in nodes that remain unchanged across a specific runtime version.\n- **[Blocks](https://docs.rs/subxt/latest/subxt/book/usage/blocks/index.html){target=\\_blank}**: Loads recent blocks or subscribes to new/finalized blocks, allowing examination of extrinsics, events, and storage at those blocks.\n- **[Runtime APIs](https://docs.rs/subxt/latest/subxt/book/usage/runtime_apis/index.html){target=\\_blank}**: Makes calls into pallet runtime APIs to fetch data.\n- **[Custom values](https://docs.rs/subxt/latest/subxt/book/usage/custom_values/index.html){target=\\_blank}**: Accesses \"custom values\" contained within metadata.\n- **[Raw RPC calls](https://docs.rs/subxt/latest/subxt/book/usage/rpc/index.html){target=\\_blank}**: Facilitates raw RPC requests to compatible nodes."}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 6, "depth": 3, "title": "Initialize the Subxt Client", "anchor": "initialize-the-subxt-client", "start_char": 5229, "end_char": 8052, "estimated_token_count": 665, "token_estimator": "heuristic-v1", "text": "### Initialize the Subxt Client\n\nTo interact with a blockchain node using subxt, create an asynchronous main function and initialize the client. Replace `INSERT_NODE_URL` with the URL of your target node:\n\n```rust\nuse std::str::FromStr;\nuse subxt::utils::AccountId32;\nuse subxt::{OnlineClient, PolkadotConfig};\nuse subxt_signer::{bip39::Mnemonic,sr25519::Keypair};\n\n// Generate an interface that we can use from the node's metadata.\n#[subxt::subxt(runtime_metadata_path = \"./polkadot_metadata.scale\")]\npub mod polkadot {}\n\n#[tokio::main(flavor = \"current_thread\")]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Define the node URL.\n    const NODE_URL: &str = \"INSERT_NODE_URL\";\n\n    // Initialize the Subxt client to interact with the blockchain.\n    let api = OnlineClient::<PolkadotConfig>::from_url(NODE_URL).await?;\n\n    // A query to obtain some constant.\n    let constant_query = polkadot::constants().balances().existential_deposit();\n\n    // Obtain the value.\n    let value = api.constants().at(&constant_query)?;\n\n    println!(\"Existential deposit: {:?}\", value);\n\n    // Define the target account address.\n    const ADDRESS: &str = \"INSERT_ADDRESS\";\n    let account = AccountId32::from_str(ADDRESS).unwrap();\n\n    // Build a storage query to access account information.\n    let storage_query = polkadot::storage().system().account(&account.into());\n\n    // Fetch the latest state for the account.\n    let result = api\n        .storage()\n        .at_latest()\n        .await?\n        .fetch(&storage_query)\n        .await?\n        .unwrap();\n\n    println!(\"Account info: {:?}\", result);\n\n    // Define the recipient address and transfer amount.\n    const DEST_ADDRESS: &str = \"INSERT_DEST_ADDRESS\";\n    const AMOUNT: u128 = INSERT_AMOUNT;\n\n    // Convert the recipient address into an `AccountId32`.\n    let dest = AccountId32::from_str(DEST_ADDRESS).unwrap();\n\n    // Build the balance transfer extrinsic.\n    let balance_transfer_tx = polkadot::tx()\n        .balances()\n        .transfer_allow_death(dest.into(), AMOUNT);\n\n    // Load the sender's keypair from a mnemonic phrase.\n    const SECRET_PHRASE: &str = \"INSERT_SECRET_PHRASE\";\n    let mnemonic = Mnemonic::parse(SECRET_PHRASE).unwrap();\n    let sender_keypair = Keypair::from_phrase(&mnemonic, None).unwrap();\n\n    // Sign and submit the extrinsic, then wait for it to be finalized.\n    let events = api\n        .tx()\n        .sign_and_submit_then_watch_default(&balance_transfer_tx, &sender_keypair)\n        .await?\n        .wait_for_finalized_success()\n        .await?;\n\n    // Check for a successful transfer event.\n    if let Some(event) = events.find_first::<polkadot::balances::events::Transfer>()? {\n        println!(\"Balance transfer successful: {:?}\", event);\n    }\n\n    Ok(())\n}\n    // Your code here...\n\n    Ok(())\n}\n```"}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 7, "depth": 3, "title": "Read Chain Data", "anchor": "read-chain-data", "start_char": 8052, "end_char": 9407, "estimated_token_count": 296, "token_estimator": "heuristic-v1", "text": "### Read Chain Data\n\nsubxt provides multiple ways to access on-chain data:\n\n- **Constants**: Constants are predefined values in the runtime that remain unchanged unless modified by a runtime upgrade.\n\n    For example, to retrieve the existential deposit, use:\n    \n    ```rust\n        // A query to obtain some constant.\n        let constant_query = polkadot::constants().balances().existential_deposit();\n\n        // Obtain the value.\n        let value = api.constants().at(&constant_query)?;\n\n        println!(\"Existential deposit: {:?}\", value);\n    ```\n\n- **State**: State refers to the current chain data, which updates with each block.\n\n    To fetch account information, replace `INSERT_ADDRESS` with the address you want to fetch data from and use:\n\n    ```rust\n        // Define the target account address.\n        const ADDRESS: &str = \"INSERT_ADDRESS\";\n        let account = AccountId32::from_str(ADDRESS).unwrap();\n\n        // Build a storage query to access account information.\n        let storage_query = polkadot::storage().system().account(&account.into());\n\n        // Fetch the latest state for the account.\n        let result = api\n            .storage()\n            .at_latest()\n            .await?\n            .fetch(&storage_query)\n            .await?\n            .unwrap();\n\n        println!(\"Account info: {:?}\", result);\n    ```"}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 8, "depth": 3, "title": "Submit Transactions", "anchor": "submit-transactions", "start_char": 9407, "end_char": 10881, "estimated_token_count": 311, "token_estimator": "heuristic-v1", "text": "### Submit Transactions\n\nTo submit a transaction, you must construct an extrinsic, sign it with your private key, and send it to the blockchain. Replace `INSERT_DEST_ADDRESS` with the recipient's address, `INSERT_AMOUNT` with the amount to transfer, and `INSERT_SECRET_PHRASE` with the sender's mnemonic phrase:\n\n```rust\n    // Define the recipient address and transfer amount.\n    const DEST_ADDRESS: &str = \"INSERT_DEST_ADDRESS\";\n    const AMOUNT: u128 = INSERT_AMOUNT;\n\n    // Convert the recipient address into an `AccountId32`.\n    let dest = AccountId32::from_str(DEST_ADDRESS).unwrap();\n\n    // Build the balance transfer extrinsic.\n    let balance_transfer_tx = polkadot::tx()\n        .balances()\n        .transfer_allow_death(dest.into(), AMOUNT);\n\n    // Load the sender's keypair from a mnemonic phrase.\n    const SECRET_PHRASE: &str = \"INSERT_SECRET_PHRASE\";\n    let mnemonic = Mnemonic::parse(SECRET_PHRASE).unwrap();\n    let sender_keypair = Keypair::from_phrase(&mnemonic, None).unwrap();\n\n    // Sign and submit the extrinsic, then wait for it to be finalized.\n    let events = api\n        .tx()\n        .sign_and_submit_then_watch_default(&balance_transfer_tx, &sender_keypair)\n        .await?\n        .wait_for_finalized_success()\n        .await?;\n\n    // Check for a successful transfer event.\n    if let Some(event) = events.find_first::<polkadot::balances::events::Transfer>()? {\n        println!(\"Balance transfer successful: {:?}\", event);\n    }\n```"}
{"page_id": "develop-toolkit-api-libraries-subxt", "page_title": "Subxt Rust API", "index": 9, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 10881, "end_char": 11111, "estimated_token_count": 57, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\nNow that you've covered the basics dive into the official [subxt documentation](https://docs.rs/subxt/latest/subxt/book/index.html){target=\\_blank} for comprehensive reference materials and advanced features."}
{"page_id": "develop-toolkit-integrations-indexers", "page_title": "Indexers", "index": 0, "depth": 2, "title": "The Challenge of Blockchain Data Access", "anchor": "the-challenge-of-blockchain-data-access", "start_char": 12, "end_char": 649, "estimated_token_count": 103, "token_estimator": "heuristic-v1", "text": "## The Challenge of Blockchain Data Access\n\nBlockchain data is inherently sequential and distributed, with information stored chronologically across numerous blocks. While retrieving data from a single block through JSON-RPC API calls is straightforward, more complex queries that span multiple blocks present significant challenges:\n\n- Data is scattered and unorganized across the blockchain.\n- Retrieving large datasets can take days or weeks to sync.\n- Complex operations (like aggregations, averages, or cross-chain queries) require additional processing.\n- Direct blockchain queries can impact dApp performance and responsiveness."}
{"page_id": "develop-toolkit-integrations-indexers", "page_title": "Indexers", "index": 1, "depth": 2, "title": "What is a Blockchain Indexer?", "anchor": "what-is-a-blockchain-indexer", "start_char": 649, "end_char": 1211, "estimated_token_count": 108, "token_estimator": "heuristic-v1", "text": "## What is a Blockchain Indexer?\n\nA blockchain indexer is a specialized infrastructure tool that processes, organizes, and stores blockchain data in an optimized format for efficient querying. Think of it as a search engine for blockchain data that:\n\n- Continuously monitors the blockchain for new blocks and transactions.\n- Processes and categorizes this data according to predefined schemas.\n- Stores the processed data in an easily queryable database.\n- Provides efficient APIs (typically [GraphQL](https://graphql.org/){target=\\_blank}) for data retrieval."}
{"page_id": "develop-toolkit-integrations-indexers", "page_title": "Indexers", "index": 2, "depth": 2, "title": "Indexer Implementations", "anchor": "indexer-implementations", "start_char": 1211, "end_char": 2230, "estimated_token_count": 217, "token_estimator": "heuristic-v1", "text": "## Indexer Implementations\n\n<div class=\"grid cards\" markdown>\n\n-   __Subsquid__\n\n    ---\n\n    Subsquid is a data network that allows rapid and cost-efficient retrieval of blockchain data from 100+ chains using Subsquid's decentralized data lake and open-source SDK. In simple terms, Subsquid can be considered an ETL (extract, transform, and load) tool with a GraphQL server included. It enables comprehensive filtering, pagination, and even full-text search capabilities. Subsquid has native and full support for EVM and Substrate data, even within the same project.\n\n    [:octicons-arrow-right-24: Reference](https://www.sqd.ai/){target=\\_blank}\n\n-   __Subquery__\n\n    ---\n\n    SubQuery is a fast, flexible, and reliable open-source data decentralised infrastructure network that provides both RPC and indexed data to consumers worldwide.\n    It provides custom APIs for your web3 project across multiple supported chains.\n\n    [:octicons-arrow-right-24: Reference](https://subquery.network/){target=\\_blank}\n\n</div>"}
{"page_id": "develop-toolkit-integrations-oracles", "page_title": "Oracles", "index": 0, "depth": 2, "title": "What is a Blockchain Oracle?", "anchor": "what-is-a-blockchain-oracle", "start_char": 11, "end_char": 749, "estimated_token_count": 125, "token_estimator": "heuristic-v1", "text": "## What is a Blockchain Oracle?\n\nOracles enable blockchains to access external data sources. Since blockchains operate as isolated networks, they cannot natively interact with external systems - this limitation is known as the \"blockchain oracle problem.\" Oracles solves this by extracting data from external sources (like APIs, IoT devices, or other blockchains), validating it, and submitting it on-chain.\n\nWhile simple oracle implementations may rely on a single trusted provider, more sophisticated solutions use decentralized networks where multiple providers stake assets and reach consensus on data validity. Typical applications include DeFi price feeds, weather data for insurance contracts, and cross-chain asset verification."}
{"page_id": "develop-toolkit-integrations-oracles", "page_title": "Oracles", "index": 1, "depth": 2, "title": "Oracle Implementations", "anchor": "oracle-implementations", "start_char": 749, "end_char": 1343, "estimated_token_count": 120, "token_estimator": "heuristic-v1", "text": "## Oracle Implementations\n\n<div class=\"grid cards\" markdown>\n\n-   __Acurast__\n\n    ---\n\n    Acurast is a decentralized, serverless cloud platform that uses a distributed network of mobile devices for oracle services, addressing centralized trust and data ownership issues. In the Polkadot ecosystem, it allows developers to define off-chain data and computation needs, which are processed by these devices acting as decentralized oracle nodes, delivering results to Substrate (Wasm) and EVM environments.\n\n    [:octicons-arrow-right-24: Reference](https://acurast.com/){target=\\_blank}\n\n</div>"}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 0, "depth": 2, "title": "Key Storage Solutions", "anchor": "key-storage-solutions", "start_char": 398, "end_char": 1036, "estimated_token_count": 138, "token_estimator": "heuristic-v1", "text": "## Key Storage Solutions\n\nBy leveraging decentralized storage, you can enhance the security, reliability, and censorship resistance of your dApps. Polkadot's ecosystem provides several options, enabling you to select the best fit for your specific needs.\n\nSome of the storage solutions available for Polkadot dApp builders are:\n\n- **[Crust Network](#crust-network):** A decentralized storage network that provides an incentive layer for IPFS.\n- **[IPFS](#ipfs):** A foundational peer-to-peer protocol for decentralized file storage.\n- **[Other Solutions](#other-solutions):** A brief overview of other storage options in the ecosystem."}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 1, "depth": 2, "title": "Crust Network", "anchor": "crust-network", "start_char": 1036, "end_char": 1342, "estimated_token_count": 63, "token_estimator": "heuristic-v1", "text": "## Crust Network\n\n[Crust Network](https://crust.network/){target=\\_blank} is a decentralized storage protocol built using the Polkadot SDK serving as an incentive layer for IPFS. As a parachain in the Polkadot ecosystem, Crust provides a comprehensive set of tools and services for decentralized storage."}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 2, "depth": 3, "title": "Key Features of Crust", "anchor": "key-features-of-crust", "start_char": 1342, "end_char": 2181, "estimated_token_count": 166, "token_estimator": "heuristic-v1", "text": "### Key Features of Crust\n\n-   **Decentralized and Immutable:** Crust leverages a global network of nodes to provide a truly decentralized storage layer, ensuring data immutability and high availability.\n-   **IPFS-based:** Crust is built on top of IPFS, providing a robust and widely used foundation for file storage. It enhances IPFS with an incentive layer, guaranteeing data persistence and replication.\n-   **Cross-Chain Interoperability:** Through Polkadot's XCM, Crust can offer storage services to other parachains, and it also supports EVM-compatible chains, enabling seamless integration with a wide range of dApps.\n-   **Developer-Friendly:** Crust offers a suite of tools, including an S3-compatible gateway, a GitHub-like application for decentralized code repositories, and various SDKs to simplify the integration process."}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 3, "depth": 3, "title": "Use Cases", "anchor": "use-cases", "start_char": 2181, "end_char": 2531, "estimated_token_count": 74, "token_estimator": "heuristic-v1", "text": "### Use Cases\n\n-   **dApp Hosting:** Deploy your dApp's front end on Crust for a fully decentralized solution.\n-   **NFT Storage:** Store NFT metadata and assets in a persistent and decentralized manner.\n-   **File Storage and Sharing:** Build decentralized applications for file storage and sharing, similar to traditional cloud storage services."}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 4, "depth": 2, "title": "IPFS", "anchor": "ipfs", "start_char": 2531, "end_char": 3117, "estimated_token_count": 128, "token_estimator": "heuristic-v1", "text": "## IPFS\n\nThe [InterPlanetary File System (IPFS)](https://ipfs.tech/){target=\\_blank} is a peer-to-peer hypermedia protocol designed to make the web faster, safer, and more open. It is a foundational technology for the decentralized web, and many storage solutions, including Crust, are built upon it.\n\nIPFS uses content-based rather than location-based addresses. When you add a file to IPFS, it is assigned a unique cryptographic hash, known as a Content Identifier (CID). This hashing process means that the content itself determines its address, making it verifiable and permanent."}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 5, "depth": 3, "title": "Using IPFS with Polkadot", "anchor": "using-ipfs-with-polkadot", "start_char": 3117, "end_char": 3868, "estimated_token_count": 162, "token_estimator": "heuristic-v1", "text": "### Using IPFS with Polkadot\n\nWhile IPFS is a standalone protocol, it can be integrated into your Polkadot dApp in several ways:\n\n-   **Off-Chain Data Storage:** Store large files, such as images, videos, and documents, off-chain on IPFS to reduce on-chain storage costs and improve performance.\n-   **Front-end Hosting:** Host your dApp's front end on IPFS to ensure that it remains accessible and censorship-resistant.\n-   **Integration with Storage Networks:** Use services like Crust Network or other pinning services to ensure your IPFS data is always available and replicated across multiple nodes.\n-   **Run your own IPFS Node:** Since IPFS is a P2P Network, you can optionally run your own IPFS node and have complete control over your data"}
{"page_id": "develop-toolkit-integrations-storage", "page_title": "Storage", "index": 6, "depth": 2, "title": "Other Solutions", "anchor": "other-solutions", "start_char": 3868, "end_char": 4369, "estimated_token_count": 116, "token_estimator": "heuristic-v1", "text": "## Other Solutions\n\nIn addition to Crust and IPFS, the Polkadot ecosystem is home to other emerging storage solutions. Projects like **[Aleph Cloud](https://aleph.cloud){target=\\_blank}** and **[Chainsafe's Files](https://files.chainsafe.io){target=\\_blank}** also offer decentralized storage services that can be integrated with your Polkadot dApp. As the ecosystem continues to grow, more storage options will become available, providing developers with a wide range of choices to meet their needs."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 28, "end_char": 472, "estimated_token_count": 92, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThis page will discuss the transaction format in Polkadot and how to create, sign, and broadcast transactions, as well as highlight some of the commands and tools available for integrators.\n\nAlways refer to each tool's documentation when integrating.\n\nFor further reading, refer to [blocks, transactions, and fees](/polkadot-protocol/parachain-basics/blocks-transactions-fees/){target=\\_blank} to learn more about the basics."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 1, "depth": 2, "title": "Transaction Format", "anchor": "transaction-format", "start_char": 472, "end_char": 3362, "estimated_token_count": 696, "token_estimator": "heuristic-v1", "text": "## Transaction Format\n\nPolkadot has some basic transaction information that is common to all transactions.\n\n- **Address**: The [SS58-encoded address](/polkadot-protocol/glossary/#ss58-address-format){target=\\_blank} of the sending account.\n- **Block hash**: The hash of the [checkpoint](/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/#transaction-mortality){target=\\_blank} block.\n- **Block number**: The number of the checkpoint block.\n- **Genesis hash**: The genesis hash of the chain.\n- **Metadata**: The [SCALE-encoded](/polkadot-protocol/parachain-basics/data-encoding/){target=\\_blank} metadata for the runtime when submitted.\n- **Nonce**: The nonce for this transaction.\n- **Spec version**: The current spec version for the runtime.\n- **Transaction version**: The current version of the transaction format.\n- **Tip**: The [tip](/polkadot-protocol/parachain-basics/blocks-transactions-fees/fees/#how-fees-are-calculated){target=\\_blank} to increase transaction priority. This is optional when constructing the transaction.\n- **Mode**: The flag indicating whether to verify the metadata hash or not.\n- **Era period**: The number of blocks after the checkpoint for which a transaction is valid. If zero, the transaction is [immortal](/polkadot-protocol/parachain-basics/blocks-transactions-fees/transactions/#transaction-mortality){target=\\_blank}. This is optional when constructing the transaction.\n- **Metadata hash**: The metadata hash which should match the [`RUNTIME_METADATA_HASH`](https://paritytech.github.io/polkadot-sdk/master/frame_metadata_hash_extension/struct.CheckMetadataHash.html){target=\\_blank} environment variable. This is optional when constructing the transaction.\n\n!!!warning\n    There are risks to making a transaction immortal. If an account is reaped and a user refunds the account, then they could replay an immortal transaction. Always default to using a mortal extrinsic.\n    \nThe nonce queried from the [System module](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/index.html){target=\\_blank} does not account for pending transactions. You must manually track and increment the nonce if you want to submit multiple valid transactions simultaneously.\n\nEach transaction will have its own parameters, or it may have none to add. For example, the [`transferKeepAlive`](https://paritytech.github.io/polkadot-sdk/master/pallet_balances/pallet/enum.Call.html#variant.transfer_keep_alive){target=\\_blank}  function from the [Balances pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_balances/index.html){target=\\_blank} will take:\n\n- `dest`: Destination address\n- `#[compact] value`: Number of tokens (compact encoding)\n\nRefer to [the protocol specifications](https://spec.polkadot.network/id-extrinsics){target=\\_blank} for the concrete specifications and types required to build a transaction."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 2, "depth": 3, "title": "Mode and Metadata Hash", "anchor": "mode-and-metadata-hash", "start_char": 3362, "end_char": 4529, "estimated_token_count": 309, "token_estimator": "heuristic-v1", "text": "### Mode and Metadata Hash\n\nThe [`mode`](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/guides/enable_metadata_hash/index.html){target=\\_blank} and [`metadata hash`](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/guides/enable_metadata_hash/index.html){target=\\_blank} fields were introduced in transaction construction to support the optional [`CheckMetadataHash` Signed Extension](https://github.com/polkadot-fellows/RFCs/blob/main/text/0078-merkleized-metadata.md){target=\\_blank}. This enables trustless metadata verification by allowing the chain to verify the correctness of the metadata used without the need of a trusted party. This functionality was included in [v1.2.5](https://github.com/polkadot-fellows/runtimes/releases/tag/v1.2.5){target=\\_blank} runtime release by the [Fellowship](https://github.com/polkadot-fellows/manifesto){target=\\_blank}. A user may opt out of this functionality by setting the `mode` to `0`. When the mode is `0`, the [`metadata hash`](https://paritytech.github.io/polkadot-sdk/master/frame_metadata_hash_extension/struct.CheckMetadataHash.html){target=\\_blank} field is empty/`None`."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 3, "depth": 3, "title": "Serialized Transactions and Metadata", "anchor": "serialized-transactions-and-metadata", "start_char": 4529, "end_char": 5164, "estimated_token_count": 121, "token_estimator": "heuristic-v1", "text": "### Serialized Transactions and Metadata\n\nBefore being submitted, transactions are serialized. Serialized transactions are hex encoded SCALE-encoded bytes. The relay chain runtimes are upgradable, and therefore, any interfaces are subject to change. The metadata allows developers to structure any extrinsics or storage entries accordingly and provides you with all of the information required to construct the serialized call data specific to your transaction. You can read more about the metadata, its format and how to get it in the [Subxt documentation](/polkadot-protocol/parachain-basics/chain-data/#use-subxt){target=\\_blank}."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 4, "depth": 3, "title": "Transaction Flow", "anchor": "transaction-flow", "start_char": 5164, "end_char": 5468, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "### Transaction Flow\n\nThe typical transaction workflow is as follows:\n\n1. Construct an unsigned transaction.\n2. Create a signing payload.\n3. Sign the payload.\n4. Serialize the signed payload into a transaction.\n5. Submit the serialized transaction.\n\nThere are several tools to help perform these steps."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 5, "depth": 2, "title": "Polkadot-JS Tools", "anchor": "polkadot-js-tools", "start_char": 5468, "end_char": 6599, "estimated_token_count": 289, "token_estimator": "heuristic-v1", "text": "## Polkadot-JS Tools\n\n[Polkadot-JS Tools](https://www.npmjs.com/package/@polkadot/signer-cli){target=\\_blank} contains a set of command-line tools for interacting with a Polkadot SDK client, including one called \"Signer CLI\" to create, sign, and broadcast transactions.\n\nThis example will use the `signer submit` command, which creates and submits the transaction. The `signer sendOffline` command has the same API, but will not broadcast the transaction. The `submit` and `sendOffline` must be connected to a node to fetch the current metadata and construct a valid transaction.\n\nStart by installing the Signer CLI.\n\n```bash\nnpm install -g @polkadot/signer-cli\n```\n\nTo create a transaction, you need to connect to a chain, enabling the creation of a transaction using the chain's metadata. \n\nHere is the format for `submit` or `sendOffline`:\n\n```bash\npolkadot-js-signer <submit|sendOffline> --account <from-account-ss58> --ws <endpoint> <module.method> [param1] [...] [paramX]\n```\n\nAnd for signing a transaction:\n\n```bash\npolkadot-js-signer sign --account <from-account-ss58> --seed <seed> --type <sr25519|ed25519> <payload>\n```"}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 6, "depth": 3, "title": "Creating a Transaction, Signing, and Submitting", "anchor": "creating-a-transaction-signing-and-submitting", "start_char": 6599, "end_char": 23064, "estimated_token_count": 3697, "token_estimator": "heuristic-v1", "text": "### Creating a Transaction, Signing, and Submitting\n\nFor the sake of this example, create two accounts using the [Subkey](/polkadot-protocol/parachain-basics/accounts/#using-subkey){target=\\_blank} CLI tool.\n\n<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\">subkey generate</span>\n    <span data-ty>Secret phrase:       south ladder exile ... grape rival settle coil</span>\n    <span data-ty>  Network ID:        substrate</span>\n    <span data-ty>  Secret seed:       0x60b875ea64f33b23093b8f8af542d5360ea121dd017d3053957c64cb73097def</span>\n    <span data-ty>  Public key (hex):  0x84a16fd4762cb944569d5b0a0deb4897fcb9d0a7bc153602f7b908c1b994222a</span>\n    <span data-ty>  Account ID:        0x84a16fd4762cb944569d5b0a0deb4897fcb9d0a7bc153602f7b908c1b994222a</span>\n    <span data-ty>  Public key (SS58): 5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2</span>\n    <span data-ty>  SS58 Address:      5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2</span>\n    <span data-ty></span>\n    <span data-ty=\"input\">subkey generate</span>\n    <span data-ty>Secret phrase:       car blood garden ... bomb armed potato</span>\n    <span data-ty>  Network ID:        substrate</span>\n    <span data-ty>  Secret seed:       0xced7bd306e992e7fce7efb3e4e1f6b196c402173d23c55ece35f1ca685d8e4eb</span>\n    <span data-ty>  Public key (hex):  0xa4e4a64dcabae6f6f95de52a81d42361926443e26efede9c7cd9d6034e43c761</span>\n    <span data-ty>  Account ID:        0xa4e4a64dcabae6f6f95de52a81d42361926443e26efede9c7cd9d6034e43c761</span>\n    <span data-ty>  Public key (SS58): 5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD</span>\n    <span data-ty>  SS58 Address:      5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD</span>\n</div>\nLet's say you want to send 1 WND from `5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2` to `5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD` on [Westend's Asset Hub](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fasset-hub-westend-rpc.n.dwellir.com#/accounts){target=\\_blank} using `polkadot-js-signer`.\n\nFirst, fund the sending account. You can use the [Westend Faucet](https://faucet.polkadot.io/westend){target=\\_blank} to do so.\nRequest some tokens for `5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2`.\n\nNext, call `submit` to create the transaction, which will give you the payload to sign.\n\n```bash\npolkadot-js-signer submit --account 5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2 --ws wss://asset-hub-westend-rpc.n.dwellir.com balances.transferKeepAlive 5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD 1000000000000\n```\n\nThis will return a payload to sign and an input waiting for a signature.\n\n<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot-js-signer submit --account 5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2 --ws wss://asset-hub-westend-rpc.n.dwellir.com balances.transferKeepAlive 5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD 1000000000000</span>\n    <span data-ty>Payload: 0x040300ff4a83f1...a8239139ff3ff7c3f6</span>\n    <span data-ty>Signature></span>\n</div>\nTake this payload and use your normal signing environment (e.g., air-gapped machine, VM, etc.). In a separate tab of your terminal, sign the payload.\n\n```bash\npolkadot-js-signer sign --account 5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2 --seed \"south ladder exile ... grape rival settle coil\" --type sr25519 0x040300ff4a83f1...a8239139ff3ff7c3f6\n```\n\nThis will output the transaction's signature. \n\n<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot-js-signer sign --account 5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2 --seed \"south ladder exile ... grape rival settle coil\" --type sr25519 0x040300ff4a83f1...a8239139ff3ff7c3f6</span>\n    <span data-ty>Signature: 0xe6facf194a8e...413ce3155c2d1240b</span>\n</div>\nPaste this signature into the `submit` signature field, and send the transaction (or just return the serialized transaction if using `sendOffline`).\n\nBy default, submit will create a mortal extrinsic with a lifetime of 50 blocks. \n\nAssuming a six-second block time, you will have five minutes to go offline, sign the transaction, paste the signature, and submit the signed transaction.\n\nYou will get useful output in the terminal with details like the events that were fired off, as well as the block in which the extrinsic is in. \n\n??? code \"Full example output\"\n    <div id=\"termynal\" data-termynal>\n        <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot-js-signer submit --account 5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2 --ws wss://westend-asset-hub-rpc.polkadot.io balances.transferKeepAlive 5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD 1000000000000</span>\n        <span data-ty>    2025-07-16 16:00:12        REGISTRY: Unknown signed extensions AuthorizeCall, StorageWeightReclaim found, treating them as no-effect</span>\n        <span data-ty>    2025-07-16 16:00:12        API/INIT: RPC methods not decorated: archive_v1_body, archive_v1_call, archive_v1_finalizedHeight, archive_v1_genesisHash, archive_v1_hashByHeight, archive_v1_header, archive_v1_stopStorage, archive_v1_storage, archive_v1_storageDiff, archive_v1_storageDiff_stopStorageDiff, chainHead_v1_body, chainHead_v1_call, chainHead_v1_continue, chainHead_v1_follow, chainHead_v1_header, chainHead_v1_stopOperation, chainHead_v1_storage, chainHead_v1_unfollow, chainHead_v1_unpin, chainSpec_v1_chainName, chainSpec_v1_genesisHash, chainSpec_v1_properties, transactionWatch_v1_submitAndWatch, transactionWatch_v1_unwatch, transaction_v1_broadcast, transaction_v1_stop</span>\n        <span data-ty>    Payload: 0x0a0300a4e4a64dcabae6f6f95de52a81d42361926443e26efede9c7cd9d6034e43c761070010a5d4e8f503000000009d880f001000000067f9723393ef76214df0118c34bbbd3dbebc8ed46a10973a8c969d48fe7598c949f8bd6deece0f1717c444d4323c255962b627b615b18de8316c5a47d960402c00</span>\n        <span data-ty>    Signature> 0x01960389b87612cda987189e21143e83907cad9bba0a0990b377df915b9e3df561dbe953cf2f20f11a5e8ad80c0d0da2dcc6bc5bc85967116c9f3ecd9f613a5e82</span>\n        <span data-ty>    {</span>\n        <span data-ty>      \"events\": [],</span>\n        <span data-ty>      \"status\": \"Ready\"</span>\n        <span data-ty>    }</span>\n        <span data-ty>    {</span>\n        <span data-ty>      \"events\": [],</span>\n        <span data-ty>      \"status\": {</span>\n        <span data-ty>        \"Broadcast\": [</span>\n        <span data-ty>          \"12D3KooWDoq4PVdWm5nzRSvEz3DSSKjVgRhWVUaKyi5JMKwJKYbk\",</span>\n        <span data-ty>          \"12D3KooWRZBHqijn91FMnihg3oN487oXLFoumr6SoN886Dxdu3yU\",</span>\n        <span data-ty>          \"12D3KooWSQvp4JByYRdieqhqoDEZ6NL2g2wttivrRuQH2KPGCWfh\",</span>\n        <span data-ty>          \"12D3KooWSKSHBXBAs7QvUKwDkFheuyL22KpHPS26q371iZ3WFQuF\",</span>\n        <span data-ty>          \"12D3KooWDkgKu9ibY92EfC2YBhVWSmnTuwE5d4M7AoSphZ7YbkSP\",</span>\n        <span data-ty>          \"12D3KooWLHHS5UtH6QCdWdDu92915k5Ka8H9uJW4SpCEuT7wJycg\",</span>\n        <span data-ty>          \"12D3KooWG4YUe7AfSxVwyLQBRRMU99krssmGAUghqUFoVY1iPkQs\",</span>\n        <span data-ty>          \"12D3KooWJaAfPyiye7ZQBuHengTJJoMrcaz7Jj1UzHiKdNxA1Nkd\",</span>\n        <span data-ty>          \"12D3KooWGD9caunL5KZuqMuHHFR6xv7gLqJH8cLrb9Q23yDy9JG1\",</span>\n        <span data-ty>          \"12D3KooWN7MjtEfEnS9FZHgRdfZcxQ9RPppeDqBLKQ4VQ1QWPtSC\",</span>\n        <span data-ty>          \"12D3KooWDfepM7kqUHMXdGqJw3ZmtvAcE2CjPcnYjT2tTfAw3ZBd\",</span>\n        <span data-ty>          \"12D3KooWCUYurDvauYyjLQH81LSj9hCdkcKtYYMEJWfLsJWZENs2\",</span>\n        <span data-ty>          \"12D3KooWJbrCd1v9i21bY7hbtnUkhmkHct62331kxRTdZDPF2U8D\",</span>\n        <span data-ty>          \"12D3KooWSVSxmf8BNTqwb9gZDVWJGho7Sy84QiAcArQUeTgkePyV\",</span>\n        <span data-ty>          \"12D3KooWLjaXWhNTSiRVFbTJCKLRWt9XXHLGVnAFtxvnExKkVPqn\",</span>\n        <span data-ty>          \"12D3KooWPPVazRmxrWK4AGYFuwNdJXzZshiLU73tw9ikpv8VhsP7\",</span>\n        <span data-ty>          \"12D3KooWE4UDXqgtTcMCyUQ8S4uvaT8VMzzTBA6NWmKuYwTacWuN\",</span>\n        <span data-ty>          \"12D3KooWJwsogNonEiY9PJUX9Gk564KJ1NfHAiTDPtL7rh7djf3A\",</span>\n        <span data-ty>          \"12D3KooWDUPyF2q8b6fVFEuwxBbRV3coAy1kzuCPU3D9TRiLnUfE\",</span>\n        <span data-ty>          \"12D3KooWFLR2UN6PMAUwNAjiWBAiEDoYcWRrtjDrUfRkdUssge4v\",</span>\n        <span data-ty>          \"12D3KooWHpoHiCNYJAcfwe8uiqybx5wX25a2YAPr9A5nq5Htg223\",</span>\n        <span data-ty>          \"12D3KooWLgfaWf4uBJkGv3MRq2x7zxgBwQ6yHVCerF3dU8FncWkX\",</span>\n        <span data-ty>          \"12D3KooWK13Bi57EgkxxiJV2RsPCWoaEWRyq6kuAPwMq39Y4WLQj\",</span>\n        <span data-ty>          \"12D3KooWFGswsMTKSrbPyRRTjcjjCVJVANKu1aLSZzxH5gSk4xhs\",</span>\n        <span data-ty>          \"12D3KooWE7C5Tebbccm76xzJY61LhqGhp9CLHyTtfDetLAURHpDJ\",</span>\n        <span data-ty>          \"12D3KooWLG4V41JQw12GXqXXmKe6w68LvyzEYcAhUmeZTf67Cs6P\",</span>\n        <span data-ty>          \"12D3KooWQKMXaeDjgWyvkBECeYF6Zz2r8YrtuvYeQ4ir9KazpqXP\",</span>\n        <span data-ty>          \"12D3KooWHU4qqSyqKdbXdrCTMXUJxxueaZjqpqSaQqYiFPw6XqEx\"</span>\n        <span data-ty>        ]</span>\n        <span data-ty>      }</span>\n        <span data-ty>    }</span>\n        <span data-ty>    {</span>\n        <span data-ty>      \"dispatchInfo\": {</span>\n        <span data-ty>        \"weight\": {</span>\n        <span data-ty>          \"refTime\": \"383,866,000\",</span>\n        <span data-ty>          \"proofSize\": \"4,261\"</span>\n        <span data-ty>        },</span>\n        <span data-ty>        \"class\": \"Normal\",</span>\n        <span data-ty>        \"paysFee\": \"Yes\"</span>\n        <span data-ty>      },</span>\n        <span data-ty>      \"events\": [</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"Withdraw\",</span>\n        <span data-ty>            \"section\": \"balances\",</span>\n        <span data-ty>            \"index\": \"0x0a08\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"who\": \"5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2\",</span>\n        <span data-ty>              \"amount\": \"2,933,772,732\"</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        },</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"NewAccount\",</span>\n        <span data-ty>            \"section\": \"system\",</span>\n        <span data-ty>            \"index\": \"0x0003\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"account\": \"5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD\"</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        },</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"Endowed\",</span>\n        <span data-ty>            \"section\": \"balances\",</span>\n        <span data-ty>            \"index\": \"0x0a00\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"account\": \"5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD\",</span>\n        <span data-ty>              \"freeBalance\": \"1,000,000,000,000\"</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        },</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"Transfer\",</span>\n        <span data-ty>            \"section\": \"balances\",</span>\n        <span data-ty>            \"index\": \"0x0a02\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"from\": \"5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2\",</span>\n        <span data-ty>              \"to\": \"5FnudgwK8xJvmujsXXP35pF2xwskhHQzBSRM8KZhXjnEz5gD\",</span>\n        <span data-ty>              \"amount\": \"1,000,000,000,000\"</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        },</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"Deposit\",</span>\n        <span data-ty>            \"section\": \"balances\",</span>\n        <span data-ty>            \"index\": \"0x0a07\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"who\": \"5EYCAe5cKPAoFh2HnQQvpKqRYZGqBpaA87u4Zzw89qPE58is\",</span>\n        <span data-ty>              \"amount\": \"2,933,772,732\"</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        },</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"TransactionFeePaid\",</span>\n        <span data-ty>            \"section\": \"transactionPayment\",</span>\n        <span data-ty>            \"index\": \"0x0b00\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"who\": \"5F4c8mNz6schf2WMXQZiz1eyR1GGxrMf2coXpAn8mNjxyzp2\",</span>\n        <span data-ty>              \"actualFee\": \"2,933,772,732\",</span>\n        <span data-ty>              \"tip\": \"0\"</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        },</span>\n        <span data-ty>        {</span>\n        <span data-ty>          \"phase\": {</span>\n        <span data-ty>            \"ApplyExtrinsic\": \"2\"</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"event\": {</span>\n        <span data-ty>            \"method\": \"ExtrinsicSuccess\",</span>\n        <span data-ty>            \"section\": \"system\",</span>\n        <span data-ty>            \"index\": \"0x0000\",</span>\n        <span data-ty>            \"data\": {</span>\n        <span data-ty>              \"dispatchInfo\": {</span>\n        <span data-ty>                \"weight\": {</span>\n        <span data-ty>                  \"refTime\": \"383,866,000\",</span>\n        <span data-ty>                  \"proofSize\": \"4,261\"</span>\n        <span data-ty>                },</span>\n        <span data-ty>                \"class\": \"Normal\",</span>\n        <span data-ty>                \"paysFee\": \"Yes\"</span>\n        <span data-ty>              }</span>\n        <span data-ty>            }</span>\n        <span data-ty>          },</span>\n        <span data-ty>          \"topics\": []</span>\n        <span data-ty>        }</span>\n        <span data-ty>      ],</span>\n        <span data-ty>      \"status\": {</span>\n        <span data-ty>        \"InBlock\": \"0x08cc8737961b31d7e9e8877e289bad780c08ac92ac09037871688e6761a8e793\"</span>\n        <span data-ty>      }</span>\n        <span data-ty>    }</span>\n    </div>\n!!!note \"Submitting Pre-Signed Transaction\"\n    You can also submit pre-signed transactions, e.g., generated using the `sendOffline` command.\n    ```bash\n    polkadot-js-signer submit --tx <signedTransaction> --ws <endpoint>\n    ```"}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 7, "depth": 2, "title": "Txwrapper", "anchor": "txwrapper", "start_char": 23064, "end_char": 23603, "estimated_token_count": 135, "token_estimator": "heuristic-v1", "text": "## Txwrapper\n\nIf you do not want to use the CLI for signing operations, Parity provides an SDK called [txwrapper-core](https://github.com/paritytech/txwrapper-core){target=\\_blank} to generate and sign transactions offline. For Polkadot, Kusama, and select parachains, use the `txwrapper-polkadot` package. Other Polkadot SDK-based chains will have their own `txwrapper-{chain}` implementations. See the [examples](https://github.com/paritytech/txwrapper-core/blob/main/packages/txwrapper-examples/README.md){target=\\_blank} for a guide."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 8, "depth": 3, "title": "Creating a Transaction, Signing, and Submitting", "anchor": "creating-a-transaction-signing-and-submitting-2", "start_char": 23603, "end_char": 26862, "estimated_token_count": 693, "token_estimator": "heuristic-v1", "text": "### Creating a Transaction, Signing, and Submitting\n\nYou will need a network to test the transaction.\nLet's use [chopsticks](/tutorials/polkadot-sdk/testing/fork-live-chains/){target=\\_blank} for this:\n\n```bash\nnpx @acala-network/chopsticks --config=polkadot -p 9944\n```\n\nYou should get a Polkadot network running on port 9944.\n\nThe [`txwrapper` example script](https://github.com/paritytech/txwrapper-core/blob/main/packages/txwrapper-examples/polkadot/src/polkadot.ts){target=\\_blank} will then be used to create and sign transactions.\n\nFor this, you will need the [`txwrapper`](https://github.com/paritytech/txwrapper-core){target=\\_blank} library. Let's clone [`txwrapper`](https://github.com/paritytech/txwrapper-core){target=\\_blank}:\n\n```bash\ngit clone https://github.com/paritytech/txwrapper-core\ncd txwrapper-core\nyarn install && yarn build\ncd packages/txwrapper-examples\n```\n\nBuild and run the [Polkadot `txwrapper` example script](https://github.com/paritytech/txwrapper-core/blob/main/packages/txwrapper-examples/polkadot/src/polkadot.ts){target=\\_blank}:\n\n```bash\nyarn run build\nyarn run polkadot\n```\n\n<div id=\"termynal\" data-termynal>\n    <span data-ty=\"input\"><span class=\"file-path\"></span>yarn run polkadot</span>\n    <span data-ty>Alice's SS58-Encoded Address: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</span>\n    <span data-ty></span>\n    <span data-ty>Decoded Transaction</span>\n    <span data-ty>  To: 14E5nqKAp3oAJcmzgZhUD2RcptBeUBScxKHgJKU4HPNcKVf3</span>\n    <span data-ty>  Amount: \"10000000000\"</span>\n    <span data-ty></span>\n    <span data-ty>Payload to Sign: 0xa40503008eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a480700e40b54028500000000b1590f001a00000091b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3843125cd049613a7edf44b55a01efbabffcd1b962068a82070cff82314b67bbc00</span>\n    <span data-ty></span>\n    <span data-ty>Decoded Transaction</span>\n    <span data-ty>  To: 14E5nqKAp3oAJcmzgZhUD2RcptBeUBScxKHgJKU4HPNcKVf3</span>\n    <span data-ty>  Amount: \"10000000000\"</span>\n    <span data-ty></span>\n    <span data-ty>Signature: 0x01ae703e667b3b444e3613a5f06d16bedf2460a18e52075b47c6442ebc1d316917c6d12e3aa7bbd2f8db76cc859b43134cecb4495613d8d504901de776d0642b82</span>\n    <span data-ty></span>\n    <span data-ty>Transaction to Submit: 0x45028400d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d01ae703e667b3b444e3613a5f06d16bedf2460a18e52075b47c6442ebc1d316917c6d12e3aa7bbd2f8db76cc859b43134cecb4495613d8d504901de776d0642b8285000000000503008eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a480700e40b5402</span>\n    <span data-ty></span>\n    <span data-ty>Expected Tx Hash: 0xa12126a095b38f0c70331be78743329a851e33839f9b2f93a7ecc34541507891</span>\n    <span data-ty>Actual Tx Hash: 0xa12126a095b38f0c70331be78743329a851e33839f9b2f93a7ecc34541507891</span>\n    <span data-ty></span>\n    <span data-ty>Decoded Transaction</span>\n    <span data-ty>  To: 14E5nqKAp3oAJcmzgZhUD2RcptBeUBScxKHgJKU4HPNcKVf3</span>\n    <span data-ty>  Amount: \"10000000000\"</span>\n</div>\nThe [`txwrapper` example script](https://github.com/paritytech/txwrapper-core/blob/main/packages/txwrapper-examples/polkadot/src/polkadot.ts){target=\\_blank} includes several reference examples."}
{"page_id": "develop-toolkit-integrations-transaction-construction", "page_title": "Transaction Construction", "index": 9, "depth": 2, "title": "Additional Libraries for Submitting a Transaction", "anchor": "additional-libraries-for-submitting-a-transaction", "start_char": 26862, "end_char": 27784, "estimated_token_count": 220, "token_estimator": "heuristic-v1", "text": "## Additional Libraries for Submitting a Transaction\n\nOther than Polkadot JS Tools and txwrapper, there are several other libraries that can also be used to submit a signed payload, such as the [Sidecar API](/develop/toolkit/api-libraries/sidecar/#sidecar-api){target=\\_blank} or using RPC calls with [`author_submitExtrinsic`](https://paritytech.github.io/polkadot-sdk/master/sc_rpc/author/trait.AuthorApiServer.html#tymethod.submit_extrinsic){target=\\_blank} or [`author_submitAndWatchExtrinsic`](https://github.com/paritytech/polkadot-sdk/blob/0ae5c5bbd96a600aed81358339be2f16bade4a81/substrate/client/rpc-api/src/author/mod.rs#L69-L78){target=\\_blank}, the latter of which will subscribe you to events to be notified as a transaction gets validated and included in the chain. You can see all the available libraries in the [API Libraries](/develop/toolkit/api-libraries/){target=\\_blank} section of the Polkadot Docs."}
{"page_id": "develop-toolkit-integrations-wallets", "page_title": "Wallets", "index": 0, "depth": 2, "title": "What is a Blockchain Wallet?", "anchor": "what-is-a-blockchain-wallet", "start_char": 11, "end_char": 656, "estimated_token_count": 129, "token_estimator": "heuristic-v1", "text": "## What is a Blockchain Wallet?\n\nA wallet serves as your gateway to interacting with blockchain networks. Rather than storing funds, wallets secure your private keys, controlling access to your blockchain assets. Your private key provides complete control over all permitted transactions on your blockchain account, making it essential to keep it secure.\n\nWallet types fall into two categories based on their connection to the internet:\n\n- **[Hot wallets](#hot-wallets)**: Online storage through websites, browser extensions or smartphone apps.\n- **[Cold wallets](#cold-wallets)**: Offline storage using hardware devices or air-gapped systems."}
{"page_id": "develop-toolkit-integrations-wallets", "page_title": "Wallets", "index": 1, "depth": 2, "title": "Hot Wallets", "anchor": "hot-wallets", "start_char": 656, "end_char": 2224, "estimated_token_count": 342, "token_estimator": "heuristic-v1", "text": "## Hot Wallets\n\n<div class=\"grid cards\" markdown>\n\n-   __Nova Wallet__\n\n    ---\n\n    A non-custodial, mobile-first wallet for managing assets and interacting with the Polkadot and Kusama ecosystems. It supports staking, governance, cross-chain transfers, and crowdloans. With advanced features, seamless multi-network support, and strong security, Nova Wallet empowers users to explore the full potential of Polkadot parachains on the go.\n\n    [:octicons-arrow-right-24: Reference](https://novawallet.io/){target=\\_blank}\n\n-   __Talisman__\n\n    ---\n\n    A non-custodial web browser extension that allows you to manage your portfolio and interact with Polkadot and Ethereum applications. It supports Web3 apps, asset storage, and account management across over 150 Polkadot SDK-based and EVM networks. Features include NFT management, Ledger support, fiat on-ramp, and portfolio tracking.\n\n    [:octicons-arrow-right-24: Reference](https://talisman.xyz/){target=\\_blank}\n\n-  __Subwallet__\n\n    ---\n\n    A non-custodial web browser extension and mobile wallet for Polkadot and Ethereum. Track, send, receive, and monitor multi-chain assets on 150+ networks. Import account with seed phrase, private key, QR code, and JSON file. Import token & NFT, attach read-only account. XCM Transfer, NFT Management, Parity Signer & Ledger support, light clients support, EVM dApp support, MetaMask compatibility, custom endpoints, fiat on-ramp, phishing detection, transaction history.\n\n    [:octicons-arrow-right-24: Reference](https://www.subwallet.app/){target=\\_blank}\n\n</div>"}
{"page_id": "develop-toolkit-integrations-wallets", "page_title": "Wallets", "index": 2, "depth": 2, "title": "Cold Wallets", "anchor": "cold-wallets", "start_char": 2224, "end_char": 2921, "estimated_token_count": 162, "token_estimator": "heuristic-v1", "text": "## Cold Wallets\n\n<div class=\"grid cards\" markdown>\n\n-   __Ledger__\n\n    ---\n\n    A hardware wallet that securely stores cryptocurrency private keys offline, protecting them from online threats. Using a secure chip and the Ledger Live app allows safe transactions and asset management while keeping keys secure.\n\n    [:octicons-arrow-right-24: Reference](https://www.ledger.com/){target=\\_blank}\n\n-   __Polkadot Vault__\n\n    ---\n\n    This cold storage solution lets you use a phone in airplane mode as an air-gapped wallet, turning any spare phone, tablet, or iOS/Android device into a hardware wallet.\n\n    [:octicons-arrow-right-24: Reference](https://vault.novasama.io/){target=\\_blank}\n\n</div>"}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 13, "end_char": 787, "estimated_token_count": 134, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nAs described in the [Interoperability](/develop/interoperability){target=\\_blank} section, XCM (Cross-Consensus Messaging) is a protocol used in the Polkadot and Kusama ecosystems to enable communication and interaction between chains. It facilitates cross-chain communication, allowing assets, data, and messages to flow seamlessly across the ecosystem.\n\nAs XCM is central to enabling communication between blockchains, developers need robust tools to help interact with, build, and test XCM messages. Several XCM tools simplify working with the protocol by providing libraries, frameworks, and utilities that enhance the development process, ensuring that applications built within the Polkadot ecosystem can efficiently use cross-chain functionalities."}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 1, "depth": 2, "title": "Popular XCM Tools", "anchor": "popular-xcm-tools", "start_char": 787, "end_char": 809, "estimated_token_count": 5, "token_estimator": "heuristic-v1", "text": "## Popular XCM Tools"}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 2, "depth": 3, "title": "Moonsong Labs XCM Tools", "anchor": "moonsong-labs-xcm-tools", "start_char": 809, "end_char": 2190, "estimated_token_count": 333, "token_estimator": "heuristic-v1", "text": "### Moonsong Labs XCM Tools\n\n[Moonsong Labs XCM Tools](https://github.com/Moonsong-Labs/xcm-tools){target=\\_blank} provides a collection of scripts for managing and testing XCM operations between Polkadot SDK-based runtimes. These tools allow performing tasks like asset registration, channel setup, and XCM initialization. Key features include:\n\n- **Asset registration**: Registers assets, setting units per second (up-front fees), and configuring error (revert) codes.\n- **XCM initializer**: Initializes XCM, sets default XCM versions, and configures revert codes for XCM-related precompiles.\n- **HRMP manipulator**: Manages HRMP channel actions, including opening, accepting, or closing channels.\n- **XCM-Transactor-Info-Setter**: Configures transactor information, including extra weight and fee settings.\n- **Decode XCM**: Decodes XCM messages on the relay chain or parachains to help interpret cross-chain communication.\n\nTo get started, clone the repository and install the required dependencies:\n\n```bash\ngit clone https://github.com/Moonsong-Labs/xcm-tools && \ncd xcm-tools &&\nyarn install\n```\n\nFor a full overview of each script, visit the [scripts](https://github.com/Moonsong-Labs/xcm-tools/tree/main/scripts){target=\\_blank} directory or refer to the [official documentation](https://github.com/Moonsong-Labs/xcm-tools/blob/main/README.md){target=\\_blank} on GitHub."}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 3, "depth": 3, "title": "ParaSpell", "anchor": "paraspell", "start_char": 2190, "end_char": 4045, "estimated_token_count": 409, "token_estimator": "heuristic-v1", "text": "### ParaSpell\n\n[ParaSpell](https://paraspell.xyz/){target=\\_blank} is a collection of open-source XCM tools designed to streamline cross-chain asset transfers and interactions within the Polkadot and Kusama ecosystems. It equips developers with an intuitive interface to manage and optimize XCM-based functionalities. Some key points included by ParaSpell are:\n\n- **[XCM SDK](https://paraspell.xyz/#xcm-sdk){target=\\_blank}**: Provides a unified layer to incorporate XCM into decentralized applications, simplifying complex cross-chain interactions.\n- **[XCM API](https://paraspell.xyz/#xcm-api){target=\\_blank}**: Offers an efficient, package-free approach to integrating XCM functionality while offloading heavy computing tasks, minimizing costs and improving application performance.\n- **[XCM router](https://paraspell.xyz/#xcm-router){target=\\_blank}**: Enables cross-chain asset swaps in a single command, allowing developers to send one asset type (such as DOT on Polkadot) and receive a different asset on another chain (like ASTR on Astar).\n- **[XCM analyser](https://paraspell.xyz/#xcm-analyser){target=\\_blank}**: Decodes and translates complex XCM multilocation data into readable information, supporting easier troubleshooting and debugging.\n- **[XCM visualizator](https://paraspell.xyz/#xcm-visualizator){target=\\_blank}**: A tool designed to give developers a clear, interactive view of XCM activity across the Polkadot ecosystem, providing insights into cross-chain communication flow.\n\nParaSpell's tools make it simple for developers to build, test, and deploy cross-chain solutions without needing extensive knowledge of the XCM protocol. With features like message composition, decoding, and practical utility functions for parachain interactions, ParaSpell is especially useful for debugging and optimizing cross-chain communications."}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 4, "depth": 3, "title": "Astar XCM Tools", "anchor": "astar-xcm-tools", "start_char": 4045, "end_char": 5585, "estimated_token_count": 369, "token_estimator": "heuristic-v1", "text": "### Astar XCM Tools\n\nThe [Astar parachain](https://github.com/AstarNetwork/Astar/tree/master){target=\\_blank} offers a crate with a set of utilities for interacting with the XCM protocol. The [xcm-tools](https://github.com/AstarNetwork/Astar/tree/master/bin/xcm-tools){target=\\_blank} crate provides a straightforward method for users to locate a sovereign account or calculate an XC20 asset ID. Some commands included by the xcm-tools crate allow users to perform the following tasks:\n\n- **Sovereign accounts**: Obtain the sovereign account address for any parachain, either on the Relay Chain or for sibling parachains, using a simple command.\n- **XC20 EVM addresses**: Generate XC20-compatible Ethereum addresses for assets by entering the asset ID, making it easy to integrate assets across Ethereum-compatible environments.\n- **Remote accounts**: Retrieve remote account addresses needed for multi-location compatibility, using flexible options to specify account types and parachain IDs.\n\nTo start using these tools, clone the [Astar repository](https://github.com/AstarNetwork/Astar){target=\\_blank} and compile the xcm-tools package:\n\n```bash\ngit clone https://github.com/AstarNetwork/Astar &&\ncd Astar &&\ncargo build --release -p xcm-tools\n```\n\nAfter compiling, verify the setup with the following command:\n\n```bash\n./target/release/xcm-tools --help\n```\nFor more details on using Astar xcm-tools, consult the [official documentation](https://docs.astar.network/docs/learn/interoperability/xcm/integration/tools/){target=\\_blank}."}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 5, "depth": 3, "title": "Chopsticks", "anchor": "chopsticks", "start_char": 5585, "end_char": 5895, "estimated_token_count": 65, "token_estimator": "heuristic-v1", "text": "### Chopsticks\n\nThe Chopsticks library provides XCM functionality for testing XCM messages across networks, enabling you to fork multiple parachains along with a relay chain. For further details, see the [Chopsticks documentation](/tutorials/polkadot-sdk/testing/fork-live-chains/){target=\\_blank} about XCM."}
{"page_id": "develop-toolkit-interoperability-xcm-tools", "page_title": "XCM Tools", "index": 6, "depth": 3, "title": "Moonbeam XCM SDK", "anchor": "moonbeam-xcm-sdk", "start_char": 5895, "end_char": 7524, "estimated_token_count": 385, "token_estimator": "heuristic-v1", "text": "### Moonbeam XCM SDK\n\nThe [Moonbeam XCM SDK](https://github.com/moonbeam-foundation/xcm-sdk){target=\\_blank} enables developers to easily transfer assets between chains, either between parachains or between a parachain and the relay chain, within the Polkadot/Kusama ecosystem. With the SDK, you don't need to worry about determining the [Multilocation](https://github.com/polkadot-fellows/xcm-format?tab=readme-ov-file#7-universal-consensus-location-identifiers){target=\\_blank} of the origin or destination assets or which extrinsics are used on which networks.\n\nThe SDK consists of two main packages:\n\n- **[XCM SDK](https://github.com/moonbeam-foundation/xcm-sdk/tree/main/packages/sdk){target=\\_blank}**: Core SDK for executing XCM transfers between chains in the Polkadot/Kusama ecosystem.\n- **[MRL SDK](https://github.com/moonbeam-foundation/xcm-sdk/tree/main/packages/mrl){target=\\_blank}**: Extension of the XCM SDK for transferring liquidity into and across the Polkadot ecosystem from other ecosystems like Ethereum.\n\nKey features include:\n\n- **Simplified asset transfers**: Abstracts away complex multilocation determinations and extrinsic selection.\n- **Cross-ecosystem support**: Enables transfers between Polkadot/Kusama chains and external ecosystems.\n- **Developer-friendly API**: Provides intuitive interfaces for cross-chain functionality.\n- **Comprehensive documentation**: Includes usage guides and API references for both packages.\n\nFor detailed usage examples and API documentation, visit the [official Moonbeam XCM SDK documentation](https://moonbeam-foundation.github.io/xcm-sdk/latest/){target=\\_blank}."}
{"page_id": "get-support-ai-ready-docs", "page_title": "AI Ready Docs", "index": 0, "depth": 2, "title": "How to Use These Files", "anchor": "how-to-use-these-files", "start_char": 286, "end_char": 952, "estimated_token_count": 164, "token_estimator": "heuristic-v1", "text": "## How to Use These Files\n\n- **Quick navigation**: Use `llms.txt` to give models a high-level map of the site.\n- **Lightweight context**: Use `site-index.json` for smaller context windows or when you only need targeted retrieval.\n- **Full content**: Use `llms-full.jsonl` for large-context models or preparing data for RAG pipelines.\n- **Focused bundles**: Use category files (e.g., `basics.md`, `parachains.md`) to limit content to a specific theme or task for more focused responses.\n\nThese AI-ready files do not include any persona or system prompts. They are purely informational and can be used without conflicting with your existing agent or tool prompting."}
{"page_id": "get-support-ai-ready-docs", "page_title": "AI Ready Docs", "index": 1, "depth": 2, "title": "Download LLM Files", "anchor": "download-llm-files", "start_char": 952, "end_char": 7659, "estimated_token_count": 1909, "token_estimator": "heuristic-v1", "text": "## Download LLM Files\n\n| Category                   | Description                                                                                                                                         | File                                                                         | Actions                                                                                                                                                                                                          |\n|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| Index                      | Markdown URL index for documentation pages, links to essential repos, and additional resources in the llms.txt standard format.                     | <code style=\"white-space: nowrap;\">llms.txt</code>                           | [:octicons-copy-16:](){ .llms-copy data-path=\"/llms.txt\" } [:octicons-download-16:](){ .llms-dl data-path=\"/llms.txt\" data-filename=\"llms.txt\" }                                                                 |\n| Site index (JSON)          | Lightweight site index of JSON objects (one per page) with metadata and content previews.                                                           | <code style=\"white-space: nowrap;\">site-index.json</code>                 | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/site-index.json\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/site-index.json\" data-filename=\"site-index.json\" }                                      |\n| Full site contents (JSONL) | Full content of documentation site enhanced with metadata.                                                                                          | <code style=\"white-space: nowrap;\">llms-full.jsonl</code>                    | [:octicons-copy-16:](){ .llms-copy data-path=\"/llms-full.jsonl\" } [:octicons-download-16:](){ .llms-dl data-path=\"/llms-full.jsonl\" data-filename=\"llms-full.jsonl\" }                                            |\n| Basics                     | Polkadot general knowledge base to provide context around overview and beginner-level content.                                                      | <code style=\"white-space: nowrap;\">basics.md</code>            | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/basics.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/basics.md\" data-filename=\"basics.md\" }                                  |\n| Reference                  | Reference material including key functions and glossary.                                                                                            | <code style=\"white-space: nowrap;\">reference.md</code>         | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/reference.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/reference.md\" data-filename=\"reference.md\" }                         |\n| Smart Contracts            | How to develop and deploy Solidity smart contracts on Polkadot Hub.                                                                                 | <code style=\"white-space: nowrap;\">smart-contracts.md</code>   | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/smart-contracts.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/smart-contracts.md\" data-filename=\"smart-contracts.md\" }       |\n| Parachains                 | How-to guides related to building, customizing, deploying, and maintaining a parachain.                                                             | <code style=\"white-space: nowrap;\">parachains.md</code>        | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/parachains.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/parachains.md\" data-filename=\"parachains.md\" }                      |\n| DApps                      | Information and tutorials for application developers.                                                                                               | <code style=\"white-space: nowrap;\">dapps.md</code>             | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/dapps.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/dapps.md\" data-filename=\"dapps.md\" }                                     |\n| Networks                   | Information about the various Polkadot networks (Polkadot, Kusama, Westend, Paseo), their purposes, and how they fit into the development workflow. | <code style=\"white-space: nowrap;\">networks.md</code>          | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/networks.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/networks.md\" data-filename=\"networks.md\" }                            |\n| Polkadot Protocol          | Polkadot's core architecture, including the relay chain, parachains, system chains, interoperability, and main actors.                              | <code style=\"white-space: nowrap;\">polkadot-protocol.md</code> | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/polkadot-protocol.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/polkadot-protocol.md\" data-filename=\"polkadot-protocol.md\" } |\n| Infrastructure             | Operational aspects of supporting the Polkadot network, including how to run a node or validator and staking mechanics.                             | <code style=\"white-space: nowrap;\">infrastructure.md</code>    | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/infrastructure.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/infrastructure.md\" data-filename=\"infrastructure.md\" }          |\n| Tooling                    | An overview of various development tools available for Polkadot development.                                                                        | <code style=\"white-space: nowrap;\">tooling.md</code>           | [:octicons-copy-16:](){ .llms-copy data-path=\"/ai/categories/tooling.md\" } [:octicons-download-16:](){ .llms-dl data-path=\"/ai/categories/tooling.md\" data-filename=\"tooling.md\" }                               |\n\n!!! note\n    The `llms-full.jsonl` file may exceed the input limits of some language models due to its size. If you encounter limitations, consider using the smaller `site-index.json` or category bundle files instead."}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 0, "depth": 2, "title": "🧠 Stack Exchange", "anchor": "stack-exchange", "start_char": 178, "end_char": 403, "estimated_token_count": 53, "token_estimator": "heuristic-v1", "text": "## 🧠 Stack Exchange\n\n- Browse commonly asked technical questions.\n- Ask your own and get detailed responses from experienced devs.\n\n👉 **[Visit Polkadot Stack Exchange](https://substrate.stackexchange.com/){target=\\_blank}**"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 1, "depth": 2, "title": "🧵 Reddit: r/Polkadot", "anchor": "reddit-rpolkadot", "start_char": 403, "end_char": 631, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "## 🧵 Reddit: r/Polkadot\n\n- General Polkadot discussions and community perspectives.\n- Developer questions are welcome — just tag them appropriately.\n\n👉 **[Visit r/Polkadot](https://www.reddit.com/r/Polkadot/){target=\\_blank}**"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 2, "depth": 2, "title": "💬 Discord (Community Threads Only)", "anchor": "discord-community-threads-only", "start_char": 631, "end_char": 900, "estimated_token_count": 66, "token_estimator": "heuristic-v1", "text": "## 💬 Discord (Community Threads Only)\n\n- Beyond the official support threads, most channels are community-driven.\n- Great place to connect with fellow builders and share insights.\n\n👉 **[Join the Polkadot Discord](https://polkadot-discord.w3f.tools/){target=\\_blank}**"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 3, "depth": 2, "title": "🎥 YouTube: @PolkadotNetwork", "anchor": "youtube-polkadotnetwork", "start_char": 900, "end_char": 1098, "estimated_token_count": 48, "token_estimator": "heuristic-v1", "text": "## 🎥 YouTube: @PolkadotNetwork\n\n- Developer tutorials\n- Ecosystem interviews\n- Event recordings and walkthroughs\n\n👉 **[Watch on YouTube](https://www.youtube.com/@PolkadotNetwork){target=\\_blank}**"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 4, "depth": 2, "title": "Community-Led Platforms and Ecosystem Updates", "anchor": "community-led-platforms-and-ecosystem-updates", "start_char": 1098, "end_char": 1298, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Community-Led Platforms and Ecosystem Updates\n\nStay in sync with what's happening across the Polkadot ecosystem — from official announcements to community-driven insights and governance activity."}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 5, "depth": 3, "title": "🔷 X (Twitter): Official Accounts", "anchor": "x-twitter-official-accounts", "start_char": 1298, "end_char": 1717, "estimated_token_count": 121, "token_estimator": "heuristic-v1", "text": "### 🔷 X (Twitter): Official Accounts\n\n- [@PolkadotDevs](https://twitter.com/PolkadotDevs){target=\\_blank}: Updates for developers\n- [@Polkadot](https://twitter.com/Polkadot){target=\\_blank}: Network-wide news\n- [@Kusamanetwork](https://twitter.com/kusamanetwork){target=\\_blank}: Kusama-specific updates\n- [@Web3Foundation](https://twitter.com/web3foundation){target=\\_blank}: Grants, research, and ecosystem programs"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 6, "depth": 3, "title": "🔁 X (Twitter): Community Accounts", "anchor": "x-twitter-community-accounts", "start_char": 1717, "end_char": 1882, "estimated_token_count": 42, "token_estimator": "heuristic-v1", "text": "### 🔁 X (Twitter): Community Accounts\n\n- [@PolkadotDeploy](https://twitter.com/PolkadotDeploy){target=\\_blank}: News from the deployment portal and tooling updates"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 7, "depth": 3, "title": "🗣️ Polkadot Forum", "anchor": "polkadot-forum", "start_char": 1882, "end_char": 2057, "estimated_token_count": 47, "token_estimator": "heuristic-v1", "text": "### 🗣️ Polkadot Forum\n\n- Join community discussions around the direction of the ecosystem.\n\n👉 **[Visit the Polkadot Forum](https://forum.polkadot.network/){target=\\_blank}**"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 8, "depth": 3, "title": "🧑‍⚖️ Polkassembly: OpenGov", "anchor": "polkassembly-opengov", "start_char": 2057, "end_char": 2282, "estimated_token_count": 59, "token_estimator": "heuristic-v1", "text": "### 🧑‍⚖️ Polkassembly: OpenGov\n\n- Explore and vote on governance proposals for Polkadot and Kusama.\n- Help shape the future of the network.\n\n👉 **[Explore on Polkassembly](https://polkadot.polkassembly.io/){target=\\_blank}**"}
{"page_id": "get-support-explore-resources", "page_title": "Subscribe to Updates", "index": 9, "depth": 3, "title": "📸 Instagram", "anchor": "instagram", "start_char": 2282, "end_char": 2456, "estimated_token_count": 49, "token_estimator": "heuristic-v1", "text": "### 📸 Instagram\n\n- **[@Polkadotnetwork](https://www.instagram.com/polkadotnetwork){target=\\_blank}**: Visual highlights from the ecosystem\n  _(Note: not developer-specific)_"}
{"page_id": "get-support-get-in-touch", "page_title": "Get in Touch", "index": 0, "depth": 2, "title": "Need Help Fast?", "anchor": "need-help-fast", "start_char": 25, "end_char": 546, "estimated_token_count": 152, "token_estimator": "heuristic-v1", "text": "## Need Help Fast?\n  \nUse one of the channels below to get live technical support or ask questions.\n\n<div class=\"button-wrapper\" style=\"display: flex; justify-content: flex-start;\">\n  <a href=\"https://t.me/substratedevs\" class=\"md-button\" style=\"margin-right: 1rem; text-decoration: none;\">\n    Connect to Telegram\n  </a>\n  <a href=\"https://polkadot-discord.w3f.tools/\" class=\"md-button\" style=\"text-decoration: none;\">\n    Connect to Discord\n  </a>\n</div>\n\nPrefer to see all available channels? Below are your options."}
{"page_id": "get-support-get-in-touch", "page_title": "Get in Touch", "index": 1, "depth": 2, "title": "📱 Telegram: Polkadot Developer Support", "anchor": "telegram-polkadot-developer-support", "start_char": 546, "end_char": 876, "estimated_token_count": 94, "token_estimator": "heuristic-v1", "text": "## 📱 Telegram: Polkadot Developer Support\n\nThe fastest way to get support.\n\n- **Who’s there:** DevRel team and active developer community.\n- **Response time:** Within **2 business days (usually faster)**.\n- **Topics:** Any developer-related question is welcome.\n\n👉 **[Join Telegram](https://t.me/substratedevs){target=\\_blank}**"}
{"page_id": "get-support-get-in-touch", "page_title": "Get in Touch", "index": 2, "depth": 2, "title": "🔌 Discord: Polkadot Official Server", "anchor": "discord-polkadot-official-server", "start_char": 876, "end_char": 1328, "estimated_token_count": 128, "token_estimator": "heuristic-v1", "text": "## 🔌 Discord: Polkadot Official Server\n\nFocused support for smart contracts and general developer chat.\n\n- **Smart contracts:** Ask in `#solidity-smart-contracts` and `#ink_smart-contracts`.\n- **General developer support:** Ask in `#solidity-smart-contracts`.\n- **Response time:** Within **1 business day (usually faster)**.\n- **Other topics:** Community-led discussion only.\n\n👉 **[Join Discord](https://polkadot-discord.w3f.tools/){target=\\_blank}**"}
{"page_id": "get-support-get-in-touch", "page_title": "Get in Touch", "index": 3, "depth": 2, "title": "🧬 Matrix: Polkadot Developer Support", "anchor": "matrix-polkadot-developer-support", "start_char": 1328, "end_char": 1949, "estimated_token_count": 183, "token_estimator": "heuristic-v1", "text": "## 🧬 Matrix: Polkadot Developer Support\n\nThis is the **support channel** staffed by engineers from **Parity**, **Web3 Foundation**, and **Polkadot DevRel**.\n\n- **Who’s there:** Parity, W3F, DevRel, and community contributors.\n- **Response time:** Within **1 business day (usually faster)**.\n- **Topics:** Full-spectrum developer support.\n- Bridged with Telegram (all messages synced).\n\n👉 **[Join Matrix](https://matrix.to/#/#substratedevs:matrix.org){target=\\_blank}**\n\n---\n\nNot sure where to start?  \n\n**Join [Telegram](#telegram-polkadot-developer-support)**: Let us know what you need, and we’ll help you get unstuck."}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 21, "end_char": 613, "estimated_token_count": 113, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nBootnodes are essential for helping blockchain nodes discover peers and join the network. When a node starts, it needs to find other nodes, and bootnodes provide an initial point of contact. Once connected, a node can expand its peer connections and play its role in the network, like participating as a validator.\n\nThis guide will walk you through setting up a Polkadot bootnode, configuring P2P, WebSocket (WS), secure WSS connections, and managing network keys. You'll also learn how to test your bootnode to ensure it is running correctly and accessible to other nodes."}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 613, "end_char": 986, "estimated_token_count": 86, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore you start, you need to have the following prerequisites:\n\n- Verify a working Polkadot (`polkadot`) binary is available on your machine.\n- Ensure you have nginx installed. Please refer to the [Installation Guide](https://nginx.org/en/docs/install.html){target=\\_blank} for help with installation if needed.\n- A VPS or other dedicated server setup."}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 2, "depth": 2, "title": "Accessing the Bootnode", "anchor": "accessing-the-bootnode", "start_char": 986, "end_char": 1573, "estimated_token_count": 149, "token_estimator": "heuristic-v1", "text": "## Accessing the Bootnode\n\nBootnodes must be accessible through three key channels to connect with other nodes in the network:\n\n- **P2P**: A direct peer-to-peer connection, set by.\n\n    ```bash\n\n    --listen-addr /ip4/0.0.0.0/tcp/INSERT_PORT\n\n    ```\n    \n    This is not enabled by default on non-validator nodes like archive RPC nodes.\n\n- **P2P/WS**: A WebSocket (WS) connection, also configured via `--listen-addr`.\n- **P2P/WSS**: A secure WebSocket (WSS) connection using SSL, often required for light clients. An SSL proxy is needed, as the node itself cannot handle certificates."}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 3, "depth": 2, "title": "Node Key", "anchor": "node-key", "start_char": 1573, "end_char": 2240, "estimated_token_count": 148, "token_estimator": "heuristic-v1", "text": "## Node Key\n\nA node key is the ED25519 key used by `libp2p` to assign your node an identity or peer ID. Generating a known node key for a bootnode is crucial, as it gives you a consistent key that can be placed in chain specifications as a known, reliable bootnode.\n\nStarting a node creates its node key in the `chains/INSERT_CHAIN/network/secret_ed25519` file.\n\nYou can create a node key using:\n\n ``` bash\n polkadot key generate-node-key\n ``` \n \nThis key can be used in the startup command line.\n\nIt is imperative that you backup the node key. If it is included in the `polkadot` binary, it is hardcoded into the binary, which must be recompiled to change the key."}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 4, "depth": 2, "title": "Running the Bootnode", "anchor": "running-the-bootnode", "start_char": 2240, "end_char": 3333, "estimated_token_count": 240, "token_estimator": "heuristic-v1", "text": "## Running the Bootnode\n\nA bootnode can be run as follows:\n\n ``` bash\n polkadot --chain polkadot \\\n --name dot-bootnode \\\n --listen-addr /ip4/0.0.0.0/tcp/30310 \\\n --listen-addr /ip4/0.0.0.0/tcp/30311/ws\n ```\n\nThis assigns the p2p to port 30310 and p2p/ws to port 30311. For the p2p/wss port, a proxy must be set up with a DNS name and a corresponding certificate. The following example is for the popular nginx server and enables p2p/wss on port 30312 by adding a proxy to the p2p/ws port 30311:\n\n``` conf title=\"/etc/nginx/sites-enabled/dot-bootnode\"\nserver {\n       listen       30312 ssl http2 default_server;\n       server_name  dot-bootnode.stakeworld.io;\n       root         /var/www/html;\n\n       ssl_certificate \"INSERT_YOUR_CERT\";\n       ssl_certificate_key \"INSERT_YOUR_KEY\";\n\n       location / {\n         proxy_buffers 16 4k;\n         proxy_buffer_size 2k;\n         proxy_pass http://localhost:30311;\n         proxy_http_version 1.1;\n         proxy_set_header Upgrade $http_upgrade;\n         proxy_set_header Connection \"Upgrade\";\n         proxy_set_header Host $host;\n   }\n\n}\n```"}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 5, "depth": 2, "title": "Testing Bootnode Connection", "anchor": "testing-bootnode-connection", "start_char": 3333, "end_char": 3727, "estimated_token_count": 78, "token_estimator": "heuristic-v1", "text": "## Testing Bootnode Connection\n\nIf the preceding node is running with DNS name `dot-bootnode.stakeworld.io`, which contains a proxy with a valid certificate and node-id `12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg` then the following commands should output `syncing 1 peers`.\n\n!!!tip\n    You can add `-lsub-libp2p=trace` on the end to get libp2p trace logging for debugging purposes."}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 6, "depth": 3, "title": "P2P", "anchor": "p2p", "start_char": 3727, "end_char": 3993, "estimated_token_count": 74, "token_estimator": "heuristic-v1", "text": "### P2P\n\n```bash\npolkadot --chain polkadot \\\n--base-path /tmp/node \\\n--name \"Bootnode testnode\" \\\n--reserved-only \\\n--reserved-nodes \"/dns/dot-bootnode.stakeworld.io/tcp/30310/p2p/12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg\" \\\n--no-hardware-benchmarks\n```"}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 7, "depth": 3, "title": "P2P/WS", "anchor": "p2pws", "start_char": 3993, "end_char": 4265, "estimated_token_count": 78, "token_estimator": "heuristic-v1", "text": "### P2P/WS\n\n```bash\npolkadot --chain polkadot \\\n--base-path /tmp/node \\\n--name \"Bootnode testnode\" \\\n--reserved-only \\\n--reserved-nodes \"/dns/dot-bootnode.stakeworld.io/tcp/30311/ws/p2p/12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg\" \\\n--no-hardware-benchmarks\n```"}
{"page_id": "infrastructure-running-a-node-setup-bootnode", "page_title": "Set Up a Bootnode", "index": 8, "depth": 3, "title": "P2P/WSS", "anchor": "p2pwss", "start_char": 4265, "end_char": 4538, "estimated_token_count": 78, "token_estimator": "heuristic-v1", "text": "### P2P/WSS\n\n```bash\npolkadot --chain polkadot \\\n--base-path /tmp/node \\\n--name \"Bootnode testnode\" \\\n--reserved-only \\\n--reserved-nodes \"/dns/dot-bootnode.stakeworld.io/tcp/30312/wss/p2p/12D3KooWAb5MyC1UJiEQJk4Hg4B2Vi3AJdqSUhTGYUqSnEqCFMFg\" \\\n--no-hardware-benchmarks\n```"}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 17, "end_char": 945, "estimated_token_count": 165, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nRunning a node on Polkadot provides direct interaction with the network, enhanced privacy, and full control over RPC requests, transactions, and data queries. As the backbone of the network, nodes ensure decentralized data propagation, transaction validation, and seamless communication across the ecosystem.\n\nPolkadot supports multiple node types, including pruned, archive, and light nodes, each suited to specific use cases. During setup, you can use configuration flags to choose the node type you wish to run.\n\nThis guide walks you through configuring, securing, and maintaining a node on Polkadot or any Polkadot SDK-based chain. It covers instructions for the different node types and how to safely expose your node's RPC server for external access. Whether you're building a local development environment, powering dApps, or supporting network decentralization, this guide provides all the essentials."}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 1, "depth": 2, "title": "Set Up a Node", "anchor": "set-up-a-node", "start_char": 945, "end_char": 1150, "estimated_token_count": 43, "token_estimator": "heuristic-v1", "text": "## Set Up a Node\n\nNow that you're familiar with the different types of nodes, this section will walk you through configuring, securing, and maintaining a node on Polkadot or any Polkadot SDK-based chain."}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 2, "depth": 3, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1150, "end_char": 1686, "estimated_token_count": 131, "token_estimator": "heuristic-v1", "text": "### Prerequisites\n\nBefore getting started, ensure the following prerequisites are met:\n\n- Ensure [Rust](https://www.rust-lang.org/tools/install){target=\\_blank} is installed on your operating system.\n- [Install the necessary dependencies for the Polkadot SDK](/develop/parachains/install-polkadot-sdk/){target=\\_blank}.\n\n!!! warning\n    This setup is not recommended for validators. If you plan to run a validator, refer to the [Running a Validator](/infrastructure/running-a-validator/){target=\\_blank} guide for proper instructions."}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 3, "depth": 3, "title": "Install and Build the Polkadot Binary", "anchor": "install-and-build-the-polkadot-binary", "start_char": 1686, "end_char": 8170, "estimated_token_count": 1560, "token_estimator": "heuristic-v1", "text": "### Install and Build the Polkadot Binary\n\nThis section will walk you through installing and building the Polkadot binary for different operating systems and methods.\n\n??? interface \"macOS\"\n\n    To get started, update and configure the Rust toolchain by running the following commands:\n\n    ```bash\n    source ~/.cargo/env\n\n    rustup default stable\n    rustup update\n\n    rustup update nightly\n    rustup target add wasm32-unknown-unknown --toolchain nightly\n    rustup component add rust-src --toolchain stable-aarch64-apple-darwin\n    ```\n\n    You can verify your installation by running:\n\n    ```bash\n    rustup show\n    rustup +nightly show\n    ```\n\n    You should see output similar to the following:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"\n        ><span class=\"file-path\"></span>rustup show <br />\n        rustup +nightly show</span\n      >\n      <span data-ty>active toolchain</span>\n      <span data-ty>----------------</span>\n      <span data-ty></span>\n      <span data-ty>stable-aarch64-apple-darwin (default)</span>\n      <span data-ty>rustc 1.82.0 (f6e511eec 2024-10-15)</span>\n      <span data-ty></span>\n      <span data-ty>active toolchain</span>\n      <span data-ty>----------------</span>\n      <span data-ty></span>\n      <span data-ty>nightly-aarch64-apple-darwin (overridden by +toolchain on the command line) </span>\n      <span data-ty>rustc 1.84.0-nightly (03ee48451 2024-11-18)</span>\n      <span data-ty=\"input\"><span class=\"file-path\"></span></span>\n    </div>\n\n    Then, run the following commands to clone and build the Polkadot binary:\n  \n    ```bash\n    git clone https://github.com/paritytech/polkadot-sdk polkadot-sdk\n    cd polkadot-sdk\n    cargo build --release\n    ```\n\n    Depending upon the specs of your machine, compiling the binary may take an hour or more. After building the Polkadot node from source, the executable binary will be located in the `./target/release/polkadot` directory.\n\n??? interface \"Windows\"\n\n    To get started, make sure that you have [WSL and Ubuntu](https://learn.microsoft.com/en-us/windows/wsl/install){target=\\_blank} installed on your Windows machine.\n\n    Once installed, you have a couple options for installing the Polkadot binary:\n\n    - If Rust is installed, then `cargo` can be used similar to the macOS instructions.\n    - Or, the instructions in the Linux section can be used.\n\n??? interface \"Linux (pre-built binary)\"\n\n    To grab the [latest release of the Polkadot binary](https://github.com/paritytech/polkadot-sdk/releases){target=\\_blank}, you can use `wget`:\n\n    ```bash\n    wget https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION/polkadot\n    ```\n    \n    Ensure you note the executable binary's location, as you'll need to use it when running the start-up command. If you prefer, you can specify the output location of the executable binary with the `-O` flag, for example:\n\n    ```bash\n    wget https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-INSERT_VERSION/polkadot \\\n    - O /var/lib/polkadot-data/polkadot\n    ```\n\n    !!!tip\n        The nature of pre-built binaries means that they may not work on your particular architecture or Linux distribution. If you see an error like `cannot execute binary file: Exec format error` it likely means the binary is incompatible with your system. You will either need to compile the binary or use [Docker](#use-docker).\n\n    Ensure that you properly configure the permissions to make the Polkadot release binary executable:\n\n    ```bash\n    sudo chmod +x polkadot\n    ```\n\n??? interface \"Linux (compile binary)\"\n\n    The most reliable (although perhaps not the fastest) way of launching a full node is to compile the binary yourself. Depending on your machine's specs, this may take an hour or more.\n\n    To get started, run the following commands to configure the Rust toolchain:\n\n    ```bash\n    rustup default stable\n    rustup update\n    rustup update nightly\n    rustup target add wasm32-unknown-unknown --toolchain nightly\n    rustup target add wasm32-unknown-unknown --toolchain stable-x86_64-unknown-linux-gnu\n    rustup component add rust-src --toolchain stable-x86_64-unknown-linux-gnu\n    ```\n\n    You can verify your installation by running:\n\n    ```bash\n    rustup show\n    ```\n\n    You should see output similar to the following:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"\n        ><span class=\"file-path\"></span>rustup show <br />\n        rustup +nightly show</span\n      >\n      <span data-ty>active toolchain</span>\n      <span data-ty>----------------</span>\n      <span data-ty></span>\n      <span data-ty>stable-x86_64-unknown-linux-gnu (default)</span>\n      <span data-ty>rustc 1.82.0 (f6e511eec 2024-10-15)</span>\n    </div>\n\n    Once Rust is configured, run the following commands to clone and build Polkadot:\n  \n    ```bash\n    git clone https://github.com/paritytech/polkadot-sdk polkadot-sdk\n    cd polkadot-sdk\n    cargo build --release\n    ```\n\n    Compiling the binary may take an hour or more, depending on your machine's specs. After building the Polkadot node from the source, the executable binary will be located in the `./target/release/polkadot` directory.\n\n??? interface \"Linux (snap package)\"\n\n    Polkadot can be installed as a [snap package](https://snapcraft.io/polkadot){target=\\_blank}. If you don't already have Snap installed, take the following steps to install it:\n\n    ```bash\n    sudo apt update\n    sudo apt install snapd\n    ```\n\n    Install the Polkadot snap package:\n\n    ```bash\n    sudo snap install polkadot\n    ```\n    \n    Before continuing on with the following instructions, check out the [Configure and Run Your Node](#configure-and-run-your-node) section to learn more about the configuration options.\n\n    To configure your Polkadot node with your desired options, you'll run a command similar to the following:\n\n    ```bash\n    sudo snap set polkadot service-args=\"--name=MyName --chain=polkadot\"\n    ```\n\n    Then to start the node service, run:\n\n    ```bash\n    sudo snap start polkadot\n    ```\n\n    You can review the logs to check on the status of the node: \n\n    ```bash\n    snap logs polkadot -f\n    ```\n\n    And at any time, you can stop the node service:\n\n    ```bash\n    sudo snap stop polkadot\n    ```\n\n    You can optionally prevent the service from stopping when snap is updated with the following command:\n\n    ```bash\n    sudo snap set polkadot endure=true\n    ```"}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 4, "depth": 3, "title": "Use Docker", "anchor": "use-docker", "start_char": 8170, "end_char": 9237, "estimated_token_count": 293, "token_estimator": "heuristic-v1", "text": "### Use Docker\n\nAs an additional option, you can use Docker to run your node in a container. Doing this is more advanced, so it's best left up to those already familiar with Docker or who have completed the other set-up instructions in this guide. You can review the latest versions on [DockerHub](https://hub.docker.com/r/parity/polkadot/tags){target=\\_blank}.\n\nBe aware that when you run Polkadot in Docker, the process only listens on `localhost` by default. If you would like to connect to your node's services (RPC and Prometheus) you need to ensure that you run the node with the `--rpc-external`, and `--prometheus-external` commands.\n\n```bash\ndocker run -p 9944:9944 -p 9615:9615 parity/polkadot:v1.16.2 --name \"my-polkadot-node-calling-home\" --rpc-external --prometheus-external\n```\n\nIf you're running Docker on an Apple Silicon machine (e.g. M4), you'll need to adapt the command slightly:\n\n```bash\ndocker run --platform linux/amd64 -p 9944:9944 -p 9615:9615 parity/polkadot:v1.16.2 --name \"kearsarge-calling-home\" --rpc-external --prometheus-external\n```"}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 5, "depth": 2, "title": "Configure and Run Your Node", "anchor": "configure-and-run-your-node", "start_char": 9237, "end_char": 11179, "estimated_token_count": 464, "token_estimator": "heuristic-v1", "text": "## Configure and Run Your Node\n\nNow that you've installed and built the Polkadot binary, the next step is to configure the start-up command depending on the type of node that you want to run. You'll need to modify the start-up command accordingly based on the location of the binary. In some cases, it may be located within the `./target/release/` folder, so you'll need to replace polkadot with `./target/release/polkadot` in the following commands.\n\nAlso, note that you can use the same binary for Polkadot as you would for Kusama or any other relay chain. You'll need to use the `--chain` flag to differentiate between chains.\n\nIf you aren't sure which type of node to run, see the [Types of Full Nodes](/infrastructure/running-a-node/#types-of-nodes){target=\\_blank} section.\n\nThe base commands for running a Polkadot node are as follows:\n\n=== \"Default pruned node\"\n\n    This uses the default pruning value of the last 256 blocks:\n\n    ```bash\n    polkadot --chain polkadot \\\n    --name \"INSERT_NODE_NAME\"\n    ```\n\n=== \"Custom pruned node\"\n\n    You can customize the pruning value, for example, to the last 1000 finalized blocks:\n\n    ```bash\n    polkadot --chain polkadot \\\n    --name INSERT_YOUR_NODE_NAME \\\n    --state-pruning 1000 \\\n    --blocks-pruning archive \\\n    --rpc-cors all \\\n    --rpc-methods safe\n    ```\n\n=== \"Archive node\"\n\n    To support the full state, use the `archive` option:\n\n    ```bash\n    polkadot --chain polkadot \\\n    --name INSERT_YOUR_NODE_NAME \\\n    --state-pruning archive \\\n    --blocks-pruning archive \\\n    ```\n\nIf you want to run an RPC node, please refer to the following [RPC Configurations](#rpc-configurations) section.\n\nTo review a complete list of the available commands, flags, and options, you can use the `--help` flag:\n\n```bash\npolkadot --help\n```\n\nOnce you've fully configured your start-up command, you can execute it in your terminal and your node will start [syncing](#sync-your-node)."}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 6, "depth": 3, "title": "RPC Configurations", "anchor": "rpc-configurations", "start_char": 11179, "end_char": 12038, "estimated_token_count": 221, "token_estimator": "heuristic-v1", "text": "### RPC Configurations\n\nThe node startup settings allow you to choose what to expose, how many connections to expose, and which systems should be granted access through the RPC server.\n\n- You can limit the methods to use with `--rpc-methods`; an easy way to set this to a safe mode is `--rpc-methods safe`.\n- You can set your maximum connections through `--rpc-max-connections`, for example, `--rpc-max-connections 200`.\n- By default, localhost and Polkadot.js can access the RPC server. You can change this by setting `--rpc-cors`. To allow access from everywhere, you can use `--rpc-cors all`.\n\nFor a list of important flags when running RPC nodes, refer to the Parity DevOps documentation: [Important Flags for Running an RPC Node](https://paritytech.github.io/devops-guide/guides/rpc_index.html?#important-flags-for-running-an-rpc-node){target=\\_blank}."}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 7, "depth": 2, "title": "Sync Your Node", "anchor": "sync-your-node", "start_char": 12038, "end_char": 15706, "estimated_token_count": 1235, "token_estimator": "heuristic-v1", "text": "## Sync Your Node\n\nThe syncing process will take a while, depending on your capacity, processing power, disk speed, and RAM. The process may be completed on a $10 DigitalOcean droplet in about ~36 hours. While syncing, your node name should be visible in gray on Polkadot Telemetry, and once it is fully synced, your node name will appear in white on [Polkadot Telemetry](https://telemetry.polkadot.io/#list/Polkadot){target=_blank}.\n\nA healthy node syncing blocks will output logs like the following:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty>2024-11-19 23:49:57 Parity Polkadot</span>\n  <span data-ty>2024-11-19 23:49:57 ✌️ version 1.14.1-7c4cd60da6d</span>\n  <span data-ty>2024-11-19 23:49:57 ❤️ by Parity Technologies &lt;admin@parity.io&gt;, 2017-2024</span>\n  <span data-ty>2024-11-19 23:49:57 📋 Chain specification: Polkadot</span>\n  <span data-ty>2024-11-19 23:49:57 🏷 Node name: myPolkadotNode</span>\n  <span data-ty>2024-11-19 23:49:57 👤 Role: FULL</span>\n  <span data-ty>2024-11-19 23:49:57 💾 Database: RocksDb at /home/ubuntu/.local/share/polkadot/chains/polkadot/db/full</span>\n  <span data-ty>2024-11-19 23:50:00 🏷 Local node identity is: 12D3KooWDmhHEgPRJUJnUpJ4TFWn28EENqvKWH4dZGCN9TS51y9h</span>\n  <span data-ty>2024-11-19 23:50:00 Running libp2p network backend</span>\n  <span data-ty>2024-11-19 23:50:00 💻 Operating system: linux</span>\n  <span data-ty>2024-11-19 23:50:00 💻 CPU architecture: x86_64</span>\n  <span data-ty>2024-11-19 23:50:00 💻 Target environment: gnu</span>\n  <span data-ty>2024-11-19 23:50:00 💻 CPU: Intel(R) Xeon(R) CPU E3-1245 V2 @ 3.40GHz</span>\n  <span data-ty>2024-11-19 23:50:00 💻 CPU cores: 4</span>\n  <span data-ty>2024-11-19 23:50:00 💻 Memory: 32001MB</span>\n  <span data-ty>2024-11-19 23:50:00 💻 Kernel: 5.15.0-113-generic</span>\n  <span data-ty>2024-11-19 23:50:00 💻 Linux distribution: Ubuntu 22.04.5 LTS</span>\n  <span data-ty>2024-11-19 23:50:00 💻 Virtual machine: no</span>\n  <span data-ty>2024-11-19 23:50:00 📦 Highest known block at #9319</span>\n  <span data-ty>2024-11-19 23:50:00 〽️ Prometheus exporter started at 127.0.0.1:9615</span>\n  <span data-ty>2024-11-19 23:50:00 Running JSON-RPC server: addr=127.0.0.1:9944, allowed origins=[\"http://localhost:*\", \"http://127.0.0.1:*\", \"https://localhost:*\", \"https://127.0.0.1:*\", \"https://polkadot.js.org\"]</span>\n  <span data-ty>2024-11-19 23:50:00 🏁 CPU score: 671.67 MiBs</span>\n  <span data-ty>2024-11-19 23:50:00 🏁 Memory score: 7.96 GiBs</span>\n  <span data-ty>2024-11-19 23:50:00 🏁 Disk score (seq. writes): 377.87 MiBs</span>\n  <span data-ty>2024-11-19 23:50:00 🏁 Disk score (rand. writes): 147.92 MiBs</span>\n  <span data-ty>2024-11-19 23:50:00 🥩 BEEFY gadget waiting for BEEFY pallet to become available...</span>\n  <span data-ty>2024-11-19 23:50:00 🔍 Discovered new external address for our node: /ip4/37.187.93.17/tcp/30333/ws/p2p/12D3KooWDmhHEgPRJUJnUpJ4TFWn28EENqvKWH4dZGCN9TS51y9h</span>\n  <span data-ty>2024-11-19 23:50:01 🔍 Discovered new external address for our node: /ip6/2001:41d0:a:3511::1/tcp/30333/ws/p2p/12D3KooWDmhHEgPRJUJnUpJ4TFWn28EENqvKWH4dZGCN9TS51y9h</span>\n  <span data-ty>2024-11-19 23:50:05 ⚙️ Syncing, target=#23486325 (5 peers), best: #12262 (0x8fb5…f310), finalized #11776 (0x9de1…32fb), ⬇ 430.5kiB/s ⬆ 17.8kiB/s</span>\n  <span data-ty>2024-11-19 23:50:10 ⚙️ Syncing 628.8 bps, target=#23486326 (6 peers), best: #15406 (0x9ce1…2d76), finalized #15360 (0x0e41…a064), ⬇ 255.0kiB/s ⬆ 1.8kiB/s</span>\n</div>\n\nCongratulations, you're now syncing a Polkadot full node! Remember that the process is identical when using any other Polkadot SDK-based chain, although individual chains may have chain-specific flag requirements."}
{"page_id": "infrastructure-running-a-node-setup-full-node", "page_title": "Set Up a Node", "index": 8, "depth": 3, "title": "Connect to Your Node", "anchor": "connect-to-your-node", "start_char": 15706, "end_char": 16059, "estimated_token_count": 117, "token_estimator": "heuristic-v1", "text": "### Connect to Your Node\n\nOpen [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=ws%3A%2F%2F127.0.0.1%3A9944#/explorer){target=\\_blank} and click the logo in the top left to switch the node. Activate the **Development** toggle and input your node's domain or IP address. The default WSS endpoint for a local node is:\n\n```bash\nws://127.0.0.1:9944\n```"}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 27, "end_char": 600, "estimated_token_count": 103, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nEnsuring secure WebSocket communication is crucial for maintaining the integrity and security of a Polkadot or Kusama node when interacting with remote clients. This guide walks you through setting up a secure WebSocket (WSS) connection for your node by leveraging SSL encryption with popular web server proxies like nginx or Apache.\n\nBy the end of this guide, you'll be able to secure your node's WebSocket port, enabling safe remote connections without exposing your node to unnecessary risks. The instructions in this guide are for UNIX-based systems."}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 1, "depth": 2, "title": "Secure a WebSocket Port", "anchor": "secure-a-websocket-port", "start_char": 600, "end_char": 1053, "estimated_token_count": 102, "token_estimator": "heuristic-v1", "text": "## Secure a WebSocket Port\n\nYou can convert a non-secured WebSocket port to a secure WSS port by placing it behind an SSL-enabled proxy. This approach can be used to secure a bootnode or RPC server. The SSL-enabled apache2/nginx/other proxy server redirects requests to the internal WebSocket and converts it to a secure (WSS) connection. You can use a service like [LetsEncrypt](https://letsencrypt.org/){target=\\_blank} to obtain an SSL certificate."}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 2, "depth": 3, "title": "Obtain an SSL Certificate", "anchor": "obtain-an-ssl-certificate", "start_char": 1053, "end_char": 2080, "estimated_token_count": 257, "token_estimator": "heuristic-v1", "text": "### Obtain an SSL Certificate\n\nLetsEncrypt suggests using the [Certbot ACME client](https://letsencrypt.org/getting-started/#with-shell-access/){target=\\_blank} for your respective web server implementation to get a free SSL certificate:\n\n- [nginx](https://certbot.eff.org/instructions?ws=nginx&os=ubuntufocal){target=\\_blank}\n- [apache2](https://certbot.eff.org/instructions?ws=apache&os=ubuntufocal){target=\\_blank}\n \nLetsEncrypt will auto-generate an SSL certificate and include it in your configuration.\n\nWhen connecting, you can generate a self-signed certificate and rely on your node's raw IP address. However, self-signed certificates aren't optimal because you must include the certificate in an allowlist to access it from a browser.\n\nUse the following command to generate a self-signed certificate using OpenSSL:\n\n```bash\nsudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/selfsigned.key -out /etc/ssl/certs/selfsigned.crt\nsudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\n```"}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 3, "depth": 2, "title": "Install a Proxy Server", "anchor": "install-a-proxy-server", "start_char": 2080, "end_char": 2477, "estimated_token_count": 99, "token_estimator": "heuristic-v1", "text": "## Install a Proxy Server\n\nThere are a lot of different implementations of a WebSocket proxy; some of the more widely used are [nginx](https://www.f5.com/go/product/welcome-to-nginx){target=\\_blank} and [apache2](https://httpd.apache.org/){target=\\_blank}, both of which are commonly used web server implementations. See the following section for configuration examples for both implementations."}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 4, "depth": 3, "title": "Use nginx", "anchor": "use-nginx", "start_char": 2477, "end_char": 3219, "estimated_token_count": 154, "token_estimator": "heuristic-v1", "text": "### Use nginx\n\n1. Install the `nginx` web server: \n    ```bash\n    apt install nginx\n    ```\n\n2. In an SSL-enabled virtual host, add:\n    ```conf\n    server {\n        (...)\n        location / {\n        proxy_buffers 16 4k;\n        proxy_buffer_size 2k;\n        proxy_pass http://localhost:9944;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n        proxy_set_header Host $host;\n        }\n    }\n    ```\n3. Optionally, you can introduce some form of rate limiting:\n    ```conf\n    http {\n        limit_req_zone  \"$http_x_forwarded_for\" zone=zone:10m rate=2r/s;\n        (...)\n    }\n    location / {\n        limit_req zone=zone burst=5;\n        (...)\n    }\n    ```"}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 5, "depth": 3, "title": "Use Apache2", "anchor": "use-apache2", "start_char": 3219, "end_char": 5047, "estimated_token_count": 406, "token_estimator": "heuristic-v1", "text": "### Use Apache2\n\nApache2 can run in various modes, including `prefork`, `worker`, and `event`. In this example, the [`event`](https://httpd.apache.org/docs/2.4/mod/event.html){target=\\_blank} mode is recommended for handling higher traffic loads, as it is optimized for performance in such environments. However, depending on the specific requirements of your setup, other modes like `prefork` or `worker` may also be appropriate.\n\n1. Install the `apache2` web server:\n    ```bash\n    apt install apache2\n    a2dismod mpm_prefork\n    a2enmod mpm_event proxy proxy_html proxy_http proxy_wstunnel rewrite ssl\n    ```\n2. The [`mod_proxy_wstunnel`](https://httpd.apache.org/docs/2.4/mod/mod_proxy_wstunnel.html){target=\\_blank} provides support for the tunneling of WebSocket connections to a backend WebSocket server. The connection is automatically upgraded to a WebSocket connection. In an SSL-enabled virtual host add:\n\n    ```apacheconf\n    # (...)\n    SSLProxyEngine on\n    ProxyRequests off\n    ProxyPass / ws://localhost:9944\n    ProxyPassReverse / ws://localhost:9944\n    ```\n    !!!warning \n        Older versions of `mod_proxy_wstunnel` don't upgrade the connection automatically and will need the following config added:\n        ```apacheconf\n        RewriteEngine on\n        RewriteCond %{HTTP:Upgrade} websocket [NC]\n        RewriteRule /(.*) ws://localhost:9944/$1 [P,L]\n        RewriteRule /(.*) http://localhost:9944/$1 [P,L]\n        ```\n\n3. Optionally, some form of rate limiting can be introduced by first running the following command:\n\n    ```bash\n    apt install libapache2-mod-qos\n    a2enmod qos\n    ```\n\n    Then edit `/etc/apache2/mods-available/qos.conf` as follows:\n\n    ```conf\n    # allows max 50 connections from a single IP address:\n    QS_SrvMaxConnPerIP                                 50\n    ```"}
{"page_id": "infrastructure-running-a-node-setup-secure-wss", "page_title": "Set Up Secure WebSocket", "index": 6, "depth": 2, "title": "Connect to the Node", "anchor": "connect-to-the-node", "start_char": 5047, "end_char": 5597, "estimated_token_count": 165, "token_estimator": "heuristic-v1", "text": "## Connect to the Node\n\n1. Open [Polkadot.js Apps interface](https://polkadot.js.org/apps){target=\\_blank} and click the logo in the top left to switch the node.\n2. Activate the **Development** toggle and input either your node's domain or IP address. Remember to prefix with `wss://` and, if you're using the 443 port, append `:443` as follows:\n\n    ```bash\n    wss://example.com:443\n    ```\n\n![A sync-in-progress chain connected to Polkadot.js UI](/images/infrastructure/running-a-validator/running-a-node/setup-secure-wss/setup-secure-wss-1.webp)"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 18, "end_char": 574, "estimated_token_count": 113, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nAfter setting up your node environment as shown in the [Setup](/infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator){target=\\_blank} section, you'll need to configure multiple keys for your validator to operate properly. This includes setting up session keys, which are essential for participating in the consensus process, and configuring a node key that maintains a stable network identity. This guide walks you through the key management process, showing you how to generate, store, and register these keys."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 1, "depth": 2, "title": "Set Session Keys", "anchor": "set-session-keys", "start_char": 574, "end_char": 1104, "estimated_token_count": 100, "token_estimator": "heuristic-v1", "text": "## Set Session Keys\n\nSetting up your validator's session keys is essential to associate your node with your stash account on the Polkadot network. Validators use session keys to participate in the consensus process. Your validator can only perform its role in the network by properly setting session keys which consist of several key pairs for different parts of the protocol (e.g., GRANDPA, BABE). These keys must be registered on-chain and associated with your validator node to ensure it can participate in validating blocks."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 2, "depth": 3, "title": "Generate Session Keys", "anchor": "generate-session-keys", "start_char": 1104, "end_char": 4115, "estimated_token_count": 644, "token_estimator": "heuristic-v1", "text": "### Generate Session Keys\n\nThere are multiple ways to create the session keys. It can be done by interacting with the [Polkadot.js Apps UI](https://polkadot.js.org/apps/#/explorer){target=\\_blank}, using the curl command or by using [Subkey](https://paritytech.github.io/polkadot-sdk/master/subkey/index.html){target=\\_blank}.\n\n=== \"Polkadot.js Apps UI\"\n\n    1. In Polkadot.js Apps, connect to your local node, navigate to the **Developer** dropdown, and select the **RPC Calls** option.\n\n    2. Construct an `author_rotateKeys` RPC call and execute it:\n\n        1. Select the **author** endpoint.\n        2. Choose the **rotateKeys()** call.\n        3. Click the **Submit RPC Call** button.\n        4. Copy the hex-encoded public key from the response.\n\n        ![](/images/infrastructure/running-a-validator/onboarding-and-offboarding/key-management/key-management-1.webp)\n\n=== \"Curl\"\n\n    Generate session keys by running the following command on your validator node:\n\n    ``` bash\n    curl -H \"Content-Type: application/json\" \\\n    -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"author_rotateKeys\", \"params\":[]}' \\\n    http://localhost:9944\n    ```\n\n    This command will return a JSON object. The `result` key is the hex-encoded public part of the newly created session key. Save this for later use.\n    \n    ```json\n    {\"jsonrpc\":\"2.0\",\"result\":\"0xda3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010\",\"id\":1}\n    ```\n\n=== \"Subkey\"\n\n    To create a keypair for your node's session keys, use the `subkey generate` command. This generates a set of cryptographic keys that must be stored in your node's keystore directory.\n\n    When you run the command, it produces output similar to this example:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>subkey generate</span>\n      <pre>\n    Secret phrase:       twist buffalo mixture excess device drastic vague mammal fitness punch match hammer\n      Network ID:        substrate\n      Secret seed:       0x5faa9e5defe42b201388d5c2b8202d6625a344abc9aa52943a71f12cb90b88a9\n      Public key (hex):  0x28cc2fdb6e28835e2bbac9a16feb65c23d448c9314ef12fe083b61bab8fc2755\n      Account ID:        0x28cc2fdb6e28835e2bbac9a16feb65c23d448c9314ef12fe083b61bab8fc2755\n      Public key (SS58): 5CzCRpXzHYhuo6G3gYFR3cgV6X3qCNwVt51m8q14ZcChsSXQ\n      SS58 Address:      5CzCRpXzHYhuo6G3gYFR3cgV6X3qCNwVt51m8q14ZcChsSXQ\n      </pre>\n    </div>\n\n    To properly store these keys, create a file in your keystore directory with a specific naming convention. The filename must consist of the hex string `61757261` (which represents \"aura\" in hex) followed by the public key without its `0x` prefix.\n\n    Using the example above, you would create a file named:\n\n    ```\n    ./keystores/6175726128cc2fdb6e28835e2bbac9a16feb65c23d448c9314ef12fe083b61bab8fc2755\n    ```\n\n    And store only the secret phrase in the file:\n\n    ```\n    \"twist buffalo mixture excess device drastic vague mammal fitness punch match hammer\"\n    ```"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 3, "depth": 3, "title": "Submit Transaction to Set Keys", "anchor": "submit-transaction-to-set-keys", "start_char": 4115, "end_char": 4748, "estimated_token_count": 148, "token_estimator": "heuristic-v1", "text": "### Submit Transaction to Set Keys\n\nNow that you have generated your session keys, you must submit them to the chain. Follow these steps:\n\n1. Go to the **Network > Staking > Accounts** section on Polkadot.js Apps.\n2. Select **Set Session Key** on the bonding account you generated earlier.\n3. Paste the hex-encoded session key string you generated (from either the UI or CLI) into the input field and submit the transaction.\n\n![](/images/infrastructure/running-a-validator/onboarding-and-offboarding/key-management/key-management-2.webp)\n\nOnce the transaction is signed and submitted, your session keys will be registered on-chain."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 4, "depth": 3, "title": "Verify Session Key Setup", "anchor": "verify-session-key-setup", "start_char": 4748, "end_char": 5293, "estimated_token_count": 138, "token_estimator": "heuristic-v1", "text": "### Verify Session Key Setup\n\nTo verify that your session keys are properly set, you can use one of two RPC calls:\n\n- **`hasKey`**: Checks if the node has a specific key by public key and key type.\n- **`hasSessionKeys`**: Verifies if your node has the full session key string associated with the validator.\n\nFor example, you can [check session keys on the Polkadot.js Apps](https://polkadot.js.org/apps/#/rpc){target=\\_blank} interface or by running an RPC query against your node. Once this is done, your validator node is ready for its role."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 5, "depth": 2, "title": "Set the Node Key", "anchor": "set-the-node-key", "start_char": 5293, "end_char": 6935, "estimated_token_count": 408, "token_estimator": "heuristic-v1", "text": "## Set the Node Key\n\nValidators on Polkadot need a static network key (also known as the node key) to maintain a stable node identity. This key ensures that your validator can maintain a consistent peer ID, even across restarts, which is crucial for maintaining reliable network connections.\n\nStarting with Polkadot version 1.11, validators without a stable network key may encounter the following error on startup:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot --validator --name \"INSERT_NAME_FROM_TELEMETRY\"</span>\n  <span data-ty>Error:</span>\n  <span data-ty>0: Starting an authority without network key</span>\n  <span data-ty>This is not a safe operation because other authorities in the network may depend on your node having a stable identity.</span>\n  <span data-ty>Otherwise these other authorities may not being able to reach you.</span>\n  <span data-ty>If it is the first time running your node you could use one of the following methods:</span>\n  <span data-ty>1. [Preferred] Separately generate the key with: INSERT_NODE_BINARY key generate-node-key --base-path INSERT_YOUR_BASE_PATH</span>\n  <span data-ty>2. [Preferred] Separately generate the key with: INSERT_NODE_BINARY key generate-node-key --file INSERT_YOUR_PATH_TO_NODE_KEY</span>\n  <span data-ty>3. [Preferred] Separately generate the key with: INSERT_NODE_BINARY key generate-node-key --default-base-path</span>\n  <span data-ty>4. [Unsafe] Pass --unsafe-force-node-key-generation and make sure you remove it for subsequent node restarts</span>\n  <span data-ty=\"input\"><span class=\"file-path\"></span></span>\n</div>"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 6, "depth": 3, "title": "Generate the Node Key", "anchor": "generate-the-node-key", "start_char": 6935, "end_char": 7596, "estimated_token_count": 144, "token_estimator": "heuristic-v1", "text": "### Generate the Node Key\n\nUse one of the following methods to generate your node key:\n\n=== \"Save to file\"\n\n    The recommended solution is to generate a node key and save it to a file using the following command:\n\n    ``` bash\n    polkadot key generate-node-key --file INSERT_PATH_TO_NODE_KEY\n    ```\n    \n=== \"Use default path\"\n\n    You can also generate the node key with the following command, which will automatically save the key to the base path of your node:\n\n    ``` bash\n    polkadot key generate-node-key --default-base-path\n    ```\n\nSave the file path for reference. You will need it in the next step to configure your node with a static identity."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-key-management", "page_title": "Validator Key Management", "index": 7, "depth": 3, "title": "Set Node Key", "anchor": "set-node-key", "start_char": 7596, "end_char": 8218, "estimated_token_count": 132, "token_estimator": "heuristic-v1", "text": "### Set Node Key\n\nAfter generating the node key, configure your node to use it by specifying the path to the key file when launching your node. Add the following flag to your validator node's startup command:\n\n``` bash\npolkadot --node-key-file INSERT_PATH_TO_NODE_KEY\n```\n\nFollowing these steps ensures that your node retains its identity, making it discoverable by peers without the risk of conflicting identities across sessions. For further technical background, see Polkadot SDK [Pull Request #3852](https://github.com/paritytech/polkadot-sdk/pull/3852){target=\\_blank} for the rationale behind requiring static keys."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 22, "end_char": 642, "estimated_token_count": 101, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nSetting up a Polkadot validator node is essential for securing the network and earning staking rewards. This guide walks you through the technical steps to set up a validator, from installing the necessary software to managing keys and synchronizing your node with the chain.\n\nRunning a validator requires a commitment to maintaining a stable, secure infrastructure. Validators are responsible for their own stakes and those of nominators who trust them with their tokens. Proper setup and ongoing management are critical to ensuring smooth operation and avoiding potential penalties such as slashing."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 642, "end_char": 1706, "estimated_token_count": 246, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nTo get the most from this guide, ensure you've done the following before going forward:\n\n- Read [Validator Requirements](/infrastructure/running-a-validator/requirements/){target=\\_blank} and understand the recommended minimum skill level and hardware needs.\n- Read [General Management](/infrastructure/running-a-validator/operational-tasks/general-management){target=\\_blank}, [Upgrade Your Node](/infrastructure/running-a-validator/operational-tasks/upgrade-your-node/){target=\\_blank}, and [Pause Validating](/infrastructure/running-a-validator/onboarding-and-offboarding/stop-validating/){target=\\_blank} and understand the tasks required to keep your validator operational.\n- Read [Rewards Payout](/infrastructure/staking-mechanics/rewards-payout/){target=\\_blank} and understand how validator rewards are determined and paid out.\n- Read [Offenses and Slashes](/infrastructure/staking-mechanics/offenses-and-slashes/){target=\\_blank} and understand how validator performance and security can affect tokens staked by you or your nominators."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 2, "depth": 2, "title": "Initial Setup", "anchor": "initial-setup", "start_char": 1706, "end_char": 2262, "estimated_token_count": 94, "token_estimator": "heuristic-v1", "text": "## Initial Setup\n\nBefore running your validator, you must configure your server environment to meet the operational and security standards required for validating.\n\nYou must use a Linux-based operating system with Kernel 5.16 or later. Configuration includes setting up time synchronization, ensuring critical security features are active, and installing the necessary binaries. Proper setup at this stage is essential to prevent issues like block production errors or being penalized for downtime. Below are the essential steps to get your system ready."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 3, "depth": 3, "title": "Install Network Time Protocol Client", "anchor": "install-network-time-protocol-client", "start_char": 2262, "end_char": 3374, "estimated_token_count": 236, "token_estimator": "heuristic-v1", "text": "### Install Network Time Protocol Client\n\nAccurate timekeeping is critical to ensure your validator is synchronized with the network. Validators need local clocks in sync with the blockchain to avoid missing block authorship opportunities. Using [Network Time Protocol (NTP)](https://en.wikipedia.org/wiki/Network_Time_Protocol){target=\\_blank} is the standard solution to keep your system's clock accurate.\n\nIf you are using Ubuntu version 18.04 or newer, the NTP Client should be installed by default. You can check whether you have the NTP client by running:\n\n```sh\ntimedatectl\n```\n\nIf NTP is running, you should see a message like the following:\n\n``` sh\nSystem clock synchronized: yes\n```\n\nIf NTP is not installed or running, you can install it using:\n\n```sh\nsudo apt-get install ntp\n```\n\nAfter installation, NTP will automatically start. To check its status:\n\n```sh\nsudo ntpq -p\n```\n\nThis command will return a message with the status of the NTP synchronization. Skipping this step could result in your validator node missing blocks due to minor clock drift, potentially affecting its network performance."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 4, "depth": 3, "title": "Verify Landlock is Activated", "anchor": "verify-landlock-is-activated", "start_char": 3374, "end_char": 4971, "estimated_token_count": 319, "token_estimator": "heuristic-v1", "text": "### Verify Landlock is Activated\n\n[Landlock](https://docs.kernel.org/userspace-api/landlock.html){target=\\_blank} is an important security feature integrated into Linux kernels starting with version 5.13. It allows processes, even those without special privileges, to limit their access to the system to reduce the machine's attack surface. This feature is crucial for validators, as it helps ensure the security and stability of the node by preventing unauthorized access or malicious behavior.\n\nTo use Landlock, ensure you use the reference kernel or newer versions. Most Linux distributions should already have Landlock activated. You can check if Landlock is activated on your machine by running the following command as root:\n\n```sh\ndmesg | grep landlock || journalctl -kg landlock\n```\n\nIf Landlock is not activated, your system logs won't show any related output. In this case, you will need to activate it manually or ensure that your Linux distribution supports it. Most modern distributions with the required kernel version should have Landlock activated by default. However, if your system lacks support, you may need to build the kernel with Landlock activated. For more information on doing so, refer to the [official kernel documentation](https://docs.kernel.org/userspace-api/landlock.html#kernel-support){target=\\_blank}.\n\nImplementing Landlock ensures your node operates in a restricted, self-imposed sandbox, limiting potential damage from security breaches or bugs. While not a mandatory requirement, enabling this feature greatly improves the security of your validator setup."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 5, "depth": 2, "title": "Install the Polkadot Binaries", "anchor": "install-the-polkadot-binaries", "start_char": 4971, "end_char": 5397, "estimated_token_count": 82, "token_estimator": "heuristic-v1", "text": "## Install the Polkadot Binaries\n\nYou must install the Polkadot binaries required to run your validator node. These binaries include the main `polkadot`, `polkadot-prepare-worker`, and `polkadot-execute-worker` binaries. All three are needed to run a fully functioning validator node.\n\nDepending on your preference and operating system setup, there are multiple methods to install these binaries. Below are the main options:"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 6, "depth": 3, "title": "Install from Official Releases", "anchor": "install-from-official-releases", "start_char": 5397, "end_char": 8187, "estimated_token_count": 622, "token_estimator": "heuristic-v1", "text": "### Install from Official Releases\n\nThe preferred, most straightforward method to install the required binaries is downloading the latest versions from the official releases. You can visit the [Github Releases](https://github.com/paritytech/polkadot-sdk/releases){target=\\_blank} page for the most current versions of the `polkadot`, `polkadot-prepare-worker`, and `polkadot-execute-worker` binaries.\n\nYou can also download the binaries by using the following direct links:\n\n=== \"`polkadot`\"\n\n    ``` bash\n    # Download the binary\n    curl -LO https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-stable2506-2/polkadot\n\n    # Verify signature\n    curl -LO https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-stable2506-2/polkadot.asc\n    \n    gpg --keyserver hkps://keyserver.ubuntu.com --receive-keys 90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE\n\n    gpg --verify polkadot.asc\n    ```\n\n=== \"`polkadot-prepare-worker`\"\n\n    ``` bash\n    # Download the binary\n    curl -LO https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-stable2506-2/polkadot-prepare-worker\n\n    # Verify signature\n    curl -LO https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-stable2506-2/polkadot-prepare-worker.asc\n\n    gpg --keyserver hkps://keyserver.ubuntu.com --receive-keys 90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE\n\n    gpg --verify polkadot-prepare-worker.asc\n    ```\n\n=== \"`polkadot-execute-worker`\"\n\n    ``` bash\n    # Download the binary\n    curl -LO https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-stable2506-2/polkadot-execute-worker\n\n    # Verify signature\n    curl -LO https://github.com/paritytech/polkadot-sdk/releases/download/polkadot-stable2506-2/polkadot-execute-worker.asc\n\n    gpg --keyserver hkps://keyserver.ubuntu.com --receive-keys 90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE\n\n    gpg --verify polkadot-execute-worker.asc\n    ```\n\n\nSignature verification cryptographically ensures the downloaded binaries are authentic and have not been tampered with by using GPG signing keys. Polkadot releases use two different signing keys:\n\n- ParityReleases (release-team@parity.io) with key [`90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE`](https://keyserver.ubuntu.com/pks/lookup?search=90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE&fingerprint=on&op=index){target=\\_blank} for current and new releases.\n- Parity Security Team (security@parity.io) with key [`9D4B2B6EB8F97156D19669A9FF0812D491B96798`](https://keyserver.ubuntu.com/pks/lookup?search=9D4B2B6EB8F97156D19669A9FF0812D491B96798&fingerprint=on&op=index){target=\\_blank} for old releases.\n\n    !!!warning\n        When verifying a signature, a \"Good signature\" message indicates successful verification, while any other output signals a potential security risk."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 7, "depth": 3, "title": "Install with Package Managers", "anchor": "install-with-package-managers", "start_char": 8187, "end_char": 9254, "estimated_token_count": 241, "token_estimator": "heuristic-v1", "text": "### Install with Package Managers\n\nUsers running Debian-based distributions like Ubuntu can install the binaries using the [APT](https://wiki.debian.org/Apt){target=\\_blank} package manager.\n\nExecute the following commands as root to add the official repository and install the binaries:\n\n```bash\n# Import the release-team@parity.io GPG key\ngpg --keyserver hkps://keyserver.ubuntu.com --receive-keys 90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE\ngpg --export 90BD75EBBB8E95CB3DA6078F94A4029AB4B35DAE > /usr/share/keyrings/parity.gpg\n\n# Add the Parity repository and update the package index\necho 'deb [signed-by=/usr/share/keyrings/parity.gpg] https://releases.parity.io/deb release main' > /etc/apt/sources.list.d/parity.list\napt update\n\n# Install the `parity-keyring` package - This will ensure the GPG key\n# used by APT remains up-to-date\napt install parity-keyring\n\n# Install polkadot\napt install polkadot\n```\n\nOnce installation completes, verify the binaries are correctly installed by following the steps in the [verify installation](#verify-installation) section."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 8, "depth": 3, "title": "Install with Ansible", "anchor": "install-with-ansible", "start_char": 9254, "end_char": 9611, "estimated_token_count": 70, "token_estimator": "heuristic-v1", "text": "### Install with Ansible\n\nYou can also manage Polkadot installations using Ansible. This approach can be beneficial for users managing multiple validator nodes or requiring automated deployment. The [Parity chain operations Ansible collection](https://github.com/paritytech/ansible-galaxy/){target=\\_blank} provides a Substrate node role for this purpose."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 9, "depth": 3, "title": "Install with Docker", "anchor": "install-with-docker", "start_char": 9611, "end_char": 9894, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "### Install with Docker\n\nIf you prefer using Docker or an OCI-compatible container runtime, the official Polkadot Docker image can be pulled directly from Docker Hub.\n\nTo pull the latest stable image, run the following command:\n\n```bash\ndocker pull parity/polkadot:stable2506-2\n```"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 10, "depth": 3, "title": "Build from Sources", "anchor": "build-from-sources", "start_char": 9894, "end_char": 10127, "estimated_token_count": 58, "token_estimator": "heuristic-v1", "text": "### Build from Sources\n\nYou may build the binaries from source by following the instructions on the [Polkadot SDK repository](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506-2/polkadot#building){target=\\_blank}."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-set-up-validator", "page_title": "Set Up a Validator", "index": 11, "depth": 2, "title": "Verify Installation", "anchor": "verify-installation", "start_char": 10127, "end_char": 11883, "estimated_token_count": 430, "token_estimator": "heuristic-v1", "text": "## Verify Installation\n\nOnce the Polkadot binaries are installed, it's essential to verify that everything is set up correctly and that all the necessary components are in place. Follow these steps to ensure the binaries are installed and functioning as expected.\n\n1. **Check the versions**: Run the following commands to verify the versions of the installed binaries.\n\n    ```bash\n    polkadot --version\n    polkadot-execute-worker --version\n    polkadot-prepare-worker --version\n    ```\n\n    The output should show the version numbers for each of the binaries. Ensure that the versions match and are consistent, similar to the following example (the specific version may vary):\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot --version polkadot-execute-worker --version polkadot-prepare-worker --version</span>\n      <span data-ty>1.16.1-36264cb36db</span>\n      <span data-ty>1.16.1-36264cb36db</span>\n      <span data-ty>1.16.1-36264cb36db</span>\n      <span data-ty=\"input\"><span class=\"file-path\"></span></span>\n    </div>\n\n    If the versions do not match or if there is an error, double-check that all the binaries were correctly installed and are accessible within your `$PATH`.\n\n2. **Ensure all binaries are in the same directory**: All the binaries must be in the same directory for the Polkadot validator node to function properly. If the binaries are not in the same location, move them to a unified directory and ensure this directory is added to your system's `$PATH`.\n\n    To verify the `$PATH`, run the following command:\n\n    ```bash\n    echo $PATH\n    ```\n\n    If necessary, you can move the binaries to a shared location, such as `/usr/local/bin/`, and add it to your `$PATH`."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 20, "end_char": 446, "estimated_token_count": 89, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nAfter configuring your node keys as shown in the [Key Management](/infrastructure/running-a-validator/onboarding-and-offboarding/key-management){target=\\_blank} section and ensuring your system is set up, you're ready to begin the validator setup process. This guide will walk you through choosing a network, synchronizing your node with the blockchain, bonding your DOT tokens, and starting your validator."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 1, "depth": 2, "title": "Choose a Network", "anchor": "choose-a-network", "start_char": 446, "end_char": 1435, "estimated_token_count": 193, "token_estimator": "heuristic-v1", "text": "## Choose a Network\n\nRunning your validator on a test network like Westend or Kusama is a smart way to familiarize yourself with the process and identify any setup issues in a lower-stakes environment before joining the Polkadot MainNet.\n\n- **Westend**: Polkadot's primary TestNet is open to anyone for testing purposes. Validator slots are intentionally limited to keep the network stable for the Polkadot release process, so it may not support as many validators at any given time.\n- **Kusama**: Often called Polkadot's \"canary network,\" Kusama has real economic value but operates with a faster and more experimental approach. Running a validator here provides an experience closer to MainNet with the benefit of more frequent validation opportunities with an era time of 6 hours vs 24 hours for Polkadot.\n- **Polkadot**: The main network, where validators secure the Polkadot relay chain. It has a slower era time of 24 hours and requires a higher minimum bond amount to participate."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 2, "depth": 2, "title": "Synchronize Chain Data", "anchor": "synchronize-chain-data", "start_char": 1435, "end_char": 4713, "estimated_token_count": 857, "token_estimator": "heuristic-v1", "text": "## Synchronize Chain Data\n\nThe next step is to sync your node with the chosen blockchain network. Synchronization is necessary to download and validate the blockchain data, ensuring your node is ready to participate as a validator. Follow these steps to sync your node:\n\n1. **Start syncing**: You can run a full or warp sync.\n\n    === \"Full sync\"\n\n        Polkadot defaults to using a full sync, which downloads and validates the entire blockchain history from the genesis block. Start the syncing process by running the following command:\n\n        ```sh\n        polkadot\n        ```\n\n        This command starts your Polkadot node in non-validator mode, allowing you to synchronize the chain data.\n\n    === \"Warp sync\"\n\n        You can opt to use warp sync which initially downloads only GRANDPA finality proofs and the latest finalized block's state. Use the following command to start a warp sync:\n\n        ``` bash\n        polkadot --sync warp\n        ```\n\n        Warp sync ensures that your node quickly updates to the latest finalized state. The historical blocks are downloaded in the background as the node continues to operate.\n\n    If you're planning to run a validator on a TestNet, you can specify the chain using the `--chain` flag. For example, the following will run a validator on Kusama:\n\n    ```sh\n    polkadot --chain=kusama\n    ```\n\n2. **Monitor sync progress**: Once the sync starts, you will see a stream of logs providing information about the node's status and progress. Here's an example of what the output might look like:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot</span>\n      <span data-ty>2021-06-17 03:07:07 Parity Polkadot</span>\n      <span data-ty>2021-06-17 03:07:07 ✌️ version 0.9.5-95f6aa201-x86_64-linux-gnu</span>\n      <span data-ty>2021-06-17 03:07:07 ❤️ by Parity Technologies &lt;admin@parity.io&gt;, 2017-2021</span>\n      <span data-ty>2021-06-17 03:07:07 📋 Chain specification: Polkadot</span>\n      <span data-ty>2021-06-17 03:07:07 🏷 Node name: boiling-pet-7554</span>\n      <span data-ty>2021-06-17 03:07:07 👤 Role: FULL</span>\n      <span data-ty>2021-06-17 03:07:07 💾 Database: RocksDb at /root/.local/share/polkadot/chains/polkadot/db</span>\n      <span data-ty>2021-06-17 03:07:07 ⛓ Native runtime: polkadot-9050 (parity-polkadot-0.tx7.au0)</span>\n      <span data-ty>2021-06-17 03:07:10 🏷 Local node identity is: 12D3KooWLtXFWf1oGrnxMGmPKPW54xWCHAXHbFh4Eap6KXmxoi9u</span>\n      <span data-ty>2021-06-17 03:07:10 📦 Highest known block at #17914</span>\n      <span data-ty>2021-06-17 03:07:10 〽️ Prometheus server started at 127.0.0.1:9615</span>\n      <span data-ty>2021-06-17 03:07:10 Listening for new connections on 127.0.0.1:9944</span>\n      <span data-ty>...</span>\n    </div>\n\n    The output logs provide information such as the current block number, node name, and network connections. Monitor the sync progress and any errors that might occur during the process. Look for information about the latest processed block and compare it with the current highest block using tools like [Telemetry](https://telemetry.polkadot.io/#list/Polkadot%20CC1){target=\\_blank} or [Polkadot.js Apps Explorer](https://polkadot.js.org/apps/#/explorer){target=\\_blank}."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 3, "depth": 3, "title": "Database Snapshot Services", "anchor": "database-snapshot-services", "start_char": 4713, "end_char": 6680, "estimated_token_count": 628, "token_estimator": "heuristic-v1", "text": "### Database Snapshot Services\n\nIf you'd like to speed up the process further, you can use a database snapshot. Snapshots are compressed backups of the blockchain's database directory and can significantly reduce the time required to sync a new node. Here are a few public snapshot providers:\n\n- [Stakeworld](https://stakeworld.io/snapshot){target=\\_blank}\n- [Polkachu](https://polkachu.com/substrate_snapshots){target=\\_blank}\n- [Polkashots](https://polkashots.io/){target=\\_blank}\n- [ITRocket](https://itrocket.net/services/mainnet/polkadot/#snapshot){target=\\_blank}\n\n!!!warning\n    Although snapshots are convenient, syncing from scratch is recommended for security purposes. If snapshots become corrupted and most nodes rely on them, the network could inadvertently run on a non-canonical chain.\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>polkadot</span>\n  <span data-ty>2021-06-17 03:07:07 Idle (0 peers), best: #0 (0x3fd7...5baf), finalized #0 (0x3fd7...5baf), ⬇ 2.9kiB/s ⬆ 3.7kiB/s</span>\n  <span data-ty>2021-06-17 03:07:12 Idle (0 peers), best: #0 (0x3fd7...5baf), finalized #0 (0x3fd7...5baf), ⬇ 1.7kiB/s ⬆ 2.0kiB/s</span>\n  <span data-ty>2021-06-17 03:07:17 Idle (0 peers), best: #0 (0x3fd7...5baf), finalized #0 (0x3fd7...5baf), ⬇ 0.9kiB/s ⬆ 1.2kiB/s</span>\n  <span data-ty>2021-06-17 03:07:19 Libp2p => Random Kademlia query has yielded empty results</span>\n  <span data-ty>2021-06-17 03:08:00 Idle (0 peers), best: #0 (0x3fd7...5baf), finalized #0 (0x3fd7...5baf), ⬇ 1.6kiB/s ⬆ 1.9kiB/s</span>\n  <span data-ty>2021-06-17 03:08:05 Idle (0 peers), best: #0 (0x3fd7...5baf), finalized #0 (0x3fd7...5baf), ⬇ 0.6kiB/s ⬆ 0.9kiB/s</span>\n  <span data-ty>...</span>\n</div>\n\nIf you see terminal output similar to the preceding, and you are unable to synchronize the chain due to having zero peers, make sure you have libp2p port `30333` activated. It will take some time to discover other peers over the network."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 4, "depth": 2, "title": "Bond DOT", "anchor": "bond-dot", "start_char": 6680, "end_char": 7246, "estimated_token_count": 119, "token_estimator": "heuristic-v1", "text": "## Bond DOT\n\nOnce your validator node is synced, the next step is bonding DOT. A bonded account, or stash, holds your staked tokens (DOT) that back your validator node. Bonding your DOT means locking it for a period, during which it cannot be transferred or spent but is used to secure your validator's role in the network. Visit the [Minimum Bond Requirement](/infrastructure/running-a-validator/requirements/#minimum-bond-requirement) section for details on how much DOT is required.\n\nThe following sections will guide you through bonding DOT for your validator."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 5, "depth": 3, "title": "Bonding DOT on Polkadot.js Apps", "anchor": "bonding-dot-on-polkadotjs-apps", "start_char": 7246, "end_char": 8847, "estimated_token_count": 382, "token_estimator": "heuristic-v1", "text": "### Bonding DOT on Polkadot.js Apps\n\nOnce you're ready to bond your DOT, head over to the [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\\_blank} staking page by clicking the **Network** dropdown at the top of the page and selecting [**Staking**](https://polkadot.js.org/apps/#/staking/actions){target=\\_blank}.\n\nTo get started with the bond submission, click on the **Accounts** tab, then the **+ Stash** button, and then enter the following information:\n\n1. **Stash account**: Select your stash account (which is the account with the DOT/KSM balance).\n2. **Value bonded**: Enter how much DOT from the stash account you want to bond/stake. You are not required to bond all of the DOT in that account and you may bond more DOT at a later time. Be aware, withdrawing any bonded amount requires waiting for the unbonding period. The unbonding period is seven days for Kusama and 28 days for Polkadot.\n3. **Payment destination**: Add the recipient account for validator rewards. If you'd like to redirect payments to an account that is not the stash account, you can do it by entering the address here. Note that it is extremely unsafe to set an exchange address as the recipient of the staking rewards.\n\nOnce everything is filled in properly, select **Bond** and sign the transaction with your stash account. If successful, you should see an `ExtrinsicSuccess` message.\n\nYour bonded account will be available under **Stashes**. After refreshing the screen, you should now see a card with all your accounts. The bonded amount on the right corresponds to the funds bonded by the stash account."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 6, "depth": 2, "title": "Validate", "anchor": "validate", "start_char": 8847, "end_char": 9075, "estimated_token_count": 45, "token_estimator": "heuristic-v1", "text": "## Validate\n\nOnce your validator node is fully synced and ready, the next step is to ensure it's visible on the network and performing as expected. Below are steps for monitoring and managing your node on the Polkadot network."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 7, "depth": 3, "title": "Verify Sync via Telemetry", "anchor": "verify-sync-via-telemetry", "start_char": 9075, "end_char": 10097, "estimated_token_count": 217, "token_estimator": "heuristic-v1", "text": "### Verify Sync via Telemetry\n\nTo confirm that your validator is live and synchronized with the Polkadot network, visit the [Telemetry](https://telemetry.polkadot.io/#list/Polkadot%20CC1){target=\\_blank} page. Telemetry provides real-time information on node performance and can help you check if your validator is connected properly. Search for your node by name. You can search all nodes currently active on the network, which is why you should use a unique name for easy recognition. Now, confirm that your node is fully synced by comparing the block height of your node with the network's latest block. Nodes that are fully synced will appear white in the list, while nodes that are not yet fully synced will appear gray.\n\nIn the following example, a node named `techedtest` is successfully located and synchronized, ensuring it's prepared to participate in the network:\n\n![Polkadot telemetry dashboard](/images/infrastructure/running-a-validator/onboarding-and-offboarding/start-validating/start-validating-01.webp)"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 8, "depth": 3, "title": "Activate using Polkadot.js Apps", "anchor": "activate-using-polkadotjs-apps", "start_char": 10097, "end_char": 11515, "estimated_token_count": 328, "token_estimator": "heuristic-v1", "text": "### Activate using Polkadot.js Apps\n\nFollow these steps to use Polkadot.js Apps to activate your validator:\n\n1. Go to the **Validator** tab in the Polkadot.js Apps UI and locate the section where you input the keys generated from `rotateKeys`. Paste the output from `author_rotateKeys`, which is a hex-encoded key that links your validator with its session keys:\n\n    ![](/images/infrastructure/running-a-validator/onboarding-and-offboarding/start-validating/start-validating-02.webp)\n\n2. Set a reward commission percentage if desired. You can set a percentage of the rewards to pay to your validator and the remainder pays to your nominators. A 100% commission rate indicates the validator intends to keep all rewards and is seen as a signal the validator is not seeking nominators.\n\n3. Toggle the **allows new nominations** option if your validator is open to more nominations from DOT holders.\n\n4. Once everything is configured, select **Bond & Validate** to activate your validator status.\n\n    ![](/images/infrastructure/running-a-validator/onboarding-and-offboarding/start-validating/start-validating-03.webp)\n\n5. Edit the **commission** and the **blocked** option via `staking.validate` extrinsic. By default, the blocked option is set to FALSE (i.e., the validator accepts nominations).\n\n    ![](/images/infrastructure/running-a-validator/onboarding-and-offboarding/start-validating/start-validating-04.webp)"}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 9, "depth": 3, "title": "Monitor Validation Status and Slots", "anchor": "monitor-validation-status-and-slots", "start_char": 11515, "end_char": 12467, "estimated_token_count": 217, "token_estimator": "heuristic-v1", "text": "### Monitor Validation Status and Slots\n\nOn the [**Staking**](https://polkadot.js.org/apps/#/staking){target=\\_blank} tab in Polkadot.js Apps, you can see your validator's status, the number of available validator slots, and the nodes that have signaled their intent to validate. Your node may initially appear in the waiting queue, especially if the validator slots are full. The following is an example view of the **Staking** tab:\n\n![staking queue](/images/infrastructure/running-a-validator/onboarding-and-offboarding/start-validating/start-validating-05.webp)\n\nThe validator set refreshes each era. If there's an available slot in the next era, your node may be selected to move from the waiting queue to the active validator set, allowing it to start validating blocks. If your validator is not selected, it remains in the waiting queue. Increasing your stake or gaining more nominators may improve your chance of being selected in future eras."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 10, "depth": 2, "title": "Run a Validator Using Systemd", "anchor": "run-a-validator-using-systemd", "start_char": 12467, "end_char": 13491, "estimated_token_count": 218, "token_estimator": "heuristic-v1", "text": "## Run a Validator Using Systemd\n\nRunning your Polkadot validator as a [systemd](https://en.wikipedia.org/wiki/Systemd){target=\\_blank} service is an effective way to ensure its high uptime and reliability. Using systemd allows your validator to automatically restart after server reboots or unexpected crashes, significantly reducing the risk of slashing due to downtime.\n\nThis following sections will walk you through creating and managing a systemd service for your validator, allowing you to seamlessly monitor and control it as part of your Linux system. \n\nEnsure the following requirements are met before proceeding with the systemd setup:\n\n- Confirm your system meets the [requirements](/infrastructure/running-a-validator/requirements/){target=\\_blank} for running a validator.\n- Ensure you meet the [minimum bond requirements](https://wiki.polkadot.com/general/chain-state-values/#minimum-validator-bond){target=\\_blank} for validating.\n- Verify the Polkadot binary is [installed](#install-the-polkadot-binaries)."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 11, "depth": 3, "title": "Create the Systemd Service File", "anchor": "create-the-systemd-service-file", "start_char": 13491, "end_char": 15230, "estimated_token_count": 338, "token_estimator": "heuristic-v1", "text": "### Create the Systemd Service File\n\nFirst create a new unit file called `polkadot-validator.service` in `/etc/systemd/system/`:\n\n```bash\ntouch /etc/systemd/system/polkadot-validator.service\n```\n\nIn this unit file, you will write the commands that you want to run on server boot/restart:\n\n```systemd title=\"/etc/systemd/system/polkadot-validator.service\"\n[Unit]\nDescription=Polkadot Node\nAfter=network.target\nDocumentation=https://github.com/paritytech/polkadot-sdk\n\n[Service]\nEnvironmentFile=-/etc/default/polkadot\nExecStart=/usr/bin/polkadot $POLKADOT_CLI_ARGS\nUser=polkadot\nGroup=polkadot\nRestart=always\nRestartSec=120\nCapabilityBoundingSet=\nLockPersonality=true\nNoNewPrivileges=true\nPrivateDevices=true\nPrivateMounts=true\nPrivateTmp=true\nPrivateUsers=true\nProtectClock=true\nProtectControlGroups=true\nProtectHostname=true\nProtectKernelModules=true\nProtectKernelTunables=true\nProtectSystem=strict\nRemoveIPC=true\nRestrictAddressFamilies=AF_INET AF_INET6 AF_NETLINK AF_UNIX\nRestrictNamespaces=false\nRestrictSUIDSGID=true\nSystemCallArchitectures=native\nSystemCallFilter=@system-service\nSystemCallFilter=landlock_add_rule landlock_create_ruleset landlock_restrict_self seccomp mount umount2\nSystemCallFilter=~@clock @module @reboot @swap @privileged\nSystemCallFilter=pivot_root\nUMask=0027\n\n[Install]\nWantedBy=multi-user.target\n```\n\n!!! warning \"Restart delay and equivocation risk\"\n    It is recommended that a node's restart be delayed with `RestartSec` in the case of a crash. It's possible that when a node crashes, consensus votes in GRANDPA aren't persisted to disk. In this case, there is potential to equivocate when immediately restarting. Delaying the restart will allow the network to progress past potentially conflicting votes."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-start-validating", "page_title": "Start Validating", "index": 12, "depth": 3, "title": "Run the Service", "anchor": "run-the-service", "start_char": 15230, "end_char": 16205, "estimated_token_count": 243, "token_estimator": "heuristic-v1", "text": "### Run the Service\n\nActivate the systemd service to start on system boot by running:\n\n```bash\nsystemctl enable polkadot-validator.service\n```\n\nTo start the service manually, use:\n\n```bash\nsystemctl start polkadot-validator.service\n```\n\nCheck the service's status to confirm it is running:\n\n```bash\nsystemctl status polkadot-validator.service\n```\n\nTo view the logs in real-time, use [journalctl](https://www.freedesktop.org/software/systemd/man/latest/journalctl.html){target=\\_blank} like so:\n\n```bash\njournalctl -f -u polkadot-validator\n```\n\nWith these steps, you can effectively manage and monitor your validator as a systemd service.\n\nOnce your validator is active, it's officially part of Polkadot's security infrastructure. For questions or further support, you can reach out to the [Polkadot Validator chat](https://matrix.to/#/!NZrbtteFeqYKCUGQtr:matrix.parity.io?via=matrix.parity.io&via=matrix.org&via=web3.foundation){target=\\_blank} for tips and troubleshooting."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-stop-validating", "page_title": "Stop Validating", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 19, "end_char": 498, "estimated_token_count": 89, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nIf you're ready to stop validating on Polkadot, there are essential steps to ensure a smooth transition while protecting your funds and account integrity. Whether you're taking a break for maintenance or unbonding entirely, you'll need to chill your validator, purge session keys, and unbond your tokens. This guide explains how to use Polkadot's tools and extrinsics to safely withdraw from validation activities, safeguarding your account's future usability."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-stop-validating", "page_title": "Stop Validating", "index": 1, "depth": 2, "title": "Pause Versus Stop", "anchor": "pause-versus-stop", "start_char": 498, "end_char": 920, "estimated_token_count": 83, "token_estimator": "heuristic-v1", "text": "## Pause Versus Stop\n\nIf you wish to remain a validator or nominator (for example, stopping for planned downtime or server maintenance), submitting the `chill` extrinsic in the `staking` pallet should suffice. Additional steps are only needed to unbond funds or reap an account.\n\nThe following are steps to ensure a smooth stop to validation:\n\n- Chill the validator.\n- Purge validator session keys.\n- Unbond your tokens."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-stop-validating", "page_title": "Stop Validating", "index": 2, "depth": 2, "title": "Chill Validator", "anchor": "chill-validator", "start_char": 920, "end_char": 1499, "estimated_token_count": 117, "token_estimator": "heuristic-v1", "text": "## Chill Validator\n\nWhen stepping back from validating, the first step is to chill your validator status. This action stops your validator from being considered for the next era without fully unbonding your tokens, which can be useful for temporary pauses like maintenance or planned downtime.\n\nUse the `staking.chill` extrinsic to initiate this. For more guidance on chilling your node, refer to the [Pause Validating](/infrastructure/running-a-validator/operational-tasks/pause-validating/){target=\\_blank} guide. You may also claim any pending staking rewards at this point."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-stop-validating", "page_title": "Stop Validating", "index": 3, "depth": 2, "title": "Purge Validator Session Keys", "anchor": "purge-validator-session-keys", "start_char": 1499, "end_char": 2530, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "## Purge Validator Session Keys\n\nPurging validator session keys is a critical step in removing the association between your validator account and its session keys, which ensures that your account is fully disassociated from validator activities. The `session.purgeKeys` extrinsic removes the reference to your session keys from the stash or staking proxy account that originally set them.\n\nHere are a couple of important things to know about purging keys:\n\n- **Account used to purge keys**: Always use the same account to purge keys you originally used to set them, usually your stash or staking proxy account. Using a different account may leave an unremovable reference to the session keys on the original account, preventing its reaping.\n- **Account reaping issue**: Failing to purge keys will prevent you from reaping (fully deleting) your stash account. If you attempt to transfer tokens without purging, you'll need to rebond, purge the session keys, unbond again, and wait through the unbonding period before any transfer."}
{"page_id": "infrastructure-running-a-validator-onboarding-and-offboarding-stop-validating", "page_title": "Stop Validating", "index": 4, "depth": 2, "title": "Unbond Your Tokens", "anchor": "unbond-your-tokens", "start_char": 2530, "end_char": 3228, "estimated_token_count": 142, "token_estimator": "heuristic-v1", "text": "## Unbond Your Tokens\n\nAfter chilling your node and purging session keys, the final step is to unbond your staked tokens. This action removes them from staking and begins the unbonding period (usually 28 days for Polkadot and seven days for Kusama), after which the tokens will be transferable.\n\nTo unbond tokens, go to **Network > Staking > Account Actions** on Polkadot.js Apps. Select your stash account, click on the dropdown menu, and choose **Unbond Funds**. Alternatively, you can use the `staking.unbond` extrinsic if you handle this via a staking proxy account.\n\nOnce the unbonding period is complete, your tokens will be available for use in transactions or transfers outside of staking."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 22, "end_char": 759, "estimated_token_count": 119, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nValidator performance is pivotal in maintaining the security and stability of the Polkadot network. As a validator, optimizing your setup ensures efficient transaction processing, minimizes latency, and maintains system reliability during high-demand periods. Proper configuration and proactive monitoring also help mitigate risks like slashing and service interruptions.\n\nThis guide covers essential practices for managing a validator, including performance tuning techniques, security hardening, and tools for real-time monitoring. Whether you're fine-tuning CPU settings, configuring NUMA balancing, or setting up a robust alert system, these steps will help you build a resilient and efficient validator operation."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 1, "depth": 2, "title": "Configuration Optimization", "anchor": "configuration-optimization", "start_char": 759, "end_char": 987, "estimated_token_count": 35, "token_estimator": "heuristic-v1", "text": "## Configuration Optimization\n\nFor those seeking to optimize their validator's performance, the following configurations can improve responsiveness, reduce latency, and ensure consistent performance during high-demand periods."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 2, "depth": 3, "title": "Deactivate Simultaneous Multithreading", "anchor": "deactivate-simultaneous-multithreading", "start_char": 987, "end_char": 2478, "estimated_token_count": 333, "token_estimator": "heuristic-v1", "text": "### Deactivate Simultaneous Multithreading\n\nPolkadot validators operate primarily in single-threaded mode for critical tasks, so optimizing single-core CPU performance can reduce latency and improve stability. Deactivating simultaneous multithreading (SMT) can prevent virtual cores from affecting performance. SMT is called Hyper-Threading on Intel and 2-way SMT on AMD Zen.\n\nTake the following steps to deactivate every other (vCPU) core:\n\n1. Loop though all the CPU cores and deactivate the virtual cores associated with them:\n\n    ```bash\n    for cpunum in $(cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list | \\\n    cut -s -d, -f2- | tr ',' '\\n' | sort -un)\n    do\n    echo 0 > /sys/devices/system/cpu/cpu$cpunum/online\n    done\n    ```\n\n2. To permanently save the changes, add `nosmt=force` to the `GRUB_CMDLINE_LINUX_DEFAULT` variable in `/etc/default/grub`:\n\n    ```bash\n    sudo nano /etc/default/grub\n    # Add to GRUB_CMDLINE_LINUX_DEFAULT\n    ```\n\n    ```config title=\"/etc/default/grub\"\n    GRUB_DEFAULT = 0;\n    GRUB_HIDDEN_TIMEOUT = 0;\n    GRUB_HIDDEN_TIMEOUT_QUIET = true;\n    GRUB_TIMEOUT = 10;\n    GRUB_DISTRIBUTOR = `lsb_release -i -s 2> /dev/null || echo Debian`;\n    GRUB_CMDLINE_LINUX_DEFAULT = 'nosmt=force';\n    GRUB_CMDLINE_LINUX = '';\n    ```\n\n3. Update GRUB to apply changes:\n\n    ```bash\n    sudo update-grub\n    ```\n\n4. After the reboot, you should see that half of the cores are offline. To confirm, run:\n\n    ```bash\n    lscpu --extended\n    ```"}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 3, "depth": 3, "title": "Deactivate Automatic NUMA Balancing", "anchor": "deactivate-automatic-numa-balancing", "start_char": 2478, "end_char": 3554, "estimated_token_count": 220, "token_estimator": "heuristic-v1", "text": "### Deactivate Automatic NUMA Balancing\n\nDeactivating NUMA (Non-Uniform Memory Access) balancing for multi-CPU setups helps keep processes on the same CPU node, minimizing latency.\n\nFollow these stpes:\n\n1. Deactivate NUMA balancing in runtime:\n\n    ```bash\n    sysctl kernel.numa_balancing=0\n    ```\n\n2. Deactivate NUMA balancing permanently by adding `numa_balancing=disable` to the GRUB settings:\n\n    ```bash\n    sudo nano /etc/default/grub\n    # Add to GRUB_CMDLINE_LINUX_DEFAULT\n    ```\n\n    ```config title=\"/etc/default/grub\"\n    GRUB_DEFAULT = 0;\n    GRUB_HIDDEN_TIMEOUT = 0;\n    GRUB_HIDDEN_TIMEOUT_QUIET = true;\n    GRUB_TIMEOUT = 10;\n    GRUB_DISTRIBUTOR = `lsb_release -i -s 2> /dev/null || echo Debian`;\n    GRUB_CMDLINE_LINUX_DEFAULT = 'numa_balancing=disable';\n    GRUB_CMDLINE_LINUX = '';\n    ```\n\n3. Update GRUB to apply changes:\n\n    ```bash\n    sudo update-grub\n    ```\n\n4. Confirm the deactivation:\n\n    ```bash\n    sysctl -a | grep 'kernel.numa_balancing'\n    ```\n\nIf you successfully deactivated NUMA balancing, the preceding command should return `0`."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 4, "depth": 3, "title": "Spectre and Meltdown Mitigations", "anchor": "spectre-and-meltdown-mitigations", "start_char": 3554, "end_char": 5210, "estimated_token_count": 319, "token_estimator": "heuristic-v1", "text": "### Spectre and Meltdown Mitigations\n\n[Spectre](https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)){target=\\_blank} and [Meltdown](https://en.wikipedia.org/wiki/Meltdown_(security_vulnerability)){target=\\_blank} are well-known CPU vulnerabilities that exploit speculative execution to access sensitive data. These vulnerabilities have been patched in recent Linux kernels, but the mitigations can slightly impact performance, especially in high-throughput or containerized environments.\n\nIf your security requirements allow it, you can deactivate specific mitigations, such as Spectre V2 and Speculative Store Bypass Disable (SSBD), to improve performance.\n\nTo selectively deactivate the Spectre mitigations, take these steps:\n\n1. Update the `GRUB_CMDLINE_LINUX_DEFAULT` variable in your `/etc/default/grub` configuration:\n\n    ```bash\n    sudo nano /etc/default/grub\n    # Add to GRUB_CMDLINE_LINUX_DEFAULT\n    ```\n\n    ```config title=\"/etc/default/grub\"\n    GRUB_DEFAULT = 0;\n    GRUB_HIDDEN_TIMEOUT = 0;\n    GRUB_HIDDEN_TIMEOUT_QUIET = true;\n    GRUB_TIMEOUT = 10;\n    GRUB_DISTRIBUTOR = `lsb_release -i -s 2> /dev/null || echo Debian`;\n    GRUB_CMDLINE_LINUX_DEFAULT =\n      'spec_store_bypass_disable=prctl spectre_v2_user=prctl';\n    ```\n\n2. Update GRUB to apply changes and then reboot:\n\n    ```bash\n    sudo update-grub\n    sudo reboot\n    ```\n\nThis approach selectively deactivates the Spectre V2 and Spectre V4 mitigations, leaving other protections intact. For full security, keep mitigations activated unless there's a significant performance need, as disabling them could expose the system to potential attacks on affected CPUs."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 5, "depth": 2, "title": "Monitor Your Node", "anchor": "monitor-your-node", "start_char": 5210, "end_char": 5907, "estimated_token_count": 167, "token_estimator": "heuristic-v1", "text": "## Monitor Your Node\n\nMonitoring your node's performance is critical for network reliability and security. Tools like the following provide valuable insights:\n\n- **[Prometheus](https://prometheus.io/){target=\\_blank}**: An open-source monitoring toolkit for collecting and querying time-series data.\n- **[Grafana](https://grafana.com/){target=\\_blank}**: A visualization tool for real-time metrics, providing interactive dashboards.\n- **[Alertmanager](https://prometheus.io/docs/alerting/latest/alertmanager/){target=\\_blank}**: A tool for managing and routing alerts based on Prometheus data.\n\nThis section covers setting up these tools and configuring alerts to notify you of potential issues."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 6, "depth": 3, "title": "Environment Setup", "anchor": "environment-setup", "start_char": 5907, "end_char": 6601, "estimated_token_count": 141, "token_estimator": "heuristic-v1", "text": "### Environment Setup\n\nBefore installing Prometheus, ensure the environment is set up securely by running Prometheus with restricted user privileges.\n\nFollow these steps:\n\n1. Create a Prometheus user to ensure Prometheus runs with minimal permissions:\n\n    ```bash\n    sudo useradd --no-create-home --shell /usr/sbin/nologin prometheus\n    ```\n\n2. Create directories for configuration and data storage:\n\n    ```bash\n    sudo mkdir /etc/prometheus\n    sudo mkdir /var/lib/prometheus\n    ```\n  \n3. Change directory ownership to ensure Prometheus has access:\n\n    ```bash\n    sudo chown -R prometheus:prometheus /etc/prometheus\n    sudo chown -R prometheus:prometheus /var/lib/prometheus\n    ```"}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 7, "depth": 3, "title": "Install and Configure Prometheus", "anchor": "install-and-configure-prometheus", "start_char": 6601, "end_char": 9085, "estimated_token_count": 545, "token_estimator": "heuristic-v1", "text": "### Install and Configure Prometheus\n\nAfter setting up the environment, install and configure the latest version of Prometheus as follows:\n\n1. Download Prometheus for your system architecture from the [releases page](https://github.com/prometheus/prometheus/releases/){target=\\_blank}. Replace `INSERT_RELEASE_DOWNLOAD` with the release binary URL (e.g., `https://github.com/prometheus/prometheus/releases/download/v3.0.0/prometheus-3.0.0.linux-amd64.tar.gz`):\n\n    ```bash\n    sudo apt-get update && sudo apt-get upgrade\n    wget INSERT_RELEASE_DOWNLOAD_LINK\n    tar xfz prometheus-*.tar.gz\n    cd prometheus-3.0.0.linux-amd64\n    ```\n\n2. Set up Prometheus:\n\n    1. Copy binaries:\n\n        ```bash\n        sudo cp ./prometheus /usr/local/bin/\n        sudo cp ./promtool /usr/local/bin/\n        sudo cp ./prometheus /usr/local/bin/\n        ```\n\n    2. Copy directories and assign ownership of these files to the `prometheus` user:\n\n        ```bash\n        sudo cp -r ./consoles /etc/prometheus\n        sudo cp -r ./console_libraries /etc/prometheus\n        sudo chown -R prometheus:prometheus /etc/prometheus/consoles\n        sudo chown -R prometheus:prometheus /etc/prometheus/console_libraries\n        ```\n\n    3. Clean up the download directory:\n\n        ```bash\n        cd .. && rm -r prometheus*\n        ```\n\n3. Create `prometheus.yml` to define global settings, rule files, and scrape targets:\n\n    ```bash\n    sudo nano /etc/prometheus/prometheus.yml\n    ```\n\n    {% raw %}\n    ```yaml title=\"prometheus-config.yml\"\n    global:\n      scrape_interval: 15s\n      evaluation_interval: 15s\n\n    rule_files:\n      # - \"first.rules\"\n      # - \"second.rules\"\n\n    scrape_configs:\n      - job_name: 'prometheus'\n        scrape_interval: 5s\n        static_configs:\n          - targets: ['localhost:9090']\n      - job_name: 'substrate_node'\n        scrape_interval: 5s\n        static_configs:\n          - targets: ['localhost:9615']\n    ```\n    {% endraw %}\n\n    Prometheus is scraped every 5 seconds in this example configuration file, ensuring detailed internal metrics. Node metrics with customizable intervals are scraped from port `9615` by default.\n\n4. Verify the configuration with `promtool`, an open source monitoring tool:\n\n    ```bash\n    promtool check config /etc/prometheus/prometheus.yml\n    ```\n\n5. Save the configuration and change the ownership of the file to `prometheus` user:\n\n    ```bash\n    sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml\n    ```"}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 8, "depth": 3, "title": "Start Prometheus", "anchor": "start-prometheus", "start_char": 9085, "end_char": 10918, "estimated_token_count": 410, "token_estimator": "heuristic-v1", "text": "### Start Prometheus\n\n1. Launch Prometheus with the appropriate configuration file, storage location, and necessary web resources, running it with restricted privileges for security:\n\n    ```bash\n    sudo -u prometheus /usr/local/bin/prometheus --config.file /etc/prometheus/prometheus.yml \\\n    --storage.tsdb.path /var/lib/prometheus/ \\\n    --web.console.templates=/etc/prometheus/consoles \\\n    --web.console.libraries=/etc/prometheus/console_libraries\n    ```\n\n    If you set the server up properly, you should see terminal output similar to the following:\n\n    \n2. Verify you can access the Prometheus interface by navigating to:\n\n    ```text\n    http://SERVER_IP_ADDRESS:9090/graph\n    ```\n\n    If the interface appears to work as expected, exit the process using `Control + C`.\n\n3. Create a systemd service file to ensure Prometheus starts on boot:\n\n    ```bash\n    sudo nano /etc/systemd/system/prometheus.service\n    ```\n\n    ```bash title=\"prometheus.service\"\n    [Unit]\n    Description=Prometheus Monitoring\n    Wants=network-online.target\n    After=network-online.target\n\n    [Service]\n    User=prometheus\n    Group=prometheus\n    Type=simple\n    ExecStart=/usr/local/bin/prometheus \\\n     --config.file /etc/prometheus/prometheus.yml \\\n     --storage.tsdb.path /var/lib/prometheus/ \\\n     --web.console.templates=/etc/prometheus/consoles \\\n     --web.console.libraries=/etc/prometheus/console_libraries\n    ExecReload=/bin/kill -HUP $MAINPID\n\n    [Install]\n    WantedBy=multi-user.target\n\n    ```\n\n4. Reload systemd and enable the service to start on boot:\n\n    ```bash\n    sudo systemctl daemon-reload && sudo systemctl enable prometheus && sudo systemctl start prometheus\n    ```\n\n5. Verify the service is running by visiting the Prometheus interface again at:\n\n    ```text\n    http://SERVER_IP_ADDRESS:9090/\n    ```"}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 9, "depth": 3, "title": "Install and Configure Grafana", "anchor": "install-and-configure-grafana", "start_char": 10918, "end_char": 14576, "estimated_token_count": 911, "token_estimator": "heuristic-v1", "text": "### Install and Configure Grafana\n\nThis guide follows [Grafana's canonical installation instructions](https://grafana.com/docs/grafana/latest/setup-grafana/installation/debian/#install-from-apt-repository){target=\\_blank}.\n\nTo install and configure Grafana, follow these steps:\n\n1. Install Grafana prerequisites:\n\n    ```bash\n    sudo apt-get install -y apt-transport-https software-properties-common wget    \n    ```\n\n2. Import the [GPG key](https://gnupg.org/){target=\\_blank}:\n\n    ```bash\n    sudo mkdir -p /etc/apt/keyrings/\n    wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg > /dev/null\n    ```\n\n3. Configure the stable release repo and update packages:\n\n    ```bash\n    echo \"deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main\" | sudo tee -a /etc/apt/sources.list.d/grafana.list\n    sudo apt-get update\n    ```\n\n4. Install the latest stable version of Grafana:\n\n    ```bash\n    sudo apt-get install grafana\n    ```\n\nTo configure Grafana, take these steps:\n\n1. Configure Grafana to start automatically on boot and start the service:\n\n    ```bash\n    sudo systemctl daemon-reload\n    sudo systemctl enable grafana-server.service\n    sudo systemctl start grafana-server\n    ```\n\n2. Check if Grafana is running:\n\n    ```bash\n    sudo systemctl status grafana-server\n    ```\n\n    If necessary, you can stop or restart the service with the following commands:\n\n    ```bash\n    sudo systemctl stop grafana-server\n    sudo systemctl restart grafana-server\n    ```\n\n3. Access Grafana by navigating to the following URL and logging in with the default username and password (`admin`):\n\n    ```text\n    http://SERVER_IP_ADDRESS:3000/login\n    ```\n\n    !!! tip \"Change default port\"\n        To change Grafana's port, edit `/usr/share/grafana/conf/defaults.ini`:\n\n        ```bash\n        sudo vim /usr/share/grafana/conf/defaults.ini\n        ```\n\n        Modify the `http_port` value, then restart Grafana:\n\n        ```bash\n        sudo systemctl restart grafana-server\n        ```\n\n![Grafana login screen](/images/infrastructure/running-a-validator/operational-tasks/general-management/general-management-1.webp)\n\nTo visualize node metrics, follow these steps:\n\n1. Select the gear icon to access **Data Sources** settings.\n2. Select **Add data source** to define the data source.\n\n    ![Select Prometheus](/images/infrastructure/running-a-validator/operational-tasks/general-management/general-management-2.webp)\n\n3. Select **Prometheus**.\n\n    ![Save and test](/images/infrastructure/running-a-validator/operational-tasks/general-management/general-management-3.webp)\n\n4. Enter `http://localhost:9090` in the **URL** field and click **Save & Test**. If **\"Data source is working\"** appears, your connection is configured correctly.\n\n    ![Import dashboard](/images/infrastructure/running-a-validator/operational-tasks/general-management/general-management-4.webp)\n\n5. Select **Import** from the left menu, choose **Prometheus** from the dropdown, and click **Import**.\n\n6. Start your Polkadot node by running `./polkadot`. You should now be able to monitor node performance, block height, network traffic, and tasks tasks on the Grafana dashboard.\n\n    ![Live dashboard](/images/infrastructure/running-a-validator/operational-tasks/general-management/general-management-5.webp)\n\nThe [Grafana dashboards](https://grafana.com/grafana/dashboards){target=\\_blank} page features user created dashboards made available for public use. For an example, see the [Substrate Node Metrics](https://grafana.com/grafana/dashboards/21715-substrate-node-metrics/){target=\\_blank} dashboard."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 10, "depth": 3, "title": "Install and Configure Alertmanager", "anchor": "install-and-configure-alertmanager", "start_char": 14576, "end_char": 22132, "estimated_token_count": 1677, "token_estimator": "heuristic-v1", "text": "### Install and Configure Alertmanager\n\n[Alertmanager](https://prometheus.io/docs/alerting/latest/alertmanager/){target=\\_blank} is an optional component that complements Prometheus by managing alerts and notifying users about potential issues.\n\nFollow these steps to install and configure Alertmanager:\n\n1. Download Alertmanager for your system architecture from the [releases page](https://github.com/prometheus/alertmanager/releases){target=\\_blank}. Replace `INSERT_RELEASE_DOWNLOAD` with the release binary URL (e.g., `https://github.com/prometheus/alertmanager/releases/download/v0.28.0-rc.0/alertmanager-0.28.0-rc.0.linux-amd64.tar.gz`):\n\n    ```bash\n    wget INSERT_RELEASE_DOWNLOAD_LINK\n    tar -xvzf alertmanager*\n    ```\n\n2. Copy the binaries to the system directory and set permissions:\n\n    ```bash\n    cd alertmanager-0.28.0-rc.0.linux-amd64\n    sudo cp ./alertmanager /usr/local/bin/\n    sudo cp ./amtool /usr/local/bin/\n    sudo chown prometheus:prometheus /usr/local/bin/alertmanager\n    sudo chown prometheus:prometheus /usr/local/bin/amtool\n    ```\n\n3. Create the `alertmanager.yml` configuration file under `/etc/alertmanager`:\n\n    ```bash\n    sudo mkdir /etc/alertmanager\n    sudo nano /etc/alertmanager/alertmanager.yml\n    ```\n\n    Generate an [app password in your Google account](https://support.google.com/accounts/answer/185833?hl=en){target=\\_blank} to enable email notifications from Alertmanager. Then, add the following code to the configuration file to define email notifications using your  email and app password: \n\n    {% raw %}\n    ```yml title=\"alertmanager.yml\"\n    global:\n      resolve_timeout: 1m\n\n    route:\n      receiver: 'gmail-notifications'\n\n    receivers:\n      - name: 'gmail-notifications'\n        email_configs:\n          - to: INSERT_YOUR_EMAIL\n            from: INSERT_YOUR_EMAIL\n            smarthost: smtp.gmail.com:587\n            auth_username: INSERT_YOUR_EMAIL\n            auth_identity: INSERT_YOUR_EMAIL\n            auth_password: INSERT_YOUR_APP_PASSWORD\n            send_resolved: true\n\n    ```\n    {% endraw %}\n\n\n    ```bash\n    sudo chown -R prometheus:prometheus /etc/alertmanager\n    ```\n\n4. Configure Alertmanager as a service by creating a systemd service file:\n\n    ```bash\n    sudo nano /etc/systemd/system/alertmanager.service\n    ```\n\n    {% raw %}\n    ```yml title=\"alertmanager.service\"\n    [Unit]\n    Description=AlertManager Server Service\n    Wants=network-online.target\n    After=network-online.target\n\n    [Service]\n    User=root\n    Group=root\n    Type=simple\n    ExecStart=/usr/local/bin/alertmanager --config.file /etc/alertmanager/alertmanager.yml --web.external-url=http://SERVER_IP:9093 --cluster.advertise-address='0.0.0.0:9093'\n\n    [Install]\n    WantedBy=multi-user.target\n\n    ```\n    {% endraw %}\n\n5. Reload and enable the service:\n\n    ```bash\n    sudo systemctl daemon-reload\n    sudo systemctl enable alertmanager\n    sudo systemctl start alertmanager\n    ```\n\n6. Verify the service status:\n\n    ```bash\n    sudo systemctl status alertmanager\n    ```\n\n    If you have configured Alertmanager properly, the **Active** field should display **active (running)** similar to below:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>sudo systemctl status alertmanager</span>\n      <span data-ty>alertmanager.service - AlertManager Server Service</span>\n      <span data-ty>Loaded: loaded (/etc/systemd/system/alertmanager.service; enabled; vendor preset: enabled)</span>\n      <span data-ty>Active: active (running) since Thu 2020-08-20 22:01:21 CEST; 3 days ago</span>\n      <span data-ty>Main PID: 20592 (alertmanager)</span>\n      <span data-ty>Tasks: 70 (limit: 9830)</span>\n      <span data-ty>CGroup: /system.slice/alertmanager.service</span>\n      <span data-ty=\"input\"><span class=\"file-path\"></span></span>\n    </div>\n\n#### Grafana Plugin\n\nThere is an [Alertmanager plugin in Grafana](https://grafana.com/grafana/plugins/alertmanager/){target=\\_blank} that can help you monitor alert information.\n\nFollow these steps to use the plugin:\n\n1. Install the plugin:\n\n    ```bash\n    sudo grafana-cli plugins install camptocamp-prometheus-alertmanager-datasource\n    ```\n\n2. Restart Grafana:\n\n    ```bash\n    sudo systemctl restart grafana-server\n    ```\n\n3. Configure Alertmanager as a data source in your Grafana dashboard (`SERVER_IP:3000`):\n\n    1. Go to **Configuration** > **Data Sources** and search for **Prometheus Alertmanager**.\n    2. Enter the server URL and port for the Alertmanager service, and select **Save & Test** to verify the connection.\n\n4. Import the [8010](https://grafana.com/grafana/dashboards/8010-prometheus-alertmanager/){target=\\_blank} dashboard for Alertmanager, selecting **Prometheus Alertmanager** in the last column, then select **Import**.\n\n#### Integrate Alertmanager\n\nComplete the integration by following these steps to enable communication between Prometheus and Alertmanager and configure detection and alert rules:\n\n1. Update the `etc/prometheus/prometheus.yml` configuration file to include the following code:\n\n    {% raw %}\n    ```yml title=\"prometheus.yml\"\n    rule_files:\n      - 'rules.yml'\n\n    alerting:\n      alertmanagers:\n        - static_configs:\n            - targets:\n                - localhost:9093\n    ```\n    {% endraw %}\n\n    Expand the following item to view the complete `prometheus.yml` file.\n\n    ??? code \"prometheus.yml\"\n\n        {% raw %}\n        ```yml title=\"prometheus.yml\"\n        global:\n          scrape_interval: 15s\n          evaluation_interval: 15s\n\n        rule_files:\n          - 'rules.yml'\n\n        alerting:\n          alertmanagers:\n            - static_configs:\n                - targets:\n                    - localhost:9093\n\n        scrape_configs:\n          - job_name: 'prometheus'\n            scrape_interval: 5s\n            static_configs:\n              - targets: ['localhost:9090']\n          - job_name: 'substrate_node'\n            scrape_interval: 5s\n            static_configs:\n              - targets: ['localhost:9615']\n\n        ```\n        {% endraw %}\n\n2. Create the rules file for detection and alerts:\n\n    ```bash\n    sudo nano /etc/prometheus/rules.yml\n    ```\n\n    Add a sample rule to trigger email notifications for node downtime over five minutes:\n\n    {% raw %}\n    ```yml title=\"rules.yml\"\n    groups:\n      - name: alert_rules\n        rules:\n          - alert: InstanceDown\n            expr: up == 0\n            for: 5m\n            labels:\n              severity: critical\n            annotations:\n              summary: 'Instance [{{ $labels.instance }}] down'\n              description: '[{{ $labels.instance }}] of job [{{ $labels.job }}] has been down for more than 5 minutes.'\n\n    ```\n    {% endraw %}\n\n    If any of the conditions defined in the rules file are met, an alert will be triggered. For more on alert rules, refer to [Alerting Rules](https://prometheus.io/docs/prometheus/latest/configuration/alerting_rules/){target=\\_blank} and [additional alerts](https://samber.github.io/awesome-prometheus-alerts/rules.html){target=\\_blank}.\n\n3. Update the file ownership to `prometheus`:\n\n    ```bash\n    sudo chown prometheus:prometheus rules.yml\n    ```\n\n4. Validate the rules syntax:\n\n    ```bash\n    sudo -u prometheus promtool check rules rules.yml\n    ```\n\n5. Restart Prometheus and Alertmanager:\n\n    ```bash\n    sudo systemctl restart prometheus && sudo systemctl restart alertmanager\n    ```\n\nNow you will receive an email alert if one of your rule triggering conditions is met."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 11, "depth": 2, "title": "Secure Your Validator", "anchor": "secure-your-validator", "start_char": 22132, "end_char": 22484, "estimated_token_count": 58, "token_estimator": "heuristic-v1", "text": "## Secure Your Validator\n\nValidators in Polkadot's Proof of Stake (PoS) network play a critical role in maintaining network integrity and security by keeping the network in consensus and verifying state transitions. To ensure optimal performance and minimize risks, validators must adhere to strict guidelines around security and reliable operations."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 12, "depth": 3, "title": "Key Management", "anchor": "key-management", "start_char": 22484, "end_char": 23751, "estimated_token_count": 261, "token_estimator": "heuristic-v1", "text": "### Key Management\n\nThough they don't transfer funds, session keys are essential for validators as they sign messages related to consensus and parachains. Securing session keys is crucial as allowing them to be exploited or used across multiple nodes can lead to a loss of staked funds via [slashing](/infrastructure/staking-mechanics/offenses-and-slashes/){target=\\_blank}.\n\nGiven the current limitations in high-availability setups and the risks associated with double-signing, it’s recommended to run only a single validator instance. Keys should be securely managed, and processes automated to minimize human error.\n\nThere are two approaches for generating session keys:\n\n- **Generate and store in node**: Using the `author.rotateKeys` RPC call. For most users, generating keys directly within the client is recommended. You must submit a session certificate from your staking proxy to register new keys. See the [How to Validate](/infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/){target=\\_blank} guide for instructions on setting keys.\n\n- **Generate outside node and insert**: Using the `author.setKeys` RPC call. This flexibility accommodates advanced security setups and should only be used by experienced validator operators."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 13, "depth": 3, "title": "Signing Outside the Client", "anchor": "signing-outside-the-client", "start_char": 23751, "end_char": 24043, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "### Signing Outside the Client\n\nPolkadot plans to support external signing, allowing session keys to reside in secure environments like Hardware Security Modules (HSMs). However, these modules can sign any payload they receive, potentially enabling an attacker to perform slashable actions."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 14, "depth": 3, "title": "Secure-Validator Mode", "anchor": "secure-validator-mode", "start_char": 24043, "end_char": 24804, "estimated_token_count": 169, "token_estimator": "heuristic-v1", "text": "### Secure-Validator Mode\n\nPolkadot's Secure-Validator mode offers an extra layer of protection through strict filesystem, networking, and process sandboxing. This secure mode is activated by default if the machine meets the following requirements:\n\n- **Linux (x86-64 architecture)**: Usually Intel or AMD.\n- **Enabled `seccomp`**: This kernel feature facilitates a more secure approach for process management on Linux. Verify by running.\n\n    ```bash\n    cat /boot/config-`uname -r` | grep CONFIG_SECCOMP=\n    ```\n\n    If `seccomp` is enabled, you should see output similar to the following:\n\n    ```bash\n    CONFIG_SECCOMP=y\n    ```\n\n!!! tip \n    Optionally, **Linux 5.13** may also be used, as it provides access to even more strict filesystem protections."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 15, "depth": 3, "title": "Linux Best Practices", "anchor": "linux-best-practices", "start_char": 24804, "end_char": 25262, "estimated_token_count": 107, "token_estimator": "heuristic-v1", "text": "### Linux Best Practices\n\nFollow these best practices to keep your validator secure:\n\n- Use a non-root user for all operations.\n- Regularly apply OS security patches.\n- Enable and configure a firewall.\n- Use key-based SSH authentication; deactivate password-based login.\n- Regularly back up data and harden your SSH configuration. Visit this [SSH guide](https://blog.stribik.technology/2015/01/04/secure-secure-shell.html){target=\\_blank} for more details."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 16, "depth": 3, "title": "Validator Best Practices", "anchor": "validator-best-practices", "start_char": 25262, "end_char": 26020, "estimated_token_count": 147, "token_estimator": "heuristic-v1", "text": "### Validator Best Practices\n\nAdditional best practices can add an additional layer of security and operational reliability:\n\n- Only run the Polkadot binary, and only listen on the configured p2p port.\n- Run on bare-metal machines, as opposed to virtual machines.\n- Provisioning of the validator machine should be automated and defined in code which is kept in private version control, reviewed, audited, and tested.\n- Generate and provide session keys in a secure way.\n- Start Polkadot at boot and restart if stopped for any reason.\n- Run Polkadot as a non-root user.\n- Establish and maintain an on-call rotation for managing alerts.\n- Establish and maintain a clear protocol with actions to perform for each level of each alert with an escalation policy."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-general-management", "page_title": "General Management", "index": 17, "depth": 2, "title": "Additional Resources", "anchor": "additional-resources", "start_char": 26020, "end_char": 26634, "estimated_token_count": 163, "token_estimator": "heuristic-v1", "text": "## Additional Resources\n\n- [Certus One's Knowledge Base](https://knowledgebase.certus.com/FAQ/){target=\\_blank}\n- [EOS Block Producer Security List](https://github.com/slowmist/eos-bp-nodes-security-checklist){target=\\_blank}\n- [HSM Policies and the Importance of Validator Security](https://medium.com/loom-network/hsm-policies-and-the-importance-of-validator-security-ec8a4cc1b6f){target=\\_blank}\n\nFor additional guidance, connect with other validators and the Polkadot engineering team in the [Polkadot Validator Lounge](https://matrix.to/#/#polkadotvalidatorlounge:web3.foundation){target=\\_blank} on Element."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-pause-validating", "page_title": "Pause Validating", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 20, "end_char": 554, "estimated_token_count": 93, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nIf you need to temporarily stop participating in Polkadot staking activities without fully unbonding your funds, chilling your account allows you to do so efficiently. Chilling removes your node from active validation or nomination in the next era while keeping your funds bonded, making it ideal for planned downtimes or temporary pauses.\n\nThis guide covers the steps for chilling as a validator or nominator, using the `chill` and `chillOther` extrinsics, and how these affect your staking status and nominations."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-pause-validating", "page_title": "Pause Validating", "index": 1, "depth": 2, "title": "Chilling Your Node", "anchor": "chilling-your-node", "start_char": 554, "end_char": 1176, "estimated_token_count": 155, "token_estimator": "heuristic-v1", "text": "## Chilling Your Node\n\nIf you need to temporarily step back from staking without unbonding your funds, you can \"chill\" your account. Chilling pauses your active staking participation, setting your account to inactive in the next era while keeping your funds bonded.\n\nTo chill your account, go to the **Network > Staking > Account Actions** page on [Polkadot.js Apps](https://polkadot.js.org/apps){target=\\_blank}, and select **Stop**. Alternatively, you can call the [`chill`](https://paritytech.github.io/polkadot-sdk/master/pallet_staking/enum.Call.html#variant.chill){target=\\_blank} extrinsic in the Staking pallet."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-pause-validating", "page_title": "Pause Validating", "index": 2, "depth": 2, "title": "Staking Election Timing Considerations", "anchor": "staking-election-timing-considerations", "start_char": 1176, "end_char": 1775, "estimated_token_count": 123, "token_estimator": "heuristic-v1", "text": "## Staking Election Timing Considerations\n\nWhen a node actively participates in staking but then chills, it will continue contributing for the remainder of the current era. However, its eligibility for the next election depends on the chill status at the start of the new era:\n\n- **Chilled during previous era**: Will not participate in the current era election and will remain inactive until reactivated.\n-**Chilled during current era**: Will not be selected for the next era's election.\n-**Chilled after current era**: May be selected if it was active during the previous era and is now chilled."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-pause-validating", "page_title": "Pause Validating", "index": 3, "depth": 2, "title": "Chilling as a Nominator", "anchor": "chilling-as-a-nominator", "start_char": 1775, "end_char": 2552, "estimated_token_count": 142, "token_estimator": "heuristic-v1", "text": "## Chilling as a Nominator\n\nWhen you choose to chill as a nominator, your active nominations are reset. Upon re-entering the nominating process, you must reselect validators to support manually. Depending on preferences, these can be the same validators as before or a new set. Remember that your previous nominations won’t be saved or automatically reactivated after chilling.\n\nWhile chilled, your nominator account remains bonded, preserving your staked funds without requiring a full unbonding process. When you’re ready to start nominating again, you can issue a new nomination call to activate your bond with a fresh set of validators. This process bypasses the need for re-bonding, allowing you to maintain your stake while adjusting your involvement in active staking."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-pause-validating", "page_title": "Pause Validating", "index": 4, "depth": 2, "title": "Chilling as a Validator", "anchor": "chilling-as-a-validator", "start_char": 2552, "end_char": 3450, "estimated_token_count": 157, "token_estimator": "heuristic-v1", "text": "## Chilling as a Validator\n\nWhen you chill as a validator, your active validator status is paused. Although your nominators remain bonded to you, the validator bond will no longer appear as an active choice for new or revised nominations until reactivated. Any existing nominators who take no action will still have their stake linked to the validator, meaning they don’t need to reselect the validator upon reactivation. However, if nominators adjust their stakes while the validator is chilled, they will not be able to nominate the chilled validator until it resumes activity.\n\nUpon reactivating as a validator, you must also reconfigure your validator preferences, such as commission rate and other parameters. These can be set to match your previous configuration or updated as desired. This step is essential for rejoining the active validator set and regaining eligibility for nominations."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-pause-validating", "page_title": "Pause Validating", "index": 5, "depth": 2, "title": "Chill Other", "anchor": "chill-other", "start_char": 3450, "end_char": 4437, "estimated_token_count": 191, "token_estimator": "heuristic-v1", "text": "## Chill Other\n\nHistorical constraints in the runtime prevented unlimited nominators and validators from being supported. These constraints created a need for checks to keep the size of the staking system manageable. One of these checks is the `chillOther` extrinsic, allowing users to chill accounts that no longer met standards such as minimum staking requirements set through on-chain governance.\n\nThis control mechanism included a `ChillThreshold`, which was structured to define how close to the maximum number of nominators or validators the staking system would be allowed to get before users could start chilling one another. With the passage of [Referendum #90](https://polkadot-old.polkassembly.io/referendum/90){target=\\_blank}, the value for `maxNominatorCount` on Polkadot was set to `None`, effectively removing the limit on how many nominators and validators can participate. This means the `ChillThreshold` will never be met; thus, `chillOther` no longer has any effect."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 28, "end_char": 821, "estimated_token_count": 123, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nUpgrading a Polkadot validator node is essential for staying current with network updates and maintaining optimal performance. This guide covers routine and extended maintenance scenarios, including software upgrades and major server changes. Following these steps, you can manage session keys and transition smoothly between servers without risking downtime, slashing, or network disruptions. The process requires strategic planning, especially if you need to perform long-lead maintenance, ensuring your validator remains active and compliant.\n\nThis guide will allow validators to seamlessly substitute an active validator server to allow for maintenance operations. The process can take several hours, so ensure you understand the instructions first and plan accordingly."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 821, "end_char": 1374, "estimated_token_count": 114, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore beginning the upgrade process for your validator node, ensure the following:\n\n- You have a fully functional validator setup with all required binaries installed. See [Set Up a Validator](/infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/){target=\\_blank} and [Validator Requirements](/infrastructure/running-a-validator/requirements/){target=\\_blank} for additional guidance.\n- Your VPS infrastructure has enough capacity to run a secondary validator instance temporarily for the upgrade process."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 2, "depth": 2, "title": "Session Keys", "anchor": "session-keys", "start_char": 1374, "end_char": 2087, "estimated_token_count": 137, "token_estimator": "heuristic-v1", "text": "## Session Keys\n\nSession keys are used to sign validator operations and establish a connection between your validator node and your staking proxy account. These keys are stored in the client, and any change to them requires a waiting period. Specifically, if you modify your session keys, the change will take effect only after the current session is completed and two additional sessions have passed.\n\nRemembering this delayed effect when planning upgrades is crucial to ensure that your validator continues to function correctly and avoids interruptions. To learn more about session keys and their importance, visit the [Keys section](https://wiki.polkadot.com/learn/learn-cryptography/#keys){target=\\_blank}."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 3, "depth": 2, "title": "Keystore", "anchor": "keystore", "start_char": 2087, "end_char": 2859, "estimated_token_count": 158, "token_estimator": "heuristic-v1", "text": "## Keystore\n\nYour validator server's `keystore` folder holds the private keys needed for signing network-level transactions. It is important not to duplicate or transfer this folder between validator instances. Doing so could result in multiple validators signing with the duplicate keys, leading to severe consequences such as [equivocation slashing](/infrastructure/staking-mechanics/offenses-and-slashes/#equivocation-slash){target=\\_blank}. Instead, always generate new session keys for each validator instance.\n\nThe default path to the `keystore` is as follows:\n\n```bash\n/home/polkadot/.local/share/polkadot/chains/<chain>/keystore\n```\n\nTaking care to manage your keys securely ensures that your validator operates safely and without the risk of slashing penalties."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 4, "depth": 2, "title": "Upgrade Using Backup Validator", "anchor": "upgrade-using-backup-validator", "start_char": 2859, "end_char": 3111, "estimated_token_count": 41, "token_estimator": "heuristic-v1", "text": "## Upgrade Using Backup Validator\n\nThe following instructions outline how to temporarily switch between two validator nodes. The original active validator is referred to as Validator A and the backup node used for maintenance purposes as Validator B."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 5, "depth": 3, "title": "Session `N`", "anchor": "session-n", "start_char": 3111, "end_char": 4063, "estimated_token_count": 216, "token_estimator": "heuristic-v1", "text": "### Session `N`\n\n1. **Start Validator B**: Launch a secondary node and wait until it is fully synced with the network. Once synced, start it with the `--validator` flag. This node will now act as Validator B.\n2. **Generate session keys**: Create new session keys specifically for Validator B.\n3. **Submit the `set_key` extrinsic**: Use your staking proxy account to submit a `set_key` extrinsic, linking the session keys for Validator B to your staking setup.\n4. **Record the session**: Make a note of the session in which you executed this extrinsic.\n5. **Wait for session changes**: Allow the current session to end and then wait for two additional full sessions for the new keys to take effect.\n\n!!! warning \"Keep Validator A running\"\n\n      It is crucial to keep Validator A operational during this entire waiting period. Since `set_key` does not take effect immediately, turning off Validator A too early may result in chilling or even slashing."}
{"page_id": "infrastructure-running-a-validator-operational-tasks-upgrade-your-node", "page_title": "Upgrade a Validator Node", "index": 6, "depth": 3, "title": "Session `N+3`", "anchor": "session-n3", "start_char": 4063, "end_char": 5624, "estimated_token_count": 378, "token_estimator": "heuristic-v1", "text": "### Session `N+3`\n\nAt this stage, Validator B becomes your active validator. You can now safely perform any maintenance tasks on Validator A.\n\nComplete the following steps when you are ready to bring Validator A back online:\n\n1. **Start Validator A**: Launch Validator A, sync the blockchain database, and ensure it is running with the `--validator` flag.\n2. **Generate new session keys for Validator A**: Create fresh session keys for Validator A.\n3. **Submit the `set_key` extrinsic**: Using your staking proxy account, submit a `set_key` extrinsic with the new Validator A session keys.\n4. **Record the session**: Again, make a note of the session in which you executed this extrinsic.\n\nKeep Validator B active until the session during which you executed the `set-key` extrinsic completes plus two additional full sessions have passed. Once Validator A has successfully taken over, you can safely stop Validator B. This process helps ensure a smooth handoff between nodes and minimizes the risk of downtime or penalties. Verify the transition by checking for finalized blocks in the new session. The logs should indicate the successful change, similar to the example below:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>INSERT_COMMAND</span>\n  <span data-ty>2019-10-28 21:44:13 Applying authority set change scheduled at block #450092</span>\n  <span data-ty>2019-10-28 21:44:13 Applying GRANDPA set change to new set with 20 authorities</span>\n  <span data-ty=\"input\"><span class=\"file-path\"></span></span>\n</div>"}
{"page_id": "infrastructure-running-a-validator-requirements", "page_title": "Validator Requirements", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 26, "end_char": 981, "estimated_token_count": 159, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nRunning a validator in the Polkadot ecosystem is essential for maintaining network security and decentralization. Validators are responsible for validating transactions and adding new blocks to the chain, ensuring the system operates smoothly. In return for their services, validators earn rewards. However, the role comes with inherent risks, such as slashing penalties for misbehavior or technical failures. If you’re new to validation, starting on Kusama provides a lower-stakes environment to gain valuable experience before progressing to the Polkadot network.\n\nThis guide covers everything you need to know about becoming a validator, including system requirements, staking prerequisites, and infrastructure setup. Whether you’re deploying on a VPS or running your node on custom hardware, you’ll learn how to optimize your validator for performance and security, ensuring compliance with network standards while minimizing risks."}
{"page_id": "infrastructure-running-a-validator-requirements", "page_title": "Validator Requirements", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 981, "end_char": 2390, "estimated_token_count": 296, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nRunning a validator requires solid system administration skills and a secure, well-maintained infrastructure. Below are the primary requirements you need to be aware of before getting started:\n\n- **System administration expertise**: Handling technical anomalies and maintaining node infrastructure is critical. Validators must be able to troubleshoot and optimize their setup.\n- **Security**: Ensure your setup follows best practices for securing your node. Refer to the [Secure Your Validator](/infrastructure/running-a-validator/operational-tasks/general-management/#secure-your-validator){target=\\_blank} section to learn about important security measures.\n- **Network choice**: Start with [Kusama](/infrastructure/running-a-validator/onboarding-and-offboarding/set-up-validator/#run-a-kusama-validator){target=\\_blank} to gain experience. Look for \"Adjustments for Kusama\" throughout these guides for tips on adapting the provided instructions for the Kusama network.\n- **Staking requirements**: A minimum amount of native token (KSM or DOT) is required to be elected into the validator set. The required stake can come from your own holdings or from nominators.\n- **Risk of slashing**: Any DOT you stake is at risk if your setup fails or your validator misbehaves. If you’re unsure of your ability to maintain a reliable validator, consider nominating your DOT to a trusted validator."}
{"page_id": "infrastructure-running-a-validator-requirements", "page_title": "Validator Requirements", "index": 2, "depth": 2, "title": "Minimum Hardware Requirements", "anchor": "minimum-hardware-requirements", "start_char": 2390, "end_char": 3554, "estimated_token_count": 251, "token_estimator": "heuristic-v1", "text": "## Minimum Hardware Requirements\n\nPolkadot validators rely on high-performance hardware to process blocks efficiently. The recommended minimum hardware requirements to ensure a fully functional and performant validator are as follows:\n\n- CPU:\n\n    - x86-64 compatible.\n    - Eight physical cores @ 3.4 GHz.\n    - Processor:\n        - **Intel**: Ice Lake or newer (Xeon or Core series)\n        - **AMD**: Zen3 or newer (EPYC or Ryzen)\n    - Simultaneous multithreading disabled:\n        - **Intel**: Hyper-Threading\n        - **AMD**: SMT\n    - [Single-threaded performance](https://www.cpubenchmark.net/singleThread.html){target=\\_blank} is prioritized over higher cores count.\n\n- Storage:\n\n    - **NVMe SSD**: At least 2 TB for blockchain data recommended (prioritize latency rather than throughput).\n    - Storage requirements will increase as the chain grows. For current estimates, see the [current chain snapshot](https://stakeworld.io/docs/dbsize){target=\\_blank}.\n\n- Memory:\n\n    - 32 GB DDR4 ECC\n\n- Network:\n\n    - Symmetric networking speed of 500 Mbit/s is required to handle large numbers of parachains and ensure congestion control during peak times."}
{"page_id": "infrastructure-running-a-validator-requirements", "page_title": "Validator Requirements", "index": 3, "depth": 2, "title": "VPS Provider List", "anchor": "vps-provider-list", "start_char": 3554, "end_char": 6073, "estimated_token_count": 575, "token_estimator": "heuristic-v1", "text": "## VPS Provider List\n\nWhen selecting a VPS provider for your validator node, prioritize reliability, consistent performance, and adherence to the specific hardware requirements set for Polkadot validators. The following server types have been tested and showed acceptable performance in benchmark tests. However, this is not an endorsement and actual performance may vary depending on your workload and VPS provider.\n\nBe aware that some providers may overprovision the underlying host and use shared storage such as NVMe over TCP, which appears as local storage. These setups might result in poor or inconsistent performance. Benchmark your infrastructure before deploying.\n\n- **[Google Cloud Platform (GCP)](https://cloud.google.com/){target=\\_blank}**: `c2` and `c2d` machine families offer high-performance configurations suitable for validators.\n- **[Amazon Web Services (AWS)](https://aws.amazon.com/){target=\\_blank}**: `c6id` machine family provides strong performance, particularly for I/O-intensive workloads.\n- **[OVH](https://www.ovhcloud.com/en-au/){target=\\_blank}**: Can be a budget-friendly solution if it meets your minimum hardware specifications.\n- **[Digital Ocean](https://www.digitalocean.com/){target=\\_blank}**: Popular among developers, Digital Ocean's premium droplets offer configurations suitable for medium to high-intensity workloads.\n- **[Vultr](https://www.vultr.com/){target=\\_blank}**: Offers flexibility with plans that may meet validator requirements, especially for high-bandwidth needs.\n- **[Linode](https://www.linode.com/){target=\\_blank}**: Provides detailed documentation, which can be helpful for setup.\n- **[Scaleway](https://www.scaleway.com/en/){target=\\_blank}**: Offers high-performance cloud instances that can be suitable for validator nodes.\n- **[OnFinality](https://onfinality.io/en){target=\\_blank}**: Specialized in blockchain infrastructure, OnFinality provides validator-specific support and configurations.\n\n!!! warning \"Acceptable use policies\"\n    Different VPS providers have varying acceptable use policies, and not all allow cryptocurrency-related activities. \n\n    For example, Digital Ocean, requires explicit permission to use servers for cryptocurrency mining and defines unauthorized mining as [network abuse](https://www.digitalocean.com/legal/acceptable-use-policy#network-abuse){target=\\_blank} in their acceptable use policy. \n    \n    Review the terms for your VPS provider to avoid account suspension or server shutdown due to policy violations."}
{"page_id": "infrastructure-running-a-validator-requirements", "page_title": "Validator Requirements", "index": 4, "depth": 2, "title": "Minimum Bond Requirement", "anchor": "minimum-bond-requirement", "start_char": 6073, "end_char": 6838, "estimated_token_count": 196, "token_estimator": "heuristic-v1", "text": "## Minimum Bond Requirement\n\nBefore bonding DOT, ensure you meet the minimum bond requirement to start a validator instance. The minimum bond is the least DOT you need to stake to enter the validator set. To become eligible for rewards, your validator node must be nominated by enough staked tokens.\n\nFor example, on November 19, 2024, the minimum stake backing a validator in Polkadot's era 1632 was 1,159,434.248 DOT. You can check the current minimum stake required using these tools:\n\n- [**Chain State Values**](https://wiki.polkadot.com/general/chain-state-values/){target=\\_blank}\n- [**Subscan**](https://polkadot.subscan.io/validator_list?status=validator){target=\\_blank}\n- [**Staking Dashboard**](https://staking.polkadot.cloud/#/overview){target=\\_blank}"}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 24, "end_char": 674, "estimated_token_count": 104, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nIn Polkadot's Nominated Proof of Stake (NPoS) system, validator misconduct is deterred through a combination of slashing, disabling, and reputation penalties. Validators and nominators who stake tokens face consequences for validator misbehavior, which range from token slashes to restrictions on network participation.\n\nThis page outlines the types of offenses recognized by Polkadot, including block equivocations and invalid votes, as well as the corresponding penalties. While some parachains may implement additional custom slashing mechanisms, this guide focuses on the offenses tied to staking within the Polkadot ecosystem."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 1, "depth": 2, "title": "Offenses", "anchor": "offenses", "start_char": 674, "end_char": 1106, "estimated_token_count": 86, "token_estimator": "heuristic-v1", "text": "## Offenses\n\nPolkadot is a public permissionless network. As such, it has a mechanism to disincentivize offenses and incentivize good behavior. You can review the [parachain protocol](https://wiki.polkadot.com/learn/learn-parachains-protocol/#parachain-protocol){target=\\_blank} to understand better the terminology used to describe offenses. Polkadot validator offenses fall into two categories: invalid votes and equivocations."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 2, "depth": 3, "title": "Invalid Votes", "anchor": "invalid-votes", "start_char": 1106, "end_char": 1733, "estimated_token_count": 128, "token_estimator": "heuristic-v1", "text": "### Invalid Votes\n\nA validator will be penalized for inappropriate voting activity during the block inclusion and approval processes. The invalid voting related offenses are as follows:\n\n- **Backing an invalid block**: A para-validator backs an invalid block for inclusion in a fork of the relay chain.\n- **`ForInvalid` vote**: When acting as a secondary checker, the validator votes in favor of an invalid block.\n- **`AgainstValid` vote**: When acting as a secondary checker, the validator votes against a valid block. This type of vote wastes network resources required to resolve the disparate votes and resulting dispute."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 3, "depth": 3, "title": "Equivocations", "anchor": "equivocations", "start_char": 1733, "end_char": 2746, "estimated_token_count": 197, "token_estimator": "heuristic-v1", "text": "### Equivocations\n\nEquivocation occurs when a validator produces statements that conflict with each other when producing blocks or voting. Unintentional equivocations usually occur when duplicate signing keys reside on the validator host. If keys are never duplicated, the probability of an honest equivocation slash decreases to near zero. The equivocation related offenses are as follows:\n\n- **Equivocation**: The validator produces two or more of the same block or vote.\n    - **GRANDPA and BEEFY equivocation**: The validator signs two or more votes in the same round on different chains.\n    - **BABE equivocation**: The validator produces two or more blocks on the relay chain in the same time slot.\n- **Double seconded equivocation**: The validator attempts to second, or back, more than one block in the same round.\n- **Seconded and valid equivocation**: The validator seconds, or backs, a block and then attempts to hide their role as the responsible backer by later placing a standard validation vote."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 4, "depth": 2, "title": "Penalties", "anchor": "penalties", "start_char": 2746, "end_char": 2924, "estimated_token_count": 31, "token_estimator": "heuristic-v1", "text": "## Penalties\n\nOn Polkadot, offenses to the network incur different penalties depending on severity. There are three main penalties: slashing, disabling, and reputation changes."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 5, "depth": 3, "title": "Slashing", "anchor": "slashing", "start_char": 2924, "end_char": 13705, "estimated_token_count": 2520, "token_estimator": "heuristic-v1", "text": "### Slashing\n\nValidators engaging in bad actor behavior in the network may be subject to slashing if they commit a qualifying offense. When a validator is slashed, they and their nominators lose a percentage of their staked DOT or KSM, from as little as 0.01% up to 100% based on the severity of the offense. Nominators are evaluated for slashing against their active validations at any given time. Validator nodes are evaluated as discrete entities, meaning an operator can't attempt to mitigate the offense on another node they operate in order to avoid a slash. \n\nAny slashed DOT or KSM will be added to the [Treasury](https://wiki.polkadot.com/learn/learn-polkadot-opengov-treasury/){target=\\_blank} rather than burned or distributed as rewards. Moving slashed funds to the Treasury allows tokens to be quickly moved away from malicious validators while maintaining the ability to revert faulty slashes when needed.\n\nA nominator with a very large bond may nominate several validators in a single era. In this case, a slash is proportionate to the amount staked to the offending validator. Stake allocation and validator activation is controlled by the [Phragmén algorithm](https://wiki.polkadot.com/learn/learn-phragmen/#algorithm){target=\\_blank}.\n\nA validator slash creates an `unapplied` state transition. You can view pending slashes on [Polkadot.js Apps](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Frpc.polkadot.io#/staking/slashes){target=\\_blank}. The UI will display the slash per validator, the affected nominators, and the slash amounts. The unapplied state includes a 27-day grace period during which a governance proposal can be made to reverse the slash. Once this grace period expires, the slash is applied.\n\n#### Equivocation Slash\n\nThe Web3 Foundation's [Slashing mechanisms](https://research.web3.foundation/Polkadot/security/slashing/amounts){target=\\_blank} page provides guidelines for evaluating the security threat level of different offenses and determining penalties proportionate to the threat level of the offense. Offenses requiring coordination between validators or extensive computational costs to the system will typically call for harsher penalties than those more likely to be unintentional than malicious. A description of potential offenses for each threat level and the corresponding penalties is as follows:\n\n- **Level 1**: Honest misconduct such as isolated cases of unresponsiveness.\n    - **Penalty**: Validator can be kicked out or slashed up to 0.1% of stake in the validator slot.\n- **Level 2**: Misconduct that can occur honestly but is a sign of bad practices. Examples include repeated cases of unresponsiveness and isolated cases of equivocation.\n    - **Penalty**: Slash of up to 1% of stake in the validator slot.\n- **Level 3**: Misconduct that is likely intentional but of limited effect on the performance or security of the network. This level will typically include signs of coordination between validators. Examples include repeated cases of equivocation or isolated cases of unjustified voting on GRANDPA.\n    - **Penalty**: Reduction in networking reputation metrics, slash of up to 10% of stake in the validator slot.\n- **Level 4**: Misconduct that poses severe security or monetary risk to the system or mass collusion. Examples include signs of extensive coordination, creating a serious security risk to the system, or forcing the system to use extensive resources to counter the misconduct.\n    - **Penalty**: Slash of up to 100% of stake in the validator slot.\n\nSee the next section to understand how slash amounts for equivocations are calculated. If you want to know more details about slashing, please look at the research page on [Slashing mechanisms](https://research.web3.foundation/Polkadot/security/slashing/amounts){target=\\_blank}.\n\n#### Slash Calculation for Equivocation\n\nThe slashing penalty for GRANDPA, BABE, and BEEFY equivocations is calculated using the formula below, where `x` represents the number of offenders and `n` is the total number of validators in the active set:\n\n```text\nmin((3 * x / n )^2, 1)\n```\n\nThe following scenarios demonstrate how this formula means slash percentages can increase exponentially based on the number of offenders involved compared to the size of the validator pool:\n\n- **Minor offense**: Assume 1 validator out of a 100 validator active set equivocates in a slot. A single validator committing an isolated offense is most likely a mistake rather than malicious attack on the network. This offense results in a 0.09% slash to the stake in the validator slot.\n\n    ``` mermaid\n    flowchart LR\n    N[\"Total Validators = 100\"]\n    X[\"Offenders = 1\"]\n    F[\"min((3 * 1 / 100)^2, 1) = 0.0009\"]\n    G[\"0.09% slash of stake\"]\n\n    N --> F\n    X --> F\n    F --> G\n    ```\n\n- **Moderate offense**: Assume 5 validators out a 100 validator active set equivocate in a slot. This is a slightly more serious event as there may be some element of coordination involved. This offense results in a 2.25% slash to the stake in the validator slot.\n\n    ``` mermaid\n    flowchart LR\n    N[\"Total Validators = 100\"]\n    X[\"Offenders = 5\"]\n    F[\"min((3 * 5 / 100)^2, 1) = 0.0225\"]\n    G[\"2.25% slash of stake\"]\n\n    N --> F\n    X --> F\n    F --> G\n    ```\n\n- **Major offense**: Assume 20 validators out a 100 validator active set equivocate in a slot. This is a major security threat as it possible represents a coordinated attack on the network. This offense results in a 36% slash and all slashed validators will also be chilled.\n    ``` mermaid\n    flowchart LR\n    N[\"Total Validators = 100\"]\n    X[\"Offenders = 20\"]\n    F[\"min((3 * 20 / 100)^2, 1) = 0.36\"]\n    G[\"36% slash of stake\"]\n\n    N --> F\n    X --> F\n    F --> G\n    ```\n\nThe examples above show the risk of nominating or running many validators in the active set. While rewards grow linearly (two validators will get you approximately twice as many staking rewards as one), slashing grows exponentially. Going from a single validator equivocating to two validators equivocating causes a slash four time as much as the single validator.\n\nValidators may run their nodes on multiple machines to ensure they can still perform validation work if one of their nodes goes down. Still, validator operators should be cautious when setting these up. Equivocation is possible if they don't coordinate well in managing signing machines.\n\n#### Best Practices to Avoid Slashing\n\nThe following are advised to node operators to ensure that they obtain pristine binaries or source code and to ensure the security of their node:\n\n- Always download either source files or binaries from the official Parity repository.\n- Verify the hash of downloaded files.\n- Use the W3F secure validator setup or adhere to its principles.\n- Ensure essential security items are checked, use a firewall, manage user access, use SSH certificates.\n- Avoid using your server as a general-purpose system. Hosting a validator on your workstation or one that hosts other services increases the risk of maleficence.\n- Avoid cloning servers (copying all contents) when migrating to new hardware. If an image is needed, create it before generating keys.\n- High Availability (HA) systems are generally not recommended as equivocation may occur if concurrent operations happen—such as when a failed server restarts or two servers are falsely online simultaneously.\n- Copying the keystore folder when moving a database between instances can cause equivocation. Even brief use of duplicated keystores can result in slashing.\n\nBelow are some examples of small equivocations that happened in the past:\n\n| Network  | Era  | Event Type         | Details                                                                                                                                                                                                                                                                                                                                                             | Action Taken                                                                                                                      |\n|----------|------|--------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|\n| Polkadot | 774  | Small Equivocation | [The validator](https://matrix.to/#/!NZrbtteFeqYKCUGQtr:matrix.parity.io/$165562246360408hKCfC:matrix.org?via=matrix.parity.io&via=corepaper.org&via=matrix.org){target=\\_blank} migrated servers and cloned the keystore folder. The on-chain event can be viewed on [Subscan](https://polkadot.subscan.io/extrinsic/11190109-0?event=11190109-5){target=\\_blank}. | The validator didn't submit a request for the slash to be canceled.                                                               |\n| Kusama   | 3329 | Small Equivocation | The validator operated a test machine with cloned keys. The test machine was online simultaneously as the primary, which resulted in a slash.                                                                                                                                                                                                                       | The validator requested a slash cancellation, but the council declined.                                                           |\n| Kusama   | 3995 | Small Equivocation | The validator noticed several errors, after which the client crashed, and a slash was applied. The validator recorded all events and opened GitHub issues to allow for technical opinions to be shared.                                                                                                                                                             | The validator requested to cancel the slash. The council approved the request as they believed the error wasn't operator-related. |\n\n#### Slashing Across Eras\n\nThere are three main difficulties to account for with slashing in NPoS:\n\n- A nominator can nominate multiple validators and be slashed as a result of actions taken by any of them.\n- Until slashed, the stake is reused from era to era.\n- Slashable offenses can be found after the fact and out of order.\n\nTo balance this, the system applies only the maximum slash a participant can receive in a given time period rather than the sum. This ensures protection from excessive slashing."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 6, "depth": 3, "title": "Disabling", "anchor": "disabling", "start_char": 13705, "end_char": 14617, "estimated_token_count": 185, "token_estimator": "heuristic-v1", "text": "### Disabling\n\nThe disabling mechanism is triggered when validators commit serious infractions, such as backing invalid blocks or engaging in equivocations. Disabling stops validators from performing specific actions after they have committed an offense. Disabling is further divided into:\n\n- **On-chain disabling**: Lasts for a whole era and stops validators from authoring blocks, backing, and initiating a dispute.\n- **Off-chain disabling**: Lasts for a session, is caused by losing a dispute, and stops validators from initiating a dispute.\n\nOff-chain disabling is always a lower priority than on-chain disabling. Off-chain disabling prioritizes disabling first backers and then approval checkers.\n\nThe material in this guide reflects the changes introduced in Stage 4. For more details, see the [State of Disabling issue](https://github.com/paritytech/polkadot-sdk/issues/4359){target=\\_blank} on GitHub."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 7, "depth": 3, "title": "Reputation Changes", "anchor": "reputation-changes", "start_char": 14617, "end_char": 15241, "estimated_token_count": 108, "token_estimator": "heuristic-v1", "text": "### Reputation Changes\n\nSome minor offenses, such as spamming, are only punished by networking reputation changes. Validators use a reputation metric when choosing which peers to connect with. The system adds reputation if a peer provides valuable data and behaves appropriately. If they provide faulty or spam data, the system reduces their reputation. If a validator loses enough reputation, their peers will temporarily close their channels to them. This helps in fighting against Denial of Service (DoS) attacks. Performing validator tasks under reduced reputation will be harder, resulting in lower validator rewards."}
{"page_id": "infrastructure-staking-mechanics-offenses-and-slashes", "page_title": "Offenses and Slashes", "index": 8, "depth": 3, "title": "Penalties by Offense", "anchor": "penalties-by-offense", "start_char": 15241, "end_char": 15427, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "### Penalties by Offense\n\nRefer to the Polkadot Wiki's [offenses page](https://wiki.polkadot.com/learn/learn-offenses/){target=\\_blank} for a summary of penalties for specific offenses."}
{"page_id": "infrastructure-staking-mechanics-rewards-payout", "page_title": "Rewards Payout", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 18, "end_char": 621, "estimated_token_count": 95, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nUnderstanding how rewards are distributed to validators and nominators is essential for network participants. In Polkadot and Kusama, validators earn rewards based on their era points, which are accrued through actions like block production and parachain validation.\n\nThis guide explains the payout scheme, factors influencing rewards, and how multiple validators affect returns. Validators can also share rewards with nominators, who contribute by staking behind them. By following the payout mechanics, validators can optimize their earnings and better engage with their nominators."}
{"page_id": "infrastructure-staking-mechanics-rewards-payout", "page_title": "Rewards Payout", "index": 1, "depth": 2, "title": "Era Points", "anchor": "era-points", "start_char": 621, "end_char": 1660, "estimated_token_count": 217, "token_estimator": "heuristic-v1", "text": "## Era Points\n\nThe Polkadot ecosystem measures its reward cycles in a unit called an era. Kusama eras are approximately 6 hours long, and Polkadot eras are 24 hours long. At the end of each era, validators are paid proportionally to the amount of [era points](/infrastructure/staking-mechanics/rewards-payout/#era-points){target=\\_blank} they have collected. Era points are reward points earned for payable actions like:\n\n- Issuing validity statements for [parachain blocks](/polkadot-protocol/parachain-basics/blocks-transactions-fees/blocks/){target=\\_blank}.\n- Producing a non-uncle block in the relay chain.\n- Producing a reference to a previously unreferenced uncle block.\n- Producing a referenced uncle block.\n\nAn uncle block is a relay chain block that is valid in every regard but has failed to become canonical. This can happen when two or more validators are block producers in a single slot, and the block produced by one validator reaches the next block producer before the others. The lagging blocks are called uncle blocks."}
{"page_id": "infrastructure-staking-mechanics-rewards-payout", "page_title": "Rewards Payout", "index": 2, "depth": 2, "title": "Reward Variance", "anchor": "reward-variance", "start_char": 1660, "end_char": 4201, "estimated_token_count": 564, "token_estimator": "heuristic-v1", "text": "## Reward Variance\n\nRewards in Polkadot and Kusama staking systems can fluctuate due to differences in era points earned by para-validators and non-para-validators. Para-validators generally contribute more to the overall reward distribution due to their role in validating parachain blocks, thus influencing the variance in staking rewards.\n\nTo illustrate this relationship:\n\n- Para-validator era points tend to have a higher impact on the expected value of staking rewards compared to non-para-validator points.\n- The variance in staking rewards increases as the total number of validators grows relative to the number of para-validators.\n- In simpler terms, when more validators are added to the active set without increasing the para-validator pool, the disparity in rewards between validators becomes more pronounced.\n\nHowever, despite this increased variance, rewards tend to even out over time due to the continuous rotation of para-validators across eras. The network's design ensures that over multiple eras, each validator has an equal opportunity to participate in para-validation, eventually leading to a balanced distribution of rewards.\n\n??? interface \"Probability in Staking Rewards\"\n\n    This should only serve as a high-level overview of the probabilistic nature for staking rewards.\n\n    Let:\n\n    - `pe` = para-validator era points\n    - `ne` = non-para-validator era points\n    - `EV` = expected value of staking rewards\n\n    Then, `EV(pe)` has more influence on the `EV` than `EV(ne)`.\n\n    Since `EV(pe)` has a more weighted probability on the `EV`, the increase in variance against the `EV` becomes apparent between the different validator pools (aka. validators in the active set and the ones chosen to para-validate).\n\n    Also, let:\n\n    - `v` = the variance of staking rewards\n    - `p` = number of para-validators\n    - `w` = number validators in the active set\n    - `e` = era\n\n    Then, `v` &#8593; if `w` &#8593;, as this reduces `p` : `w`, with respect to `e`.\n\n    Increased `v` is expected, and initially keeping `p` &#8595; using the same para-validator set for all parachains ensures [availability](https://spec.polkadot.network/chapter-anv){target=\\_blank} and [voting](https://wiki.polkadot.com/learn/learn-polkadot-opengov/){target=\\_blank}. In addition, despite `v` &#8593; on an `e` to `e` basis, over time, the amount of rewards each validator receives will equal out based on the continuous selection of para-validators.\n\n    There are plans to scale the active para-validation set in the future."}
{"page_id": "infrastructure-staking-mechanics-rewards-payout", "page_title": "Rewards Payout", "index": 3, "depth": 2, "title": "Payout Scheme", "anchor": "payout-scheme", "start_char": 4201, "end_char": 5622, "estimated_token_count": 328, "token_estimator": "heuristic-v1", "text": "## Payout Scheme\n\nValidator rewards are distributed equally among all validators in the active set, regardless of the total stake behind each validator. However, individual payouts may differ based on the number of era points a validator has earned. Although factors like network connectivity can affect era points, well-performing validators should accumulate similar totals over time.\n\nValidators can also receive tips from users, which incentivize them to include certain transactions in their blocks. Validators retain 100% of these tips.\n\nRewards are paid out in the network's native token (DOT for Polkadot and KSM for Kusama). \n\nThe following example illustrates a four member validator set with their names, amount they have staked, and how payout of rewards is divided. This scenario assumes all validators earned the same amount of era points and no one received tips: \n\n``` mermaid\nflowchart TD\n    A[\"Alice (18 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    D[\"Dave (7 DOT)\"]\n    E[\"Payout (8 DOT total)\"]\n    E --\"2 DOT\"--> A\n    E --\"2 DOT\"--> B\n    E --\"2 DOT\"--> C\n    E --\"2 DOT\"--> D\n```\n\nNote that this is different than most other Proof of Stake (PoS) systems. As long as a validator is in the validator set, it will receive the same block reward as every other validator. Validator Alice, who had 18 DOT staked, received the same 2 DOT reward in this era as Dave, who had only 7 DOT staked."}
{"page_id": "infrastructure-staking-mechanics-rewards-payout", "page_title": "Rewards Payout", "index": 4, "depth": 2, "title": "Running Multiple Validators", "anchor": "running-multiple-validators", "start_char": 5622, "end_char": 7233, "estimated_token_count": 423, "token_estimator": "heuristic-v1", "text": "## Running Multiple Validators\n\nRunning multiple validators can offer a more favorable risk/reward ratio compared to running a single one. If you have sufficient DOT or nominators staking on your validators, maintaining multiple validators within the active set can yield higher rewards.\n\nIn the preceding section, with 18 DOT staked and no nominators, Alice earned 2 DOT in one era. This example uses DOT, but the same principles apply for KSM on the Kusama network. By managing stake across multiple validators, you can potentially increase overall returns. Recall the set of validators from the preceding section:\n\n``` mermaid\nflowchart TD\n    A[\"Alice (18 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    D[\"Dave (7 DOT)\"]\n    E[\"Payout (8 DOT total)\"]\n    E --\"2 DOT\"--> A\n    E --\"2 DOT\"--> B\n    E --\"2 DOT\"--> C\n    E --\"2 DOT\"--> D \n```\n\nNow, assume Alice decides to split their stake and run two validators, each with a nine DOT stake. This validator set only has four spots and priority is given to validators with a larger stake. In this example, Dave has the smallest stake and loses his spot in the validator set. Now, Alice will earn two shares of the total payout each era as illustrated below:\n\n``` mermaid\nflowchart TD\n    A[\"Alice (9 DOT)\"]\n    F[\"Alice (9 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    E[\"Payout (8 DOT total)\"]\n    E --\"2 DOT\"--> A\n    E --\"2 DOT\"--> B\n    E --\"2 DOT\"--> C\n    E --\"2 DOT\"--> F \n```\n\nWith enough stake, you could run more than two validators. However, each validator must have enough stake behind it to maintain a spot in the validator set."}
{"page_id": "infrastructure-staking-mechanics-rewards-payout", "page_title": "Rewards Payout", "index": 5, "depth": 2, "title": "Nominators and Validator Payments", "anchor": "nominators-and-validator-payments", "start_char": 7233, "end_char": 11070, "estimated_token_count": 990, "token_estimator": "heuristic-v1", "text": "## Nominators and Validator Payments\n\nA nominator's stake allows them to vote for validators and earn a share of the rewards without managing a validator node. Although staking rewards depend on validator activity during an era, validators themselves never control or own nominator rewards. To trigger payouts, anyone can call the `staking.payoutStakers` or `staking.payoutStakerByPage` methods, which mint and distribute rewards directly to the recipients. This trustless process ensures nominators receive their earned rewards.\n\nValidators set a commission rate as a percentage of the block reward, affecting how rewards are shared with nominators. A 0% commission means the validator keeps only rewards from their self-stake, while a 100% commission means they retain all rewards, leaving none for nominators.\n\nThe following examples model splitting validator payments between nominator and validator using various commission percentages. For simplicity, these examples assume a Polkadot-SDK based relay chain that uses DOT as a native token and a single nominator per validator. Calculations of KSM reward payouts for Kusama follow the same formula. \n\nStart with the original validator set from the previous section: \n\n``` mermaid\nflowchart TD\n    A[\"Alice (18 DOT)\"]\n    B[\"Bob (9 DOT)\"]\n    C[\"Carol (8 DOT)\"]\n    D[\"Dave (7 DOT)\"]\n    E[\"Payout (8 DOT total)\"]\n    E --\"2 DOT\"--> A\n    E --\"2 DOT\"--> B\n    E --\"2 DOT\"--> C\n    E --\"2 DOT\"--> D \n```\n\nThe preceding diagram shows each validator receiving a 2 DOT payout, but doesn't account for sharing rewards with nominators. The following diagram shows what nominator payout might look like for validator Alice. Alice has a 20% commission rate and holds 50% of the stake for their validator:\n\n``` mermaid\n\nflowchart TD\n    A[\"Gross Rewards = 2 DOT\"]\n    E[\"Commission = 20%\"]\n    F[\"Alice Validator Payment = 0.4 DOT\"]\n    G[\"Total Stake Rewards = 1.6 DOT\"]\n    B[\"Alice Validator Stake = 18 DOT\"]\n    C[\"9 DOT Alice (50%)\"]\n    H[\"Alice Stake Reward = 0.8 DOT\"]\n    I[\"Total Alice Validator Reward = 1.2 DOT\"]\n    D[\"9 DOT Nominator (50%)\"]\n    J[\"Total Nominator Reward = 0.8 DOT\"]\n    \n    A --> E\n    E --(2 x 0.20)--> F\n    F --(2 - 0.4)--> G\n    B --> C\n    B --> D\n    C --(1.6 x 0.50)--> H\n    H --(0.4 + 0.8)--> I\n    D --(1.60 x 0.50)--> J\n```\n\nNotice the validator commission rate is applied against the gross amount of rewards for the era. The validator commission is subtracted from the total rewards. After the commission is paid to the validator, the remaining amount is split among stake owners according to their percentage of the total stake. A validator's total rewards for an era include their commission plus their piece of the stake rewards. \n\nNow, consider a different scenario for validator Bob where the commission rate is 40%, and Bob holds 33% of the stake for their validator:\n\n``` mermaid\n\nflowchart TD\n    A[\"Gross Rewards = 2 DOT\"]\n    E[\"Commission = 40%\"]\n    F[\"Bob Validator Payment = 0.8 DOT\"]\n    G[\"Total Stake Rewards = 1.2 DOT\"]\n    B[\"Bob Validator Stake = 9 DOT\"]\n    C[\"3 DOT Bob (33%)\"]\n    H[\"Bob Stake Reward = 0.4 DOT\"]\n    I[\"Total Bob Validator Reward = 1.2 DOT\"]\n    D[\"6 DOT Nominator (67%)\"]\n    J[\"Total Nominator Reward = 0.8 DOT\"]\n    \n    A --> E\n    E --(2 x 0.4)--> F\n    F --(2 - 0.8)--> G\n    B --> C\n    B --> D\n    C --(1.2 x 0.33)--> H\n    H --(0.8 + 0.4)--> I\n    D --(1.2 x 0.67)--> J\n```\n\nBob holds a smaller percentage of their node's total stake, making their stake reward smaller than Alice's. In this scenario, Bob makes up the difference by charging a 40% commission rate and ultimately ends up with the same total payment as Alice. Each validator will need to find their ideal balance between the amount of stake and commission rate to attract nominators while still making running a validator worthwhile."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 0, "depth": 2, "title": "Authority", "anchor": "authority", "start_char": 416, "end_char": 897, "estimated_token_count": 119, "token_estimator": "heuristic-v1", "text": "## Authority\n\nThe role in a blockchain that can participate in consensus mechanisms. \n\n- **[GRANDPA](#grandpa)**: The authorities vote on chains they consider final.\n- **[Blind Assignment of Blockchain Extension](#blind-assignment-of-blockchain-extension-babe) (BABE)**: The authorities are also [block authors](#block-author).\n\nAuthority sets can be used as a basis for consensus mechanisms such as the [Nominated Proof of Stake (NPoS)](#nominated-proof-of-stake-npos) protocol."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 1, "depth": 2, "title": "Authority Round (Aura)", "anchor": "authority-round-aura", "start_char": 897, "end_char": 1416, "estimated_token_count": 118, "token_estimator": "heuristic-v1", "text": "## Authority Round (Aura)\n\nA deterministic [consensus](#consensus) protocol where block production is limited to a rotating list of [authorities](#authority) that take turns creating blocks. In authority round (Aura) consensus, most online authorities are assumed to be honest. It is often used in combination with [GRANDPA](#grandpa) as a [hybrid consensus](#hybrid-consensus) protocol.\n\nLearn more by reading the official [Aura consensus algorithm](https://openethereum.github.io/Aura){target=\\_blank} wiki article."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 2, "depth": 2, "title": "Blind Assignment of Blockchain Extension (BABE)", "anchor": "blind-assignment-of-blockchain-extension-babe", "start_char": 1416, "end_char": 1930, "estimated_token_count": 124, "token_estimator": "heuristic-v1", "text": "## Blind Assignment of Blockchain Extension (BABE)\n\nA [block authoring](#block-author) protocol similar to [Aura](#authority-round-aura), except [authorities](#authority) win [slots](#slot) based on a Verifiable Random Function (VRF) instead of the round-robin selection method. The winning authority can select a chain and submit a new block.\n\nLearn more by reading the official Web3 Foundation [BABE research document](https://research.web3.foundation/Polkadot/protocols/block-production/Babe){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 3, "depth": 2, "title": "Block Author", "anchor": "block-author", "start_char": 1930, "end_char": 2099, "estimated_token_count": 35, "token_estimator": "heuristic-v1", "text": "## Block Author\n\nThe node responsible for the creation of a block, also called _block producers_. In a Proof of Work (PoW) blockchain, these nodes are called _miners_."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 4, "depth": 2, "title": "Byzantine Fault Tolerance (BFT)", "anchor": "byzantine-fault-tolerance-bft", "start_char": 2099, "end_char": 2527, "estimated_token_count": 79, "token_estimator": "heuristic-v1", "text": "## Byzantine Fault Tolerance (BFT)\n\nThe ability of a distributed computer network to remain operational if a certain proportion of its nodes or [authorities](#authority) are defective or behaving maliciously. A distributed network is typically considered Byzantine fault tolerant if it can remain functional, with up to one-third of nodes assumed to be defective, offline, actively malicious, and part of a coordinated attack."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 5, "depth": 3, "title": "Byzantine Failure", "anchor": "byzantine-failure", "start_char": 2527, "end_char": 2667, "estimated_token_count": 26, "token_estimator": "heuristic-v1", "text": "### Byzantine Failure\n\nThe loss of a network service due to node failures that exceed the proportion of nodes required to reach consensus."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 6, "depth": 3, "title": "Practical Byzantine Fault Tolerance (pBFT)", "anchor": "practical-byzantine-fault-tolerance-pbft", "start_char": 2667, "end_char": 3007, "estimated_token_count": 71, "token_estimator": "heuristic-v1", "text": "### Practical Byzantine Fault Tolerance (pBFT)\n\nAn early approach to Byzantine fault tolerance (BFT), practical Byzantine fault tolerance (pBFT) systems tolerate Byzantine behavior from up to one-third of participants.\n\nThe communication overhead for such systems is `O(n²)`, where `n` is the number of nodes (participants) in the system."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 7, "depth": 3, "title": "Preimage", "anchor": "preimage", "start_char": 3007, "end_char": 3284, "estimated_token_count": 74, "token_estimator": "heuristic-v1", "text": "### Preimage\n\nA preimage is the data that is input into a hash function to calculate a hash. Since a hash function is a [one-way function](https://en.wikipedia.org/wiki/One-way_function){target=\\_blank}, the output, the hash, cannot be used to reveal the input, the preimage."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 8, "depth": 2, "title": "Call", "anchor": "call", "start_char": 3284, "end_char": 3561, "estimated_token_count": 56, "token_estimator": "heuristic-v1", "text": "## Call\n\nIn the context of pallets containing functions to be dispatched to the runtime, `Call` is an enumeration data type that describes the functions that can be dispatched with one variant per pallet. A `Call` represents a [dispatch](#dispatchable) data structure object."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 9, "depth": 2, "title": "Chain Specification", "anchor": "chain-specification", "start_char": 3561, "end_char": 4014, "estimated_token_count": 84, "token_estimator": "heuristic-v1", "text": "## Chain Specification \n\nA chain specification file defines the properties required to run a node in an active or new Polkadot SDK-built network. It often contains the initial genesis runtime code, network properties (such as the network's name), the initial state for some pallets, and the boot node list. The chain specification file makes it easy to use a single Polkadot SDK codebase as the foundation for multiple independently configured chains."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 10, "depth": 2, "title": "Collator", "anchor": "collator", "start_char": 4014, "end_char": 4353, "estimated_token_count": 98, "token_estimator": "heuristic-v1", "text": "## Collator\n\nAn [author](#block-author) of a [parachain](#parachain) network.\nThey aren't [authorities](#authority) in themselves, as they require a [relay chain](#relay-chain) to coordinate [consensus](#consensus).\n\nMore details are found on the [Polkadot Collator Wiki](https://wiki.polkadot.com/learn/learn-collator/){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 11, "depth": 2, "title": "Collective", "anchor": "collective", "start_char": 4353, "end_char": 4593, "estimated_token_count": 54, "token_estimator": "heuristic-v1", "text": "## Collective\n\nMost often used to refer to an instance of the Collective pallet on Polkadot SDK-based networks such as [Kusama](#kusama) or [Polkadot](#polkadot) if the Collective pallet is part of the FRAME-based runtime for the network."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 12, "depth": 2, "title": "Consensus", "anchor": "consensus", "start_char": 4593, "end_char": 4984, "estimated_token_count": 86, "token_estimator": "heuristic-v1", "text": "## Consensus\n\nConsensus is the process blockchain nodes use to agree on a chain's canonical fork. It is composed of [authorship](#block-author), finality, and [fork-choice rule](#fork-choice-rulestrategy). In the Polkadot ecosystem, these three components are usually separate and the term consensus often refers specifically to authorship.\n\nSee also [hybrid consensus](#hybrid-consensus)."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 13, "depth": 2, "title": "Consensus Algorithm", "anchor": "consensus-algorithm", "start_char": 4984, "end_char": 5546, "estimated_token_count": 120, "token_estimator": "heuristic-v1", "text": "## Consensus Algorithm\n\nEnsures a set of [actors](#authority)—who don't necessarily trust each other—can reach an agreement about the state as the result of some computation. Most consensus algorithms assume that up to one-third of the actors or nodes can be [Byzantine fault tolerant](#byzantine-fault-tolerance-bft).\n\nConsensus algorithms are generally concerned with ensuring two properties:\n\n- **Safety**: Indicating that all honest nodes eventually agreed on the state of the chain.\n- **Liveness**: Indicating the ability of the chain to keep progressing."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 14, "depth": 2, "title": "Consensus Engine", "anchor": "consensus-engine", "start_char": 5546, "end_char": 5885, "estimated_token_count": 75, "token_estimator": "heuristic-v1", "text": "## Consensus Engine\n\nThe node subsystem responsible for consensus tasks.\n\nFor detailed information about the consensus strategies of the [Polkadot](#polkadot) network, see the [Polkadot Consensus](/polkadot-protocol/architecture/polkadot-chain/pos-consensus/){target=\\_blank} blog series.\n\nSee also [hybrid consensus](#hybrid-consensus)."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 15, "depth": 2, "title": "Coretime", "anchor": "coretime", "start_char": 5885, "end_char": 6685, "estimated_token_count": 177, "token_estimator": "heuristic-v1", "text": "## Coretime\n\nThe time allocated for utilizing a core, measured in relay chain blocks. There are two types of coretime: *on-demand* and *bulk*.\n\nOn-demand coretime refers to coretime acquired through bidding in near real-time for the validation of a single parachain block on one of the cores reserved specifically for on-demand orders. They are available as an on-demand coretime pool. Set of cores that are available on-demand. Cores reserved through bulk coretime could also be made available in the on-demand coretime pool, in parts or in entirety.\n\nBulk coretime is a fixed duration of continuous coretime represented by an NFT that can be split, shared, or resold. It is managed by the [Broker pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_broker/index.html){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 16, "depth": 2, "title": "Development Phrase", "anchor": "development-phrase", "start_char": 6685, "end_char": 7343, "estimated_token_count": 157, "token_estimator": "heuristic-v1", "text": "## Development Phrase\n\nA [mnemonic phrase](https://en.wikipedia.org/wiki/Mnemonic#For_numerical_sequences_and_mathematical_operations){target=\\_blank} that is intentionally made public.\n\nWell-known development accounts, such as Alice, Bob, Charlie, Dave, Eve, and Ferdie, are generated from the same secret phrase:\n\n```\nbottom drive obey lake curtain smoke basket hold race lonely fit walk\n```\n\nMany tools in the Polkadot SDK ecosystem, such as [`subkey`](https://github.com/paritytech/polkadot-sdk/tree/polkadot-stable2506-2/substrate/bin/utils/subkey){target=\\_blank}, allow you to implicitly specify an account using a derivation path such as `//Alice`."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 17, "depth": 2, "title": "Digest", "anchor": "digest", "start_char": 7343, "end_char": 7655, "estimated_token_count": 66, "token_estimator": "heuristic-v1", "text": "## Digest\n\nAn extensible field of the [block header](#header) that encodes information needed by several actors in a blockchain network, including:\n\n- [Light clients](#light-client) for chain synchronization.\n- Consensus engines for block verification.\n- The runtime itself, in the case of pre-runtime digests."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 18, "depth": 2, "title": "Dispatchable", "anchor": "dispatchable", "start_char": 7655, "end_char": 7953, "estimated_token_count": 62, "token_estimator": "heuristic-v1", "text": "## Dispatchable\n\nFunction objects that act as the entry points in FRAME [pallets](#pallet). Internal or external entities can call them to interact with the blockchain’s state. They are a core aspect of the runtime logic, handling [transactions](#transaction) and other state-changing operations."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 19, "depth": 2, "title": "Events", "anchor": "events", "start_char": 7953, "end_char": 8385, "estimated_token_count": 90, "token_estimator": "heuristic-v1", "text": "## Events\n\nA means of recording that some particular [state](#state) transition happened.\n\nIn the context of [FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities), events are composable data types that each [pallet](#pallet) can individually define. Events in FRAME are implemented as a set of transient storage items inspected immediately after a block has been executed and reset during block initialization."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 20, "depth": 2, "title": "Executor", "anchor": "executor", "start_char": 8385, "end_char": 9021, "estimated_token_count": 134, "token_estimator": "heuristic-v1", "text": "## Executor\n\nA means of executing a function call in a given [runtime](#runtime) with a set of dependencies.\nThere are two orchestration engines in Polkadot SDK, _WebAssembly_ and _native_.\n\n- The _native executor_ uses a natively compiled runtime embedded in the node to execute calls. This is a performance optimization available to up-to-date nodes.\n\n- The _WebAssembly executor_ uses a [Wasm](#webassembly-wasm) binary and a Wasm interpreter to execute calls. The binary is guaranteed to be up-to-date regardless of the version of the blockchain node because it is persisted in the [state](#state) of the Polkadot SDK-based chain."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 21, "depth": 2, "title": "Existential Deposit", "anchor": "existential-deposit", "start_char": 9021, "end_char": 9761, "estimated_token_count": 179, "token_estimator": "heuristic-v1", "text": "## Existential Deposit\n\nThe minimum balance an account is allowed to have in the [Balances pallet](https://paritytech.github.io/polkadot-sdk/master/pallet_balances/index.html){target=\\_blank}. Accounts cannot be created with a balance less than the existential deposit amount. \n\nIf an account balance drops below this amount, the Balances pallet uses [a FRAME System API](https://paritytech.github.io/substrate/master/frame_system/pallet/struct.Pallet.html#method.dec_ref){target=\\_blank} to drop its references to that account.\n\nIf the Balances pallet reference to an account is dropped, the account can be [reaped](https://paritytech.github.io/substrate/master/frame_system/pallet/struct.Pallet.html#method.allow_death){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 22, "depth": 2, "title": "Extrinsic", "anchor": "extrinsic", "start_char": 9761, "end_char": 10377, "estimated_token_count": 130, "token_estimator": "heuristic-v1", "text": "## Extrinsic\n\nA general term for data that originates outside the runtime, is included in a block, and leads to some action. This includes user-initiated transactions and inherent transactions placed into the block by the block builder.\n\nIt is a SCALE-encoded array typically consisting of a version number, signature, and varying data types indicating the resulting runtime function to be called. Extrinsics can take two forms: [inherents](#inherent-transactions) and [transactions](#transaction). \n\nFor more technical details, see the [Polkadot spec](https://spec.polkadot.network/id-extrinsics){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 23, "depth": 2, "title": "Fork Choice Rule/Strategy", "anchor": "fork-choice-rulestrategy", "start_char": 10377, "end_char": 10723, "estimated_token_count": 79, "token_estimator": "heuristic-v1", "text": "## Fork Choice Rule/Strategy\n\nA fork choice rule or strategy helps determine which chain is valid when reconciling several network forks. A common fork choice rule is the [longest chain](https://paritytech.github.io/polkadot-sdk/master/sc_consensus/struct.LongestChain.html){target=\\_blank}, in which the chain with the most blocks is selected."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 24, "depth": 2, "title": "FRAME (Framework for Runtime Aggregation of Modularized Entities)", "anchor": "frame-framework-for-runtime-aggregation-of-modularized-entities", "start_char": 10723, "end_char": 11169, "estimated_token_count": 97, "token_estimator": "heuristic-v1", "text": "## FRAME (Framework for Runtime Aggregation of Modularized Entities)\n\nEnables developers to create blockchain [runtime](#runtime) environments from a modular set of components called [pallets](#pallet). It utilizes a set of procedural macros to construct runtimes.\n\n[Visit the Polkadot SDK docs for more details on FRAME.](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/polkadot_sdk/frame_runtime/index.html){target=\\_blank}"}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 25, "depth": 2, "title": "Full Node", "anchor": "full-node", "start_char": 11169, "end_char": 11448, "estimated_token_count": 48, "token_estimator": "heuristic-v1", "text": "## Full Node\n\nA node that prunes historical states, keeping only recently finalized block states to reduce storage needs. Full nodes provide current chain state access and allow direct submission and validation of [extrinsics](#extrinsic), maintaining network decentralization."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 26, "depth": 2, "title": "Genesis Configuration", "anchor": "genesis-configuration", "start_char": 11448, "end_char": 11783, "estimated_token_count": 63, "token_estimator": "heuristic-v1", "text": "## Genesis Configuration\n\nA mechanism for specifying the initial state of a blockchain. By convention, this initial state or first block is commonly referred to as the genesis state or genesis block. The genesis configuration for Polkadot SDK-based chains is accomplished by way of a [chain specification](#chain-specification) file."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 27, "depth": 2, "title": "GRANDPA", "anchor": "grandpa", "start_char": 11783, "end_char": 12139, "estimated_token_count": 101, "token_estimator": "heuristic-v1", "text": "## GRANDPA\n\nA deterministic finality mechanism for blockchains that is implemented in the [Rust](https://www.rust-lang.org/){target=\\_blank} programming language.\n\nThe [formal specification](https://github.com/w3f/consensus/blob/master/pdf/grandpa-old.pdf){target=\\_blank} is maintained by the [Web3 Foundation](https://web3.foundation/){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 28, "depth": 2, "title": "Header", "anchor": "header", "start_char": 12139, "end_char": 12379, "estimated_token_count": 44, "token_estimator": "heuristic-v1", "text": "## Header\n\nA structure that aggregates the information used to summarize a block. Primarily, it consists of cryptographic information used by [light clients](#light-client) to get minimally secure but very efficient chain synchronization."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 29, "depth": 2, "title": "Hybrid Consensus", "anchor": "hybrid-consensus", "start_char": 12379, "end_char": 12793, "estimated_token_count": 81, "token_estimator": "heuristic-v1", "text": "## Hybrid Consensus\n\nA blockchain consensus protocol that consists of independent or loosely coupled mechanisms for [block production](#block-author) and finality.\n\nHybrid consensus allows the chain to grow as fast as probabilistic consensus protocols, such as [Aura](#authority-round-aura), while maintaining the same level of security as deterministic finality consensus protocols, such as [GRANDPA](#grandpa)."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 30, "depth": 2, "title": "Inherent Transactions", "anchor": "inherent-transactions", "start_char": 12793, "end_char": 13259, "estimated_token_count": 81, "token_estimator": "heuristic-v1", "text": "## Inherent Transactions\n\nA special type of unsigned transaction, referred to as _inherents_, that enables a block authoring node to insert information that doesn't require validation directly into a block.\n\nOnly the block-authoring node that calls the inherent transaction function can insert data into its block. In general, validators assume the data inserted using an inherent transaction is valid and reasonable even if it can't be deterministically verified."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 31, "depth": 2, "title": "JSON-RPC", "anchor": "json-rpc", "start_char": 13259, "end_char": 13600, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "## JSON-RPC\n\nA stateless, lightweight remote procedure call protocol encoded in JavaScript Object Notation (JSON). JSON-RPC provides a standard way to call functions on a remote system by using JSON.\n\nFor Polkadot SDK, this protocol is implemented through the [Parity JSON-RPC](https://github.com/paritytech/jsonrpc){target=\\_blank} crate."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 32, "depth": 2, "title": "Keystore", "anchor": "keystore", "start_char": 13600, "end_char": 13685, "estimated_token_count": 16, "token_estimator": "heuristic-v1", "text": "## Keystore\n\nA subsystem for managing keys for the purpose of producing new blocks."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 33, "depth": 2, "title": "Kusama", "anchor": "kusama", "start_char": 13685, "end_char": 14379, "estimated_token_count": 174, "token_estimator": "heuristic-v1", "text": "## Kusama\n\n[Kusama](https://kusama.network/){target=\\_blank} is a Polkadot SDK-based blockchain that implements a design similar to the [Polkadot](#polkadot) network.\n\nKusama is a [canary](https://en.wiktionary.org/wiki/canary_in_a_coal_mine){target=\\_blank} network and is referred to as [Polkadot's \"wild cousin.\"](https://wiki.polkadot.com/learn/learn-comparisons-kusama/){target=\\_blank}.\n\nAs a canary network, Kusama is expected to be more stable than a test network like [Westend](#westend) but less stable than a production network like [Polkadot](#polkadot). Kusama is controlled by its network participants and is intended to be stable enough to encourage meaningful experimentation."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 34, "depth": 2, "title": "libp2p", "anchor": "libp2p", "start_char": 14379, "end_char": 14655, "estimated_token_count": 67, "token_estimator": "heuristic-v1", "text": "## libp2p\n\nA peer-to-peer networking stack that allows the use of many transport mechanisms, including WebSockets (usable in a web browser).\n\nPolkadot SDK uses the [Rust implementation](https://github.com/libp2p/rust-libp2p){target=\\_blank} of the `libp2p` networking stack."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 35, "depth": 2, "title": "Light Client", "anchor": "light-client", "start_char": 14655, "end_char": 14993, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "## Light Client\n\nA type of blockchain node that doesn't store the [chain state](#state) or produce blocks.\n\nA light client can verify cryptographic primitives and provides a [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call){target=\\_blank} server, enabling blockchain users to interact with the network."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 36, "depth": 2, "title": "Metadata", "anchor": "metadata", "start_char": 14993, "end_char": 15189, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Metadata\n\nData that provides information about one or more aspects of a system.\nThe metadata that exposes information about a Polkadot SDK blockchain enables you to interact with that system."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 37, "depth": 2, "title": "Nominated Proof of Stake (NPoS)", "anchor": "nominated-proof-of-stake-npos", "start_char": 15189, "end_char": 15416, "estimated_token_count": 51, "token_estimator": "heuristic-v1", "text": "## Nominated Proof of Stake (NPoS)\n\nA method for determining [validators](#validator) or _[authorities](#authority)_ based on a willingness to commit their stake to the proper functioning of one or more block-producing nodes."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 38, "depth": 2, "title": "Oracle", "anchor": "oracle", "start_char": 15416, "end_char": 15653, "estimated_token_count": 42, "token_estimator": "heuristic-v1", "text": "## Oracle\n\nAn entity that connects a blockchain to a non-blockchain data source. Oracles enable the blockchain to access and act upon information from existing data sources and incorporate data from non-blockchain systems and services."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 39, "depth": 2, "title": "Origin", "anchor": "origin", "start_char": 15653, "end_char": 16143, "estimated_token_count": 126, "token_estimator": "heuristic-v1", "text": "## Origin\n\nA [FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities) primitive that identifies the source of a [dispatched](#dispatchable) function call into the [runtime](#runtime). The FRAME System pallet defines three built-in [origins](#origin). As a [pallet](#pallet) developer, you can also define custom origins, such as those defined by the [Collective pallet](https://paritytech.github.io/substrate/master/pallet_collective/enum.RawOrigin.html){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 40, "depth": 2, "title": "Pallet", "anchor": "pallet", "start_char": 16143, "end_char": 16434, "estimated_token_count": 75, "token_estimator": "heuristic-v1", "text": "## Pallet\n\nA module that can be used to extend the capabilities of a [FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities)-based [runtime](#runtime).\nPallets bundle domain-specific logic with runtime primitives like [events](#events) and [storage items](#storage-item)."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 41, "depth": 2, "title": "Parachain", "anchor": "parachain", "start_char": 16434, "end_char": 16690, "estimated_token_count": 66, "token_estimator": "heuristic-v1", "text": "## Parachain\n\nA parachain is a blockchain that derives shared infrastructure and security from a _[relay chain](#relay-chain)_.\nYou can learn more about parachains on the [Polkadot Wiki](https://wiki.polkadot.com/learn/learn-parachains/){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 42, "depth": 2, "title": "Paseo", "anchor": "paseo", "start_char": 16690, "end_char": 17144, "estimated_token_count": 95, "token_estimator": "heuristic-v1", "text": "## Paseo\n\nPaseo TestNet provisions testing on Polkadot's \"production\" runtime, which means less chance of feature or code mismatch when developing parachain apps. Specifically, after the [Polkadot Technical fellowship](https://wiki.polkadot.com/learn/learn-polkadot-technical-fellowship/){target=\\_blank} proposes a runtime upgrade for Polkadot, this TestNet is updated, giving a period where the TestNet will be ahead of Polkadot to allow for testing."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 43, "depth": 2, "title": "Polkadot", "anchor": "polkadot", "start_char": 17144, "end_char": 17445, "estimated_token_count": 71, "token_estimator": "heuristic-v1", "text": "## Polkadot\n\nThe [Polkadot network](https://polkadot.com/){target=\\_blank} is a blockchain that serves as the central hub of a heterogeneous blockchain network. It serves the role of the [relay chain](#relay-chain) and provides shared infrastructure and security to support [parachains](#parachain)."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 44, "depth": 2, "title": "Polkadot Cloud", "anchor": "polkadot-cloud", "start_char": 17445, "end_char": 18083, "estimated_token_count": 97, "token_estimator": "heuristic-v1", "text": "## Polkadot Cloud\n\nPolkadot Cloud is a platform for deploying resilient, customizable and scalable Web3 applications through Polkadot's functionality. It encompasses the wider Polkadot network infrastructure and security layer where parachains operate. The platform enables users to launch Ethereum-compatible chains, build specialized blockchains, and flexibly manage computing resources through on-demand or bulk coretime purchases. Initially launched with basic parachain functionality, Polkadot Cloud has evolved to offer enhanced flexibility with features like coretime, elastic scaling, and async backing for improved performance."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 45, "depth": 2, "title": "Polkadot Hub", "anchor": "polkadot-hub", "start_char": 18083, "end_char": 18491, "estimated_token_count": 68, "token_estimator": "heuristic-v1", "text": "## Polkadot Hub\n\nPolkadot Hub is a Layer 1 platform that serves as the primary entry point to the Polkadot ecosystem, providing essential functionality without requiring parachain deployment. It offers core services including smart contracts, identity management, staking, governance, and interoperability with other ecosystems, making it simple and fast for both builders and users to get started in Web3."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 46, "depth": 2, "title": "PolkaVM", "anchor": "polkavm", "start_char": 18491, "end_char": 18774, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "## PolkaVM\n\nPolkaVM is a custom virtual machine optimized for performance, leveraging a RISC-V-based architecture to support Solidity and any language that compiles to RISC-V. It is specifically designed for the Polkadot ecosystem, enabling smart contract deployment and execution."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 47, "depth": 2, "title": "Relay Chain", "anchor": "relay-chain", "start_char": 18774, "end_char": 19090, "estimated_token_count": 57, "token_estimator": "heuristic-v1", "text": "## Relay Chain\n\nRelay chains are blockchains that provide shared infrastructure and security to the [parachains](#parachain) in the network. In addition to providing [consensus](#consensus) capabilities, relay chains allow parachains to communicate and exchange digital assets without needing to trust one another."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 48, "depth": 2, "title": "Rococo", "anchor": "rococo", "start_char": 19090, "end_char": 19342, "estimated_token_count": 54, "token_estimator": "heuristic-v1", "text": "## Rococo\n\nA [parachain](#parachain) test network for the Polkadot network. The [Rococo](#rococo) network is a Polkadot SDK-based blockchain with an October 14, 2024 deprecation date. Development teams are encouraged to use the Paseo TestNet instead."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 49, "depth": 2, "title": "Runtime", "anchor": "runtime", "start_char": 19342, "end_char": 19679, "estimated_token_count": 73, "token_estimator": "heuristic-v1", "text": "## Runtime\n\nThe runtime represents the [state transition function](#state-transition-function-stf) for a blockchain. In Polkadot SDK, the runtime is stored as a [Wasm](#webassembly-wasm) binary in the chain state. The Runtime is stored under a unique state key and can be modified during the execution of the state transition function."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 50, "depth": 2, "title": "Slot", "anchor": "slot", "start_char": 19679, "end_char": 19959, "estimated_token_count": 79, "token_estimator": "heuristic-v1", "text": "## Slot\n\nA fixed, equal interval of time used by consensus engines such as [Aura](#authority-round-aura) and [BABE](#blind-assignment-of-blockchain-extension-babe). In each slot, a subset of [authorities](#authority) is permitted, or obliged, to [author](#block-author) a block."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 51, "depth": 2, "title": "Sovereign Account", "anchor": "sovereign-account", "start_char": 19959, "end_char": 20461, "estimated_token_count": 91, "token_estimator": "heuristic-v1", "text": "## Sovereign Account\n\nThe unique account identifier for each chain in the relay chain ecosystem. It is often used in cross-consensus (XCM) interactions to sign XCM messages sent to the relay chain or other chains in the ecosystem.\n\nThe sovereign account for each chain is a root-level account that can only be accessed using the Sudo pallet or through governance. The account identifier is calculated by concatenating the Blake2 hash of a specific text string and the registered parachain identifier."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 52, "depth": 2, "title": "SS58 Address Format", "anchor": "ss58-address-format", "start_char": 20461, "end_char": 21014, "estimated_token_count": 128, "token_estimator": "heuristic-v1", "text": "## SS58 Address Format\n\nA public key address based on the Bitcoin [`Base-58-check`](https://en.bitcoin.it/wiki/Base58Check_encoding){target=\\_blank} encoding. Each Polkadot SDK SS58 address uses a `base-58` encoded value to identify a specific account on a specific Polkadot SDK-based chain\n\nThe [canonical `ss58-registry`](https://github.com/paritytech/ss58-registry){target=\\_blank} provides additional details about the address format used by different Polkadot SDK-based chains, including the network prefix and website used for different networks"}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 53, "depth": 2, "title": "State Transition Function (STF)", "anchor": "state-transition-function-stf", "start_char": 21014, "end_char": 21243, "estimated_token_count": 46, "token_estimator": "heuristic-v1", "text": "## State Transition Function (STF)\n\nThe logic of a blockchain that determines how the state changes when a block is processed. In Polkadot SDK, the state transition function is effectively equivalent to the [runtime](#runtime)."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 54, "depth": 2, "title": "Storage Item", "anchor": "storage-item", "start_char": 21243, "end_char": 21606, "estimated_token_count": 92, "token_estimator": "heuristic-v1", "text": "## Storage Item\n\n[FRAME](#frame-framework-for-runtime-aggregation-of-modularized-entities) primitives that provide type-safe data persistence capabilities to the [runtime](#runtime).\nLearn more in the [storage items](https://paritytech.github.io/polkadot-sdk/master/frame_support/storage/types/index.html){target=\\_blank} reference document in the Polkadot SDK."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 55, "depth": 2, "title": "Substrate", "anchor": "substrate", "start_char": 21606, "end_char": 21888, "estimated_token_count": 73, "token_estimator": "heuristic-v1", "text": "## Substrate\n\nA flexible framework for building modular, efficient, and upgradeable blockchains. Substrate is written in the [Rust](https://www.rust-lang.org/){target=\\_blank} programming language and is maintained by [Parity Technologies](https://www.parity.io/){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 56, "depth": 2, "title": "Transaction", "anchor": "transaction", "start_char": 21888, "end_char": 22179, "estimated_token_count": 66, "token_estimator": "heuristic-v1", "text": "## Transaction\n\nAn [extrinsic](#extrinsic) that includes a signature that can be used to verify the account authorizing it inherently or via [signed extensions](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/signed_extensions/index.html){target=\\_blank}."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 57, "depth": 2, "title": "Transaction Era", "anchor": "transaction-era", "start_char": 22179, "end_char": 22458, "estimated_token_count": 51, "token_estimator": "heuristic-v1", "text": "## Transaction Era\n\nA definable period expressed as a range of block numbers during which a transaction can be included in a block.\nTransaction eras are used to protect against transaction replay attacks if an account is reaped and its replay-protecting nonce is reset to zero."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 58, "depth": 2, "title": "Trie (Patricia Merkle Tree)", "anchor": "trie-patricia-merkle-tree", "start_char": 22458, "end_char": 23204, "estimated_token_count": 155, "token_estimator": "heuristic-v1", "text": "## Trie (Patricia Merkle Tree)\n\nA data structure used to represent sets of key-value pairs and enables the items in the data set to be stored and retrieved using a cryptographic hash. Because incremental changes to the data set result in a new hash, retrieving data is efficient even if the data set is very large. With this data structure, you can also prove whether the data set includes any particular key-value pair without access to the entire data set.\n\nIn Polkadot SDK-based blockchains, state is stored in a trie data structure that supports the efficient creation of incremental digests. This trie is exposed to the [runtime](#runtime) as [a simple key/value map](#storage-item) where both keys and values can be arbitrary byte arrays."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 59, "depth": 2, "title": "Validator", "anchor": "validator", "start_char": 23204, "end_char": 23407, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Validator\n\nA validator is a node that participates in the consensus mechanism of the network. Its roles include block production, transaction validation, network integrity, and security maintenance."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 60, "depth": 2, "title": "WebAssembly (Wasm)", "anchor": "webassembly-wasm", "start_char": 23407, "end_char": 23870, "estimated_token_count": 113, "token_estimator": "heuristic-v1", "text": "## WebAssembly (Wasm)\n\nAn execution architecture that allows for the efficient, platform-neutral expression of\ndeterministic, machine-executable logic.\n\n[Wasm](https://webassembly.org/){target=\\_blank} can be compiled from many languages, including\nthe [Rust](https://www.rust-lang.org/){target=\\_blank} programming language. Polkadot SDK-based chains use a Wasm binary to provide portable [runtimes](#runtime) that can be included as part of the chain's state."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 61, "depth": 2, "title": "Weight", "anchor": "weight", "start_char": 23870, "end_char": 24596, "estimated_token_count": 133, "token_estimator": "heuristic-v1", "text": "## Weight\n\nA convention used in Polkadot SDK-based blockchains to measure and manage the time it takes to validate a block.\nPolkadot SDK defines one unit of weight as one picosecond of execution time on reference hardware.\n\nThe maximum block weight should be equivalent to one-third of the target block time with an allocation of one-third each for:\n\n- Block construction\n- Network propagation\n- Import and verification\n\nBy defining weights, you can trade-off the number of transactions per second and the hardware required to maintain the target block time appropriate for your use case. Weights are defined in the runtime, meaning you can tune them using runtime updates to keep up with hardware and software improvements."}
{"page_id": "polkadot-protocol-glossary", "page_title": "Glossary", "index": 62, "depth": 2, "title": "Westend", "anchor": "westend", "start_char": 24596, "end_char": 24739, "estimated_token_count": 32, "token_estimator": "heuristic-v1", "text": "## Westend\n\nWestend is a Parity-maintained, Polkadot SDK-based blockchain that serves as a test network for the [Polkadot](#polkadot) network."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 211, "end_char": 1055, "estimated_token_count": 149, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nAsset Hub natively utilizes Polkadot's 32-byte account system while providing interoperability with Ethereum's 20-byte addresses through an automatic conversion system. When interacting with smart contracts:\n\n- Ethereum-compatible wallets (like MetaMask) can use their familiar 20-byte addresses.\n- Polkadot accounts continue using their native 32-byte format.\n- The Asset Hub chain automatically handles conversion between the two formats behind the scenes:\n\n    - 20-byte Ethereum addresses are padded with `0xEE` bytes to create valid 32-byte Polkadot accounts.\n    - 32-byte Polkadot accounts can optionally register a mapping to a 20-byte address for Ethereum compatibility.\n\nThis dual-format approach enables Asset Hub to maintain compatibility with Ethereum tooling while fully integrating with the Polkadot ecosystem."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 1, "depth": 2, "title": "Address Types and Mappings", "anchor": "address-types-and-mappings", "start_char": 1055, "end_char": 1369, "estimated_token_count": 83, "token_estimator": "heuristic-v1", "text": "## Address Types and Mappings\n\nThe platform handles two distinct address formats:\n\n- [Ethereum-style addresses (20 bytes)](https://ethereum.org/en/developers/docs/accounts/#account-creation){target=\\_blank}\n- [Polkadot native account IDs (32 bytes)](/polkadot-protocol/parachain-basics/accounts/){target=\\_blank}"}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 2, "depth": 3, "title": "Ethereum to Polkadot Mapping", "anchor": "ethereum-to-polkadot-mapping", "start_char": 1369, "end_char": 2414, "estimated_token_count": 237, "token_estimator": "heuristic-v1", "text": "### Ethereum to Polkadot Mapping\n\nThe [`AccountId32Mapper`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/struct.AccountId32Mapper.html){target=\\_blank} implementation in [`pallet_revive`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/index.html){target=\\_blank} handles the core address conversion logic. For converting a 20-byte Ethereum address to a 32-byte Polkadot address, the pallet uses a simple concatenation approach:\n\n- [**Core mechanism**](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_fallback_account_id){target=\\_blank}: Takes a 20-byte Ethereum address and extends it to 32 bytes by adding twelve `0xEE` bytes at the end. The key benefits of this approach are:\n    - Able to fully revert, allowing a smooth transition back to the Ethereum format.\n    - Provides clear identification of Ethereum-controlled accounts through the `0xEE` suffix pattern.\n    - Maintains cryptographic security with a `2^96` difficulty for pattern reproduction."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 3, "depth": 3, "title": "Polkadot to Ethereum Mapping", "anchor": "polkadot-to-ethereum-mapping", "start_char": 2414, "end_char": 4743, "estimated_token_count": 517, "token_estimator": "heuristic-v1", "text": "### Polkadot to Ethereum Mapping\n\nThe conversion from 32-byte Polkadot accounts to 20-byte Ethereum addresses is more complex than the reverse direction due to the lossy nature of the conversion. The [`AccountId32Mapper`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/struct.AccountId32Mapper.html){target=\\_blank} handles this through two distinct approaches:\n\n- **For Ethereum-derived accounts**: The system uses the [`is_eth_derived`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/fn.is_eth_derived.html){target=\\_blank} function to detect accounts that were originally Ethereum addresses (identified by the `0xEE` suffix pattern). For these accounts, the conversion strips the last 12 bytes to recover the original 20-byte Ethereum address.\n\n- **For native Polkadot accounts**: Since these accounts utilize the whole 32-byte space and weren't derived from Ethereum addresses, direct truncation would result in lost information. Instead, the system:\n\n    1. Hashes the entire 32-byte account using Keccak-256.\n    2. Takes the last 20 bytes of the hash to create the Ethereum address.\n    3. This ensures a deterministic mapping while avoiding simple truncation.\n\nThe conversion process is implemented through the [`to_address`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_address){target=\\_blank} function, which automatically detects the account type and applies the appropriate conversion method.\n\n**Stateful Mapping for Reversibility** : Since the conversion from 32-byte to 20-byte addresses is inherently lossy, the system provides an optional stateful mapping through the [`OriginalAccount`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/storage_types/struct.OriginalAccount.html){target=\\_blank} storage. When a Polkadot account registers a mapping (via the [`map`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.map){target=\\_blank} function), the system stores the original 32-byte account ID, enabling the [`to_account_id`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_account_id){target=\\_blank} function to recover the exact original account rather than falling back to a default conversion."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 4, "depth": 3, "title": "Account Mapping for Native Polkadot Accounts", "anchor": "account-mapping-for-native-polkadot-accounts", "start_char": 4743, "end_char": 5911, "estimated_token_count": 250, "token_estimator": "heuristic-v1", "text": "### Account Mapping for Native Polkadot Accounts\n\nIf you have a native Polkadot account (32-byte format) that was created with a Polkadot/Substrate keypair (Ed25519/Sr25519) rather than an Ethereum-compatible keypair (secp256k1), you'll need to map your account to enable Ethereum compatibility.\n\nTo map your account, call the [`map_account`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/dispatchables/fn.map_account.html){target=\\_blank} extrinsic of the [`pallet_revive`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/index.html){target=\\_blank} pallet using your original Substrate account. This creates a stateful mapping that allows your 32-byte account to interact with the Ethereum-compatible smart contract system.\n\nOnce mapped, you'll be able to:\n\n- Transfer funds between 20-byte format addresses.\n- Interact with smart contracts using Ethereum-compatible tools like MetaMask.\n- Maintain full reversibility to your original 32-byte account format.\n\n!!! warning \"Mapping Requirement\"\n    Without this mapping, native Polkadot accounts cannot transfer funds or interact with the Ethereum-compatible layer on the Hub."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 5, "depth": 2, "title": "Account Registration", "anchor": "account-registration", "start_char": 5911, "end_char": 6356, "estimated_token_count": 94, "token_estimator": "heuristic-v1", "text": "## Account Registration\n\nThe registration process is implemented through the [`map`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.map){target=\\_blank} function. This process involves:\n\n- Checking if the account is already mapped.\n- Calculating and collecting required deposits based on data size.\n- Storing the address suffix for future reference.\n- Managing the currency holds for security."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 6, "depth": 2, "title": "Fallback Accounts", "anchor": "fallback-accounts", "start_char": 6356, "end_char": 6810, "estimated_token_count": 93, "token_estimator": "heuristic-v1", "text": "## Fallback Accounts\n\nThe fallback mechanism is integrated into the [`to_account_id`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_account_id){target=\\_blank} function. It provides a safety net for address conversion by:\n\n- First, attempting to retrieve stored mapping data.\n- Falling back to the default conversion method if no mapping exists.\n- Maintaining consistency in address representation."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 7, "depth": 2, "title": "Contract Address Generation", "anchor": "contract-address-generation", "start_char": 6810, "end_char": 7408, "estimated_token_count": 131, "token_estimator": "heuristic-v1", "text": "## Contract Address Generation\n\nThe system supports two methods for generating contract addresses:\n\n- [CREATE1 method](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/fn.create1.html){target=\\_blank}:\n\n    - Uses the deployer address and nonce.\n    - Generates deterministic addresses for standard contract deployment.\n\n- [CREATE2 method](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/fn.create2.html){target=\\_blank}:\n\n    - Uses the deployer address, initialization code, input data, and salt.\n    - Enables predictable address generation for advanced use cases."}
{"page_id": "polkadot-protocol-smart-contract-basics-accounts", "page_title": "Accounts in Asset Hub Smart Contracts", "index": 8, "depth": 2, "title": "Security Considerations", "anchor": "security-considerations", "start_char": 7408, "end_char": 8538, "estimated_token_count": 268, "token_estimator": "heuristic-v1", "text": "## Security Considerations\n\nThe address mapping system maintains security through several design choices evident in the implementation:\n\n- The stateless mapping requires no privileged operations, as shown in the [`to_fallback_account_id`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/trait.AddressMapper.html#tymethod.to_fallback_account_id){target=\\_blank} implementation.\n- The stateful mapping requires a deposit managed through the [`Currency`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/trait.Config.html#associatedtype.Currency){target=\\_blank} trait.\n- Mapping operations are protected against common errors through explicit checks.\n- The system prevents double-mapping through the [`ensure!(!Self::is_mapped(account_id))`](https://github.com/paritytech/polkadot-sdk/blob/stable2412/substrate/frame/revive/src/address.rs#L125){target=\\_blank} check.\n\nAll source code references are from the [`address.rs`](https://github.com/paritytech/polkadot-sdk/blob/stable2412/substrate/frame/revive/src/address.rs){target=\\_blank} file in the Revive pallet of the Polkadot SDK repository."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 204, "end_char": 648, "estimated_token_count": 82, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nAsset Hub smart contracts operate within the Polkadot ecosystem using the [`pallet_revive`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/){target=\\_blank} implementation, which provides EVM compatibility. While many aspects of blocks and transactions are inherited from the underlying parachain architecture, there are specific considerations and mechanisms unique to smart contract operations on Asset Hub."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 1, "depth": 2, "title": "Smart Contract Blocks", "anchor": "smart-contract-blocks", "start_char": 648, "end_char": 1271, "estimated_token_count": 131, "token_estimator": "heuristic-v1", "text": "## Smart Contract Blocks\n\nSmart contract blocks in Asset Hub follow the same fundamental structure as parachain blocks, inheriting all standard parachain block components. The `pallet_revive` implementation maintains this consistency while adding necessary [EVM-specific features](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm){target=\\_blank}. For detailed implementation specifics, the [`Block`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Block.html){target=\\_blank} struct in `pallet_revive` demonstrates how parachain and smart contract block implementations align."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 2, "depth": 2, "title": "Smart Contract Transactions", "anchor": "smart-contract-transactions", "start_char": 1271, "end_char": 1495, "estimated_token_count": 31, "token_estimator": "heuristic-v1", "text": "## Smart Contract Transactions\n\nAsset Hub implements a sophisticated transaction system that supports various transaction types and formats, encompassing both traditional parachain operations and EVM-specific interactions."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 3, "depth": 3, "title": "EVM Transaction Types", "anchor": "evm-transaction-types", "start_char": 1495, "end_char": 3540, "estimated_token_count": 433, "token_estimator": "heuristic-v1", "text": "### EVM Transaction Types\n\nThe system provides a fundamental [`eth_transact`](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/dispatchables/fn.eth_transact.html){target=\\_blank} interface for processing raw EVM transactions dispatched through [Ethereum JSON-RPC APIs](/develop/smart-contracts/json-rpc-apis/){target=\\_blank}. This interface acts as a wrapper for Ethereum transactions, requiring an encoded signed transaction payload, though it cannot be dispatched directly. Building upon this foundation, the system supports multiple transaction formats to accommodate different use cases and optimization needs:\n\n- **[Legacy transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.TransactionLegacyUnsigned.html){target=\\_blank}**: The original Ethereum transaction format, providing basic transfer and contract interaction capabilities. These transactions use a simple pricing mechanism and are supported for backward compatibility.\n\n- **[EIP-1559 transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Transaction1559Unsigned.html){target=\\_blank}**: An improved transaction format that introduces a more predictable fee mechanism with base fee and priority fee components. This format helps optimize gas fee estimation and network congestion management.\n\n- **[EIP-2930 transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Transaction2930Unsigned.html){target=\\_blank}**: Introduces access lists to optimize gas costs for contract interactions by pre-declaring accessed addresses and storage slots.\n\n- **[EIP-4844 transactions](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/evm/struct.Transaction4844Unsigned.html){target=\\_blank}**: Implements blob-carrying transactions, designed to optimize Layer 2 scaling solutions by providing dedicated space for roll-up data.\n\nEach transaction type can exist in both signed and unsigned states, with appropriate validation and processing mechanisms for each."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 4, "depth": 2, "title": "Fees and Gas", "anchor": "fees-and-gas", "start_char": 3540, "end_char": 3748, "estimated_token_count": 31, "token_estimator": "heuristic-v1", "text": "## Fees and Gas\n\nAsset Hub implements a sophisticated resource management system that combines parachain transaction fees with EVM gas mechanics, providing both Ethereum compatibility and enhanced features."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 5, "depth": 3, "title": "Gas Model Overview", "anchor": "gas-model-overview", "start_char": 3748, "end_char": 5536, "estimated_token_count": 330, "token_estimator": "heuristic-v1", "text": "### Gas Model Overview\n\nGas serves as the fundamental unit for measuring computational costs, with each network operation consuming a specified amount. This implementation maintains compatibility with Ethereum's approach while adding parachain-specific optimizations.\n\n- **Dynamic gas scaling**: Asset Hub implements a dynamic pricing mechanism that reflects actual execution performance. This results in:\n\n    - More efficient pricing for computational instructions relative to I/O operations.\n    - Better correlation between gas costs and actual resource consumption.\n    - Need for developers to implement flexible gas calculation rather than hardcoding values.\n\n- **Multi-dimensional resource metering**: Asset Hub extends beyond the traditional single-metric gas model to track three distinct resources.\n\n    - `ref_time` (computation time):\n\n        - Functions as traditional gas equivalent.\n        - Measures actual computational resource usage.\n        - Primary metric for basic operation costs.\n\n\n    - `proof_size` (verification overhead):\n\n        - Tracks state proof size required for validator verification.\n        - Helps manage consensus-related resource consumption.\n        - Important for cross-chain operations.\n\n\n    - `storage_deposit` (state management):\n\n        - Manages blockchain state growth.\n        - Implements a deposit-based system for long-term storage.\n        - Refundable when storage is freed.\n\nThese resources can be limited at both transaction and contract levels, similar to Ethereum's gas limits. For more information, check the [Gas Model](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm#gas-model){target=\\_blank} section in the [EVM vs PolkaVM](/polkadot-protocol/smart-contract-basics/evm-vs-polkavm/){target=\\_blank} article."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 6, "depth": 3, "title": "Fee Components", "anchor": "fee-components", "start_char": 5536, "end_char": 6012, "estimated_token_count": 84, "token_estimator": "heuristic-v1", "text": "### Fee Components\n\n- Base fees:\n\n    - Storage deposit for contract deployment.\n    - Minimum transaction fee for network access.\n    - Network maintenance costs.\n\n- Execution fees:\n\n    - Computed based on gas consumption.\n    - Converted to native currency using network-defined rates.\n    - Reflects actual computational resource usage.\n\n- Storage fees:\n\n    - Deposit for long-term storage usage.\n    - Refundable when storage is freed.\n    - Helps prevent state bloat."}
{"page_id": "polkadot-protocol-smart-contract-basics-blocks-transactions-fees", "page_title": "Transactions and Fees on Asset Hub", "index": 7, "depth": 3, "title": "Gas Calculation and Conversion", "anchor": "gas-calculation-and-conversion", "start_char": 6012, "end_char": 6361, "estimated_token_count": 56, "token_estimator": "heuristic-v1", "text": "### Gas Calculation and Conversion\n\nThe system maintains precise conversion mechanisms between:\n\n- Substrate weights and EVM gas units.\n- Native currency and gas costs.\n- Different resource metrics within the multi-dimensional model.\n\nThis ensures accurate fee calculation while maintaining compatibility with existing Ethereum tools and workflows."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 188, "end_char": 629, "estimated_token_count": 92, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nWhile [PolkaVM](/polkadot-protocol/smart-contract-basics/polkavm-design/){target=\\_blank} strives for maximum Ethereum compatibility, several fundamental design decisions create necessary divergences from the [EVM](https://ethereum.org/en/developers/docs/evm/){target=\\_blank}. These differences represent trade-offs that enhance performance and resource management while maintaining accessibility for Solidity developers."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 1, "depth": 2, "title": "Core Virtual Machine Architecture", "anchor": "core-virtual-machine-architecture", "start_char": 629, "end_char": 3063, "estimated_token_count": 479, "token_estimator": "heuristic-v1", "text": "## Core Virtual Machine Architecture\n\nThe most significant departure from Ethereum comes from PolkaVM's foundation itself. Rather than implementing the EVM, PolkaVM utilizes a RISC-V instruction set. For most Solidity developers, this architectural change remains transparent thanks to the [Revive compiler's](https://github.com/paritytech/revive){target=\\_blank} complete Solidity support, including inline assembler functionality.\n\n```mermaid\ngraph TD\n    subgraph \"Ethereum Path\"\n        EthCompile[\"Standard Solidity Compiler\"] --> EVM_Bytecode[\"EVM Bytecode\"]\n        EVM_Bytecode --> EVM[\"Stack-based EVM\"]\n        EVM --> EthExecution[\"Contract Execution\"]\n    end\n\n    subgraph \"PolkaVM Path\"\n        ReviveCompile[\"Revive Compiler\"] --> RISCV_Bytecode[\"RISC-V Format Bytecode\"]\n        RISCV_Bytecode --> PolkaVM[\"RISC-V Based PolkaVM\"]\n        PolkaVM --> PolkaExecution[\"Contract Execution\"]\n    end\n\n    EthExecution -.-> DifferencesNote[\"Key Differences:\n    - Instruction Set Architecture\n    - Bytecode Format\n    - Runtime Behavior\"]\n    PolkaExecution -.-> DifferencesNote\n```\n\nHowever, this architectural difference becomes relevant in specific scenarios. Tools that attempt to download and inspect contract bytecode will fail, as they expect EVM bytecode rather than PolkaVM's RISC-V format. Most applications typically pass bytecode as an opaque blob, making this a non-issue for standard use cases.\n\nThis primarily affects contracts using [`EXTCODECOPY`](https://www.evm.codes/?fork=cancun#3c){target=\\_blank} to manipulate code at runtime. A contract encounters problems specifically when it uses `EXTCODECOPY` to copy contract code into memory and then attempts to mutate it. This pattern is not possible in standard Solidity and requires dropping down to YUL assembly. An example would be a factory contract written in assembly that constructs and instantiates new contracts by generating code at runtime. Such contracts are rare in practice.\n\nPolkaVM offers an elegant alternative through its [on-chain constructors](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/pallet/struct.Pallet.html#method.bare_instantiate){target=\\_blank}, enabling contract instantiation without runtime code modification, making this pattern unnecessary. This architectural difference also impacts how contract deployment works more broadly, as discussed in the [Contract Deployment](#contract-deployment) section."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 2, "depth": 3, "title": "High-Level Architecture Comparison", "anchor": "high-level-architecture-comparison", "start_char": 3063, "end_char": 5062, "estimated_token_count": 382, "token_estimator": "heuristic-v1", "text": "### High-Level Architecture Comparison\n\n|            Feature            |                            Ethereum Virtual Machine (EVM)                            |                        PolkaVM                         |\n|:-----------------------------:|:------------------------------------------------------------------------------------:|:------------------------------------------------------:|\n|      **Instruction Set**      |                               Stack-based architecture                               |                 RISC-V instruction set                 |\n|      **Bytecode Format**      |                                     EVM bytecode                                     |                     RISC-V format                      |\n|    **Contract Size Limit**    |                                 24KB code size limit                                 |            Contract-specific memory limits             |\n|         **Compiler**          |                                  Solidity Compiler                                   |                    Revive Compiler                     |\n|      **Inline Assembly**      |                                      Supported                                       |         Supported with the compatibility layer         |\n|    **Code Introspection**     | Supported via [`EXTCODECOPY`](https://www.evm.codes/?fork=cancun#3c){target=\\_blank} | Limited support, alternative via on-chain constructors |\n|     **Resource Metering**     |                                  Single gas metric                                   |                   Multi-dimensional                    |\n| **Runtime Code Modification** |                                      Supported                                       |               Limited, with alternatives               |\n|  **Contract Instantiation**   |                                 Standard deployment                                  |    On-chain constructors for flexible instantiation    |"}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 3, "depth": 2, "title": "Gas Model", "anchor": "gas-model", "start_char": 5062, "end_char": 5557, "estimated_token_count": 105, "token_estimator": "heuristic-v1", "text": "## Gas Model\n\nEthereum's resource model relies on a single metric: [gas](https://ethereum.org/en/developers/docs/gas/#what-is-gas){target=\\_blank}, which serves as the universal unit for measuring computational costs. Each operation on the network consumes a specific amount of gas. Most platforms aiming for Ethereum compatibility typically adopt identical gas values to ensure seamless integration.\n\nThe significant changes to Ethereum's gas model will be outlined in the following sections."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 4, "depth": 3, "title": "Dynamic Gas Value Scaling", "anchor": "dynamic-gas-value-scaling", "start_char": 5557, "end_char": 5900, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "### Dynamic Gas Value Scaling\n\nInstead of adhering to Ethereum's fixed gas values, PolkaVM implements benchmark-based pricing that better reflects its improved execution performance. This makes instructions cheaper relative to I/O-bound operations but requires developers to avoid hardcoding gas values, particularly in cross-contract calls."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 5, "depth": 3, "title": "Multi-Dimensional Resource Metering", "anchor": "multi-dimensional-resource-metering", "start_char": 5900, "end_char": 8046, "estimated_token_count": 461, "token_estimator": "heuristic-v1", "text": "### Multi-Dimensional Resource Metering\n\nMoving beyond Ethereum's single gas metric, PolkaVM meters three distinct resources:\n\n- **`ref_time`**: Equivalent to traditional gas, measuring computation time.\n- **`proof_size`**: Tracks state proof size for validator verification.\n- **`storage_deposit`**: Manages state bloat through a deposit system.\n\nAll three resources can be limited at the transaction level, just like gas on Ethereum. The [Ethereum RPC proxy](https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/revive/rpc){target=\\_blank} maps all three dimensions into the single gas dimension, ensuring everything behaves as expected for users.\n\nThese resources can also be limited when making cross-contract calls, which is essential for security when interacting with untrusted contracts. However, Solidity only allows specifying `gas_limit` for cross-contract calls. The `gas_limit` is most similar to Polkadots `ref_time_limit`, but the Revive compiler doesn't supply any imposed `gas_limit` for cross-contract calls for two key reasons:\n\n- **Semantic differences**: `gas_limit` and `ref_time_limit` are not semantically identical; blindly passing EVM gas as `ref_time_limit` can lead to unexpected behavior.\n- **Incomplete protection**: The other two resources (`proof_size` and `storage_deposit`) would remain uncapped anyway, making it insufficient to prevent malicious callees from performing DOS attacks.\n\nWhen resources are \"uncapped\" in cross-contract calls, they remain constrained by transaction-specified limits, preventing abuse of the transaction signer.\n\n!!! note\n    The runtime will provide a special precompile, allowing cross-contract calls with limits specified for all weight dimensions in the future.\n\nAll gas-related opcodes like [`GAS`](https://www.evm.codes/?fork=cancun#5a){target=\\_blank} or [`GAS_LIMIT`](https://www.evm.codes/?fork=cancun#45){target=\\_blank} return only the `ref_time` value as it's the closest match to traditional gas. Extended APIs will be provided through precompiles to make full use of all resources, including cross-contract calls with all three resources specified."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 6, "depth": 2, "title": "Memory Management", "anchor": "memory-management", "start_char": 8046, "end_char": 10026, "estimated_token_count": 413, "token_estimator": "heuristic-v1", "text": "## Memory Management\n\nThe EVM and the PolkaVM take fundamentally different approaches to memory constraints:\n\n|         Feature          |      Ethereum Virtual Machine (EVM)       |                    PolkaVM                     |\n|:------------------------:|:-----------------------------------------:|:----------------------------------------------:|\n|  **Memory Constraints**  |      Indirect control via gas costs       |        Hard memory limits per contract         |\n|      **Cost Model**      | Increasing gas curve with allocation size |    Fixed costs separated from execution gas    |\n|    **Memory Limits**     | Soft limits through prohibitive gas costs |         Hard fixed limits per contract         |\n|  **Pricing Efficiency**  |     Potential overcharging for memory     | More efficient through separation of concerns  |\n|   **Contract Nesting**   |         Limited by available gas          |    Limited by constant memory per contract     |\n|   **Memory Metering**    |     Dynamic based on total allocation     |      Static limits per contract instance       |\n| **Future Improvements**  |       Incremental gas cost updates        | Potential dynamic metering for deeper nesting  |\n| **Cross-Contract Calls** |      Handled through gas forwarding       | Requires careful boundary limit implementation |\n\nThe architecture establishes a constant memory limit per contract, which is the basis for calculating maximum contract nesting depth. This calculation assumes worst-case memory usage for each nested contract, resulting in a straightforward but conservative limit that operates independently of actual memory consumption. Future iterations may introduce dynamic memory metering, allowing deeper nesting depths for contracts with smaller memory footprints. However, such an enhancement would require careful implementation of cross-contract boundary limits before API stabilization, as it would introduce an additional resource metric to the system."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 7, "depth": 3, "title": "Current Memory Limits", "anchor": "current-memory-limits", "start_char": 10026, "end_char": 10851, "estimated_token_count": 176, "token_estimator": "heuristic-v1", "text": "### Current Memory Limits\n\nThe following table depicts memory-related limits at the time of writing:\n\n|                   Limit                    |     Maximum     |\n|:------------------------------------------:|:---------------:|\n|              Call stack depth              |        5        |\n|                Event topics                |        4        |\n| Event data payload size (including topics) |    416 bytes    |\n|             Storage value size             |    416 bytes    |\n|        Transient storage variables         | 128 uint values |\n|            Immutable variables             | 16 uint values  |\n|          Contract code blob size           | ~100 kilobytes  |\n\n!!! note\n    Limits might be increased in the future. To guarantee existing contracts work as expected, limits will never be decreased."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 8, "depth": 2, "title": "Account Management - Existential Deposit", "anchor": "account-management-existential-deposit", "start_char": 10851, "end_char": 11013, "estimated_token_count": 22, "token_estimator": "heuristic-v1", "text": "## Account Management - Existential Deposit\n\nEthereum and Polkadot handle account persistence differently, affecting state management and contract interactions:"}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 9, "depth": 3, "title": "Account Management Comparison", "anchor": "account-management-comparison", "start_char": 11013, "end_char": 13378, "estimated_token_count": 470, "token_estimator": "heuristic-v1", "text": "### Account Management Comparison\n\n|          Feature          |                   Ethereum Approach                   |               PolkaVM/Polkadot Approach                |\n|:-------------------------:|:-----------------------------------------------------:|:------------------------------------------------------:|\n|  **Account Persistence**  | Accounts persist indefinitely, even with zero balance | Requires existential deposit (ED) to maintain account  |\n|    **Minimum Balance**    |                         None                          |                      ED required                       |\n|   **Account Deletion**    |               Accounts remain in state                |      Accounts below ED are automatically deleted       |\n|   **Contract Accounts**   |                  Exist indefinitely                   |                    Must maintain ED                    |\n|   **Balance Reporting**   |                 Reports full balance                  |      Reports ED-adjusted balance via Ethereum RPC      |\n| **New Account Transfers** |                   Standard transfer                   |     Includes ED automatically with extra fee cost      |\n| **Contract-to-Contract**  |                   Direct transfers                    | ED drawn from transaction signer, not sending contract |\n|   **State Management**    |      Potential bloat from zero-balance accounts       |     Optimized with auto-deletion of dust accounts      |\n\nThis difference introduces potential compatibility challenges for Ethereum-based contracts and tools, particularly wallets. To mitigate this, PolkaVM implements several transparent adjustments:\n\n- Balance queries via Ethereum RPC automatically deduct the ED, ensuring reported balances match spendable amounts.\n- Account balance checks through EVM opcodes reflect the ED-adjusted balance.\n- Transfers to new accounts automatically include the ED (`x + ED`), with the extra cost incorporated into transaction fees.\n- Contract-to-contract transfers handle ED requirements by:\n    - Drawing ED from the transaction signer instead of the sending contract.\n    - Keeping transfer amounts transparent for contract logic.\n    - Treating ED like other storage deposit costs.\n\nThis approach ensures that Ethereum contracts work without modifications while maintaining Polkadot's optimized state management."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 10, "depth": 2, "title": "Contract Deployment", "anchor": "contract-deployment", "start_char": 13378, "end_char": 15236, "estimated_token_count": 327, "token_estimator": "heuristic-v1", "text": "## Contract Deployment\n\nFor most users deploying contracts (like ERC-20 tokens), contract deployment works seamlessly without requiring special steps. However, when using advanced patterns like factory contracts that dynamically create other contracts at runtime, you'll need to understand PolkaVM's unique deployment model.\n\nIn the PolkaVM, contract deployment follows a fundamentally different model from EVM. The EVM allows contracts to be deployed with a single transaction, where the contract code is bundled with the deployment transaction. In contrast, PolkaVM has a different process for contract instantiation.\n\n- **Code must be pre-uploaded**: Unlike EVM, where contract code is bundled within the deploying contract, PolkaVM requires all contract bytecode to be uploaded to the chain before instantiation.\n- **Factory pattern limitations**: The common EVM pattern, where contracts dynamically create other contracts, will fail with a `CodeNotFound` error unless the dependent contract code was previously uploaded.\n- **Separate upload and instantiation**: This creates a two-step process where developers must first upload all contract code, then instantiate relationships between contracts.\n\nThis architecture impacts several common EVM patterns and requires developers to adapt their deployment strategies accordingly. _Factory contracts must be modified to work with pre-uploaded code rather than embedding bytecode_, and runtime code generation is not supported due to PolkaVM's RISC-V bytecode format. The specific behavior of contract creation opcodes is detailed in the [YUL IR Translation](#yul-function-translation-differences) section.\n\nWhen migrating EVM projects to PolkaVM, developers should identify all contracts that will be instantiated at runtime and ensure they are pre-uploaded to the chain before any instantiation attempts."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 11, "depth": 2, "title": "Solidity and YUL IR Translation Incompatibilities", "anchor": "solidity-and-yul-ir-translation-incompatibilities", "start_char": 15236, "end_char": 15581, "estimated_token_count": 52, "token_estimator": "heuristic-v1", "text": "## Solidity and YUL IR Translation Incompatibilities\n\nWhile PolkaVM maintains high-level compatibility with Solidity, several low-level differences exist in the translation of YUL IR and specific Solidity constructs. These differences are particularly relevant for developers working with assembly code or utilizing advanced contract patterns."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 12, "depth": 3, "title": "Contract Code Structure", "anchor": "contract-code-structure", "start_char": 15581, "end_char": 16541, "estimated_token_count": 184, "token_estimator": "heuristic-v1", "text": "### Contract Code Structure\n\nPolkaVM's contract runtime does not differentiate between runtime code and deploy (constructor) code. Instead, both are emitted into a single PolkaVM contract code blob and live on-chain. Therefore, in EVM terminology, the deploy code equals the runtime code. For most standard Solidity contracts, this is transparent. However, if you are analyzing raw bytecode or building tools that expect separate deploy and runtime sections, you'll need to adjust for this unified structure.\n\nIn the constructor code, the `codesize` instruction returns the call data size instead of the actual code blob size, which differs from standard EVM behavior. Developers might consider that the constructor logic uses `codesize` to inspect the deployed contract's size (e.g., for self-validation or specific deployment patterns); this will return an incorrect value on PolkaVM. Re-evaluate such logic or use alternative methods to achieve your goal."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 13, "depth": 3, "title": "Solidity-Specific Differences", "anchor": "solidity-specific-differences", "start_char": 16541, "end_char": 17089, "estimated_token_count": 103, "token_estimator": "heuristic-v1", "text": "### Solidity-Specific Differences\n\nSolidity constructs behave differently under PolkaVM:\n\n- **`address.creationCode`**: Returns the bytecode keccak256 hash instead of the actual creation code, reflecting PolkaVM's hash-based code referencing system.\n    - If your contract relies on `address.creationCode` to verify or interact with the full raw bytecode of a newly deployed contract, this will not work as expected. You will receive a hash, not the code itself. This typically affects highly specialized factory contracts or introspection tools."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 14, "depth": 3, "title": "YUL Function Translation Differences", "anchor": "yul-function-translation-differences", "start_char": 17089, "end_char": 24317, "estimated_token_count": 1348, "token_estimator": "heuristic-v1", "text": "### YUL Function Translation Differences\n\nThe following YUL functions exhibit notable behavioral differences in PolkaVM:\n\n- Memory operations:\n\n    - **`mload`, `mstore`, `msize`, `mcopy`**: PolkaVM preserves memory layout but implements several constraints.\n\n        - EVM linear heap memory is emulated using a fixed 64KB byte buffer, limiting maximum contract memory usage.\n        - Accessing memory offsets larger than the buffer size traps the contract with an `OutOfBound` error.\n        - Compiler optimizations may eliminate unused memory operations, potentially causing `msize` to differ from EVM behavior.\n\n        For Solidity developers, the compiler generally handles memory efficiently within this 64KB limit. However, if you are writing low-level YUL assembly and perform direct memory manipulations, you must respect the 64KB buffer limit. Attempting to access memory outside this range will cause your transaction to revert. Be aware that `msize` might not always reflect the exact EVM behavior if compiler optimizations occur.\n\n- Call data operations:\n\n    - **`calldataload`, `calldatacopy`**: In constructor code, the offset parameter is ignored and these functions always return `0`, diverging from EVM behavior where call data represents constructor arguments.\n\n        - If your constructor logic in YUL assembly attempts to read constructor arguments using `calldataload` or `calldatacopy` with specific offsets, this will not yield the expected constructor arguments. Instead, these functions will return `zeroed` values. Standard Solidity constructors are handled correctly by the compiler, but manual YUL assembly for constructor argument parsing will need adjustment.\n\n- Code operations:\n\n    - **`codecopy`**: Only supported within constructor code, reflecting PolkaVM's different approach to code handling and the unified code blob structure.\n\n        - If your contracts use `codecopy` (e.g., for self-modifying code or inspecting other contract's runtime bytecode) outside of the constructor, this will not be supported and will likely result in a compile-time error or runtime trap. This implies that patterns like dynamically generating or modifying contract code at runtime are not directly feasible with `codecopy` on PolkaVM.\n\n- Control flow:\n\n    - **`invalid`**: Traps the contract execution but does not consume remaining gas, unlike EVM where it consumes all available gas.\n\n        - While `invalid` still reverts the transaction, the difference in gas consumption could subtly affect very specific error handling or gas accounting patterns that rely on `invalid` to consume all remaining gas. For most error scenarios, `revert()` is the standard and recommended practice.\n\n- Cross-contract calls:\n\n    - **`call`, `delegatecall`, `staticall`**: These functions ignore supplied gas limits and forward all remaining resources due to PolkaVM's multi-dimensional resource model. This creates important security implications:\n\n        - Contract authors must implement reentrancy protection since gas stipends don't provide protection.\n        - The compiler detects `address payable.{send,transfer}` patterns and disables call reentrancy as a protective heuristic.\n        - Using `address payable.{send,transfer}` is already deprecated; PolkaVM will provide dedicated precompiles for safe balance transfers.\n\n        The traditional EVM pattern of limiting gas in cross-contract calls (especially with the 2300 gas stipend for send/transfer) does not provide reentrancy protection on PolkaVM. Developers must explicitly implement reentrancy guards (e.g., using a reentrancy lock mutex) in their Solidity code when making external calls to untrusted contracts. Relying on gas limits alone for reentrancy prevention is unsafe and will lead to vulnerabilities on PolkaVM.\n\n        !!! warning\n            The 2300 gas stipend that is provided by solc for address payable.{send, transfer} calls offers no reentrancy protection in PolkaVM. While the compiler attempts to detect and mitigate this pattern, developers should avoid these deprecated functions.\n\n- Contract creation:\n\n    - **`create`, `create2`**: Contract instantiation works fundamentally differently in PolkaVM. Instead of supplying deploy code concatenated with constructor arguments, the runtime expects:\n\n        1. A buffer containing the code hash to deploy.\n        2. The constructor arguments buffer.\n\n        PolkaVM translates `dataoffset` and `datasize` instructions to handle contract hashes instead of contract code, enabling seamless use of the `new` keyword in Solidity. However, this translation may fail for contracts creating other contracts within `assembly` blocks.\n\n        If you use the Solidity `new` keyword to deploy contracts, the Revive compiler handles this transparently. However, if you are creating contracts manually in YUL assembly using `create` or `create2` opcodes, you must provide the code hash of the contract to be deployed, not its raw bytecode. Attempting to pass raw bytecode will fail. This fundamentally changes how manual contract creation is performed in assembly.\n\n        !!! warning\n            Avoid using `create` family opcodes for manual deployment crafting in `assembly` blocks. This pattern is discouraged due to translation complexity and offers no gas savings benefits in PolkaVM.\n\n- Data operations:\n\n    - **`dataoffset`**: Returns the contract hash instead of code offset, aligning with PolkaVM's hash-based code referencing.\n    - **`datasize`**: Returns the constant contract hash size (32 bytes) rather than variable code size.\n\n    These changes are primarily relevant for low-level YUL assembly developers who are trying to inspect or manipulate contract code directly. `dataoffset` will provide a hash, not a memory offset to the code, and `datasize` will always be 32 bytes (the size of a hash). This reinforces that direct manipulation of contract bytecode at runtime, as might be done in some EVM patterns, is not supported.\n\n- Resource queries:\n\n    - **`gas`, `gaslimit`**: Return only the `ref_time` component of PolkaVM's multi-dimensional weight system, providing the closest analog to traditional gas measurements.\n\n        - While `gas` and `gaslimit` still provide a useful metric, consider that they represent `ref_time` (computation time) only. If your contract logic depends on precise knowledge of other resource costs (like `proof_size` or `storage_deposit`), you won't get that information from these opcodes. You'll need to use future precompiles for full multi-dimensional resource queries.\n\n- Blockchain state:\n\n    - **`prevrandao`, `difficulty`**: Both translate to a constant value of `2500000000000000`, as PolkaVM doesn't implement Ethereum's difficulty adjustment or randomness mechanisms.\n\n        - If your Solidity contract relies on `block.difficulty` (or its equivalent YUL opcode `difficulty`) for randomness generation or any logic tied to Ethereum's proof-of-work difficulty, this will not provide true randomness on PolkaVM. The value will always be constant. Developers needing on-chain randomness should utilize Polkadot's native randomness sources or dedicated VRF (Verifiable Random Function) solutions if available."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 15, "depth": 3, "title": "Unsupported Operations", "anchor": "unsupported-operations", "start_char": 24317, "end_char": 25724, "estimated_token_count": 270, "token_estimator": "heuristic-v1", "text": "### Unsupported Operations\n\nSeveral EVM operations are not supported in PolkaVM and produce compile-time errors:\n\n- **`pc`, `extcodecopy`**: These operations are EVM-specific and have no equivalent functionality in PolkaVM's RISC-V architecture.\n\n    - Any Solidity contracts that utilize inline assembly to interact with `pc` (program counter) or `extcodecopy` will fail to compile or behave unexpectedly. This means patterns involving introspection of the current execution location or copying external contract bytecode at runtime are not supported.\n\n- **`blobhash`, `blobbasefee`**: Related to Ethereum's rollup model and blob data handling, these operations are unnecessary given Polkadot's superior rollup architecture.\n\n    - If you are porting contracts designed for Ethereum's EIP-4844 (proto-danksharding) and rely on these blob-related opcodes, they will not be available on PolkaVM.\n\n- **`extcodecopy`, `selfdestruct`**: These deprecated operations are not supported and generate compile-time errors.\n\n    - The `selfdestruct` opcode, which allowed contracts to remove themselves from the blockchain, is not supported. Contracts cannot be self-destroyed on PolkaVM. This affects contract upgradeability patterns that rely on self-destruction and redeployment. Similarly, `extcodecopy` is unsupported, impacting contracts that intend to inspect or copy the bytecode of other deployed contracts."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 16, "depth": 3, "title": "Compilation Pipeline Considerations", "anchor": "compilation-pipeline-considerations", "start_char": 25724, "end_char": 26423, "estimated_token_count": 143, "token_estimator": "heuristic-v1", "text": "### Compilation Pipeline Considerations\n\nPolkaVM processes YUL IR exclusively, meaning all contracts exhibit behavior consistent with Solidity's `via-ir` compilation mode. Developers familiar with the legacy compilation pipeline should expect [IR-based codegen behavior](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html){target=\\_blank} when working with PolkaVM contracts.\n\nIf you've previously worked with older Solidity compilers that did not use the `via-ir` pipeline by default, you might observe subtle differences in compiled bytecode size or gas usage. It's recommended to familiarize yourself with Solidity's IR-based codegen behavior, as this is the standard for PolkaVM."}
{"page_id": "polkadot-protocol-smart-contract-basics-evm-vs-polkavm", "page_title": "EVM vs PolkaVM", "index": 17, "depth": 3, "title": "Memory Pointer Limitations", "anchor": "memory-pointer-limitations", "start_char": 26423, "end_char": 27685, "estimated_token_count": 216, "token_estimator": "heuristic-v1", "text": "### Memory Pointer Limitations\n\nYUL functions accepting memory buffer offset pointers or size arguments are limited by PolkaVM's 32-bit pointer size. Supplying values above `2^32-1` will trap the contract immediately. The Solidity compiler typically generates valid memory references, making this primarily a concern for low-level assembly code.\n\nFor standard Solidity development, this limitation is unlikely to be hit as the compiler handles memory addresses correctly within typical contract sizes. However, if you are writing extremely large contracts using YUL assembly that manually and extensively manipulate memory addresses, ensure that your memory offsets and sizes do not exceed PolkaVM's **fixed 64KB memory limit per contract**. While the YUL functions might accept 32-bit pointers (up to 2^32-1), attempting to access memory beyond the allocated 64KB buffer will trap the contract immediately.\n\nThese incompatibilities reflect the fundamental architectural differences between EVM and PolkaVM while maintaining high-level Solidity compatibility. Most developers using standard Solidity patterns will encounter no issues, but those working with assembly code or advanced contract patterns should carefully review these differences during migration."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 182, "end_char": 813, "estimated_token_count": 96, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPolkadot Hub provides smart contract functionality across multiple networks to facilitate smart contract development in the Polkadot ecosystem. Whether you're testing new contracts or deploying to production, Polkadot Hub offers several network environments tailored for each stage of development. Developers can thoroughly test, iterate, and validate their smart contracts from local testing environments to production networks like Polkadot Hub.\n\nThis guide will introduce you to the current and upcoming networks available for smart contract development and explain how they fit into the development workflow."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 1, "depth": 2, "title": "Network Overview", "anchor": "network-overview", "start_char": 813, "end_char": 2105, "estimated_token_count": 219, "token_estimator": "heuristic-v1", "text": "## Network Overview\n\nSmart contract development on Polkadot Hub follows a structured process to ensure rigorous testing of new contracts and upgrades before deployment on production networks. Development progresses through a well-defined path, beginning with local environments, advancing through TestNets, and ultimately reaching MainNets. The diagram below illustrates this progression:\n\n``` mermaid\nflowchart LR\n    id1[Local Polkadot Hub] --> id2[TestNet Polkadot Hub] --> id4[MainNet Polkadot Hub]\n```\n\nThis progression ensures developers can thoroughly test and iterate their smart contracts without risking real tokens or affecting production networks. A typical development journey consists of three main stages:\n\n1. Local development:\n\n    - Developers start in a local environment to create, test, and iterate on smart contracts.\n    - Provides rapid experimentation in an isolated setup without external dependencies.\n\n2. TestNet development:\n\n    - Contracts move to TestNets like Westend Hub and Passet Hub.\n    - Enables testing in simulated real-world conditions without using real tokens.\n\n3. Production deployment:\n\n    - Final deployment to MainNets like Kusama Hub and Polkadot Hub.\n    - Represents the live environment where contracts interact with real economic value."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 2, "depth": 2, "title": "Local Development", "anchor": "local-development", "start_char": 2105, "end_char": 3108, "estimated_token_count": 202, "token_estimator": "heuristic-v1", "text": "## Local Development\n\nThe local development environment is crucial for smart contract development on Polkadot Hub. It provides developers a controlled space for rapid testing and iteration before moving to public networks. The local setup consists of several key components:\n\n- **[Kitchensink node](https://paritytech.github.io/polkadot-sdk/master/kitchensink_runtime/index.html){target=\\_blank}**: A local node that can be run for development and testing. It includes logging capabilities for debugging contract execution and provides a pre-configured development environment with pre-funded accounts for testing purposes.\n- **[Ethereum RPC proxy](https://paritytech.github.io/polkadot-sdk/master/pallet_revive_eth_rpc/index.html){target=\\_blank}**: Bridges Ethereum-compatible tools with the Polkadot SDK-based network. It enables seamless integration with popular development tools like MetaMask and Remix IDE. The purpose of this component is to translate Ethereum RPC calls into Substrate format."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 3, "depth": 2, "title": "Test Networks", "anchor": "test-networks", "start_char": 3108, "end_char": 3539, "estimated_token_count": 96, "token_estimator": "heuristic-v1", "text": "## Test Networks\n\nThe following test networks provide controlled environments for testing smart contracts. TestNet tokens are available from the [Polkadot faucet](https://faucet.polkadot.io/){target=\\_blank}. They provide a stable environment for testing your contracts without using real tokens.\n\n``` mermaid\nflowchart TB\n    id1[Polkadot Hub TestNets] --> id2[Passet Hub]\n    id1[Polkadot Hub TestNets] --> id3[Westend Hub]\n```"}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 4, "depth": 3, "title": "Passet Hub", "anchor": "passet-hub", "start_char": 3539, "end_char": 3820, "estimated_token_count": 47, "token_estimator": "heuristic-v1", "text": "### Passet Hub\n\nThe Passet Hub will be a community-managed TestNet designed specifically for smart contract development. It will mirror Asset Hub's runtime and provide developers with an additional environment for testing their contracts before deployment to production networks."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 5, "depth": 3, "title": "Westend Hub", "anchor": "westend-hub", "start_char": 3820, "end_char": 4088, "estimated_token_count": 46, "token_estimator": "heuristic-v1", "text": "### Westend Hub\n\nWestend Hub is the TestNet for smart contract development and its cutting-edge features. The network maintains the same features and capabilities as the production Polkadot Hub, and also incorporates the latest features developed by core developers."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 6, "depth": 2, "title": "Production Networks", "anchor": "production-networks", "start_char": 4088, "end_char": 4425, "estimated_token_count": 68, "token_estimator": "heuristic-v1", "text": "## Production Networks\n\nThe MainNet environments represent the final destination for thoroughly tested and validated smart contracts, where they operate with real economic value and serve actual users.\n\n``` mermaid\nflowchart TB\n    id1[Polkadot Hub MainNets] --> id2[Polkadot Hub]\n    id1[Polkadot Hub MainNets] --> id3[Kusama Hub]\n```"}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 7, "depth": 3, "title": "Polkadot Hub", "anchor": "polkadot-hub", "start_char": 4425, "end_char": 4790, "estimated_token_count": 59, "token_estimator": "heuristic-v1", "text": "### Polkadot Hub\n\nPolkadot Hub is the primary production network for deploying smart contracts in the Polkadot ecosystem. It provides a secure and stable environment for running smart contracts with real economic value. The network supports PolkaVM-compatible contracts written in Solidity or Rust, maintaining compatibility with Ethereum-based development tools."}
{"page_id": "polkadot-protocol-smart-contract-basics-networks", "page_title": "Networks for Polkadot Hub Smart Contracts", "index": 8, "depth": 3, "title": "Kusama Hub", "anchor": "kusama-hub", "start_char": 4790, "end_char": 5108, "estimated_token_count": 58, "token_estimator": "heuristic-v1", "text": "### Kusama Hub\n\nKusama Hub is the canary version of Polkadot Hub. It is designed for developers who want to move quickly and test their smart contracts in a real-world environment with economic incentives. It provides a more flexible space for innovation while maintaining the same core functionality as Polkadot Hub."}
{"page_id": "polkadot-protocol-smart-contract-basics-overview", "page_title": "Smart Contracts Basics Overview", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 229, "end_char": 1690, "estimated_token_count": 301, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nPolkadot is designed to support an ecosystem of parachains, rather than hosting smart contracts directly. Developers aiming to build smart contract applications on Polkadot rely on parachains within the ecosystem that provide smart contract functionality.\n\nThis guide outlines the primary approaches to developing smart contracts in the Polkadot ecosystem:\n\n- **PolkaVM-compatible contracts**: Support Solidity and any language that compiles down to RISC-V while maintaining compatibility with Ethereum based tools.\n- **EVM-compatible contracts**: Support languages like [Solidity](https://soliditylang.org/){target=\\_blank} and [Vyper](https://vyperlang.org/){target=\\_blank}, offering compatibility with popular Ethereum tools and wallets.\n- **Wasm-based smart contracts**: Using [ink!](https://use.ink/){target=\\_blank}, a Rust-based embedded domain-specific language (eDSL), enabling developers to leverage Rust’s safety and tooling.\n\nYou'll explore the key differences between these development paths, along with considerations for parachain developers integrating smart contract functionality.\n\n!!!note \"Parachain Developer?\"\n    If you are a parachain developer looking to add smart contract functionality to your chain, please refer to the [Add Smart Contract Functionality](/develop/parachains/customize-parachain/add-smart-contract-functionality/){target=\\_blank} page, which covers both Wasm and EVM-based contract implementations."}
{"page_id": "polkadot-protocol-smart-contract-basics-overview", "page_title": "Smart Contracts Basics Overview", "index": 1, "depth": 2, "title": "Smart Contracts Versus Parachains", "anchor": "smart-contracts-versus-parachains", "start_char": 1690, "end_char": 4951, "estimated_token_count": 708, "token_estimator": "heuristic-v1", "text": "## Smart Contracts Versus Parachains\n\nA smart contract is a program that executes specific logic isolated to the chain on which it is being executed. All the logic executed is bound to the same state transition rules determined by the underlying virtual machine (VM). Consequently, smart contracts are more streamlined to develop, and programs can easily interact with each other through similar interfaces.\n\n``` mermaid\nflowchart LR\n  subgraph A[Chain State]\n    direction LR\n    B[\"Program Logic and Storage<br/>(Smart Contract)\"]\n    C[\"Tx Relevant Storage\"]\n  end\n  A --> D[[Virtual Machine]]\n  E[Transaction] --> D\n  D --> F[(New State)]\n  D --> G[Execution Logs]\n  style A fill:#ffffff,stroke:#000000,stroke-width:1px\n```\n\nIn addition, because smart contracts are programs that execute on top of existing chains, teams don't have to think about the underlying consensus they are built on.\n\nThese strengths do come with certain limitations. Some smart contracts environments, like EVM, tend to be immutable by default. Developers have developed different [proxy strategies](https://www.openzeppelin.com/news/proxy-patterns){target=\\_blank} to be able to upgrade smart contracts over time. The typical pattern relies on a proxy contract which holds the program storage forwarding a call to an implementation contract where the execution logic resides. Smart contract upgrades require changing the implementation contract while retaining the same storage structure, necessitating careful planning.\n\nAnother downside is that smart contracts often follow a gas metering model, where program execution is associated with a given unit and a marketplace is set up to pay for such an execution unit. This fee system is often very rigid, and some complex flows, like account abstraction, have been developed to circumvent this problem.\n\nIn contrast, parachains can create their own custom logics (known as pallets or modules), and combine them as the state transition function (STF or runtime) thanks to the modularity provided by the [Polkadot-SDK](https://github.com/paritytech/polkadot-sdk/){target=\\_blank}. The different pallets within the parachain runtime can give developers a lot of flexibility when building applications on top of it.\n\n``` mermaid\nflowchart LR\n    A[(Chain State)] --> B[[\"STF<br/>[Pallet 1]<br/>[Pallet 2]<br/>...<br/>[Pallet N]\"]]\n    C[Transaction<br/>Targeting Pallet 2] --> B\n    B --> E[(New State)]\n    B --> F[Execution Logs]\n```\n\nParachains inherently offer features such as logic upgradeability, flexible transaction fee mechanisms, and chain abstraction logic. More so, by using Polkadot, parachains can benefit from robust consensus guarantees with little engineering overhead.\n\nTo read more about the differences between smart contracts and parachain runtimes, see the [Runtime vs. Smart Contracts](https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/reference_docs/runtime_vs_smart_contract/index.html){target=\\_blank} section of the Polkadot SDK Rust docs. For a more in-depth discussion about choosing between runtime development and smart contract development, see the Stack Overflow post on [building a Polkadot SDK runtime versus a smart contract](https://stackoverflow.com/a/56041305){target=\\_blank}."}
{"page_id": "polkadot-protocol-smart-contract-basics-overview", "page_title": "Smart Contracts Basics Overview", "index": 2, "depth": 2, "title": "Building a Smart Contract", "anchor": "building-a-smart-contract", "start_char": 4951, "end_char": 6260, "estimated_token_count": 377, "token_estimator": "heuristic-v1", "text": "## Building a Smart Contract\n\nThe Polkadot SDK supports multiple smart contract execution environments:\n\n- **PolkaVM**: A cutting-edge virtual machine tailored to optimize smart contract execution on Polkadot. Unlike traditional EVMs, PolkaVM is built with a [RISC-V-based register architecture](https://en.wikipedia.org/wiki/RISC-V){target=\\_blank} for increased performance and scalability.\n- **EVM**: Through [Frontier](https://github.com/polkadot-evm/frontier){target=\\_blank}. It consists of a full Ethereum JSON RPC compatible client, an Ethereum emulation layer, and a [Rust-based EVM](https://github.com/rust-ethereum/evm){target=\\_blank}. This is used by chains like [Acala](https://acala.network/){target=\\_blank}, [Astar](https://astar.network/){target=\\_blank}, [Moonbeam](https://moonbeam.network){target=\\_blank} and more.\n- **Wasm**: [ink!](https://use.ink/){target=\\_blank} is a domain-specific language (DSL) for Rust smart contract development that uses the [Contracts pallet](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/frame/contracts/){target=\\_blank} with [`cargo-contract`](https://github.com/use-ink/cargo-contract){target=\\_blank} serving as the compiler to WebAssembly. Wasm contracts can be used by chains like [Astar](https://astar.network/){target=\\_blank}."}
{"page_id": "polkadot-protocol-smart-contract-basics-overview", "page_title": "Smart Contracts Basics Overview", "index": 3, "depth": 3, "title": "PolkaVM Contracts", "anchor": "polkavm-contracts", "start_char": 6260, "end_char": 6676, "estimated_token_count": 82, "token_estimator": "heuristic-v1", "text": "### PolkaVM Contracts\n\nA component of the Asset Hub parachain, PolkaVM helps enable the deployment of Solidity-based smart contracts directly on Asset Hub. Learn more about how this cutting edge virtual machine facilitates using familiar Ethereum-compatible contracts and tools with Asset Hub by visiting the [Native Smart Contracts](/develop/smart-contracts/overview#native-smart-contracts){target=\\_blank} guide."}
{"page_id": "polkadot-protocol-smart-contract-basics-overview", "page_title": "Smart Contracts Basics Overview", "index": 4, "depth": 3, "title": "EVM Contracts", "anchor": "evm-contracts", "start_char": 6676, "end_char": 9412, "estimated_token_count": 721, "token_estimator": "heuristic-v1", "text": "### EVM Contracts\n\nThe [Frontier](https://github.com/polkadot-evm/frontier){target=\\_blank} project provides a set of modules that enables a Polkadot SDK-based chain to run an Ethereum emulation layer that allows the execution of EVM smart contracts natively with the same API/RPC interface.\n\n[Ethereum addresses (ECDSA)](https://ethereum.org/en/glossary/#address){target=\\_blank} can also be mapped directly to and from the Polkadot SDK's SS58 scheme from existing accounts. Moreover, you can modify Polkadot SDK to use the ECDSA signature scheme directly to avoid any mapping.\n\nAt a high level, [Frontier](https://github.com/polkadot-evm/frontier){target=\\_blank} is composed of three main components:\n\n- **[Ethereum Client](https://github.com/polkadot-evm/frontier/tree/master/client){target=\\_blank}**: An Ethereum JSON RPC compliant client that allows any request coming from an Ethereum tool, such as [Remix](https://remix.ethereum.org/){target=\\_blank}, [Hardhat](https://hardhat.org/){target=\\_blank} or [Foundry](https://getfoundry.sh/){target=\\_blank}, to be admitted by the network.\n- **[Pallet Ethereum](https://docs.rs/pallet-ethereum/latest/pallet_ethereum/){target=\\_blank}**: A block emulation and Ethereum transaction validation layer that works jointly with the Ethereum client to ensure compatibility with Ethereum tools.\n- **[Pallet EVM](https://docs.rs/pallet-evm/latest/pallet_evm/){target=\\_blank}**: Access layer to the [Rust-based EVM](https://github.com/rust-ethereum/evm){target=\\_blank}, enabling the execution of EVM smart contract logic natively.\n\nThe following diagram illustrates a high-level overview of the path an EVM transaction follows when using this configuration:\n\n``` mermaid\nflowchart TD\n    A[Users and Devs] -->|Send Tx| B[Frontier RPC Ext]\n    subgraph C[Pallet Ethereum]\n        D[Validate Tx]\n        E[Send<br/>Valid Tx]    \n    end\n    B -->|Interact with| C\n    D --> E\n    subgraph F[Pallet EVM]\n        G[Rust EVM]\n    end\n    I[(Current EVM<br/>Emulated State)]\n\n    H[Smart Contract<br/>Solidity, Vyper...] <-->|Compiled to EVM<br/>Bytecode| I\n\n    C --> F\n    I --> F\n    F --> J[(New Ethereum<br/>Emulated State)]\n    F --> K[Execution Logs]\n\n    style C fill:#ffffff,stroke:#000000,stroke-width:1px\n    style F fill:#ffffff,stroke:#000000,stroke-width:1px\n```\n\nAlthough it seems complex, users and developers are abstracted of that complexity, and tools can easily interact with the parachain as they would with any other Ethereum-compatible environment.\n\nThe Rust EVM is capable of executing regular [EVM bytecode](https://www.ethervm.io/){target=\\_blank}. Consequently, any language that compiles to EVM bytecode can be used to create programs that the parachain can execute."}
{"page_id": "polkadot-protocol-smart-contract-basics-overview", "page_title": "Smart Contracts Basics Overview", "index": 5, "depth": 3, "title": "Wasm Contracts", "anchor": "wasm-contracts", "start_char": 9412, "end_char": 10923, "estimated_token_count": 384, "token_estimator": "heuristic-v1", "text": "### Wasm Contracts\n\nThe [`pallet_contracts`](https://docs.rs/pallet-contracts/latest/pallet_contracts/index.html#contracts-pallet){target=\\_blank} provides the execution environment for Wasm-based smart contracts. Consequently, any smart contract language that compiles to Wasm can be executed in a parachain that enables this module.\n\nAt the time of writing there are two main languages that can be used for Wasm programs:\n\n- **[ink!](https://use.ink/){target=\\_blank}**: A Rust-based language that compiles to Wasm. It allows developers to inherit all its safety guarantees and use normal Rust tooling, being the dedicated domain-specific language.\n- **Solidity**: Can be compiled to Wasm via the [Solang](https://github.com/hyperledger-solang/solang/){target=\\_blank} compiler. Consequently, developers can write Solidity 0.8 smart contracts that can be executed as Wasm programs in parachains.\n\nThe following diagram illustrates a high-level overview of the path a transaction follows when using [`pallet_contracts`](https://docs.rs/pallet-contracts/latest/pallet_contracts/index.html#contracts-pallet){target=\\_blank}:\n\n``` mermaid\nflowchart TD\n    \n    subgraph A[Wasm Bytecode API]\n        C[Pallet Contracts]\n    end\n\n    B[Users and Devs] -- Interact with ---> A\n    \n    D[(Current State)]\n\n    E[Smart Contract<br/>ink!, Solidity...] <-->|Compiled to Wasm<br/>Bytecode| D\n\n    D --> A\n    A --> F[(New State)]\n    A --> G[Execution Logs]\n\n    style A fill:#ffffff,stroke:#000000,stroke-width:1px\n```"}
{"page_id": "polkadot-protocol-smart-contract-basics-polkavm-design", "page_title": "PolkaVM Design", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 188, "end_char": 480, "estimated_token_count": 40, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThe Asset Hub smart contracts solution includes multiple components to ensure Ethereum compatibility and high performance. Its architecture allows for integration with current Ethereum tools, while its innovative virtual machine design enhances performance characteristics."}
{"page_id": "polkadot-protocol-smart-contract-basics-polkavm-design", "page_title": "PolkaVM Design", "index": 1, "depth": 2, "title": "PolkaVM", "anchor": "polkavm", "start_char": 480, "end_char": 1366, "estimated_token_count": 172, "token_estimator": "heuristic-v1", "text": "## PolkaVM\n\n[**PolkaVM**](https://github.com/paritytech/polkavm){target=\\_blank} is a custom virtual machine optimized for performance with [RISC-V-based](https://en.wikipedia.org/wiki/RISC-V){target=\\_blank} architecture, supporting Solidity and additional high-performance languages. It serves as the core execution environment, integrated directly within the runtime. It features:\n\n- An efficient interpreter for immediate code execution.\n- A planned JIT compiler for optimized performance.\n- Dual-mode execution capability, allowing selection of the most appropriate backend for specific workloads.\n- Optimized performance for short-running contract calls through the interpreter.\n\nThe interpreter remains particularly beneficial for contracts with minimal code execution, as it eliminates JIT compilation overhead and enables immediate code execution through lazy interpretation."}
{"page_id": "polkadot-protocol-smart-contract-basics-polkavm-design", "page_title": "PolkaVM Design", "index": 2, "depth": 2, "title": "Architecture", "anchor": "architecture", "start_char": 1366, "end_char": 1531, "estimated_token_count": 26, "token_estimator": "heuristic-v1", "text": "## Architecture\n\nThe smart contract solution consists of the following key components that work together to enable Ethereum compatibility on Polkadot-based chains."}
{"page_id": "polkadot-protocol-smart-contract-basics-polkavm-design", "page_title": "PolkaVM Design", "index": 3, "depth": 3, "title": "Pallet Revive", "anchor": "pallet-revive", "start_char": 1531, "end_char": 2801, "estimated_token_count": 230, "token_estimator": "heuristic-v1", "text": "### Pallet Revive\n\n[**`pallet_revive`**](https://paritytech.github.io/polkadot-sdk/master/pallet_revive/index.html){target=\\_blank} is a runtime module that executes smart contracts by adding extrinsics, runtime APIs, and logic to convert Ethereum-style transactions into formats compatible with Polkadot SDK-based blockchains. It processes Ethereum-style transactions through the following workflow:\n\n```mermaid\nsequenceDiagram\n    participant User as User/dApp\n    participant Proxy as Ethereum JSON RPC Proxy\n    participant Chain as Blockchain Node\n    participant Pallet as pallet_revive\n    \n    User->>Proxy: Submit Ethereum Transaction\n    Proxy->>Chain: Repackage as Polkadot Compatible Transaction\n    Chain->>Pallet: Process Transaction\n    Pallet->>Pallet: Decode Ethereum Transaction\n    Pallet->>Pallet: Execute Contract via PolkaVM\n    Pallet->>Chain: Return Results\n    Chain->>Proxy: Forward Results\n    Proxy->>User: Return Ethereum-compatible Response\n```\n\nThis proxy-based approach eliminates the need for node binary modifications, maintaining compatibility across different client implementations. Preserving the original Ethereum transaction payload simplifies adapting existing tools, which can continue processing familiar transaction formats."}
{"page_id": "polkadot-protocol-smart-contract-basics-polkavm-design", "page_title": "PolkaVM Design", "index": 4, "depth": 3, "title": "PolkaVM Design Fundamentals", "anchor": "polkavm-design-fundamentals", "start_char": 2801, "end_char": 4302, "estimated_token_count": 258, "token_estimator": "heuristic-v1", "text": "### PolkaVM Design Fundamentals\n\nPolkaVM introduces two fundamental architectural differences compared to the Ethereum Virtual Machine (EVM):\n\n```mermaid\nflowchart TB\n    subgraph \"EVM Architecture\"\n        EVMStack[Stack-Based]\n        EVM256[256-bit Word Size]\n    end\n    \n    subgraph \"PolkaVM Architecture\"\n        PVMReg[Register-Based]\n        PVM64[64-bit Word Size]\n    end\n```\n\n- **Register-based design**: PolkaVM utilizes a RISC-V register-based approach. This design:\n\n    - Employs a finite set of registers for argument passing instead of an infinite stack.\n    - Facilitates efficient translation to underlying hardware architectures.\n    - Optimizes register allocation through careful register count selection.\n    - Enables simple 1:1 mapping to x86-64 instruction sets.\n    - Reduces compilation complexity through strategic register limitation.\n    - Improves overall execution performance through hardware-aligned design.\n\n- **64-bit word size**: PolkaVM operates with a 64-bit word size. This design:\n\n    - Enables direct hardware-supported arithmetic operations.\n    - Maintains compatibility with Solidity's 256-bit operations through YUL translation.\n    - Allows integration of performance-critical components written in lower-level languages.\n    - Optimizes computation-intensive operations through native word size alignment.\n    - Reduces overhead for operations not requiring extended precision.\n    - Facilitates efficient integration with modern CPU architectures."}
{"page_id": "polkadot-protocol-smart-contract-basics-polkavm-design", "page_title": "PolkaVM Design", "index": 5, "depth": 2, "title": "Compilation Process", "anchor": "compilation-process", "start_char": 4302, "end_char": 5334, "estimated_token_count": 268, "token_estimator": "heuristic-v1", "text": "## Compilation Process\n\nWhen compiling a Solidity smart contract, the code passes through the following stages:\n\n```mermaid\nflowchart LR\n    Dev[Developer] --> |Solidity<br>Source<br>Code| Solc\n    \n    subgraph \"Compilation Process\"\n        direction LR\n        Solc[solc] --> |YUL<br>IR| Revive\n        Revive[Revive Compiler] --> |LLVM<br>IR| LLVM\n        LLVM[LLVM<br>Optimizer] --> |RISC-V ELF<br>Shared Object| PVMLinker\n    end\n    \n    PVMLinker[PVM Linker] --> PVM[PVM Blob<br>with Metadata]\n```\n\nThe compilation process integrates several specialized components:\n\n1. **Solc**: The standard Ethereum Solidity compiler that translates Solidity source code to [YUL IR](https://docs.soliditylang.org/en/latest/yul.html){target=\\_blank}.\n2. **Revive Compiler**: Takes YUL IR and transforms it to [LLVM IR](https://llvm.org/){target=\\_blank}.\n3. **LLVM**: A compiler infrastructure that optimizes the code and generates RISC-V ELF objects.\n4. **PVM linker**: Links the RISC-V ELF object into a final PolkaVM blob with metadata."}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 25, "end_char": 1000, "estimated_token_count": 220, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nThis tutorial demonstrates how to build a simple command-line interface (CLI) application that monitors a user's account on the relay chain for the [`system.remarkWithEvent`](https://paritytech.github.io/polkadot-sdk/master/frame_system/pallet/struct.Pallet.html#method.remark_with_event){target=\\_blank} extrinsic, using the [Polkadot API](/develop/toolkit/api-libraries/papi){target=\\_blank}.\n\nThe `system.remarkWithEvent` extrinsic enables the submission of arbitrary data on-chain. In this tutorial, the data consists of a hash derived from the combination of an account address and the word \"email\" (`address+email`). This hash is monitored on-chain, and the application listens for remarks addressed to the specified account. The `system.remarkWithEvent` extrinsic emits an event that can be observed using the Polkadot API (PAPI).\n\nWhen the application detects a remark addressed to the specified account, it plays the \"You've Got Mail!\" sound byte."}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1000, "end_char": 1349, "estimated_token_count": 96, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore starting, ensure the following tools and dependencies are installed:\n\n- Node.js (version 18 or higher).\n- A package manager (npm or yarn).\n- [Polkadot.js browser extension (wallet)](https://polkadot.js.org/extension/){target=\\_blank}.\n- An account with [Westend tokens](https://faucet.polkadot.io/westend){target=\\_blank}."}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 2, "depth": 2, "title": "Clone the Repository", "anchor": "clone-the-repository", "start_char": 1349, "end_char": 2001, "estimated_token_count": 164, "token_estimator": "heuristic-v1", "text": "## Clone the Repository\n\nTo follow this tutorial, you can either run the example directly or use a boilerplate/template. This tutorial uses a template that includes all necessary dependencies for working with the Polkadot API and TypeScript. Clone the `polkadot-api-example-cli` project and checkout to the [`empty-cli`](https://github.com/CrackTheCode016/polkadot-api-example-cli/tree/empty-cli){target=\\_blank} as follows:\n\n```bash\ngit clone https://github.com/polkadot-developers/dapp-examples/tree/v0.0.2\ncd polkadot-api-example-cli\ngit checkout empty-cli\n```\n\nAfter cloning, install the required dependencies by running:\n\n```bash\nnpm install\n```"}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 3, "depth": 2, "title": "Explore the Template (Light Clients)", "anchor": "explore-the-template-light-clients", "start_char": 2001, "end_char": 2852, "estimated_token_count": 199, "token_estimator": "heuristic-v1", "text": "## Explore the Template (Light Clients)\n\nAfter opening the repository, you will find the following code (excluding imports):\n\n```typescript title=\"index.ts\"\nasync function withLightClient(): Promise<PolkadotClient> {\n  // Start the light client\n  const smoldot = start();\n  // The Westend Relay Chain\n  const relayChain = await smoldot.addChain({ chainSpec: westEndChainSpec });\n  return createClient(getSmProvider(relayChain));\n}\n\nasync function main() {\n  // CLI code goes here...\n}\n\nmain();\n\n```\n\nThe `withLightClient` function is particularly important. It uses the built-in [light client](/develop/toolkit/parachains/light-clients/){target=\\_blank} functionality, powered by [`smoldot`](https://github.com/smol-dot/smoldot){target=\\_blank}, to create a light client that synchronizes and interacts with Polkadot directly within the application."}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 4, "depth": 2, "title": "Create the CLI", "anchor": "create-the-cli", "start_char": 2852, "end_char": 3451, "estimated_token_count": 166, "token_estimator": "heuristic-v1", "text": "## Create the CLI\n\nThe CLI functionality is implemented within the `main` function. The CLI includes an option (`-a` / `--account`) to specify the account to monitor for remarks:\n\n```typescript title=\"index.ts\"\nconst program = new Command();\nconsole.log(chalk.white.dim(figlet.textSync('Web3 Mail Watcher')));\nprogram\n  .version('0.0.1')\n  .description(\n    'Web3 Mail Watcher - A simple CLI tool to watch for remarks on the Polkadot network'\n  )\n  .option('-a, --account <account>', 'Account to watch')\n  .parse(process.argv);\n\n// CLI arguments from commander\nconst options = program.opts();\n\n```"}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 5, "depth": 2, "title": "Watch for Remarks", "anchor": "watch-for-remarks", "start_char": 3451, "end_char": 4775, "estimated_token_count": 338, "token_estimator": "heuristic-v1", "text": "## Watch for Remarks\n\nThe application monitors the Westend network for remarks sent to the specified account. The following code, placed within the `main` function, implements this functionality:\n\n```typescript title=\"index.ts\"\nif (options.account) {\n  console.log(\n    chalk.black.bgRed('Watching account:'),\n    chalk.bold.whiteBright(options.account)\n  );\n  // Create a light client to connect to the Polkadot (Westend) network\n  const lightClient = await withLightClient();\n  // Get the typed API to interact with the network\n  const dotApi = lightClient.getTypedApi(wnd);\n  // Subscribe to the System.Remarked event and watch for remarks from the account\n  dotApi.event.System.Remarked.watch().subscribe((event) => {\n    const { sender, hash } = event.payload;\n    const calculatedHash = bytesToHex(\n      blake2b(`${options.account}+email`, { dkLen: 32 })\n    );\n    if (`0x${calculatedHash}` === hash.asHex()) {\n      sound.play('youve-got-mail-sound.mp3');\n      console.log(chalk.black.bgRed('You got mail!'));\n      console.log(\n        chalk.black.bgCyan('From:'),\n        chalk.bold.whiteBright(sender.toString())\n      );\n      console.log(\n        chalk.black.bgBlue('Hash:'),\n        chalk.bold.whiteBright(hash.asHex())\n      );\n    }\n  });\n} else {\n  console.error('Account is required');\n  return;\n}\n\n```"}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 6, "depth": 2, "title": "Compile and Run", "anchor": "compile-and-run", "start_char": 4775, "end_char": 6108, "estimated_token_count": 478, "token_estimator": "heuristic-v1", "text": "## Compile and Run\n\nCompile and execute the application using the following command:\n\n```bash\nnpm start -- --account <account-address>\n```\n\nFor example:\n\n```bash\nnpm start -- --account 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\n```\n\nThe output should look like this:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npm start -- --account 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</span>\n  <span data-ty> __ __ _ _____ __ __ _ _ __ __ _ _</span>\n  <span data-ty> \\ \\ / /__| |__|___ / | \\/ | __ _(_) | \\ \\ / /_ _| |_ ___| |__ ___ _ __</span>\n  <span data-ty> \\ \\ /\\ / / _ \\ '_ \\ |_ \\ | |\\/| |/ _` | | | \\ \\ /\\ / / _` | __/ __| '_ \\ / _ \\ '__|</span>\n  <span data-ty> \\ V V / __/ |_) |__) | | | | | (_| | | | \\ V V / (_| | || (__| | | | __/ |</span>\n  <span data-ty> \\_/\\_/ \\___|_.__/____/ |_| |_|\\__,_|_|_| \\_/\\_/ \\__,_|\\__\\___|_| |_|\\___|_|</span>\n  <span data-ty> </span>\n  <span data-ty>📬 Watching account: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</span>\n  <span data-ty>⚙️ [smoldot] Smoldot v2.0.34</span>\n  <span data-ty>✅ [smoldot] Chain initialization complete for westend2.</span>\n  <span data-ty>🔗 Name: \"Westend\"</span>\n  <span data-ty>🧬 Genesis hash: 0xe143…423e</span>\n  <span data-ty>⛓️ Chain specification starting at: 0x10cf…b908 (#23920337)</span>\n</div>"}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 7, "depth": 2, "title": "Test the CLI", "anchor": "test-the-cli", "start_char": 6108, "end_char": 7721, "estimated_token_count": 521, "token_estimator": "heuristic-v1", "text": "## Test the CLI\n\nTo test the application, navigate to the [**Extrinsics** page of the PAPI Dev Console](https://dev.papi.how/extrinsics#networkId=westend&endpoint=light-client){target=\\_blank}. Select the **System** pallet and the **remark_with_event** call. Ensure the input field follows the convention `address+email`. For example, if monitoring `5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY`, the input should be:\n\n![](/images/tutorials/dapps/remark-tutorial/papi-console.webp)\n\nSubmit the extrinsic and sign it using the Polkadot.js browser wallet. The CLI will display the following output and play the \"You've Got Mail!\" sound:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npm start -- --account 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</span>\n  <span data-ty> __ __ _ _____ __ __ _ _ __ __ _ _</span>\n  <span data-ty> \\ \\ / /__| |__|___ / | \\/ | __ _(_) | \\ \\ / /_ _| |_ ___| |__ ___ _ __</span>\n  <span data-ty> \\ \\ /\\ / / _ \\ '_ \\ |_ \\ | |\\/| |/ _` | | | \\ \\ /\\ / / _` | __/ __| '_ \\ / _ \\ '__|</span>\n  <span data-ty> \\ V V / __/ |_) |__) | | | | | (_| | | | \\ V V / (_| | || (__| | | | __/ |</span>\n  <span data-ty> \\_/\\_/ \\___|_.__/____/ |_| |_|\\__,_|_|_| \\_/\\_/ \\__,_|\\__\\___|_| |_|\\___|_|</span>\n  <span data-ty> </span>\n  <span data-ty>📬 Watching account: 5Cm8yiG45rqrpyV2zPLrbtr8efksrRuCXcqcB4xj8AejfcTB</span>\n  <span data-ty>📥 You've got mail!</span>\n  <span data-ty>👤 From: 5Cm8yiG45rqrpyV2zPLrbtr8efksrRuCXcqcB4xj8AejfcTB</span>\n  <span data-ty>🔖 Hash: 0xb6999c9082f5b1dede08b387404c9eb4eb2deee4781415dfa7edf08b87472050</span>\n</div>"}
{"page_id": "tutorials-dapps-remark-tutorial", "page_title": "PAPI Account Watcher Tutorial", "index": 8, "depth": 2, "title": "Next Steps", "anchor": "next-steps", "start_char": 7721, "end_char": 8055, "estimated_token_count": 69, "token_estimator": "heuristic-v1", "text": "## Next Steps\n\nThis application demonstrates how the Polkadot API can be used to build decentralized applications. While this is not a production-grade application, it introduces several key features for developing with the Polkadot API.\n\nTo explore more, refer to the [official PAPI documentation](https://papi.how){target=\\_blank}."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 44, "end_char": 735, "estimated_token_count": 150, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nIn this tutorial, you'll learn how to replay and dry-run XCMs using [Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/){target=\\_blank}, a powerful tool for forking live Polkadot SDK-based chains in your local environment. These techniques are essential for:\n\n- Debugging cross-chain message failures.\n- Tracing execution across relay chains and parachains.\n- Analyzing weight usage, error types, and message flow.\n- Safely simulating XCMs without committing state changes.\n\nBy the end of this guide, you'll be able to set up a local fork, capture and replay real XCMs, and use dry-run features to diagnose and resolve complex cross-chain issues."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 735, "end_char": 1478, "estimated_token_count": 199, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore you begin, make sure you have:\n\n- [Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/){target=\\_blank} installed (`npm i -g @acala-network/chopsticks`).\n- Access to the endpoint or genesis file of the parachain you want to fork.\n- The block number or hash where the XCM was sent.\n- (Optional) A Chopsticks config file for repeated setups.\n\nIf you haven't forked a chain before, see the [Fork a Chain with Chopsticks guide](/tutorials/polkadot-sdk/testing/fork-live-chains/){target=\\_blank} or [Fork a Network Locally using Chopsticks](https://wiki.polkadot.com/learn/learn-guides-test-opengov-proposals/#fork-a-network-locally-using-chopsticks){target=\\_blank} for step-by-step instructions."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 2, "depth": 2, "title": "Set Up Your Project", "anchor": "set-up-your-project", "start_char": 1478, "end_char": 2310, "estimated_token_count": 194, "token_estimator": "heuristic-v1", "text": "## Set Up Your Project\n\nLet's start by creating a dedicated workspace for your XCM replay and dry-run experiments.\n\n1. Create a new directory and navigate into it:\n\n    ```bash\n    mkdir -p replay-xcm-tests\n    cd replay-xcm-tests\n    ```\n\n2. Initialize a new Node project:\n\n    ```bash\n    npm init -y\n    ```\n\n3. Install Chopsticks globally (recommended to avoid conflicts with local installs):\n\n    ```bash\n    npm install -g @acala-network/chopsticks@latest\n    ```\n\n4. Install TypeScript and related tooling for local development:\n\n    ```bash\n    npm install --save-dev typescript @types/node tsx\n    ```\n\n5. Install the required Polkadot packages:\n\n    ```bash\n    npm install polkadot-api @polkadot-labs/hdkd @polkadot-labs/hdkd-helpers\n    ```\n\n6. Initialize the TypeScript config:\n\n    ```bash\n    npx tsc --init\n    ```"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 3, "depth": 2, "title": "Capture the XCM to Replay", "anchor": "capture-the-xcm-to-replay", "start_char": 2310, "end_char": 2886, "estimated_token_count": 151, "token_estimator": "heuristic-v1", "text": "## Capture the XCM to Replay\n\nTo replay a specific XCM, identify:\n\n- The source and destination chains involved.\n- The block number or height where the XCM was sent.\n- Optionally, the call payload (if you plan to simulate it manually via development commands).\n\nYou can use [Polkadot.js Apps](/tutorials/polkadot-sdk/testing/fork-live-chains/#use-polkadotjs-apps){target=\\_blank}, [papi console](https://dev.papi.how/){target=\\_blank}, or indexers such as [Subscan](https://polkadot.subscan.io/xcm_dashboard){target=\\_blank} to locate and inspect the original XCM execution."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 4, "depth": 2, "title": "Fork the Relevant Chains", "anchor": "fork-the-relevant-chains", "start_char": 2886, "end_char": 3074, "estimated_token_count": 48, "token_estimator": "heuristic-v1", "text": "## Fork the Relevant Chains\n\nUse Chopsticks to [fork the required chains](/tutorials/polkadot-sdk/testing/fork-live-chains/#xcm-testing){target=\\_blank} at the appropriate block heights."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 5, "depth": 3, "title": "Set the Block Numbers", "anchor": "set-the-block-numbers", "start_char": 3074, "end_char": 3359, "estimated_token_count": 61, "token_estimator": "heuristic-v1", "text": "### Set the Block Numbers\n\nCreate/edit a `.env` file with the block heights for each chain. These should be just before the XCM is sent to allow a full replay:\n\n```text title=\".env\"\nPOLKADOT_BLOCK_NUMBER=26481107\nPOLKADOT_ASSET_HUB_BLOCK_NUMBER=9079591\nACALA_BLOCK_NUMBER=8826385\n```"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 6, "depth": 3, "title": "Enable Logging and Wasm Override", "anchor": "enable-logging-and-wasm-override", "start_char": 3359, "end_char": 7220, "estimated_token_count": 1021, "token_estimator": "heuristic-v1", "text": "### Enable Logging and Wasm Override\n\nFull execution logs only work if the runtime was compiled with logging enabled. Most live chains are built using the `production` profile, which disables logs. To enable logging, you'll need to override the Wasm with a locally built `release` or `debug` version. The `release` profile is faster to load in Chopsticks. \n\n1. Clone the `polkadot-fellows/runtimes` repository:\n\n    ```bash\n    git clone git@github.com:polkadot-fellows/runtimes.git\n    ```\n\n2. Build the Polkadot Asset Hub runtime:\n\n    ```bash\n    cd runtimes\n    # Build with the `debug` profile (default): \n    # cargo build -p asset-hub-polkadot-runtime\n\n    # Build with the `release` profile (faster to load in Chopsticks)\n    cargo build --release -p asset-hub-polkadot-runtime\n    ```\n\n3. Copy the compiled Wasm to your working directory:\n\n    ```bash\n    # Assuming you're still in the `runtimes` directory\n    mkdir -p ../wasms  # or your <replay-xcm-tests>/wasms path\n\n    # Copy the compiled Wasm to your working directory:\n\n    # If built with the `debug` profile:\n    # cp target/debug/wbuild/asset-hub-polkadot-runtime/asset_hub_polkadot_runtime.wasm ../wasms\n\n    # If built with the `release` profile:\n    cp target/release/wbuild/asset-hub-polkadot-runtime/asset_hub_polkadot_runtime.compact.compressed.wasm ../wasms\n    ```\n\n4. Download and modify a config file:\n\n    ```bash\n    # Still in the `runtimes` directory\n    cd .. # Return to your replay-xcm-tests root\n    mkdir -p configs\n    wget https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot-asset-hub.yml -O configs/polkadot-asset-hub-override.yaml\n    ```\n\n5. Edit `configs/polkadot-asset-hub-override.yaml` to include:\n\n    {% raw %}\n    ```yaml title=\"configs/polkadot-asset-hub-override.yaml\"\n    ...\n    runtime-log-level: 5\n    # wasm-override: wasms/asset_hub_polkadot_runtime.wasm                     # Uncomment if using the `debug` build\n    wasm-override: wasms/asset_hub_polkadot_runtime.compact.compressed.wasm    # Use this if you built with `release`\n    ...\n    ```\n    {% endraw %}\n\n6. Start the forked chains using your custom config:\n\n    ```bash\n    npx @acala-network/chopsticks xcm \\\n    -r polkadot \\\n    -p configs/polkadot-asset-hub-override.yaml \\\n    -p acala\n    ```\n\n    This command starts the relay chain and parachains locally, with full runtime execution logs enabled. Once the chains are running, you should see output indicating that the following RPC endpoints are available:\n\n    - Polkadot Asset Hub RPC on `http://localhost:8000`\n    - Acala RPC on `http://localhost:8001`\n    - Polkadot RPC on `http://localhost:8002`\n\n    You'll also see runtime logs such as:\n\n    <div class=\"termynal\" data-termynal>\n      <span data-ty=\"input\">npx @acala-network/chopsticks xcm \\ -r polkadot \\ -p configs/polkadot-asset-hub-override.yaml \\ -p acala</span>\n      <span data-ty>[09:29:14.988] INFO: Polkadot Asset Hub RPC listening on http://[::]:8000 and ws://[::]:8000</span>\n      <span data-ty>[09:29:14.988] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/acala.yml</span>\n      <span data-ty>[09:29:15.984] INFO: Acala RPC listening on http://[::]:8001 and ws://[::]:8001</span>\n      <span data-ty>[09:29:15.990] INFO (xcm): Connected parachains [1000,2000]</span>\n      <span data-ty>[09:29:15.990] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml</span>\n      <span data-ty>[09:29:16.927] INFO: Polkadot RPC listening on http://[::]:8002 and ws://[::]:8002</span>\n      <span data-ty>[09:29:16.984] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Polkadot Asset Hub'</span>\n      <span data-ty>[09:29:17.028] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Acala'</span>\n    </div>"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 7, "depth": 2, "title": "Identify and Extract the XCM", "anchor": "identify-and-extract-the-xcm", "start_char": 7220, "end_char": 8843, "estimated_token_count": 333, "token_estimator": "heuristic-v1", "text": "## Identify and Extract the XCM\n\nTo replay an XCM, you'll first need to identify the exact extrinsic that triggered it. In this example, we'll use block 9079592 on the Polkadot Asset Hub.\n\n1. Find and open the block on Subscan to inspect its extrinsics and events. In this case, the block is [9079592](https://assethub-polkadot.subscan.io/block/9079592){target=\\_blank}.\n\n2. Copy the black hash. Look for the block hash at the top of the page. For block 9079592, the hash is:\n\n    ```bash title=\"Block Hash\"\n    0xeb5a5737d47367dc1c02b978232283cdb096eb7e51d2eb22366a106a011347f6\n    ```\n\n3. Explore and view the block in [Polkadot.Js Apps](https://polkadot.js.org/apps){target=\\_blank} using this direct link: [Block Hash Explorer](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fpolkadot-asset-hub-rpc.polkadot.io#/explorer/query/0xeb5a5737d47367dc1c02b978232283cdb096eb7e51d2eb22366a106a011347f6){target=\\_blank}.\n\n4. Locate and decode the XCM extrinsic. Once you've found the extrinsic (e.g., 9079592-2), extract and decode its call data. For example, the call data is:\n   \n    ```bash title=\"Call Data\"\n    0xad028400fc39fcf04a8071b7409823b7c82427ce67910c6ed80aa0e5093aff234624c820016a30461702adc48213e5c9ee4d15c5a481c578cb5cbc935f0bd11fe8aee489082a745ffbbe94282f91b67daa6cb44920d77c30849c1d25f5f6c3e59015a3e383440055040000011f0803010100411f0300010100fc39fcf04a8071b7409823b7c82427ce67910c6ed80aa0e5093aff234624c8200304000002043205011f0092e81d790000000000\n    ```\n\n5. From the decoded view, copy the **hex-encoded call** (e.g. `0x1f08...0000`). You'll pass this into `api.txFromCallData(...)` to replay the XCM locally."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 8, "depth": 2, "title": "Replay the XCM", "anchor": "replay-the-xcm", "start_char": 8843, "end_char": 9097, "estimated_token_count": 50, "token_estimator": "heuristic-v1", "text": "## Replay the XCM\n\nOnce your project is set up, you're ready to replay the XCM locally.\n\nThis is useful for:\n\n- Diagnosing execution failures or weight limits.\n- Inspecting all emitted events.\n- Verifying behaviour before submitting a real transaction."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 9, "depth": 3, "title": "Add the Asset Hub Descriptor", "anchor": "add-the-asset-hub-descriptor", "start_char": 9097, "end_char": 9530, "estimated_token_count": 105, "token_estimator": "heuristic-v1", "text": "### Add the Asset Hub Descriptor\n\nThis will let you use type-safe APIs with PAPI:\n\n```bash\nnpx papi add assetHub -w ws://localhost:8000\n```\n\nThe script assumes the Polkadot Asset Hub is served on `ws://localhost:8000`. If you're using a different port or config, update the WebSocket endpoint in the script or descriptor. You can confirm the port by checking your terminal logs or by seeing [Launch Chopsticks](#launch-chopsticks)."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 10, "depth": 3, "title": "Create a Replay Script", "anchor": "create-a-replay-script", "start_char": 9530, "end_char": 12408, "estimated_token_count": 667, "token_estimator": "heuristic-v1", "text": "### Create a Replay Script\n\nCreate a file named `replay-xcm.ts` and copy the following code into it:\n\n```ts\nimport { Binary, createClient, Transaction } from 'polkadot-api';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\nimport { getPolkadotSigner } from 'polkadot-api/signer';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { assetHub } from '@polkadot-api/descriptors';\nimport { sr25519CreateDerive } from '@polkadot-labs/hdkd';\nimport {\n  DEV_PHRASE,\n  entropyToMiniSecret,\n  mnemonicToEntropy,\n} from '@polkadot-labs/hdkd-helpers';\n\nconst toHuman = (_key: any, value: any) => {\n  if (typeof value === 'bigint') {\n    return Number(value);\n  }\n\n  if (value && typeof value === 'object' && typeof value.asHex === 'function') {\n    return value.asHex();\n  }\n\n  return value;\n};\n\nfunction getSigner() {\n  const entropy = mnemonicToEntropy(DEV_PHRASE);\n  const miniSecret = entropyToMiniSecret(entropy);\n  const derive = sr25519CreateDerive(miniSecret);\n  const alice = derive('//Alice');\n\n  return getPolkadotSigner(alice.publicKey, 'Sr25519', alice.sign);\n}\n\nasync function main() {\n  const provider = withPolkadotSdkCompat(getWsProvider('ws://localhost:8000'));\n  const client = createClient(provider);\n  const api = client.getTypedApi(assetHub);\n  const aliceSigner = getSigner();\n\n  const callData = Binary.fromHex(\n    '0x1f0803010100411f0300010100fc39fcf04a8071b7409823b7c82427ce67910c6ed80aa0e5093aff234624c8200304000002043205011f0092e81d790000000000',\n  );\n  const tx: Transaction<any, string, string, any> =\n    await api.txFromCallData(callData);\n  console.log('👀 Executing XCM:', JSON.stringify(tx.decodedCall, toHuman, 2));\n\n  await new Promise<void>((resolve) => {\n    const subscription = tx.signSubmitAndWatch(aliceSigner).subscribe((ev) => {\n      if (\n        ev.type === 'finalized' ||\n        (ev.type === 'txBestBlocksState' && ev.found)\n      ) {\n        console.log(\n          `📦 Included in block #${ev.block.number}: ${ev.block.hash}`,\n        );\n\n        if (!ev.ok) {\n          const dispatchError = ev.dispatchError;\n          if (dispatchError.type === 'Module') {\n            const modErr: any = dispatchError.value;\n            console.error(\n              `❌ Dispatch error in module: ${modErr.type} → ${modErr.value?.type}`,\n            );\n          } else {\n            console.error(\n              '❌ Dispatch error:',\n              JSON.stringify(dispatchError, toHuman, 2),\n            );\n          }\n        }\n\n        for (const event of ev.events) {\n          console.log(\n            '📣 Event:',\n            event.type,\n            JSON.stringify(event.value, toHuman, 2),\n          );\n        }\n\n        console.log('✅ Process completed, exiting...');\n        subscription.unsubscribe();\n        resolve();\n      }\n    });\n  });\n\n  client.destroy();\n}\n\nmain().catch(console.error);\n\n```"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 11, "depth": 3, "title": "Execute the Replay Script", "anchor": "execute-the-replay-script", "start_char": 12408, "end_char": 12597, "estimated_token_count": 48, "token_estimator": "heuristic-v1", "text": "### Execute the Replay Script\n\nEnsure Chopsticks is running and serving a chain that includes `pallet-xcm`, such as a Polkadot Asset Hub fork. Then run:\n\n```bash\nnpx tsx replay-xcm.ts\n```"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 12, "depth": 3, "title": "Expected Output", "anchor": "expected-output", "start_char": 12597, "end_char": 14503, "estimated_token_count": 674, "token_estimator": "heuristic-v1", "text": "### Expected Output\n\nIf everything is working, you'll see logs like:\n\n<div class=\"termynal\" data-termynal>\n  <span data-ty=\"input\">npx tsx replay-xcm.ts</span>\n  <pre data-ty>\nexecuting xcm: {\n  \"type\": \"polkadotxcm\",\n  \"value\": {\n    \"type\": \"limited_reserve_transfer_assets\",\n    \"value\": {\n      \"dest\": { \"parents\": 0, \"interior\": { \"X1\": [{ \"Parachain\": 2006 }] } },\n      \"beneficiary\": { \"parents\": 0, \"interior\": { \"X1\": [{ \"AccountId32\": { \"network\": null, \"id\": \"0x...\" } }] } },\n      \"assets\": [{ \"id\": { \"Concrete\": { \"parents\": 0, \"interior\": \"Here\" } }, \"fun\": { \"Fungible\": 120000000000 } }],\n      \"fee_asset_item\": 0,\n      \"weight_limit\": { \"type\": \"Unlimited\" }\n    }\n  }\n}\n  </pre>\n  <span data-ty>📦 Included in block #9079592: 0x227a11c64f6051ba2e090a13abd17e5f7581640a80f6c03fc2d43fac66ab7949</span>\n  <span data-ty>📣 Event: Balances { \"type\": \"Upgraded\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: Balances { \"type\": \"Withdraw\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: Assets { \"type\": \"Transferred\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: PolkadotXcm { \"type\": \"Attempted\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: Balances { \"type\": \"Burned\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: Balances { \"type\": \"Minted\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: PolkadotXcm { \"type\": \"FeesPaid\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: XcmpQueue { \"type\": \"XcmpMessageSent\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: PolkadotXcm { \"type\": \"Sent\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: Balances { \"type\": \"Deposit\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: TransactionPayment { \"type\": \"TransactionFeePaid\", \"value\": { ... } }</span>\n  <span data-ty>📣 Event: System { \"type\": \"ExtrinsicSuccess\", \"value\": { ... } }</span>\n  <span data-ty>✅ Process completed, exiting...</span>\n</div>"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 13, "depth": 2, "title": "Dry Run the XCM", "anchor": "dry-run-the-xcm", "start_char": 14503, "end_char": 14691, "estimated_token_count": 38, "token_estimator": "heuristic-v1", "text": "## Dry Run the XCM\n\nTo simulate the XCM without actually sending it, you can use the `dry_run_call` method. This lets you check whether the XCM would succeed without modifying any state."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 14, "depth": 3, "title": "Create a Dry Run Script", "anchor": "create-a-dry-run-script", "start_char": 14691, "end_char": 16373, "estimated_token_count": 366, "token_estimator": "heuristic-v1", "text": "### Create a Dry Run Script\n\nAssuming you've the `tx` transaction from the previous step, you can create a new script, `dry-run-call.ts`, then paste in the following code:\n\n```ts\nimport { Binary, createClient, Enum } from 'polkadot-api';\nimport { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\nimport { getWsProvider } from 'polkadot-api/ws-provider/web';\nimport { assetHub } from '@polkadot-api/descriptors';\nimport { sr25519CreateDerive } from '@polkadot-labs/hdkd';\nimport {\n  DEV_PHRASE,\n  entropyToMiniSecret,\n  mnemonicToEntropy,\n  ss58Address,\n} from '@polkadot-labs/hdkd-helpers';\n\nconst XCM_VERSION = 5;\n\nasync function main() {\n  const provider = withPolkadotSdkCompat(getWsProvider('ws://localhost:8000'));\n  const client = createClient(provider);\n  const api = client.getTypedApi(assetHub);\n\n  const entropy = mnemonicToEntropy(DEV_PHRASE);\n  const miniSecret = entropyToMiniSecret(entropy);\n  const derive = sr25519CreateDerive(miniSecret);\n  const alice = derive('//Alice');\n  const aliceAddress = ss58Address(alice.publicKey);\n\n  const callData = Binary.fromHex(\n    '0x1f0803010100411f0300010100fc39fcf04a8071b7409823b7c82427ce67910c6ed80aa0e5093aff234624c8200304000002043205011f0092e81d790000000000',\n  );\n  const tx: any = await api.txFromCallData(callData);\n  const origin = Enum('system', Enum('Signed', aliceAddress));\n  const dryRunResult: any = await api.apis.DryRunApi.dry_run_call(\n    origin,\n    tx.decodedCall,\n    XCM_VERSION,\n  );\n  console.dir(dryRunResult.value, { depth: null });\n\n  client.destroy();\n}\n\nmain().catch(console.error);\n\n```\n\nEnsure your local Chopsticks fork is running and the ports match those used in the script."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 15, "depth": 3, "title": "Execute the Dry Run Script", "anchor": "execute-the-dry-run-script", "start_char": 16373, "end_char": 17946, "estimated_token_count": 496, "token_estimator": "heuristic-v1", "text": "### Execute the Dry Run Script\n\n```bash\nnpx tsx dry-run-call.ts\n```\n\nIf successful, the dry run confirms that the XCM would execute correctly:\n\n<div class=\"termynal\" data-termynal>\n  <span data-ty=\"input\">npx tsx dry-run-call.ts</span>\n  <pre data-ty>\nexecution_result: {\n  \"success\": true,\n  \"value\": {\n    \"post_info\": { \"actual_weight\": 123456, \"pays_fee\": \"Yes\" },\n    \"result\": \"Ok\"\n  }\n}\nemitted_events: [ { \"section\": \"Balances\", \"method\": \"Transfer\", \"data\": { \"from\": \"0x...\", \"to\": \"0x...\", \"amount\": 1000000000 } } ]\nlocal_xcm: { \"type\": \"SomeType\", \"value\": { ... } }\nforwarded_xcms: []\n  </pre>\n  <span data-ty>✅ Dry run succeeded</span>\n  <span data-ty>✅ Process completed, exiting...</span>\n</div>\n\nIf it fails, you'll receive detailed error information:\n\n<div class=\"termynal\" data-termynal>\n  <span data-ty=\"input\">npx tsx dry-run-call.ts</span>\n  <pre data-ty>\nexecution_result: {\n  \"success\": false,\n  \"value\": {\n    \"post_info\": { \"actual_weight\": 123456, \"pays_fee\": \"Yes\" },\n    \"error\": {\n      \"type\": \"Module\",\n      \"value\": {\n        \"type\": \"PolkadotXcm\",\n        \"value\": { \"type\": \"LocalExecutionIncomplete\", \"value\": null }\n      }\n    }\n  }\n}\n  </pre>\n  <span data-ty>❌ Dry run failed: LocalExecutionIncomplete</span>\n  <span data-ty>✅ Process completed, exiting...</span>\n</div>\n\nFor more information, see:\n\n- [Dry Run Call](/develop/interoperability/xcm-runtime-apis/#dry-run-call){target=\\_blank} to simulate a full extrinsic\n- [Dry Run XCM](/develop/interoperability/xcm-runtime-apis/#dry-run-xcm){target=\\_blank} to simulate a raw XCM"}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 16, "depth": 2, "title": "Review and Debug", "anchor": "review-and-debug", "start_char": 17946, "end_char": 18291, "estimated_token_count": 60, "token_estimator": "heuristic-v1", "text": "## Review and Debug\n\nReplaying XCMs with full logging provides fine-grained control and visibility into cross-chain message behaviour. Chopsticks makes this possible in a safe, local environment – empowering developers to:\n\n- Debug complex message flows.\n- Identify root causes of XCM failures.\n- Improve observability for future integrations."}
{"page_id": "tutorials-interoperability-replay-and-dry-run-xcms", "page_title": "Replay and Dry Run XCMs", "index": 17, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 18291, "end_char": 18992, "estimated_token_count": 183, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge external\">External</span> __Chopsticks Repository__\n\n    ---\n\n    View the official Chopsticks GitHub repository.\n\n    [:octicons-arrow-right-24: Get Started](https://github.com/AcalaNetwork/chopsticks/)\n\n-   <span class=\"badge guide\">Guide</span> __Polkadot XCM Docs__\n\n    ---\n\n    Learn how to use XCM effectively.\n\n    [:octicons-arrow-right-24: Get Started](/develop/interoperability/intro-to-xcm/)\n\n-   <span class=\"badge tutorial\">Tutorial</span> __XCM Runtime APIs__\n\n    ---\n\n    Learn how to use XCM Runtime APIs.\n\n    [:octicons-arrow-right-24: Get Started](/develop/interoperability/xcm-runtime-apis/)\n\n</div>"}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 44, "end_char": 1023, "estimated_token_count": 166, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nFor establishing communication channels between parachains on the Polkadot network using the Horizontal Relay-routed Message Passing (HRMP) protocol, the following steps are required:\n\n1. **Channel request**: The parachain that wants to open an HRMP channel must make a request to the parachain it wishes to have an open channel with.\n2. **Channel acceptance**: The other parachain must then accept this request to complete the channel establishment.\n\nThis process results in a unidirectional HRMP channel, where messages can flow in only one direction between the two parachains.\n\nAn additional HRMP channel must be established in the opposite direction to enable bidirectional communication. This requires repeating the request and acceptance process but with the parachains reversing their roles.\n\nOnce both unidirectional channels are established, the parachains can send messages back and forth freely through the bidirectional HRMP communication channel."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1023, "end_char": 1267, "estimated_token_count": 40, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore proceeding, ensure you meet the following requirements:\n\n- Blockchain network with a relay chain and at least two connected parachains.\n- Wallet with sufficient funds to execute transactions on the participant chains."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 2, "depth": 2, "title": "Procedure to Initiate an HRMP Channel", "anchor": "procedure-to-initiate-an-hrmp-channel", "start_char": 1267, "end_char": 1444, "estimated_token_count": 32, "token_estimator": "heuristic-v1", "text": "## Procedure to Initiate an HRMP Channel\n\nThis example will demonstrate how to open a channel between parachain 2500 and parachain 2600, using Rococo Local as the relay chain."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 3, "depth": 3, "title": "Fund Sender Sovereign Account", "anchor": "fund-sender-sovereign-account", "start_char": 1444, "end_char": 3063, "estimated_token_count": 358, "token_estimator": "heuristic-v1", "text": "### Fund Sender Sovereign Account\n\n\nThe [sovereign account](https://github.com/polkadot-fellows/xcm-format/blob/10726875bd3016c5e528c85ed6e82415e4b847d7/README.md?plain=1#L50){target=_blank} for parachain 2500 on the relay chain must be funded so it can take care of any XCM transact fees.\n\nUse [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank} UI to connect to the relay chain and transfer funds from your account to the parachain 2500 sovereign account.\n![](/images/tutorials/interoperability/xcm-channels/hrmp-channels-2.webp)\n\n??? note \"Calculating Parachain Sovereign Account\"\n    To generate the sovereign account address for a parachain, you'll need to follow these steps:\n\n    1. Determine if the parachain is an \"up/down\" chain (parent or child) or a \"sibling\" chain:\n\n        - Up/down chains use the prefix `0x70617261` (which decodes to `b\"para\"`).\n        - Sibling chains use the prefix `0x7369626c` (which decodes to `b\"sibl\"`).\n\n    2. Calculate the u32 scale encoded value of the parachain ID:\n\n        - Parachain 2500 would be encoded as `c4090000`.\n\n    3. Combine the prefix and parachain ID encoding to form the full sovereign account address:\n\n        The sovereign account of parachain 2500 in relay chain will be `0x70617261c4090000000000000000000000000000000000000000000000000000`\n        and the SS58 format of this address is `5Ec4AhPSY2GEE4VoHUVheqv5wwq2C1HMKa7c9fVJ1WKivX1Y`.\n    \n    To perform this conversion, you can also use the **\"Para ID\" to Address** section in [Substrate Utilities](https://www.shawntabrizi.com/substrate-js-utilities/){target=_blank}."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 4, "depth": 3, "title": "Create Channel Opening Extrinsic", "anchor": "create-channel-opening-extrinsic", "start_char": 3063, "end_char": 4022, "estimated_token_count": 239, "token_estimator": "heuristic-v1", "text": "### Create Channel Opening Extrinsic\n\n1. In Polkadot.js Apps, connect to the relay chain, navigate to the **Developer** dropdown and select the **Extrinsics** option.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-1.webp)\n\n2. Construct an `hrmpInitOpenChannel` extrinsic call:\n\n    1. Select the **`hrmp`** pallet.\n    2. Choose the **`hrmpInitOpenChannel`** extrinsic.\n    3. Fill in the parameters:\n        - **`recipient`**: Parachain ID of the target chain (in this case, 2600).\n        - **`proposedMaxCapacity`**: Max number of messages that can be pending in the channel at once.\n        - **`proposedMaxMessageSize`**: Max message size that could be put into the channel.\n    4. Copy the encoded call data.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-2.webp)\n\n    The encoded call data for opening a channel with parachain 2600 is `0x3c00280a00000800000000001000`."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 5, "depth": 3, "title": "Craft and Submit the XCM Message from the Sender", "anchor": "craft-and-submit-the-xcm-message-from-the-sender", "start_char": 4022, "end_char": 7453, "estimated_token_count": 737, "token_estimator": "heuristic-v1", "text": "### Craft and Submit the XCM Message from the Sender\n\nTo initiate the HRMP channel opening process, you need to create an XCM message that includes the encoded `hrmpInitOpenChannel` call data from the previous step. This message will be sent from your parachain to the relay chain.\n\nThis example uses the `sudo` pallet to dispatch the extrinsic. Verify the XCM configuration of the parachain you're working with and ensure you're using an origin with the necessary privileges to execute the `polkadotXcm.send` extrinsic.\n\nThe XCM message should contain the following instructions:\n\n- **`WithdrawAsset`**: Withdraws assets from the origin's ownership and places them in the Holding Register.\n- **`BuyExecution`**: Pays for the execution of the current message using the assets in the Holding Register.\n- **`Transact`**: Execute the encoded transaction call.\n- **`RefundSurplus`**: Increases the Refunded Weight Register to the value of the Surplus Weight Register, attempting to reclaim any excess fees paid via BuyExecution.\n- **`DepositAsset`**: Subtracts assets from the Holding Register and deposits equivalent on-chain assets under the specified beneficiary's ownership.\n\n!!!note \n    For more detailed information about XCM's functionality, complexities, and instruction set, refer to the [xcm-format](https://github.com/polkadot-fellows/xcm-format){target=_blank} documentation.\n\nIn essence, this process withdraws funds from the parachain's sovereign account to the XCVM Holding Register, then uses these funds to purchase execution time for the XCM `Transact` instruction, executes `Transact`, refunds any unused execution time and deposits any remaining funds into a specified account.\n\nTo send the XCM message to the relay chain, connect to parachain 2500 in Polkadot.js Apps. Fill in the required parameters as shown in the image below, ensuring that you:\n\n1. Replace the **`call`** field with your encoded `hrmpInitOpenChannel` call data from the previous step.\n2. Use the correct beneficiary information.\n3. Click the **Submit Transaction** button to dispatch the XCM message to the relay chain.\n\n![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-3.webp)\n\n!!! note\n    The exact process and parameters for submitting this XCM message may vary depending on your specific parachain and relay chain configurations. Always refer to the most current documentation for your particular network setup.\n\nAfter submitting the XCM message to initiate the HRMP channel opening, you should verify that the request was successful. Follow these steps to check the status of your channel request:\n\n1. Using Polkadot.js Apps, connect to the relay chain and navigate to the **Developer** dropdown, then select the **Chain state** option.\n\n    ![](/images/tutorials/interoperability/xcm-channels/hrmp-channels-1.webp)\n\n2. Query the HRMP open channel requests:\n\n    1. Select **`hrmp`**.\n    2. Choose the **`hrmpOpenChannelRequests`** call.\n    3. Click the **+** button to execute the query.\n    4. Check the status of all pending channel requests.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-4.webp)\n\nIf your channel request was successful, you should see an entry for your parachain ID in the list of open channel requests. This confirms that your request has been properly registered on the relay chain and is awaiting acceptance by the target parachain."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 6, "depth": 2, "title": "Procedure to Accept an HRMP Channel", "anchor": "procedure-to-accept-an-hrmp-channel", "start_char": 7453, "end_char": 7637, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Procedure to Accept an HRMP Channel\n\nFor the channel to be fully established, the target parachain must accept the channel request by submitting an XCM message to the relay chain."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 7, "depth": 3, "title": "Fund Receiver Sovereign Account", "anchor": "fund-receiver-sovereign-account", "start_char": 7637, "end_char": 7983, "estimated_token_count": 68, "token_estimator": "heuristic-v1", "text": "### Fund Receiver Sovereign Account\n\nBefore proceeding, ensure that the sovereign account of parachain 2600 on the relay chain is funded. This account will be responsible for covering any XCM transact fees.\nTo fund the account, follow the same process described in the previous section, [Fund Sovereign Account](#fund-sender-sovereign-account)."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 8, "depth": 3, "title": "Create Channel Accepting Extrinsic", "anchor": "create-channel-accepting-extrinsic", "start_char": 7983, "end_char": 8749, "estimated_token_count": 197, "token_estimator": "heuristic-v1", "text": "### Create Channel Accepting Extrinsic\n\n1. In Polkadot.js Apps, connect to the relay chain, navigate to the **Developer** dropdown and select the **Extrinsics** option.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-1.webp)\n\n2. Construct an `hrmpAcceptOpenChannel` extrinsic call:\n\n    1. Select the **`hrmp`** pallet.\n    2. Choose the **`hrmpAcceptOpenChannel`** extrinsic.\n    3. Fill in the parameters:\n        - **`sender`**: Parachain ID of the requesting chain (in this case, 2500).\n    4. Copy the encoded call data.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-5.webp)\n    \n    The encoded call data for accepting a channel with parachain 2500 should be `0x3c01c4090000`."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-para", "page_title": "Opening HRMP Channels Between Parachains", "index": 9, "depth": 3, "title": "Craft and Submit the XCM Message from the Receiver", "anchor": "craft-and-submit-the-xcm-message-from-the-receiver", "start_char": 8749, "end_char": 10985, "estimated_token_count": 504, "token_estimator": "heuristic-v1", "text": "### Craft and Submit the XCM Message from the Receiver\n\nTo accept the HRMP channel opening, you need to create and submit an XCM message that includes the encoded `hrmpAcceptOpenChannel` call data from the previous step. This process is similar to the one described in the previous section, [Craft and Submit the XCM Message](#craft-and-submit-the-xcm-message-from-the-sender), with a few key differences:\n\n- Use the encoded call data for `hrmpAcceptOpenChannel` obtained in step 2 of this section.\n- In the last XCM instruction (DepositAsset), set the beneficiary to parachain 2600's sovereign account to receive any surplus funds.\n\nTo send the XCM message to the relay chain, connect to parachain 2600 in Polkadot.js Apps. Fill in the required parameters as shown in the image below, ensuring that you:\n\n1. Replace the **`call`** field with your encoded `hrmpAcceptOpenChannel` call data from the previous step.\n2. Use the correct beneficiary information.\n3. Click the **Submit Transaction** button to dispatch the XCM message to the relay chain.\n\n![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-6.webp)\n\nAfter submitting the XCM message to accept the HRMP channel opening, verify that the channel has been set up correctly.\n\n1. Using Polkadot.js Apps, connect to the relay chain and navigate to the **Developer** dropdown, then select the **Chain state** option.\n\n    ![](/images/tutorials/interoperability/xcm-channels/hrmp-channels-1.webp)\n\n2. Query the HRMP channels:\n\n    1. Select **`hrmp`**.\n    2. Choose the **`hrmpChannels`** call.\n    3. Click the **+** button to execute the query.\n    4. Check the status of the opened channel.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-7.webp)\n\nIf the channel has been successfully established, you should see the channel details in the query results.\n\nBy following these steps, you will have successfully accepted the HRMP channel request and established a unidirectional channel between the two parachains. \n\n!!! note\n    Remember that for full bidirectional communication, you'll need to repeat this process in the opposite direction, with parachain 2600 initiating a channel request to parachain 2500."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-system", "page_title": "Opening HRMP Channels with System Parachains", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 48, "end_char": 827, "estimated_token_count": 123, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nWhile establishing Horizontal Relay-routed Message Passing (HRMP) channels between regular parachains involves a two-step request and acceptance procedure, opening channels with system parachains follows a more straightforward approach.\n\nSystem parachains are specialized chains that provide core functionality to the Polkadot network. Examples include Asset Hub for cross-chain asset transfers and Bridge Hub for connecting to external networks. Given their critical role, establishing communication channels with these system parachains has been optimized for efficiency and ease of use.\n\nAny parachain can establish a bidirectional channel with a system chain through a single operation, requiring just one XCM message from the parachain to the relay chain."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-system", "page_title": "Opening HRMP Channels with System Parachains", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 827, "end_char": 1146, "estimated_token_count": 59, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nTo successfully complete this process, you'll need to have the following in place:\n\n- Access to a blockchain network consisting of:\n    - A relay chain\n    - A parachain\n    - An Asset Hub system chain\n- A wallet containing enough funds to cover transaction fees on each of the participating chains."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-system", "page_title": "Opening HRMP Channels with System Parachains", "index": 2, "depth": 2, "title": "Procedure to Establish an HRMP Channel", "anchor": "procedure-to-establish-an-hrmp-channel", "start_char": 1146, "end_char": 1338, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Procedure to Establish an HRMP Channel\n\nThis guide demonstrates opening an HRMP channel between parachain 2500 and system chain Asset Hub (parachain 1000) on the Rococo Local relay chain."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-system", "page_title": "Opening HRMP Channels with System Parachains", "index": 3, "depth": 3, "title": "Fund Parachain Sovereign Account", "anchor": "fund-parachain-sovereign-account", "start_char": 1338, "end_char": 2961, "estimated_token_count": 359, "token_estimator": "heuristic-v1", "text": "### Fund Parachain Sovereign Account\n\nThe [sovereign account](https://github.com/polkadot-fellows/xcm-format/blob/10726875bd3016c5e528c85ed6e82415e4b847d7/README.md?plain=1#L50){target=_blank} for parachain 2500 on the relay chain must be funded so it can take care of any XCM transact fees.\n\nUse [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank} UI to connect to the relay chain and transfer funds from your account to the parachain 2500 sovereign account.\n\n![](/images/tutorials/interoperability/xcm-channels/hrmp-channels-2.webp)\n\n??? note \"Calculating Parachain Sovereign Account\"\n    To generate the sovereign account address for a parachain, you'll need to follow these steps:\n\n    1. Determine if the parachain is an \"up/down\" chain (parent or child) or a \"sibling\" chain:\n\n        - Up/down chains use the prefix `0x70617261` (which decodes to `b\"para\"`).\n        - Sibling chains use the prefix `0x7369626c` (which decodes to `b\"sibl\"`).\n\n    2. Calculate the u32 scale encoded value of the parachain ID:\n\n        - Parachain 2500 would be encoded as `c4090000`.\n\n    3. Combine the prefix and parachain ID encoding to form the full sovereign account address:\n\n        The sovereign account of parachain 2500 in relay chain will be `0x70617261c4090000000000000000000000000000000000000000000000000000`\n        and the SS58 format of this address is `5Ec4AhPSY2GEE4VoHUVheqv5wwq2C1HMKa7c9fVJ1WKivX1Y`.\n    \n    To perform this conversion, you can also use the **\"Para ID\" to Address** section in [Substrate Utilities](https://www.shawntabrizi.com/substrate-js-utilities/){target=\\_blank}."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-system", "page_title": "Opening HRMP Channels with System Parachains", "index": 4, "depth": 3, "title": "Create Establish Channel with System Extrinsic", "anchor": "create-establish-channel-with-system-extrinsic", "start_char": 2961, "end_char": 3780, "estimated_token_count": 201, "token_estimator": "heuristic-v1", "text": "### Create Establish Channel with System Extrinsic\n\n1. In Polkadot.js Apps, connect to the relay chain, navigate to the **Developer** dropdown and select the **Extrinsics** option.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-para/hrmp-para-to-para-1.webp)\n\n2. Construct an `establish_channel_with_system` extrinsic call:\n\n    1. Select the **`hrmp`** pallet.\n    2. Choose the **`establish_channel_with_system`** extrinsic.\n    3. Fill in the parameters:\n        - **`target_system_chain`**: Parachain ID of the target system chain (in this case, 1000).\n    4. Copy the encoded call data.\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-system/hrmp-para-to-system-1.webp)\n\n    The encoded call data for establishing a channel with system parachain 1000 should be `0x3c0ae8030000`."}
{"page_id": "tutorials-interoperability-xcm-channels-para-to-system", "page_title": "Opening HRMP Channels with System Parachains", "index": 5, "depth": 3, "title": "Craft and Submit the XCM Message", "anchor": "craft-and-submit-the-xcm-message", "start_char": 3780, "end_char": 7208, "estimated_token_count": 685, "token_estimator": "heuristic-v1", "text": "### Craft and Submit the XCM Message\n\nConnect to parachain 2500 using Polkadot.js Apps to send the XCM message to the relay chain. Input the necessary parameters as illustrated in the image below. Make sure to:\n\n1. Insert your previously encoded `establish_channel_with_system` call data into the **`call`** field.\n2. Provide beneficiary details.\n3. Dispatch the XCM message to the relay chain by clicking the **Submit Transaction** button.\n\n![](/images/tutorials/interoperability/xcm-channels/para-to-system/hrmp-para-to-system-2.webp)\n\n!!! note\n    The exact process and parameters for submitting this XCM message may vary depending on your specific parachain and relay chain configurations. Always refer to the most current documentation for your particular network setup.\n\nAfter successfully submitting the XCM message to the relay chain, two [`HrmpSystemChannelOpened`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/hrmp/pallet/enum.Event.html#variant.HrmpSystemChannelOpened){target=\\_blank} events are emitted, indicating that the channels are now present in storage under [`HrmpOpenChannelRequests`](https://paritytech.github.io/polkadot-sdk/master/polkadot_runtime_parachains/hrmp/pallet/storage_types/struct.HrmpOpenChannelRequests.html){target=\\_blank}. However, the channels are not actually set up until the start of the next session, at which point bidirectional communication between parachain 2500 and system chain 1000 is established.\n\nTo verify this, wait for the next session and then follow these steps:\n\n1. Using Polkadot.js Apps, connect to the relay chain and navigate to the **Developer** dropdown, then select **Chain state**.\n\n    ![](/images/tutorials/interoperability/xcm-channels/hrmp-channels-1.webp)\n\n2. Query the HRMP channels:\n\n    1. Select **`hrmp`** from the options.\n    2. Choose the **`hrmpChannels`** call.\n    3. Click the **+** button to execute the query.\n\n    ![](/images/tutorials/interoperability/xcm-channels/para-to-system/hrmp-para-to-system-3.webp)\n    \n3. Examine the query results. You should see output similar to the following:\n\n    ```json\n    [\n        [\n            [\n                {\n                    \"sender\": 1000,\n                    \"recipient\": 2500\n                }\n            ],\n            {\n                \"maxCapacity\": 8,\n                \"maxTotalSize\": 8192,\n                \"maxMessageSize\": 1048576,\n                \"msgCount\": 0,\n                \"totalSize\": 0,\n                \"mqcHead\": null,\n                \"senderDeposit\": 0,\n                \"recipientDeposit\": 0\n            }\n        ],\n        [\n            [\n                {\n                    \"sender\": 2500,\n                    \"recipient\": 1000\n                }\n            ],\n            {\n                \"maxCapacity\": 8,\n                \"maxTotalSize\": 8192,\n                \"maxMessageSize\": 1048576,\n                \"msgCount\": 0,\n                \"totalSize\": 0,\n                \"mqcHead\": null,\n                \"senderDeposit\": 0,\n                \"recipientDeposit\": 0\n            }\n        ]\n    ]\n\n    ```\n\nThe output confirms the successful establishment of two HRMP channels:\n\n- From chain 1000 (system chain) to chain 2500 (parachain).\n- From chain 2500 (parachain) to chain 1000 (system chain).\n\nThis bidirectional channel enables direct communication between the system chain and the parachain, allowing for cross-chain message passing."}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 22, "end_char": 450, "estimated_token_count": 76, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nWhen sending cross-chain messages, ensure that the transaction will be successful not only in the local chain but also in the destination chain and any intermediate chains.\n\nSending cross-chain messages requires estimating the fees for the operation. \n\nThis tutorial will demonstrate how to dry-run and estimate the fees for teleporting assets from the Paseo Asset Hub parachain to the Paseo Bridge Hub chain."}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 1, "depth": 2, "title": "Fee Mechanism", "anchor": "fee-mechanism", "start_char": 450, "end_char": 1437, "estimated_token_count": 222, "token_estimator": "heuristic-v1", "text": "## Fee Mechanism\n\nThere are three types of fees that can be charged when sending a cross-chain message:\n\n- **Local execution fees**: Fees charged in the local chain for executing the message.\n- **Delivery fees**: Fees charged for delivering the message to the destination chain.\n- **Remote execution fees**: Fees charged in the destination chain for executing the message.\n\nIf there are multiple intermediate chains, delivery fees and remote execution fees will be charged for each one.\n\nIn this example, you will estimate the fees for teleporting assets from the Paseo Asset Hub parachain to the Paseo Bridge Hub chain. The fee structure will be as follows:\n\n```mermaid\nflowchart LR\n    AssetHub[Paseo Asset Hub] -->|Delivery Fees| BridgeHub[Paseo Bridge Hub]\n    AssetHub -->|<br />Local<br />Execution<br />Fees| AssetHub\n    BridgeHub -->|<br />Remote<br />Execution<br />Fees| BridgeHub\n```\n\nThe overall fees are `local_execution_fees` + `delivery_fees` + `remote_execution_fees`."}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 2, "depth": 2, "title": "Environment Setup", "anchor": "environment-setup", "start_char": 1437, "end_char": 14563, "estimated_token_count": 2582, "token_estimator": "heuristic-v1", "text": "## Environment Setup\n\nFirst, you need to set up your environment:\n\n1. Create a new directory and initialize the project:\n\n    ```bash\n    mkdir xcm-fee-estimation && \\\n    cd xcm-fee-estimation\n    ```\n\n2. Initialize the project:\n\n    ```bash\n    npm init -y\n    ```\n\n3. Install dev dependencies:\n\n    ```bash\n    npm install --save-dev @types/node@^22.12.0 ts-node@^10.9.2 typescript@^5.7.3\n    ```\n\n4. Install dependencies:\n\n    ```bash\n    npm install --save @polkadot-labs/hdkd@^0.0.13 @polkadot-labs/hdkd-helpers@^0.0.13 polkadot-api@1.9.5\n    ```\n\n5. Create TypeScript configuration:\n\n    ```bash\n    npx tsc --init\n    ```\n\n6. Generate the types for the Polkadot API for Paseo Bridge Hub and Paseo Asset Hub:\n\n    ```bash\n    npx papi add paseoAssetHub -n paseo_asset_hub && \\\n    npx papi add paseoBridgeHub -w wss://bridge-hub-paseo.dotters.network\n    ```\n\n7. Create a new file called `teleport-ah-to-bridge-hub.ts`:\n\n    ```bash\n    touch teleport-ah-to-bridge-hub.ts\n    ```\n\n8. Import the necessary modules. Add the following code to the `teleport-ah-to-bridge-hub.ts` file:\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n    import { paseoAssetHub, paseoBridgeHub } from '@polkadot-api/descriptors';\n    import { createClient, FixedSizeBinary, Enum } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/node';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import {\n      XcmVersionedLocation,\n      XcmVersionedAssetId,\n      XcmV3Junctions,\n      XcmV3MultiassetFungibility,\n      XcmVersionedXcm,\n      XcmV5Instruction,\n      XcmV5Junctions,\n      XcmV5Junction,\n      XcmV5AssetFilter,\n      XcmV5WildAsset,\n    } from '@polkadot-api/descriptors';\n\n    // 1 PAS = 10^10 units\n    const PAS_UNITS = 10_000_000_000n; // 1 PAS\n    const PAS_CENTS = 100_000_000n; // 0.01 PAS\n\n    // Paseo Asset Hub constants\n    const PASEO_ASSET_HUB_RPC_ENDPOINT = 'ws://localhost:8001';\n    const ASSET_HUB_ACCOUNT = '15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5'; // Alice (Paseo Asset Hub)\n\n    // Bridge Hub destination\n    const BRIDGE_HUB_RPC_ENDPOINT = 'ws://localhost:8000';\n    const BRIDGE_HUB_PARA_ID = 1002;\n    const BRIDGE_HUB_BENEFICIARY =\n      '14E5nqKAp3oAJcmzgZhUD2RcptBeUBScxKHgJKU4HPNcKVf3'; // Bob (Bridge Hub)\n\n    // Create the XCM message for teleport (Asset Hub → Bridge Hub)\n    function createTeleportXcmToBridgeHub(paraId: number) {\n      return XcmVersionedXcm.V5([\n        // Withdraw PAS from Asset Hub (PAS on parachains is parents:1, interior: Here)\n        XcmV5Instruction.WithdrawAsset([\n          {\n            id: { parents: 1, interior: XcmV5Junctions.Here() },\n            fun: XcmV3MultiassetFungibility.Fungible(1n * PAS_UNITS), // 1 PAS\n          },\n        ]),\n        // Pay local fees on Asset Hub in PAS\n        XcmV5Instruction.PayFees({\n          asset: {\n            id: { parents: 1, interior: XcmV5Junctions.Here() },\n            fun: XcmV3MultiassetFungibility.Fungible(10n * PAS_CENTS), // 0.01 PAS\n          },\n        }),\n        // Send to Bridge Hub parachain (parents:1, interior: X1(Parachain(paraId)))\n        XcmV5Instruction.InitiateTransfer({\n          destination: {\n            parents: 1,\n            interior: XcmV5Junctions.X1(XcmV5Junction.Parachain(paraId)),\n          },\n          remote_fees: Enum(\n            'Teleport',\n            XcmV5AssetFilter.Definite([\n              {\n                id: { parents: 1, interior: XcmV5Junctions.Here() },\n                fun: XcmV3MultiassetFungibility.Fungible(10n * PAS_CENTS), // 0.01 PAS\n              },\n            ]),\n          ),\n          preserve_origin: false,\n          remote_xcm: [\n            XcmV5Instruction.DepositAsset({\n              assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n              beneficiary: {\n                parents: 0,\n                interior: XcmV5Junctions.X1(\n                  XcmV5Junction.AccountId32({\n                    network: undefined,\n                    id: FixedSizeBinary.fromAccountId32(BRIDGE_HUB_BENEFICIARY),\n                  }),\n                ),\n              },\n            }),\n          ],\n          assets: [\n            Enum('Teleport', XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1))), // Send everything.\n          ],\n        }),\n      ]);\n    }\n\n    async function estimateXcmFeesFromAssetHubToBridgeHub(\n      xcm: any,\n      assetHubApi: any,\n    ) {\n      console.log('=== Fee Estimation Process (Asset Hub → Bridge Hub) ===');\n\n      // 1. LOCAL EXECUTION FEES on Asset Hub\n      console.log('1. Calculating local execution fees on Asset Hub...');\n      let localExecutionFees = 0n;\n\n      const weightResult =\n        await assetHubApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n      if (weightResult.success) {\n        console.log('✓ XCM weight (Asset Hub):', weightResult.value);\n\n        // Convert weight to PAS fees from Asset Hub's perspective (parents:1, Here)\n        const executionFeesResult =\n          await assetHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n            weightResult.value,\n            XcmVersionedAssetId.V4({\n              parents: 1,\n              interior: XcmV3Junctions.Here(),\n            }),\n          );\n\n        if (executionFeesResult.success) {\n          localExecutionFees = executionFeesResult.value;\n          console.log(\n            '✓ Local execution fees (Asset Hub):',\n            localExecutionFees.toString(),\n            'PAS units',\n          );\n        } else {\n          console.log(\n            '✗ Failed to calculate local execution fees:',\n            executionFeesResult.value,\n          );\n        }\n      } else {\n        console.log(\n          '✗ Failed to query XCM weight on Asset Hub:',\n          weightResult.value,\n        );\n      }\n\n      // 2. DELIVERY FEES + REMOTE EXECUTION FEES\n      console.log('\\n2. Calculating delivery and remote execution fees...');\n      let deliveryFees = 0n;\n      let remoteExecutionFees = 0n; // Skipped (Bridge Hub descriptor not available)\n\n      // Origin from Asset Hub perspective\n      const origin = XcmVersionedLocation.V5({\n        parents: 0,\n        interior: XcmV5Junctions.X1(\n          XcmV5Junction.AccountId32({\n            id: FixedSizeBinary.fromAccountId32(ASSET_HUB_ACCOUNT),\n            network: undefined,\n          }),\n        ),\n      });\n\n      // Dry run the XCM locally on Asset Hub\n      const dryRunResult = await assetHubApi.apis.DryRunApi.dry_run_xcm(\n        origin,\n        xcm,\n      );\n\n      if (\n        dryRunResult.success &&\n        dryRunResult.value.execution_result.type === 'Complete'\n      ) {\n        console.log('✓ Local dry run on Asset Hub successful');\n\n        const { forwarded_xcms: forwardedXcms } = dryRunResult.value;\n\n        // Find the XCM message sent to Bridge Hub (parents:1, interior: X1(Parachain(1002)))\n        const bridgeHubXcmEntry = forwardedXcms.find(\n          ([location, _]: [any, any]) =>\n            (location.type === 'V4' || location.type === 'V5') &&\n            location.value.parents === 1 &&\n            location.value.interior?.type === 'X1' &&\n            location.value.interior.value?.type === 'Parachain' &&\n            location.value.interior.value.value === BRIDGE_HUB_PARA_ID,\n        );\n\n        if (bridgeHubXcmEntry) {\n          const [destination, messages] = bridgeHubXcmEntry;\n          const remoteXcm = messages[0];\n\n          console.log('✓ Found XCM message to Bridge Hub');\n\n          // Calculate delivery fees from Asset Hub to Bridge Hub\n          const deliveryFeesResult =\n            await assetHubApi.apis.XcmPaymentApi.query_delivery_fees(\n              destination,\n              remoteXcm,\n            );\n\n          if (\n            deliveryFeesResult.success &&\n            deliveryFeesResult.value.type === 'V5' &&\n            deliveryFeesResult.value.value[0]?.fun?.type === 'Fungible'\n          ) {\n            deliveryFees = deliveryFeesResult.value.value[0].fun.value;\n            console.log('✓ Delivery fees:', deliveryFees.toString(), 'PAS units');\n          } else {\n            console.log('✗ Failed to calculate delivery fees:', deliveryFeesResult);\n          }\n\n          // 3. REMOTE EXECUTION FEES on Bridge Hub\n          console.log('\\n3. Calculating remote execution fees on Bridge Hub');\n          try {\n            const bridgeHubClient = createClient(\n              withPolkadotSdkCompat(getWsProvider(BRIDGE_HUB_RPC_ENDPOINT)),\n            );\n            const bridgeHubApi = bridgeHubClient.getTypedApi(paseoBridgeHub);\n            const remoteWeightResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_xcm_weight(remoteXcm);\n            const remoteFeesResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n                remoteWeightResult.value as {\n                  ref_time: bigint;\n                  proof_size: bigint;\n                },\n                XcmVersionedAssetId.V4({\n                  parents: 1,\n                  interior: XcmV3Junctions.Here(),\n                }),\n              );\n            bridgeHubClient.destroy();\n            remoteExecutionFees = remoteFeesResult.value as bigint;\n            console.log(\n              '✓ Remote execution fees:',\n              remoteExecutionFees.toString(),\n              'PAS units',\n            );\n          } catch (error) {\n            console.error(\n              'Error calculating remote execution fees on Bridge Hub:',\n              error,\n            );\n          }\n        } else {\n          console.log('✗ No XCM message found to Bridge Hub');\n        }\n      } else {\n        console.log('✗ Local dry run failed on Asset Hub:', dryRunResult.value);\n      }\n\n      // 4. TOTAL FEES\n      const totalFees = localExecutionFees + deliveryFees + remoteExecutionFees;\n\n      console.log('\\n=== Fee Summary (Asset Hub → Bridge Hub) ===');\n      console.log(\n        'Local execution fees:',\n        localExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('Delivery fees:', deliveryFees.toString(), 'PAS units');\n      console.log(\n        'Remote execution fees:',\n        remoteExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('TOTAL FEES:', totalFees.toString(), 'PAS units');\n      console.log(\n        'TOTAL FEES:',\n        (Number(totalFees) / Number(PAS_UNITS)).toFixed(4),\n        'PAS',\n      );\n\n      return {\n        localExecutionFees,\n        deliveryFees,\n        remoteExecutionFees,\n        totalFees,\n      };\n    }\n\n    async function main() {\n      // Connect to the Asset Hub parachain\n      const assetHubClient = createClient(\n        withPolkadotSdkCompat(getWsProvider(PASEO_ASSET_HUB_RPC_ENDPOINT)),\n      );\n\n      // Get the typed API for Asset Hub\n      const assetHubApi = assetHubClient.getTypedApi(paseoAssetHub);\n\n      try {\n        // Create the XCM message for teleport (Asset Hub → Bridge Hub)\n        const xcm = createTeleportXcmToBridgeHub(BRIDGE_HUB_PARA_ID);\n\n        console.log('=== XCM Teleport: Paseo Asset Hub → Bridge Hub ===');\n        console.log('From:', ASSET_HUB_ACCOUNT, '(Alice on Asset Hub)');\n        console.log('To:', BRIDGE_HUB_BENEFICIARY, '(Beneficiary on Bridge Hub)');\n        console.log('Amount:', '1 PAS');\n        console.log('');\n\n        // Estimate all fees\n        const fees = await estimateXcmFeesFromAssetHubToBridgeHub(xcm, assetHubApi);\n        void fees; // prevent unused var under isolatedModules\n\n        // Create the execute transaction on Asset Hub\n        const tx = assetHubApi.tx.PolkadotXcm.execute({\n          message: xcm,\n          max_weight: {\n            ref_time: 6000000000n,\n            proof_size: 65536n,\n          },\n        });\n\n        console.log('\\n=== Transaction Details ===');\n        console.log('Transaction hex:', (await tx.getEncodedData()).asHex());\n        console.log('Ready to submit!');\n      } catch (error) {\n        console.log('Error stack:', (error as Error).stack);\n        console.error('Error occurred:', (error as Error).message);\n        if ((error as Error).cause) {\n          console.dir((error as Error).cause, { depth: null });\n        }\n      } finally {\n        // Ensure client is always destroyed\n        assetHubClient.destroy();\n      }\n    }\n\n    main().catch(console.error);\n\n    ```\n\n9. Define constants and a `main` function where you will implement all the logic:\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n    // 1 PAS = 10^10 units\n    const PAS_UNITS = 10_000_000_000n; // 1 PAS\n    const PAS_CENTS = 100_000_000n; // 0.01 PAS\n\n    // Paseo Asset Hub constants\n    const PASEO_ASSET_HUB_RPC_ENDPOINT = 'ws://localhost:8001';\n    const ASSET_HUB_ACCOUNT = '15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5'; // Alice (Paseo Asset Hub)\n\n    // Bridge Hub destination\n    const BRIDGE_HUB_RPC_ENDPOINT = 'ws://localhost:8000';\n    const BRIDGE_HUB_PARA_ID = 1002;\n    const BRIDGE_HUB_BENEFICIARY =\n    async function main() {\n      // Code will go here\n    }\n    ```\n\nAll the following code explained in the subsequent sections must be added inside the `main` function."}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 3, "depth": 2, "title": "Client and API Setup", "anchor": "client-and-api-setup", "start_char": 14563, "end_char": 15440, "estimated_token_count": 172, "token_estimator": "heuristic-v1", "text": "## Client and API Setup\n\nNow you are ready to start implementing the logic for the fee estimation for the teleport you want to perform. In this step, you will create the client for the Paseo Asset Hub parachain and generate the typed API to interact with the chain. Follow the steps below:\n\nCreate the API client. You will need to create a client for the Paseo Asset Hub parachain:\n\n```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n  // Connect to the Asset Hub parachain\n  const assetHubClient = createClient(\n    withPolkadotSdkCompat(getWsProvider(PASEO_ASSET_HUB_RPC_ENDPOINT)),\n  );\n\n  // Get the typed API for Asset Hub\n  const assetHubApi = assetHubClient.getTypedApi(paseoAssetHub);\n```\n\nEnsure that you replace the endpoint URLs with the actual WebSocket endpoints. This example uses local chopsticks endpoints, but you can use public endpoints or run local nodes."}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 4, "depth": 2, "title": "Create the XCM Message", "anchor": "create-the-xcm-message", "start_char": 15440, "end_char": 17400, "estimated_token_count": 395, "token_estimator": "heuristic-v1", "text": "## Create the XCM Message\n\nNow, you can construct a proper XCM message using the new XCM V5 instructions for teleporting from Asset Hub to the Bridge Hub Chain:\n\n```typescript title=\"teleport-ah-to-bridge-hub.ts\"\nfunction createTeleportXcmToBridgeHub(paraId: number) {\n  return XcmVersionedXcm.V5([\n    // Withdraw PAS from Asset Hub (PAS on parachains is parents:1, interior: Here)\n    XcmV5Instruction.WithdrawAsset([\n      {\n        id: { parents: 1, interior: XcmV5Junctions.Here() },\n        fun: XcmV3MultiassetFungibility.Fungible(1n * PAS_UNITS), // 1 PAS\n      },\n    ]),\n    // Pay local fees on Asset Hub in PAS\n    XcmV5Instruction.PayFees({\n      asset: {\n        id: { parents: 1, interior: XcmV5Junctions.Here() },\n        fun: XcmV3MultiassetFungibility.Fungible(10n * PAS_CENTS), // 0.01 PAS\n      },\n    }),\n    // Send to Bridge Hub parachain (parents:1, interior: X1(Parachain(paraId)))\n    XcmV5Instruction.InitiateTransfer({\n      destination: {\n        parents: 1,\n        interior: XcmV5Junctions.X1(XcmV5Junction.Parachain(paraId)),\n      },\n      remote_fees: Enum(\n        'Teleport',\n        XcmV5AssetFilter.Definite([\n          {\n            id: { parents: 1, interior: XcmV5Junctions.Here() },\n            fun: XcmV3MultiassetFungibility.Fungible(10n * PAS_CENTS), // 0.01 PAS\n          },\n        ]),\n      ),\n      preserve_origin: false,\n      remote_xcm: [\n        XcmV5Instruction.DepositAsset({\n          assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n          beneficiary: {\n            parents: 0,\n            interior: XcmV5Junctions.X1(\n              XcmV5Junction.AccountId32({\n                network: undefined,\n                id: FixedSizeBinary.fromAccountId32(BRIDGE_HUB_BENEFICIARY),\n              }),\n            ),\n          },\n        }),\n      ],\n      assets: [\n        Enum('Teleport', XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1))), // Send everything.\n      ],\n    }),\n  ]);\n}\n```"}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 5, "depth": 2, "title": "Fee Estimation Function", "anchor": "fee-estimation-function", "start_char": 17400, "end_char": 31262, "estimated_token_count": 2699, "token_estimator": "heuristic-v1", "text": "## Fee Estimation Function\n\nBelow is a four-step breakdown of the logic needed to estimate the fees for the teleport.\n\nFirst, you need to create the function that will estimate the fees for the teleport:\n\n```typescript title=\"teleport-ah-to-bridge-hub.ts\"\nasync function estimateXcmFeesFromAssetHubToBridgeHub(\n  xcm: any,\n  assetHubApi: any,\n) {\n  // Code will go here\n}\n```\n\n1. **Local execution fees on Asset Hub**: Compute the XCM weight locally, then convert that weight to PAS using Asset Hub's view of PAS (`parents: 1, interior: Here`). Add the code to the function:\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n      console.log('=== Fee Estimation Process (Asset Hub → Bridge Hub) ===');\n\n      // 1. LOCAL EXECUTION FEES on Asset Hub\n      console.log('1. Calculating local execution fees on Asset Hub...');\n      let localExecutionFees = 0n;\n\n      const weightResult =\n        await assetHubApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n      if (weightResult.success) {\n        console.log('✓ XCM weight (Asset Hub):', weightResult.value);\n\n        // Convert weight to PAS fees from Asset Hub's perspective (parents:1, Here)\n        const executionFeesResult =\n          await assetHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n            weightResult.value,\n            XcmVersionedAssetId.V4({\n              parents: 1,\n              interior: XcmV3Junctions.Here(),\n            }),\n          );\n\n        if (executionFeesResult.success) {\n          localExecutionFees = executionFeesResult.value;\n          console.log(\n            '✓ Local execution fees (Asset Hub):',\n            localExecutionFees.toString(),\n            'PAS units',\n          );\n        } else {\n          console.log(\n            '✗ Failed to calculate local execution fees:',\n            executionFeesResult.value,\n          );\n        }\n      } else {\n        console.log(\n          '✗ Failed to query XCM weight on Asset Hub:',\n          weightResult.value,\n        );\n      }\n    ```\n\n2. **Dry-run and delivery fees to Bridge Hub**: Dry-run the XCM on Asset Hub to capture forwarded messages, locate the one targeting Bridge Hub (`parents: 1, interior: Here`), and ask for delivery fees. Add the code to the function:\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n      // 2. DELIVERY FEES + REMOTE EXECUTION FEES\n      console.log('\\n2. Calculating delivery and remote execution fees...');\n      let deliveryFees = 0n;\n      let remoteExecutionFees = 0n; // Skipped (Bridge Hub descriptor not available)\n\n      // Origin from Asset Hub perspective\n      const origin = XcmVersionedLocation.V5({\n        parents: 0,\n        interior: XcmV5Junctions.X1(\n          XcmV5Junction.AccountId32({\n            id: FixedSizeBinary.fromAccountId32(ASSET_HUB_ACCOUNT),\n            network: undefined,\n          }),\n        ),\n      });\n\n      // Dry run the XCM locally on Asset Hub\n      const dryRunResult = await assetHubApi.apis.DryRunApi.dry_run_xcm(\n        origin,\n        xcm,\n      );\n\n      if (\n        dryRunResult.success &&\n        dryRunResult.value.execution_result.type === 'Complete'\n      ) {\n        console.log('✓ Local dry run on Asset Hub successful');\n\n        const { forwarded_xcms: forwardedXcms } = dryRunResult.value;\n\n        // Find the XCM message sent to Bridge Hub (parents:1, interior: X1(Parachain(1002)))\n        const bridgeHubXcmEntry = forwardedXcms.find(\n          ([location, _]: [any, any]) =>\n            (location.type === 'V4' || location.type === 'V5') &&\n            location.value.parents === 1 &&\n            location.value.interior?.type === 'X1' &&\n            location.value.interior.value?.type === 'Parachain' &&\n            location.value.interior.value.value === BRIDGE_HUB_PARA_ID,\n        );\n\n        if (bridgeHubXcmEntry) {\n          const [destination, messages] = bridgeHubXcmEntry;\n          const remoteXcm = messages[0];\n\n          console.log('✓ Found XCM message to Bridge Hub');\n\n          // Calculate delivery fees from Asset Hub to Bridge Hub\n          const deliveryFeesResult =\n            await assetHubApi.apis.XcmPaymentApi.query_delivery_fees(\n              destination,\n              remoteXcm,\n            );\n\n          if (\n            deliveryFeesResult.success &&\n            deliveryFeesResult.value.type === 'V5' &&\n            deliveryFeesResult.value.value[0]?.fun?.type === 'Fungible'\n          ) {\n            deliveryFees = deliveryFeesResult.value.value[0].fun.value;\n            console.log('✓ Delivery fees:', deliveryFees.toString(), 'PAS units');\n          } else {\n            console.log('✗ Failed to calculate delivery fees:', deliveryFeesResult);\n          }\n    ```\n\n3. **Remote execution fees on Bridge Hub**: Connect to Bridge Hub, recompute the forwarded XCM weight there, and convert weight to PAS (`parents: 0, interior: Here`). Add the code to the function:\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n          // 3. REMOTE EXECUTION FEES on Bridge Hub\n          console.log('\\n3. Calculating remote execution fees on Bridge Hub');\n          try {\n            const bridgeHubClient = createClient(\n              withPolkadotSdkCompat(getWsProvider(BRIDGE_HUB_RPC_ENDPOINT)),\n            );\n            const bridgeHubApi = bridgeHubClient.getTypedApi(paseoBridgeHub);\n            const remoteWeightResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_xcm_weight(remoteXcm);\n            const remoteFeesResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n                remoteWeightResult.value as {\n                  ref_time: bigint;\n                  proof_size: bigint;\n                },\n                XcmVersionedAssetId.V4({\n                  parents: 1,\n                  interior: XcmV3Junctions.Here(),\n                }),\n              );\n            bridgeHubClient.destroy();\n            remoteExecutionFees = remoteFeesResult.value as bigint;\n            console.log(\n              '✓ Remote execution fees:',\n              remoteExecutionFees.toString(),\n              'PAS units',\n            );\n          } catch (error) {\n            console.error(\n              'Error calculating remote execution fees on Bridge Hub:',\n              error,\n            );\n          }\n        } else {\n          console.log('✗ No XCM message found to Bridge Hub');\n        }\n      } else {\n        console.log('✗ Local dry run failed on Asset Hub:', dryRunResult.value);\n      }\n    ```\n\n4. **Sum and return totals**: Aggregate all parts, print a short summary, and return a structured result. Add the code to the function:\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n      // 4. TOTAL FEES\n      const totalFees = localExecutionFees + deliveryFees + remoteExecutionFees;\n\n      console.log('\\n=== Fee Summary (Asset Hub → Bridge Hub) ===');\n      console.log(\n        'Local execution fees:',\n        localExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('Delivery fees:', deliveryFees.toString(), 'PAS units');\n      console.log(\n        'Remote execution fees:',\n        remoteExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('TOTAL FEES:', totalFees.toString(), 'PAS units');\n      console.log(\n        'TOTAL FEES:',\n        (Number(totalFees) / Number(PAS_UNITS)).toFixed(4),\n        'PAS',\n      );\n\n      return {\n        localExecutionFees,\n        deliveryFees,\n        remoteExecutionFees,\n        totalFees,\n      };\n    }\n    ```\n\nThe full code for the fee estimation function is the following:\n\n??? code \"Fee Estimation Function\"\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n    async function estimateXcmFeesFromAssetHubToBridgeHub(\n      xcm: any,\n      assetHubApi: any,\n    ) {\n      console.log('=== Fee Estimation Process (Asset Hub → Bridge Hub) ===');\n\n      // 1. LOCAL EXECUTION FEES on Asset Hub\n      console.log('1. Calculating local execution fees on Asset Hub...');\n      let localExecutionFees = 0n;\n\n      const weightResult =\n        await assetHubApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n      if (weightResult.success) {\n        console.log('✓ XCM weight (Asset Hub):', weightResult.value);\n\n        // Convert weight to PAS fees from Asset Hub's perspective (parents:1, Here)\n        const executionFeesResult =\n          await assetHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n            weightResult.value,\n            XcmVersionedAssetId.V4({\n              parents: 1,\n              interior: XcmV3Junctions.Here(),\n            }),\n          );\n\n        if (executionFeesResult.success) {\n          localExecutionFees = executionFeesResult.value;\n          console.log(\n            '✓ Local execution fees (Asset Hub):',\n            localExecutionFees.toString(),\n            'PAS units',\n          );\n        } else {\n          console.log(\n            '✗ Failed to calculate local execution fees:',\n            executionFeesResult.value,\n          );\n        }\n      } else {\n        console.log(\n          '✗ Failed to query XCM weight on Asset Hub:',\n          weightResult.value,\n        );\n      }\n\n      // 2. DELIVERY FEES + REMOTE EXECUTION FEES\n      console.log('\\n2. Calculating delivery and remote execution fees...');\n      let deliveryFees = 0n;\n      let remoteExecutionFees = 0n; // Skipped (Bridge Hub descriptor not available)\n\n      // Origin from Asset Hub perspective\n      const origin = XcmVersionedLocation.V5({\n        parents: 0,\n        interior: XcmV5Junctions.X1(\n          XcmV5Junction.AccountId32({\n            id: FixedSizeBinary.fromAccountId32(ASSET_HUB_ACCOUNT),\n            network: undefined,\n          }),\n        ),\n      });\n\n      // Dry run the XCM locally on Asset Hub\n      const dryRunResult = await assetHubApi.apis.DryRunApi.dry_run_xcm(\n        origin,\n        xcm,\n      );\n\n      if (\n        dryRunResult.success &&\n        dryRunResult.value.execution_result.type === 'Complete'\n      ) {\n        console.log('✓ Local dry run on Asset Hub successful');\n\n        const { forwarded_xcms: forwardedXcms } = dryRunResult.value;\n\n        // Find the XCM message sent to Bridge Hub (parents:1, interior: X1(Parachain(1002)))\n        const bridgeHubXcmEntry = forwardedXcms.find(\n          ([location, _]: [any, any]) =>\n            (location.type === 'V4' || location.type === 'V5') &&\n            location.value.parents === 1 &&\n            location.value.interior?.type === 'X1' &&\n            location.value.interior.value?.type === 'Parachain' &&\n            location.value.interior.value.value === BRIDGE_HUB_PARA_ID,\n        );\n\n        if (bridgeHubXcmEntry) {\n          const [destination, messages] = bridgeHubXcmEntry;\n          const remoteXcm = messages[0];\n\n          console.log('✓ Found XCM message to Bridge Hub');\n\n          // Calculate delivery fees from Asset Hub to Bridge Hub\n          const deliveryFeesResult =\n            await assetHubApi.apis.XcmPaymentApi.query_delivery_fees(\n              destination,\n              remoteXcm,\n            );\n\n          if (\n            deliveryFeesResult.success &&\n            deliveryFeesResult.value.type === 'V5' &&\n            deliveryFeesResult.value.value[0]?.fun?.type === 'Fungible'\n          ) {\n            deliveryFees = deliveryFeesResult.value.value[0].fun.value;\n            console.log('✓ Delivery fees:', deliveryFees.toString(), 'PAS units');\n          } else {\n            console.log('✗ Failed to calculate delivery fees:', deliveryFeesResult);\n          }\n\n          // 3. REMOTE EXECUTION FEES on Bridge Hub\n          console.log('\\n3. Calculating remote execution fees on Bridge Hub');\n          try {\n            const bridgeHubClient = createClient(\n              withPolkadotSdkCompat(getWsProvider(BRIDGE_HUB_RPC_ENDPOINT)),\n            );\n            const bridgeHubApi = bridgeHubClient.getTypedApi(paseoBridgeHub);\n            const remoteWeightResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_xcm_weight(remoteXcm);\n            const remoteFeesResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n                remoteWeightResult.value as {\n                  ref_time: bigint;\n                  proof_size: bigint;\n                },\n                XcmVersionedAssetId.V4({\n                  parents: 1,\n                  interior: XcmV3Junctions.Here(),\n                }),\n              );\n            bridgeHubClient.destroy();\n            remoteExecutionFees = remoteFeesResult.value as bigint;\n            console.log(\n              '✓ Remote execution fees:',\n              remoteExecutionFees.toString(),\n              'PAS units',\n            );\n          } catch (error) {\n            console.error(\n              'Error calculating remote execution fees on Bridge Hub:',\n              error,\n            );\n          }\n        } else {\n          console.log('✗ No XCM message found to Bridge Hub');\n        }\n      } else {\n        console.log('✗ Local dry run failed on Asset Hub:', dryRunResult.value);\n      }\n\n      // 4. TOTAL FEES\n      const totalFees = localExecutionFees + deliveryFees + remoteExecutionFees;\n\n      console.log('\\n=== Fee Summary (Asset Hub → Bridge Hub) ===');\n      console.log(\n        'Local execution fees:',\n        localExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('Delivery fees:', deliveryFees.toString(), 'PAS units');\n      console.log(\n        'Remote execution fees:',\n        remoteExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('TOTAL FEES:', totalFees.toString(), 'PAS units');\n      console.log(\n        'TOTAL FEES:',\n        (Number(totalFees) / Number(PAS_UNITS)).toFixed(4),\n        'PAS',\n      );\n\n      return {\n        localExecutionFees,\n        deliveryFees,\n        remoteExecutionFees,\n        totalFees,\n      };\n    }\n    ```"}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 6, "depth": 2, "title": "Complete Implementation", "anchor": "complete-implementation", "start_char": 31262, "end_char": 32977, "estimated_token_count": 411, "token_estimator": "heuristic-v1", "text": "## Complete Implementation\n\nNow put it all together in the main function:\n\n```typescript title=\"teleport-ah-to-bridge-hub.ts\"\nasync function main() {\n  // Connect to the Asset Hub parachain\n  const assetHubClient = createClient(\n    withPolkadotSdkCompat(getWsProvider(PASEO_ASSET_HUB_RPC_ENDPOINT)),\n  );\n\n  // Get the typed API for Asset Hub\n  const assetHubApi = assetHubClient.getTypedApi(paseoAssetHub);\n\n  try {\n    // Create the XCM message for teleport (Asset Hub → Bridge Hub)\n    const xcm = createTeleportXcmToBridgeHub(BRIDGE_HUB_PARA_ID);\n\n    console.log('=== XCM Teleport: Paseo Asset Hub → Bridge Hub ===');\n    console.log('From:', ASSET_HUB_ACCOUNT, '(Alice on Asset Hub)');\n    console.log('To:', BRIDGE_HUB_BENEFICIARY, '(Beneficiary on Bridge Hub)');\n    console.log('Amount:', '1 PAS');\n    console.log('');\n\n    // Estimate all fees\n    const fees = await estimateXcmFeesFromAssetHubToBridgeHub(xcm, assetHubApi);\n    void fees; // prevent unused var under isolatedModules\n\n    // Create the execute transaction on Asset Hub\n    const tx = assetHubApi.tx.PolkadotXcm.execute({\n      message: xcm,\n      max_weight: {\n        ref_time: 6000000000n,\n        proof_size: 65536n,\n      },\n    });\n\n    console.log('\\n=== Transaction Details ===');\n    console.log('Transaction hex:', (await tx.getEncodedData()).asHex());\n    console.log('Ready to submit!');\n  } catch (error) {\n    console.log('Error stack:', (error as Error).stack);\n    console.error('Error occurred:', (error as Error).message);\n    if ((error as Error).cause) {\n      console.dir((error as Error).cause, { depth: null });\n    }\n  } finally {\n    // Ensure client is always destroyed\n    assetHubClient.destroy();\n  }\n}\n```"}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 7, "depth": 2, "title": "Full Code", "anchor": "full-code", "start_char": 32977, "end_char": 44340, "estimated_token_count": 2142, "token_estimator": "heuristic-v1", "text": "## Full Code\n\nThe full code for the complete implementation is the following:\n\n??? code \"Teleport from Asset Hub to Bridge Hub\"\n\n    ```typescript title=\"teleport-ah-to-bridge-hub.ts\"\n    import { paseoAssetHub, paseoBridgeHub } from '@polkadot-api/descriptors';\n    import { createClient, FixedSizeBinary, Enum } from 'polkadot-api';\n    import { getWsProvider } from 'polkadot-api/ws-provider/node';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import {\n      XcmVersionedLocation,\n      XcmVersionedAssetId,\n      XcmV3Junctions,\n      XcmV3MultiassetFungibility,\n      XcmVersionedXcm,\n      XcmV5Instruction,\n      XcmV5Junctions,\n      XcmV5Junction,\n      XcmV5AssetFilter,\n      XcmV5WildAsset,\n    } from '@polkadot-api/descriptors';\n\n    // 1 PAS = 10^10 units\n    const PAS_UNITS = 10_000_000_000n; // 1 PAS\n    const PAS_CENTS = 100_000_000n; // 0.01 PAS\n\n    // Paseo Asset Hub constants\n    const PASEO_ASSET_HUB_RPC_ENDPOINT = 'ws://localhost:8001';\n    const ASSET_HUB_ACCOUNT = '15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5'; // Alice (Paseo Asset Hub)\n\n    // Bridge Hub destination\n    const BRIDGE_HUB_RPC_ENDPOINT = 'ws://localhost:8000';\n    const BRIDGE_HUB_PARA_ID = 1002;\n    const BRIDGE_HUB_BENEFICIARY =\n      '14E5nqKAp3oAJcmzgZhUD2RcptBeUBScxKHgJKU4HPNcKVf3'; // Bob (Bridge Hub)\n\n    // Create the XCM message for teleport (Asset Hub → Bridge Hub)\n    function createTeleportXcmToBridgeHub(paraId: number) {\n      return XcmVersionedXcm.V5([\n        // Withdraw PAS from Asset Hub (PAS on parachains is parents:1, interior: Here)\n        XcmV5Instruction.WithdrawAsset([\n          {\n            id: { parents: 1, interior: XcmV5Junctions.Here() },\n            fun: XcmV3MultiassetFungibility.Fungible(1n * PAS_UNITS), // 1 PAS\n          },\n        ]),\n        // Pay local fees on Asset Hub in PAS\n        XcmV5Instruction.PayFees({\n          asset: {\n            id: { parents: 1, interior: XcmV5Junctions.Here() },\n            fun: XcmV3MultiassetFungibility.Fungible(10n * PAS_CENTS), // 0.01 PAS\n          },\n        }),\n        // Send to Bridge Hub parachain (parents:1, interior: X1(Parachain(paraId)))\n        XcmV5Instruction.InitiateTransfer({\n          destination: {\n            parents: 1,\n            interior: XcmV5Junctions.X1(XcmV5Junction.Parachain(paraId)),\n          },\n          remote_fees: Enum(\n            'Teleport',\n            XcmV5AssetFilter.Definite([\n              {\n                id: { parents: 1, interior: XcmV5Junctions.Here() },\n                fun: XcmV3MultiassetFungibility.Fungible(10n * PAS_CENTS), // 0.01 PAS\n              },\n            ]),\n          ),\n          preserve_origin: false,\n          remote_xcm: [\n            XcmV5Instruction.DepositAsset({\n              assets: XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1)),\n              beneficiary: {\n                parents: 0,\n                interior: XcmV5Junctions.X1(\n                  XcmV5Junction.AccountId32({\n                    network: undefined,\n                    id: FixedSizeBinary.fromAccountId32(BRIDGE_HUB_BENEFICIARY),\n                  }),\n                ),\n              },\n            }),\n          ],\n          assets: [\n            Enum('Teleport', XcmV5AssetFilter.Wild(XcmV5WildAsset.AllCounted(1))), // Send everything.\n          ],\n        }),\n      ]);\n    }\n\n    async function estimateXcmFeesFromAssetHubToBridgeHub(\n      xcm: any,\n      assetHubApi: any,\n    ) {\n      console.log('=== Fee Estimation Process (Asset Hub → Bridge Hub) ===');\n\n      // 1. LOCAL EXECUTION FEES on Asset Hub\n      console.log('1. Calculating local execution fees on Asset Hub...');\n      let localExecutionFees = 0n;\n\n      const weightResult =\n        await assetHubApi.apis.XcmPaymentApi.query_xcm_weight(xcm);\n      if (weightResult.success) {\n        console.log('✓ XCM weight (Asset Hub):', weightResult.value);\n\n        // Convert weight to PAS fees from Asset Hub's perspective (parents:1, Here)\n        const executionFeesResult =\n          await assetHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n            weightResult.value,\n            XcmVersionedAssetId.V4({\n              parents: 1,\n              interior: XcmV3Junctions.Here(),\n            }),\n          );\n\n        if (executionFeesResult.success) {\n          localExecutionFees = executionFeesResult.value;\n          console.log(\n            '✓ Local execution fees (Asset Hub):',\n            localExecutionFees.toString(),\n            'PAS units',\n          );\n        } else {\n          console.log(\n            '✗ Failed to calculate local execution fees:',\n            executionFeesResult.value,\n          );\n        }\n      } else {\n        console.log(\n          '✗ Failed to query XCM weight on Asset Hub:',\n          weightResult.value,\n        );\n      }\n\n      // 2. DELIVERY FEES + REMOTE EXECUTION FEES\n      console.log('\\n2. Calculating delivery and remote execution fees...');\n      let deliveryFees = 0n;\n      let remoteExecutionFees = 0n; // Skipped (Bridge Hub descriptor not available)\n\n      // Origin from Asset Hub perspective\n      const origin = XcmVersionedLocation.V5({\n        parents: 0,\n        interior: XcmV5Junctions.X1(\n          XcmV5Junction.AccountId32({\n            id: FixedSizeBinary.fromAccountId32(ASSET_HUB_ACCOUNT),\n            network: undefined,\n          }),\n        ),\n      });\n\n      // Dry run the XCM locally on Asset Hub\n      const dryRunResult = await assetHubApi.apis.DryRunApi.dry_run_xcm(\n        origin,\n        xcm,\n      );\n\n      if (\n        dryRunResult.success &&\n        dryRunResult.value.execution_result.type === 'Complete'\n      ) {\n        console.log('✓ Local dry run on Asset Hub successful');\n\n        const { forwarded_xcms: forwardedXcms } = dryRunResult.value;\n\n        // Find the XCM message sent to Bridge Hub (parents:1, interior: X1(Parachain(1002)))\n        const bridgeHubXcmEntry = forwardedXcms.find(\n          ([location, _]: [any, any]) =>\n            (location.type === 'V4' || location.type === 'V5') &&\n            location.value.parents === 1 &&\n            location.value.interior?.type === 'X1' &&\n            location.value.interior.value?.type === 'Parachain' &&\n            location.value.interior.value.value === BRIDGE_HUB_PARA_ID,\n        );\n\n        if (bridgeHubXcmEntry) {\n          const [destination, messages] = bridgeHubXcmEntry;\n          const remoteXcm = messages[0];\n\n          console.log('✓ Found XCM message to Bridge Hub');\n\n          // Calculate delivery fees from Asset Hub to Bridge Hub\n          const deliveryFeesResult =\n            await assetHubApi.apis.XcmPaymentApi.query_delivery_fees(\n              destination,\n              remoteXcm,\n            );\n\n          if (\n            deliveryFeesResult.success &&\n            deliveryFeesResult.value.type === 'V5' &&\n            deliveryFeesResult.value.value[0]?.fun?.type === 'Fungible'\n          ) {\n            deliveryFees = deliveryFeesResult.value.value[0].fun.value;\n            console.log('✓ Delivery fees:', deliveryFees.toString(), 'PAS units');\n          } else {\n            console.log('✗ Failed to calculate delivery fees:', deliveryFeesResult);\n          }\n\n          // 3. REMOTE EXECUTION FEES on Bridge Hub\n          console.log('\\n3. Calculating remote execution fees on Bridge Hub');\n          try {\n            const bridgeHubClient = createClient(\n              withPolkadotSdkCompat(getWsProvider(BRIDGE_HUB_RPC_ENDPOINT)),\n            );\n            const bridgeHubApi = bridgeHubClient.getTypedApi(paseoBridgeHub);\n            const remoteWeightResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_xcm_weight(remoteXcm);\n            const remoteFeesResult =\n              await bridgeHubApi.apis.XcmPaymentApi.query_weight_to_asset_fee(\n                remoteWeightResult.value as {\n                  ref_time: bigint;\n                  proof_size: bigint;\n                },\n                XcmVersionedAssetId.V4({\n                  parents: 1,\n                  interior: XcmV3Junctions.Here(),\n                }),\n              );\n            bridgeHubClient.destroy();\n            remoteExecutionFees = remoteFeesResult.value as bigint;\n            console.log(\n              '✓ Remote execution fees:',\n              remoteExecutionFees.toString(),\n              'PAS units',\n            );\n          } catch (error) {\n            console.error(\n              'Error calculating remote execution fees on Bridge Hub:',\n              error,\n            );\n          }\n        } else {\n          console.log('✗ No XCM message found to Bridge Hub');\n        }\n      } else {\n        console.log('✗ Local dry run failed on Asset Hub:', dryRunResult.value);\n      }\n\n      // 4. TOTAL FEES\n      const totalFees = localExecutionFees + deliveryFees + remoteExecutionFees;\n\n      console.log('\\n=== Fee Summary (Asset Hub → Bridge Hub) ===');\n      console.log(\n        'Local execution fees:',\n        localExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('Delivery fees:', deliveryFees.toString(), 'PAS units');\n      console.log(\n        'Remote execution fees:',\n        remoteExecutionFees.toString(),\n        'PAS units',\n      );\n      console.log('TOTAL FEES:', totalFees.toString(), 'PAS units');\n      console.log(\n        'TOTAL FEES:',\n        (Number(totalFees) / Number(PAS_UNITS)).toFixed(4),\n        'PAS',\n      );\n\n      return {\n        localExecutionFees,\n        deliveryFees,\n        remoteExecutionFees,\n        totalFees,\n      };\n    }\n\n    async function main() {\n      // Connect to the Asset Hub parachain\n      const assetHubClient = createClient(\n        withPolkadotSdkCompat(getWsProvider(PASEO_ASSET_HUB_RPC_ENDPOINT)),\n      );\n\n      // Get the typed API for Asset Hub\n      const assetHubApi = assetHubClient.getTypedApi(paseoAssetHub);\n\n      try {\n        // Create the XCM message for teleport (Asset Hub → Bridge Hub)\n        const xcm = createTeleportXcmToBridgeHub(BRIDGE_HUB_PARA_ID);\n\n        console.log('=== XCM Teleport: Paseo Asset Hub → Bridge Hub ===');\n        console.log('From:', ASSET_HUB_ACCOUNT, '(Alice on Asset Hub)');\n        console.log('To:', BRIDGE_HUB_BENEFICIARY, '(Beneficiary on Bridge Hub)');\n        console.log('Amount:', '1 PAS');\n        console.log('');\n\n        // Estimate all fees\n        const fees = await estimateXcmFeesFromAssetHubToBridgeHub(xcm, assetHubApi);\n        void fees; // prevent unused var under isolatedModules\n\n        // Create the execute transaction on Asset Hub\n        const tx = assetHubApi.tx.PolkadotXcm.execute({\n          message: xcm,\n          max_weight: {\n            ref_time: 6000000000n,\n            proof_size: 65536n,\n          },\n        });\n\n        console.log('\\n=== Transaction Details ===');\n        console.log('Transaction hex:', (await tx.getEncodedData()).asHex());\n        console.log('Ready to submit!');\n      } catch (error) {\n        console.log('Error stack:', (error as Error).stack);\n        console.error('Error occurred:', (error as Error).message);\n        if ((error as Error).cause) {\n          console.dir((error as Error).cause, { depth: null });\n        }\n      } finally {\n        // Ensure client is always destroyed\n        assetHubClient.destroy();\n      }\n    }\n\n    main().catch(console.error);\n\n    ```"}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 8, "depth": 2, "title": "Running the Script", "anchor": "running-the-script", "start_char": 44340, "end_char": 48589, "estimated_token_count": 950, "token_estimator": "heuristic-v1", "text": "## Running the Script\n\nBefore running the script, you can use chopsticks to fork the Paseo Asset Hub and Paseo Bridge Hub chains locally. To do so, you can use the following files and commands:\n\n1. Create a new directory called `.chopsticks` and add the files:\n\n    ??? code \"paseo-bridge-hub.yml\"\n\n        {% raw %}\n        ```yaml title=\".chopsticks/paseo-bridge-hub.yml\"\n        endpoint: wss://bridge-hub-paseo.dotters.network\n        mock-signature-host: true\n        block: ${env.PASEO_BRIDGE_HUB_BLOCK_NUMBER}\n        db: ./db.sqlite\n\n        import-storage:\n          Sudo:\n            Key: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY # Alice\n          System:\n            Account:\n              -\n                -\n                  - 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\n                - providers: 1\n                  data:\n                    free: '10000000000000000000'\n        ```\n        {% endraw %}\n    \n    ??? code \"paseo-asset-hub.yml\"\n\n        {% raw %}\n        ```yaml title=\".chopsticks/paseo-asset-hub.yml\"\n        endpoint: wss://asset-hub-paseo-rpc.n.dwellir.com\n        mock-signature-host: true\n        block: ${env.PASEO_ASSET_HUB_BLOCK_NUMBER}\n        db: ./db.sqlite\n\n        import-storage:\n          Sudo:\n            Key: 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY # Alice\n          System:\n            Account:\n              -\n                -\n                  - 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\n                - providers: 1\n                  data:\n                    free: '10000000000000000000'\n        ```\n        {% endraw %}\n\n2. Run the following command to fork the Paseo Bridge Hub chain:\n\n    ```bash\n    chopsticks --config=.chopsticks/paseo-bridge-hub.yml\n    ```\n\n    After running the command, you will see the following output:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>chopsticks --config=.chopsticks/paseo-bridge-hub.yml</span>\n      <span data-ty=\"output\">[15:55:22.770] INFO: Paseo Bridge Hub RPC listening on http://[::]:8000 and ws://[::]:8000</span>\n      <span data-ty=\"output\">app: \"chopsticks\"</span>\n    </div>\n\n3. Run the following command to fork the Paseo Asset Hub chain:\n\n    ```bash\n    chopsticks --config=.chopsticks/paseo-asset-hub.yml\n    ```\n\n    After running the commands, you will see the following output:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>chopsticks --config=.chopsticks/paseo-asset-hub.yml</span>\n      <span data-ty=\"output\">[15:55:22.770] INFO: Paseo Asset Hub Testnet RPC listening on http://[::]:8001 and ws://[::]:8001</span>\n      <span data-ty=\"output\">app: \"chopsticks\"</span>\n    </div>\n\n4. Run the script:\n\n    ```bash\n    npx ts-node teleport-ah-to-bridge-hub.ts\n    ```\n\nAfter running the script, you will see the following output:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx ts-node teleport-ah-to-bridge-hub.ts</span>\n  <pre>\n=== XCM Teleport: Paseo Asset Hub → Bridge Hub ===\nFrom: 15oF4uVJwmo4TdGW7VfQxNLavjCXviqxT9S1MgbjMNHr6Sp5 (Alice on Asset Hub)\nTo: 14E5nqKAp3oAJcmzgZhUD2RcptBeUBScxKHgJKU4HPNcKVf3 (Beneficiary on Bridge Hub)\nAmount: 1 PAS\n\n=== Fee Estimation Process (Asset Hub → Bridge Hub) ===\n1. Calculating local execution fees on Asset Hub...\n✓ XCM weight (Asset Hub): { ref_time: 1462082000n, proof_size: 19578n }\n✓ Local execution fees (Asset Hub): 97890000 PAS units\n\n2. Calculating delivery and remote execution fees...\n✓ Local dry run on Asset Hub successful\n✓ Found XCM message to Bridge Hub\n✓ Delivery fees: 305150000 PAS units\n\n3. Calculating remote execution fees on Bridge Hub\n✓ Remote execution fees: 17965000 PAS units\n\n=== Fee Summary (Asset Hub → Bridge Hub) ===\nLocal execution fees: 97890000 PAS units\nDelivery fees: 305150000 PAS units\nRemote execution fees: 17965000 PAS units\nTOTAL FEES: 421005000 PAS units\nTOTAL FEES: 0.0421 PAS\n\n=== Transaction Details ===\nTransaction hex: 0x1f03050c00040100000700e40b54023001000002286bee31010100a90f0100000401000002286bee000400010204040d010204000101008eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a480700bca0650102000400\nReady to submit!\n\n</pre\n  >\n</div>"}
{"page_id": "tutorials-interoperability-xcm-fee-estimation", "page_title": "XCM Fee Estimation", "index": 9, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 48589, "end_char": 49199, "estimated_token_count": 100, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nThis approach provides accurate fee estimation for XCM teleports from Asset Hub to Bridge Hub Chain by properly simulating execution on both chains and utilizing dedicated runtime APIs for fee calculation. The fee breakdown helps you understand the cost structure of reverse cross-chain operations (parachain → bridge hub chain) and ensures your transactions have sufficient funds to complete successfully.\n\nThe key insight is understanding how asset references change based on the perspective of each chain in the XCM ecosystem, which is crucial for proper fee estimation and XCM construction."}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 33, "end_char": 1004, "estimated_token_count": 227, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[Cross-Consensus Messaging (XCM)](/develop/interoperability/intro-to-xcm/){target=\\_blank} facilitates asset transfers both within the same consensus system and between different ones, such as between a relay chain and its parachains. For cross-system transfers, two main methods are available:\n\n- **[Asset teleportation](https://paritytech.github.io/xcm-docs/journey/transfers/teleports.html){target=\\_blank}**: A simple and efficient method involving only the source and destination chains, ideal for systems with a high level of trust.\n- **[Reserve-backed transfers](https://paritytech.github.io/xcm-docs/journey/transfers/reserve.html){target=\\_blank}**: Involves a trusted reserve holding real assets and mints derivative tokens to track ownership. This method is suited for systems with lower trust levels.\n\nIn this tutorial, you will learn how to perform a reserve-backed transfer of DOT between a relay chain (Polkadot) and a parachain (Astar)."}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1004, "end_char": 1600, "estimated_token_count": 130, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nWhen adapting this tutorial for other chains, before you can send messages between different consensus systems, you must first open HRMP channels. For detailed guidance, refer to the [XCM Channels](/develop/interoperability/xcm-channels/#xcm-channels){target=\\_blank} article before for further information about.\n\nThis tutorial uses Chopsticks to fork a relay chain and a parachain connected via HRMP channels. For more details on this setup, see the [XCM Testing](/tutorials/polkadot-sdk/testing/fork-live-chains/#xcm-testing){target=\\_blank} section on the Chopsticks page."}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 2, "depth": 2, "title": "Setup", "anchor": "setup", "start_char": 1600, "end_char": 2447, "estimated_token_count": 241, "token_estimator": "heuristic-v1", "text": "## Setup\n\nTo simulate XCM operations between different consensus systems, start by forking the network with the following command:\n\n```bash\nchopsticks xcm -r polkadot -p astar\n```\nAfter executing this command, the relay chain and parachain will expose the following WebSocket endpoints:\n\n| Chain                  | WebSocket Endpoint                   |\n|------------------------|--------------------------------------|\n| Polkadot (relay chain) | <pre>```ws://localhost:8001```</pre> |\n| Astar (parachain)      | <pre>```ws://localhost:8000```</pre> |\n\nYou can perform the reserve-backed transfer using either the [Polkadot.js Apps interface](#using-polkadotjs-apps) or the [Polkadot API](#using-papi), depending on your preference. Both methods provide the same functionality to facilitate asset transfers between the relay chain and parachain."}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 3, "depth": 2, "title": "Use Polkadot.js Apps", "anchor": "use-polkadotjs-apps", "start_char": 2447, "end_char": 3470, "estimated_token_count": 224, "token_estimator": "heuristic-v1", "text": "## Use Polkadot.js Apps\n\nUse the [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\\_blank} interface to connect to each chain. Open two browser tabs—one for each chain—and follow these steps:\n\na. Add the custom endpoint for each chain, as defined above.\n\nb. Click **Switch** to connect to the respective network.\n\n![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-01.webp)\n\nThis reserve-backed transfer method facilitates asset transfers from a local chain to a destination chain by trusting a third party called a reserve to store the real assets. Fees on the destination chain are deducted from the asset specified in the assets vector at the `fee_asset_item` index, covering up to the specified `weight_limit.` The operation fails if the required weight exceeds this limit, potentially putting the transferred assets at risk.\n\nThe following steps outline how to execute a reserve-backed transfer from the Polkadot relay chain to the Astar parachain."}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 4, "depth": 3, "title": "From the Relay Chain Perspective", "anchor": "from-the-relay-chain-perspective", "start_char": 3470, "end_char": 5777, "estimated_token_count": 557, "token_estimator": "heuristic-v1", "text": "### From the Relay Chain Perspective\n\n1. Navigate to the Extrinsics page:\n\n    1. Click on the **Developer** tab from the top navigation bar.\n    2. Select **Extrinsics** from the dropdown.\n\n    ![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-02.webp)\n\n2. Select **xcmPallet**.\n\n    ![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-03.webp)\n\n3. Select the **limitedReservedAssetTransfer** extrinsic from the dropdown list.\n\n    ![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-04.webp)\n\n4. Fill out the required fields:\n\n    1. **dest**: Specifies the destination context for the assets. Commonly set to `[Parent, Parachain(..)]` for parachain-to-parachain transfers or `[Parachain(..)]` for relay chain-to-parachain transfers. In this case, since the transfer is from a relay chain to a parachain, the destination ([`Location`](https://paritytech.github.io/xcm-docs/fundamentals/multilocation/index.html){target=\\_blank}) is the following:\n\n        ```bash\n        { parents: 0, interior: { X1: [{ Parachain: 2006 }] } }\n        ```\n\n    2. **beneficiary**: Defines the recipient of the assets within the destination context, typically represented as an `AccountId32` value. This example uses the following account present in the destination chain:\n\n        ```bash\n        X2mE9hCGX771c3zzV6tPa8U2cDz4U4zkqUdmBrQn83M3cm7\n        ```\n\n    3. **assets**: Lists the assets to be withdrawn, including those designated for fee payment on the destination chain.\n    4. **feeAssetItem**: Indicates the index of the asset within the assets list to be used for paying fees.\n    5. **weightLimit**: Specifies the weight limit, if applicable, for the fee payment on the remote chain.\n    6. Click on the **Submit Transaction** button to send the transaction.\n\n        ![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-05.webp)\n\nAfter submitting the transaction, verify that the `xcmPallet.FeesPaid` and `xcmPallet.Sent` events have been emitted:\n\n![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-06.webp)"}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 5, "depth": 3, "title": "From the Parachain Perspective", "anchor": "from-the-parachain-perspective", "start_char": 5777, "end_char": 6162, "estimated_token_count": 86, "token_estimator": "heuristic-v1", "text": "### From the Parachain Perspective\n\nAfter submitting the transaction from the relay chain, confirm its success by checking the parachain's events. Look for the `assets.Issued` event, which verifies that the assets have been issued to the destination as expected:\n\n![](/images/tutorials/interoperability/xcm-transfers/from-relaychain-to-parachain/from-relaychain-to-parachain-07.webp)"}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 6, "depth": 2, "title": "Use PAPI", "anchor": "use-papi", "start_char": 6162, "end_char": 12547, "estimated_token_count": 1271, "token_estimator": "heuristic-v1", "text": "## Use PAPI\n\nTo programmatically execute the reserve-backed asset transfer between the relay chain and the parachain, you can use [Polkadot API (PAPI)](/develop/toolkit/api-libraries/papi/){target=\\_blank}. PAPI is a robust toolkit that simplifies interactions with Polkadot-based chains. For this project, you'll first need to set up your environment, install necessary dependencies, and create a script to handle the transfer process.\n\n1. Start by creating a folder for your project:\n\n   ```bash\n   mkdir reserve-backed-asset-transfer\n   cd reserve-backed-asset\n   ```\n\n2. Initialize a Node.js project and install the required dependencies. Execute the following commands:\n\n    ```bash\n    npm init\n    npm install polkadot-api @polkadot-labs/hdkd @polkadot-labs/hdkd-helpers\n    ```\n\n3. To enable static, type-safe APIs for interacting with the Polkadot and Astar chains, add their metadata to your project using PAPI:\n\n    ```bash\n    npx papi add dot -n polkadot\n    npx papi add astar -w wss://rpc.astar.network\n    ```\n\n    !!! note \n        - `dot` and `astar` are arbitrary names you assign to the chains, allowing you to access their metadata information.\n        - The first command uses the well-known Polkadot chain, while the second connects to the Astar chain using its WebSocket endpoint.\n\n4. Create a `index.js` file and insert the following code to configure the clients and handle the asset transfer:\n\n    ```js\n    // Import necessary modules from Polkadot API and helpers\n    import {\n      astar, // Astar chain metadata\n      dot, // Polkadot chain metadata\n      XcmVersionedLocation,\n      XcmVersionedAssets,\n      XcmV3Junction,\n      XcmV3Junctions,\n      XcmV3WeightLimit,\n      XcmV3MultiassetFungibility,\n      XcmV3MultiassetAssetId,\n    } from '@polkadot-api/descriptors';\n    import { createClient } from 'polkadot-api';\n    import { sr25519CreateDerive } from '@polkadot-labs/hdkd';\n    import {\n      DEV_PHRASE,\n      entropyToMiniSecret,\n      mnemonicToEntropy,\n      ss58Decode,\n    } from '@polkadot-labs/hdkd-helpers';\n    import { getPolkadotSigner } from 'polkadot-api/signer';\n    import { getWsProvider } from 'polkadot-api/ws-provider/web';\n    import { withPolkadotSdkCompat } from 'polkadot-api/polkadot-sdk-compat';\n    import { Binary } from 'polkadot-api';\n\n    // Create Polkadot client using WebSocket provider for Polkadot chain\n    const polkadotClient = createClient(\n      withPolkadotSdkCompat(getWsProvider('ws://127.0.0.1:8001'))\n    );\n    const dotApi = polkadotClient.getTypedApi(dot);\n\n    // Create Astar client using WebSocket provider for Astar chain\n    const astarClient = createClient(\n      withPolkadotSdkCompat(getWsProvider('ws://localhost:8000'))\n    );\n    const astarApi = astarClient.getTypedApi(astar);\n\n    // Create keypair for Alice using dev phrase to sign transactions\n    const miniSecret = entropyToMiniSecret(mnemonicToEntropy(DEV_PHRASE));\n    const derive = sr25519CreateDerive(miniSecret);\n    const aliceKeyPair = derive('//Alice');\n    const alice = getPolkadotSigner(\n      aliceKeyPair.publicKey,\n      'Sr25519',\n      aliceKeyPair.sign\n    );\n\n    // Define recipient (Dave) address on Astar chain\n    const daveAddress = 'X2mE9hCGX771c3zzV6tPa8U2cDz4U4zkqUdmBrQn83M3cm7';\n    const davePublicKey = ss58Decode(daveAddress)[0];\n    const idBenef = Binary.fromBytes(davePublicKey);\n\n    // Define Polkadot Asset ID on Astar chain (example)\n    const polkadotAssetId = 340282366920938463463374607431768211455n;\n\n    // Fetch asset balance of recipient (Dave) before transaction\n    let assetMetadata = await astarApi.query.Assets.Account.getValue(\n      polkadotAssetId,\n      daveAddress\n    );\n    console.log('Asset balance before tx:', assetMetadata?.balance ?? 0);\n\n    // Prepare and submit transaction to transfer assets from Polkadot to Astar\n    const tx = dotApi.tx.XcmPallet.limited_reserve_transfer_assets({\n      dest: XcmVersionedLocation.V3({\n        parents: 0,\n        interior: XcmV3Junctions.X1(\n          XcmV3Junction.Parachain(2006) // Destination is the Astar parachain\n        ),\n      }),\n      beneficiary: XcmVersionedLocation.V3({\n        parents: 0,\n        interior: XcmV3Junctions.X1(\n          XcmV3Junction.AccountId32({\n            // Beneficiary address on Astar\n            network: undefined,\n            id: idBenef,\n          })\n        ),\n      }),\n      assets: XcmVersionedAssets.V3([\n        {\n          id: XcmV3MultiassetAssetId.Concrete({\n            parents: 0,\n            interior: XcmV3Junctions.Here(), // Asset from the sender's location\n          }),\n          fun: XcmV3MultiassetFungibility.Fungible(120000000000), // Asset amount to transfer\n        },\n      ]),\n      fee_asset_item: 0, // Asset used to pay transaction fees\n      weight_limit: XcmV3WeightLimit.Unlimited(), // No weight limit on transaction\n    });\n\n    // Sign and submit the transaction\n    tx.signSubmitAndWatch(alice).subscribe({\n      next: async (event) => {\n        if (event.type === 'finalized') {\n          console.log('Transaction completed successfully');\n        }\n      },\n      error: console.error,\n      complete() {\n        polkadotClient.destroy(); // Clean up after transaction\n      },\n    });\n\n    // Wait for transaction to complete\n    await new Promise((resolve) => setTimeout(resolve, 20000));\n\n    // Fetch asset balance of recipient (Dave) after transaction\n    assetMetadata = await astarApi.query.Assets.Account.getValue(\n      polkadotAssetId,\n      daveAddress\n    );\n    console.log('Asset balance after tx:', assetMetadata?.balance ?? 0);\n\n    // Exit the process\n    process.exit(0);\n\n    ```\n\n    !!! note\n        To use this script with real-world blockchains, you'll need to update the WebSocket endpoint to the appropriate one, replace the Alice account with a valid account, and ensure the account has sufficient funds to cover transaction fees.\n\n4. Execute the script:\n\n    ```bash \n    node index.js\n    ```\n\n5. Check the terminal output. If the operation is successful, you should see the following message:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>node index.js</span>\n      <span data-ty> Asset balance before tx: 0</span>\n      <span data-ty> Transaction completed successfully</span>\n      <span data-ty> Asset balance after tx: 119999114907n</span>\n    </div>"}
{"page_id": "tutorials-interoperability-xcm-transfers-from-relaychain-to-parachain", "page_title": "XCM Transfers from Relay Chain to Parachain", "index": 7, "depth": 2, "title": "Additional Resources", "anchor": "additional-resources", "start_char": 12547, "end_char": 12692, "estimated_token_count": 34, "token_estimator": "heuristic-v1", "text": "## Additional Resources\n\nYou can perform these operations using [ParaSpell](https://paraspell.xyz/){target=\\_blank} for an alternative approach."}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 32, "end_char": 1108, "estimated_token_count": 208, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nChopsticks is an innovative tool that simplifies the process of forking live Polkadot SDK chains. This guide provides step-by-step instructions to configure and fork chains, enabling developers to:\n\n- Replay blocks for state analysis.\n- Test cross-chain messaging (XCM).\n- Simulate blockchain environments for debugging and experimentation.\n\nWith support for both configuration files and CLI commands, Chopsticks offers flexibility for diverse development workflows. Whether you're testing locally or exploring complex blockchain scenarios, Chopsticks empowers developers to gain deeper insights and accelerate application development.\n\nChopsticks uses the [Smoldot](https://github.com/smol-dot/smoldot){target=\\_blank} light client, which does not support calls made through the Ethereum JSON-RPC. As a result, you can't fork your chain using Chopsticks and then interact with it using tools like MetaMask.\n\nFor additional support and information, please reach out through [GitHub Issues](https://github.com/AcalaNetwork/chopsticks/issues){target=\\_blank}."}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1108, "end_char": 1591, "estimated_token_count": 118, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nTo follow this tutorial, ensure you have completed the following:\n\n- **Installed Chopsticks**: If you still need to do so, see the [Install Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/#install-chopsticks){target=\\_blank} guide for assistance.\n- **Reviewed** [Configure Chopsticks](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/#configure-chopsticks){target=\\_blank}: And understand how forked chains are configured."}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 2, "depth": 2, "title": "Configuration File", "anchor": "configuration-file", "start_char": 1591, "end_char": 3200, "estimated_token_count": 440, "token_estimator": "heuristic-v1", "text": "## Configuration File \n\nTo run Chopsticks using a configuration file, utilize the `--config` flag. You can use a raw GitHub URL, a path to a local file, or simply the chain's name. The following commands all look different but they use the `polkadot` configuration in the same way:\n\n=== \"GitHub URL\"\n\n    ```bash\n    npx @acala-network/chopsticks \\\n    --config=https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml\n    ```\n\n=== \"Local File Path\"\n\n    ```bash\n    npx @acala-network/chopsticks --config=configs/polkadot.yml\n    ```\n\n=== \"Chain Name\"\n\n    ```bash\n    npx @acala-network/chopsticks --config=polkadot\n    ```\n\nRegardless of which method you choose from the preceding examples, you'll see an output similar to the following:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx @acala-network/chopsticks --config=polkadot</span>\n  <br />\n  <span data-ty>[18:38:26.155] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty> chopsticks::executor TRACE: Calling Metadata_metadata</span>\n  <span data-ty> chopsticks::executor TRACE: Completed Metadata_metadata</span>\n  <span data-ty>[18:38:28.186] INFO: Polkadot RPC listening on port 8000</span>\n  <span data-ty> app: \"chopsticks\"</span>\n</div>\n\nIf using a file path, make sure you've downloaded the [Polkadot configuration file](https://github.com/AcalaNetwork/chopsticks/blob/master/configs/polkadot.yml){target=\\_blank}, or have created your own."}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 3, "depth": 2, "title": "Create a Fork", "anchor": "create-a-fork", "start_char": 3200, "end_char": 3905, "estimated_token_count": 212, "token_estimator": "heuristic-v1", "text": "## Create a Fork\n\nOnce you've configured Chopsticks, use the following command to fork Polkadot at block 100:\n\n```bash\nnpx @acala-network/chopsticks \\\n--endpoint wss://polkadot-rpc.dwellir.com \\\n--block 100\n```\n\nIf the fork is successful, you will see output similar to the following:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx @acala-network/chopsticks \\ --endpoint wss://polkadot-rpc.dwellir.com \\ --block 100</span>\n  <br />\n  <span data-ty>[19:12:21.023] INFO: Polkadot RPC listening on port 8000</span>\n  <span data-ty> app: \"chopsticks\"</span>\n</div>\n\nAccess the running Chopsticks fork using the default address.\n\n```bash\nws://localhost:8000\n```"}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 4, "depth": 2, "title": "Interact with a Fork", "anchor": "interact-with-a-fork", "start_char": 3905, "end_char": 4211, "estimated_token_count": 95, "token_estimator": "heuristic-v1", "text": "## Interact with a Fork\n\nYou can interact with the forked chain using various [libraries](/develop/toolkit/#libraries){target=\\_blank} such as [Polkadot.js](https://polkadot.js.org/docs/){target=\\_blank} and its user interface, [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank}."}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 5, "depth": 3, "title": "Use Polkadot.js Apps", "anchor": "use-polkadotjs-apps", "start_char": 4211, "end_char": 4887, "estimated_token_count": 192, "token_estimator": "heuristic-v1", "text": "### Use Polkadot.js Apps\n\nTo interact with Chopsticks via the hosted user interface, visit [Polkadot.js Apps](https://polkadot.js.org/apps/#/explorer){target=\\_blank} and follow these steps:\n\n1. Select the network icon in the top left corner.\n\n    ![](/images/tutorials/polkadot-sdk/testing/fork-live-chains/chopsticks-1.webp)\n\n2. Scroll to the bottom and select **Development**.\n3. Choose **Custom**.\n4. Enter `ws://localhost:8000` in the input field.\n5. Select the **Switch** button.\n\n    ![](/images/tutorials/polkadot-sdk/testing/fork-live-chains/chopsticks-2.webp)\n\nYou should now be connected to your local fork and can interact with it as you would with a real chain."}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 6, "depth": 3, "title": "Use Polkadot.js Library", "anchor": "use-polkadotjs-library", "start_char": 4887, "end_char": 5411, "estimated_token_count": 136, "token_estimator": "heuristic-v1", "text": "### Use Polkadot.js Library\n\nFor programmatic interaction, you can use the Polkadot.js library. The following is a basic example:\n\n```js\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function connectToFork() {\n  const wsProvider = new WsProvider('ws://localhost:8000');\n  const api = await ApiPromise.create({ provider: wsProvider });\n  await api.isReady;\n\n  // Now you can use 'api' to interact with your fork\n  console.log(`Connected to chain: ${await api.rpc.system.chain()}`);\n}\n\nconnectToFork();\n\n```"}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 7, "depth": 2, "title": "Replay Blocks", "anchor": "replay-blocks", "start_char": 5411, "end_char": 19843, "estimated_token_count": 575, "token_estimator": "heuristic-v1", "text": "## Replay Blocks\n\nChopsticks allows you to replay specific blocks from a chain, which is useful for debugging and analyzing state changes. You can use the parameters in the [Configuration](/develop/toolkit/parachains/fork-chains/chopsticks/get-started/#configure-chopsticks){target=\\_blank} section to set up the chain configuration, and then use the run-block subcommand with the following additional options:\n\n- **`output-path`**: Path to print output.\n- **`html`**: Generate HTML with storage diff.\n- **`open`**: Open generated HTML.\n\nFor example, the command to replay block 1000 from Polkadot and save the output to a JSON file would be as follows:\n\n```bash\nnpx @acala-network/chopsticks run-block  \\\n--endpoint wss://polkadot-rpc.dwellir.com  \\\n--output-path ./polkadot-output.json  \\\n--block 1000\n```\n\n??? code \"polkadot-output.json\"\n\n    ```json\n    {\n        \"Call\": {\n            \"result\": \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44a10f6fc59a4d90c3b78e38fac100fc6adc6f9e69a07565ec8abce6165bd0d24078cc7bf34f450a2cc7faacc1fa1e244b959f0ed65437f44208876e1e5eefbf8dd34c040642414245b501030100000083e2cc0f00000000d889565422338aa58c0fd8ebac32234149c7ce1f22ac2447a02ef059b58d4430ca96ba18fbf27d06fe92ec86d8b348ef42f6d34435c791b952018d0a82cae40decfe5faf56203d88fdedee7b25f04b63f41f23da88c76c876db5c264dad2f70c\",\n            \"storageDiff\": [\n                [\n                    \"0x0b76934f4cc08dee01012d059e1b83eebbd108c4899964f707fdaffb82636065\",\n                    \"0x00\"\n                ],\n                [\n                    \"0x1cb6f36e027abb2091cfb5110ab5087f0323475657e0890fbdbf66fb24b4649e\",\n                    null\n                ],\n                [\n                    \"0x1cb6f36e027abb2091cfb5110ab5087f06155b3cd9a8c9e5e9a23fd5dc13a5ed\",\n                    \"0x83e2cc0f00000000\"\n                ],\n                [\n                    \"0x1cb6f36e027abb2091cfb5110ab5087ffa92de910a7ce2bd58e99729c69727c1\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef702a5c1b19ab7a04f536c519aca4983ac\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef70a98fdbe9ce6c55837576c60c7af3850\",\n                    \"0x02000000\"\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef734abf5cb34d6244378cddbf18e849d96\",\n                    \"0xc03b86ae010000000000000000000000\"\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef780d41e5e16056765bc8461851072c9d7\",\n                    \"0x080000000000000080e36a09000000000200000001000000000000ca9a3b00000000020000\"\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef78a42f33323cb5ced3b44dd825fda9fcc\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef799e7f93fc6a98f0874fd057f111c4d2d\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7a44704b568d21667356a5a050c118746d366e7fe86e06375e7030000\",\n                    \"0xba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44\"\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7a86da5a932684f199539836fcb8c886f\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7b06c3320c6ac196d813442e270868d63\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7bdc0bd303e9855813aa8a30d4efc5112\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d15153cb1f00942ff401000000\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7df1daeb8986837f21cc5d17596bb78d1b4def25cfda6ef3a00000000\",\n                    null\n                ],\n                [\n                    \"0x26aa394eea5630e07c48ae0c9558cef7ff553b5a9862a516939d82b3d3d8661a\",\n                    null\n                ],\n                [\n                    \"0x2b06af9719ac64d755623cda8ddd9b94b1c371ded9e9c565e89ba783c4d5f5f9b4def25cfda6ef3a000000006f3d6b177c8acbd8dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e7201\",\n                    \"0x9b000000\"\n                ],\n                [\"0x3a65787472696e7369635f696e646578\", null],\n                [\n                    \"0x3f1467a096bcd71a5b6a0c8155e208103f2edf3bdf381debe331ab7446addfdc\",\n                    \"0x550057381efedcffffffffffffffffff\"\n                ],\n                [\n                    \"0x3fba98689ebed1138735e0e7a5a790ab0f41321f75df7ea5127be2db4983c8b2\",\n                    \"0x00\"\n                ],\n                [\n                    \"0x3fba98689ebed1138735e0e7a5a790ab21a5051453bd3ae7ed269190f4653f3b\",\n                    \"0x080000\"\n                ],\n                [\n                    \"0x3fba98689ebed1138735e0e7a5a790abb984cfb497221deefcefb70073dcaac1\",\n                    \"0x00\"\n                ],\n                [\n                    \"0x5f3e4907f716ac89b6347d15ececedca80cc6574281671b299c1727d7ac68cabb4def25cfda6ef3a00000000\",\n                    \"0x204e0000183887050ecff59f58658b3df63a16d03a00f92890f1517f48c2f6ccd215e5450e380e00005809fd84af6483070acbb92378e3498dbc02fb47f8e97f006bb83f60d7b2b15d980d000082104c22c383925323bf209d771dec6e1388285abe22c22d50de968467e0bb6ce00b000088ee494d719d68a18aade04903839ea37b6be99552ceceb530674b237afa9166480d0000dc9974cdb3cebfac4d31333c30865ff66c35c1bf898df5c5dd2924d3280e72011c0c0000e240d12c7ad07bb0e7785ee6837095ddeebb7aef84d6ed7ea87da197805b343a0c0d0000\"\n                ],\n                [\n                    \"0xae394d879ddf7f99595bc0dd36e355b5bbd108c4899964f707fdaffb82636065\",\n                    null\n                ],\n                [\n                    \"0xbd2a529379475088d3e29a918cd478721a39ec767bd5269111e6492a1675702a\",\n                    \"0x4501407565175cfbb5dca18a71e2433f838a3d946ef532c7bff041685db1a7c13d74252fffe343a960ef84b15187ea0276687d8cb3168aeea5202ea6d651cb646517102b81ff629ee6122430db98f2cadf09db7f298b49589b265dae833900f24baa8fb358d87e12f3e9f7986a9bf920c2fb48ce29886199646d2d12c6472952519463e80b411adef7e422a1595f1c1af4b5dd9b30996fba31fa6a30bd94d2022d6b35c8bc5a8a51161d47980bf4873e01d15afc364f8939a6ce5a09454ab7f2dd53bf4ee59f2c418e85aa6eb764ad218d0097fb656900c3bdd859771858f87bf7f06fc9b6db154e65d50d28e8b2374898f4f519517cd0bedc05814e0f5297dc04beb307b296a93cc14d53afb122769dfd402166568d8912a4dff9c2b1d4b6b34d811b40e5f3763e5f3ab5cd1da60d75c0ff3c12bcef3639f5f792a85709a29b752ffd1233c2ccae88ed3364843e2fa92bdb49021ee36b36c7cdc91b3e9ad32b9216082b6a2728fccd191a5cd43896f7e98460859ca59afbf7c7d93cd48da96866f983f5ff8e9ace6f47ee3e6c6edb074f578efbfb0907673ebca82a7e1805bc5c01cd2fa5a563777feeb84181654b7b738847c8e48d4f575c435ad798aec01631e03cf30fe94016752b5f087f05adf1713910767b7b0e6521013be5370776471191641c282fdfe7b7ccf3b2b100a83085cd3af2b0ad4ab3479448e71fc44ff987ec3a26be48161974b507fb3bc8ad23838f2d0c54c9685de67dc6256e71e739e9802d0e6e3b456f6dca75600bc04a19b3cc1605784f46595bfb10d5e077ce9602ae3820436166aa1905a7686b31a32d6809686462bc9591c0bc82d9e49825e5c68352d76f1ac6e527d8ac02db3213815080afad4c2ecb95b0386e3e9ab13d4f538771dac70d3059bd75a33d0b9b581ec33bb16d0e944355d4718daccb35553012adfcdacb1c5200a2aec3756f6ad5a2beffd30018c439c1b0c4c0f86dbf19d0ad59b1c9efb7fe90906febdb9001af1e7e15101089c1ab648b199a40794d30fe387894db25e614b23e833291a604d07eec2ade461b9b139d51f9b7e88475f16d6d23de6fe7831cc1dbba0da5efb22e3b26cd2732f45a2f9a5d52b6d6eaa38782357d9ae374132d647ef60816d5c98e6959f8858cfa674c8b0d340a8f607a68398a91b3a965585cc91e46d600b1310b8f59c65b7c19e9d14864a83c4ad6fa4ba1f75bba754e7478944d07a1f7e914422b4d973b0855abeb6f81138fdca35beb474b44c7736fc3ab2969878810153aa3c93fc08c99c478ed1bb57f647d3eb02f25cee122c70424643f4b106a7643acaa630a5c4ac39364c3cb14453055170c01b44e8b1ef007c7727494411958932ae8b3e0f80d67eec8e94dd2ff7bbe8c9e51ba7e27d50bd9f52cbaf9742edecb6c8af1aaf3e7c31542f7d946b52e0c37d194b3dd13c3fddd39db0749755c7044b3db1143a027ad428345d930afcefc0d03c3a0217147900bdea1f5830d826f7e75ecd1c4e2bc8fd7de3b35c6409acae1b2215e9e4fd7e360d6825dc712cbf9d87ae0fd4b349b624d19254e74331d66a39657da81e73d7b13adc1e5efa8efd65aa32c1a0a0315913166a590ae551c395c476116156cf9d872fd863893edb41774f33438161f9b973e3043f819d087ba18a0f1965e189012496b691f342f7618fa9db74e8089d4486c8bd1993efd30ff119976f5cc0558e29b417115f60fd8897e13b6de1a48fbeee38ed812fd267ae25bffea0caa71c09309899b34235676d5573a8c3cf994a3d7f0a5dbd57ab614c6caf2afa2e1a860c6307d6d9341884f1b16ef22945863335bb4af56e5ef5e239a55dbd449a4d4d3555c8a3ec5bd3260f88cabca88385fe57920d2d2dfc5d70812a8934af5691da5b91206e29df60065a94a0a8178d118f1f7baf768d934337f570f5ec68427506391f51ab4802c666cc1749a84b5773b948fcbe460534ed0e8d48a15c149d27d67deb8ea637c4cc28240ee829c386366a0b1d6a275763100da95374e46528a0adefd4510c38c77871e66aeda6b6bfd629d32af9b2fad36d392a1de23a683b7afd13d1e3d45dad97c740106a71ee308d8d0f94f6771164158c6cd3715e72ccfbc49a9cc49f21ead8a3c5795d64e95c15348c6bf8571478650192e52e96dd58f95ec2c0fb4f2ccc05b0ab749197db8d6d1c6de07d6e8cb2620d5c308881d1059b50ffef3947c273eaed7e56c73848e0809c4bd93619edd9fd08c8c5c88d5f230a55d2c6a354e5dd94440e7b5bf99326cf4a112fe843e7efdea56e97af845761d98f40ed2447bd04a424976fcf0fe0a0c72b97619f85cf431fe4c3aa6b3a4f61df8bc1179c11e77783bfedb7d374bd1668d0969333cb518bd20add8329462f2c9a9f04d150d60413fdd27271586405fd85048481fc2ae25b6826cb2c947e4231dc7b9a0d02a9a03f88460bced3fef5d78f732684bd218a1954a4acfc237d79ccf397913ab6864cd8a07e275b82a8a72520624738368d1c5f7e0eaa2b445cf6159f2081d3483618f7fc7b16ec4e6e4d67ab5541bcda0ca1af40efd77ef8653e223191448631a8108c5e50e340cd405767ecf932c1015aa8856b834143dc81fa0e8b9d1d8c32278fca390f2ff08181df0b74e2d13c9b7b1d85543416a0dae3a77530b9cd1366213fcf3cd12a9cd3ae0a006d6b29b5ffc5cdc1ab24343e2ab882abfd719892fca5bf2134731332c5d3bef6c6e4013d84a853cb03d972146b655f0f8541bcd36c3c0c8a775bb606edfe50d07a5047fd0fe01eb125e83673930bc89e91609fd6dfe97132679374d3de4a0b3db8d3f76f31bed53e247da591401d508d65f9ee01d3511ee70e3644f3ab5d333ca7dbf737fe75217b4582d50d98b5d59098ea11627b7ed3e3e6ee3012eadd326cf74ec77192e98619427eb0591e949bf314db0fb932ed8be58258fb4f08e0ccd2cd18b997fb5cf50c90d5df66a9f3bb203bd22061956128b800e0157528d45c7f7208c65d0592ad846a711fa3c5601d81bb318a45cc1313b122d4361a7d7a954645b04667ff3f81d3366109772a41f66ece09eb93130abe04f2a51bb30e767dd37ec6ee6a342a4969b8b342f841193f4f6a9f0fac4611bc31b6cab1d25262feb31db0b8889b6f8d78be23f033994f2d3e18e00f3b0218101e1a7082782aa3680efc8502e1536c30c8c336b06ae936e2bcf9bbfb20dd514ed2867c03d4f44954867c97db35677d30760f37622b85089cc5d182a89e29ab0c6b9ef18138b16ab91d59c2312884172afa4874e6989172014168d3ed8db3d9522d6cbd631d581d166787c93209bec845d112e0cbd825f6df8b64363411270921837cfb2f9e7f2e74cdb9cd0d2b02058e5efd9583e2651239654b887ea36ce9537c392fc5dfca8c5a0facbe95b87dfc4232f229bd12e67937d32b7ffae2e837687d2d292c08ff6194a2256b17254748857c7e3c871c3fff380115e6f7faf435a430edf9f8a589f6711720cfc5cec6c8d0d94886a39bb9ac6c50b2e8ef6cf860415192ca4c1c3aaa97d36394021a62164d5a63975bcd84b8e6d74f361c17101e3808b4d8c31d1ee1a5cf3a2feda1ca2c0fd5a50edc9d95e09fb5158c9f9b0eb5e2c90a47deb0459cea593201ae7597e2e9245aa5848680f546256f3\"\n                ],\n                [\n                    \"0xd57bce545fb382c34570e5dfbf338f5e326d21bc67a4b34023d577585d72bfd7\",\n                    null\n                ],\n                [\n                    \"0xd57bce545fb382c34570e5dfbf338f5ea36180b5cfb9f6541f8849df92a6ec93\",\n                    \"0x00\"\n                ],\n                [\n                    \"0xd57bce545fb382c34570e5dfbf338f5ebddf84c5eb23e6f53af725880d8ffe90\",\n                    null\n                ],\n                [\n                    \"0xd5c41b52a371aa36c9254ce34324f2a53b996bb988ea8ee15bad3ffd2f68dbda\",\n                    \"0x00\"\n                ],\n                [\n                    \"0xf0c365c3cf59d671eb72da0e7a4113c49f1f0515f462cdcf84e0f1d6045dfcbb\",\n                    \"0x50defc5172010000\"\n                ],\n                [\n                    \"0xf0c365c3cf59d671eb72da0e7a4113c4bbd108c4899964f707fdaffb82636065\",\n                    null\n                ],\n                [\n                    \"0xf68f425cf5645aacb2ae59b51baed90420d49a14a763e1cbc887acd097f92014\",\n                    \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n                ],\n                [\n                    \"0xf68f425cf5645aacb2ae59b51baed9049b58374218f48eaf5bc23b7b3e7cf08a\",\n                    \"0xb3030000\"\n                ],\n                [\n                    \"0xf68f425cf5645aacb2ae59b51baed904b97380ce5f4e70fbf9d6b5866eb59527\",\n                    \"0x9501800300008203000082030000840300008503000086030000870300008703000089030000890300008b0300008b0300008d0300008d0300008f0300008f0300009103000092030000920300009403000094030000960300009603000098030000990300009a0300009b0300009b0300009d0300009d0300009f0300009f030000a1030000a2030000a3030000a4030000a5030000a6030000a6030000a8030000a8030000aa030000ab030000ac030000ad030000ae030000af030000b0030000b1030000b1030000b3030000b3030000b5030000b6030000b7030000b8030000b9030000ba030000ba030000bc030000bc030000be030000be030000c0030000c1030000c2030000c2030000c4030000c5030000c5030000c7030000c7030000c9030000c9030000cb030000cc030000cd030000ce030000cf030000d0030000d0030000d2030000d2030000d4030000d4030000d6030000d7030000d8030000d9030000da030000db030000db030000dd030000dd030000df030000e0030000e1030000e2030000e3030000e4030000e4030000\"\n                ]\n            ],\n            \"offchainStorageDiff\": [],\n            \"runtimeLogs\": []\n        }\n    }\n\n    ```"}
{"page_id": "tutorials-polkadot-sdk-testing-fork-live-chains", "page_title": "Fork a Chain with Chopsticks", "index": 8, "depth": 2, "title": "XCM Testing", "anchor": "xcm-testing", "start_char": 19843, "end_char": 22380, "estimated_token_count": 761, "token_estimator": "heuristic-v1", "text": "## XCM Testing\n\nTo test XCM (Cross-Consensus Messaging) messages between networks, you can fork multiple parachains and a relay chain locally using Chopsticks.\n\n- **`relaychain`**: Relay chain config file.\n- **`parachain`**: Parachain config file.\n\nFor example, to fork Moonbeam, Astar, and Polkadot enabling XCM between them, you can use the following command:\n\n```bash\nnpx @acala-network/chopsticks xcm \\\n--r polkadot \\\n--p moonbeam \\\n--p astar\n```\n\nAfter running it, you should see output similar to the following:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx @acala-network/chopsticks xcm \\</span>\n  <span data-ty>--r polkadot \\</span>\n  <span data-ty>--p moonbeam \\</span>\n  <span data-ty>--p astar</span>\n  <br />\n  <span data-ty>[13:46:07.901] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/moonbeam.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:12.631] INFO: Moonbeam RPC listening on port 8000</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:12.632] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/astar.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty> chopsticks::executor TRACE: Calling Metadata_metadata</span>\n  <span data-ty> chopsticks::executor TRACE: Completed Metadata_metadata</span>\n  <span data-ty>[13:46:23.669] INFO: Astar RPC listening on port 8001</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:25.144] INFO (xcm): Connected parachains [2004,2006]</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:25.144] INFO: Loading config file https://raw.githubusercontent.com/AcalaNetwork/chopsticks/master/configs/polkadot.yml</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty> chopsticks::executor TRACE: Calling Metadata_metadata</span>\n  <span data-ty> chopsticks::executor TRACE: Completed Metadata_metadata</span>\n  <span data-ty>[13:46:53.320] INFO: Polkadot RPC listening on port 8002</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:54.038] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Moonbeam'</span>\n  <span data-ty> app: \"chopsticks\"</span>\n  <span data-ty>[13:46:55.028] INFO (xcm): Connected relaychain 'Polkadot' with parachain 'Astar'</span>\n  <span data-ty> app: \"chopsticks\"</span>\n</div>\n\nNow you can interact with your forked chains using the ports specified in the output."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 38, "end_char": 732, "estimated_token_count": 118, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nZombienet simplifies blockchain development by enabling developers to create temporary, customizable networks for testing and validation. These ephemeral chains are ideal for experimenting with configurations, debugging applications, and validating functionality in a controlled environment.\n\nIn this guide, you'll learn how to define a basic network configuration file, spawn a blockchain network using Zombienet's CLI, and interact with nodes and monitor network activity using tools like Polkadot.js Apps and Prometheus\n\nBy the end of this tutorial, you'll be equipped to deploy and test your own blockchain networks, paving the way for more advanced setups and use cases."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 732, "end_char": 1297, "estimated_token_count": 128, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nTo successfully complete this tutorial, you must ensure you've first:\n\n- [Installed Zombienet](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#install-zombienet){target=\\_blank}. This tutorial requires Zombienet version `v1.3.133`. Verify that you're using the specified version to ensure compatibility with the instructions.\n- Reviewed the information in [Configure Zombienet](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#configure-zombienet){target=\\_blank} and understand how to customize a spawned network."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 2, "depth": 2, "title": "Set Up Local Provider", "anchor": "set-up-local-provider", "start_char": 1297, "end_char": 2341, "estimated_token_count": 238, "token_estimator": "heuristic-v1", "text": "## Set Up Local Provider\n\nIn this tutorial, you will use the Zombienet [local provider](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#local-provider){target=\\_blank} (also called native provider) that enables you to run nodes as local processes in your development environment.\n\nYou must have the necessary binaries installed (such as `polkadot` and `polkadot-parachain`) to spin up your network successfully.\n\nTo install the required binaries, use the following Zombienet CLI command:\n\n```bash\nzombienet setup polkadot polkadot-parachain\n```\n\nThis command downloads the following binaries:\n\n- `polkadot`\n- `polkadot-execute-worker`\n- `polkadot-parachain`\n- `polkadot-prepare-worker`\n\nFinally, add these binaries to your PATH environment variable to ensure Zombienet can locate them when spawning the network.\n\nFor example, you can move the binaries to a directory in your PATH, such as `/usr/local/bin`:\n\n```bash\nsudo mv ./polkadot ./polkadot-execute-worker ./polkadot-parachain ./polkadot-prepare-worker /usr/local/bin\n```"}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 3, "depth": 2, "title": "Define the Network", "anchor": "define-the-network", "start_char": 2341, "end_char": 3372, "estimated_token_count": 247, "token_estimator": "heuristic-v1", "text": "## Define the Network\n\nZombienet uses a [configuration file](/develop/toolkit/parachains/spawn-chains/zombienet/get-started/#configuration-files){target=\\_blank} to define the ephemeral network that will be spawned. Follow these steps to create and define the configuration file:\n\n1. Create a file named `spawn-a-basic-network.toml`:\n\n    ```bash\n    touch spawn-a-basic-network.toml\n    ```\n\n2. Add the following code to the file you just created:\n\n    ```toml title=\"spawn-a-basic-network.toml\"\n    [settings]\n    timeout = 120\n\n    [relaychain]\n\n    [[relaychain.nodes]]\n    name = \"alice\"\n    validator = true\n\n    [[relaychain.nodes]]\n    name = \"bob\"\n    validator = true\n\n    [[parachains]]\n    id = 100\n\n    [parachains.collator]\n    name = \"collator01\"\n\n    ```\n\nThis configuration file defines a network with the following chains:\n\n- **relaychain**: With two nodes named `alice` and `bob`.\n- **parachain**: With a collator named `collator01`.\n\nSettings also defines a timeout of 120 seconds for the network to be ready."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 4, "depth": 2, "title": "Spawn the Network", "anchor": "spawn-the-network", "start_char": 3372, "end_char": 6748, "estimated_token_count": 1132, "token_estimator": "heuristic-v1", "text": "## Spawn the Network\n\nTo spawn the network, run the following command:\n\n```bash\nzombienet -p native spawn spawn-a-basic-network.toml\n```\n\nThis command will spawn the network defined in the `spawn-a-basic-network.toml` configuration file. The `-p native` flag specifies that the network will be spawned using the native provider.\n\nIf successful, you will see the following output:\n\n<div id=\"termynal\" class=\"table-termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>zombienet -p native spawn spawn-a-basic-network.toml</span>\n  <table>\n    <thead>\n      <tr>\n        <th colspan=\"2\" class=\"center-header\">Network launched 🚀🚀</th>\n      </tr>\n    </thead>\n    <tr>\n      <th class=\"left-header\">Namespace</th>\n      <td>zombie-75a01b93c92d571f6198a67bcb380fcd</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Provider</th>\n      <td>native</td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" class=\"center-header\">Node Information</th>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Name</th>\n      <td>alice</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Direct Link</th>\n      <td><a href=\"https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer\">https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer</a></td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Prometheus Link</th>\n      <td>http://127.0.0.1:55310/metrics</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Log Cmd</th>\n      <td>tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/alice.log</td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" class=\"center-header\">Node Information</th>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Name</th>\n      <td>bob</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Direct Link</th>\n      <td><a href=\"https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:50312#explorer\">https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55312#explorer</a></td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Prometheus Link</th>\n      <td>http://127.0.0.1:50634/metrics</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Log Cmd</th>\n      <td>tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/bob.log</td>\n    </tr>\n    <tr>\n      <th colspan=\"3\" class=\"center-header\">Node Information</th>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Name</th>\n      <td>collator01</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Direct Link</th>\n      <td><a href=\"https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55316#explorer\">https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55316#explorer</a></td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Prometheus Link</th>\n      <td>http://127.0.0.1:55318/metrics</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Log Cmd</th>\n      <td>tail -f /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/collator01.log</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">Parachain ID</th>\n      <td>100</td>\n    </tr>\n    <tr>\n      <th class=\"left-header\">ChainSpec Path</th>\n      <td>/tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/100-rococo-local.json</td>\n    </tr>\n  </table>\n</div>\n\n!!! note \n    If the IPs and ports aren't explicitly defined in the configuration file, they may change each time the network is started, causing the links provided in the output to differ from the example."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 5, "depth": 2, "title": "Interact with the Spawned Network", "anchor": "interact-with-the-spawned-network", "start_char": 6748, "end_char": 7010, "estimated_token_count": 68, "token_estimator": "heuristic-v1", "text": "## Interact with the Spawned Network\n\nAfter the network is launched, you can interact with it using [Polkadot.js Apps](https://polkadot.js.org/apps/){target=\\_blank}. To do so, open your browser and use the provided links listed by the output as `Direct Link`."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 6, "depth": 3, "title": "Connect to the Nodes", "anchor": "connect-to-the-nodes", "start_char": 7010, "end_char": 8354, "estimated_token_count": 365, "token_estimator": "heuristic-v1", "text": "### Connect to the Nodes\n\nUse the [55308 port address](https://polkadot.js.org/apps/?rpc=ws://127.0.0.1:55308#explorer){target=\\_blank} to interact with the same `alice` node used for this tutorial. Ports can change from spawn to spawn so be sure to locate the link in the output when spawning your own node to ensure you are accessing the correct port.\n\nIf you want to interact with the nodes more programmatically, you can also use the [Polkadot.js API](https://polkadot.js.org/docs/api/){target=\\_blank}. For example, the following code snippet shows how to connect to the `alice` node using the Polkadot.js API and log some information about the chain and node:\n\n```typescript\nimport { ApiPromise, WsProvider } from '@polkadot/api';\n\nasync function main() {\n  const wsProvider = new WsProvider('ws://127.0.0.1:55308');\n  const api = await ApiPromise.create({ provider: wsProvider });\n\n  // Retrieve the chain & node information via rpc calls\n  const [chain, nodeName, nodeVersion] = await Promise.all([\n    api.rpc.system.chain(),\n    api.rpc.system.name(),\n    api.rpc.system.version(),\n  ]);\n\n  console.log(\n    `You are connected to chain ${chain} using ${nodeName} v${nodeVersion}`\n  );\n}\n\nmain()\n  .catch(console.error)\n  .finally(() => process.exit());\n\n```\n\nBoth methods allow you to interact easily with the network and its nodes."}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 7, "depth": 3, "title": "Check Metrics", "anchor": "check-metrics", "start_char": 8354, "end_char": 8901, "estimated_token_count": 132, "token_estimator": "heuristic-v1", "text": "### Check Metrics\n\nYou can also check the metrics of the nodes by accessing the links provided in the output as `Prometheus Link`. [Prometheus](https://prometheus.io/){target=\\_blank} is a monitoring and alerting toolkit that collects metrics from the nodes. By accessing the provided links, you can see the metrics of the nodes in a web interface. So, for example, the following image shows the Prometheus metrics for Bob's node from the Zombienet test:\n\n![](/images/tutorials/polkadot-sdk/testing/spawn-basic-chain/spawn-basic-network-01.webp)"}
{"page_id": "tutorials-polkadot-sdk-testing-spawn-basic-chain", "page_title": "Spawn a Basic Chain with Zombienet", "index": 8, "depth": 3, "title": "Check Logs", "anchor": "check-logs", "start_char": 8901, "end_char": 9572, "estimated_token_count": 152, "token_estimator": "heuristic-v1", "text": "### Check Logs\n\nTo view individual node logs, locate the `Log Cmd` command in Zombienet's startup output. For example, to see what the alice node is doing, find the log command that references `alice.log` in its file path. Note that Zombienet will show you the correct path for your instance when it starts up, so use that path rather than copying from the below example:\n\n```bash\ntail -f  /tmp/zombie-794af21178672e1ff32c612c3c7408dc_-2397036-6717MXDxcS55/alice.log\n```\n\nAfter running this command, you will see the logs of the `alice` node in real-time, which can be useful for debugging purposes. The logs of the `bob` and `collator01` nodes can be checked similarly."}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 191, "end_char": 857, "estimated_token_count": 131, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nDecentralized exchanges (DEXs) are a cornerstone of the DeFi ecosystem, allowing for permissionless token swaps without intermediaries. [Uniswap V2](https://docs.uniswap.org/contracts/v2/overview){target=\\_blank}, with its Automated Market Maker (AMM) model, revolutionized DEXs by enabling liquidity provision for any ERC-20 token pair.\n\nThis tutorial will guide you through how Uniswap V2 works so you can take advantage of it in your projects deployed to Polkadot Hub. By understanding these contracts, you'll gain hands-on experience with one of the most influential DeFi protocols and understand how it functions across blockchain ecosystems."}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 857, "end_char": 1352, "estimated_token_count": 121, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore starting, make sure you have:\n\n- Node.js (v16.0.0 or later) and npm installed.\n- Basic understanding of Solidity and JavaScript.\n- Familiarity with [`hardhat-polkadot`](/develop/smart-contracts/dev-environments/hardhat){target=\\_blank} development environment.\n- Some PAS test tokens to cover transaction fees (obtained from the [Polkadot faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}).\n- Basic understanding of how AMMs and liquidity pools work."}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 2, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 1352, "end_char": 3690, "estimated_token_count": 572, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nLet's start by cloning the Uniswap V2 project:\n\n1. Clone the Uniswap V2 repository:\n\n    ```\n    git clone https://github.com/polkadot-developers/polkavm-hardhat-examples.git -b v0.0.6\n    cd polkavm-hardhat-examples/uniswap-v2-polkadot/\n    ```\n\n2. Install the required dependencies:\n\n    ```bash\n    npm install\n    ```\n\n3. Update the `hardhat.config.js` file so the paths for the Substrate node and the ETH-RPC adapter match with the paths on your machine. For more info, check the [Testing your Contract](/develop/smart-contracts/dev-environments/hardhat/#testing-your-contract){target=\\_blank} section in the Hardhat guide.\n\n    ```js title=\"hardhat.config.js\"\n    hardhat: {\n      polkavm: true,\n      nodeConfig: {\n        nodeBinaryPath: '../bin/substrate-node',\n        rpcPort: 8000,\n        dev: true,\n      },\n      adapterConfig: {\n        adapterBinaryPath: '../bin/eth-rpc',\n        dev: true,\n      },\n    },\n    ```\n\n4. Create a `.env` file in your project root to store your private keys (you can use as an example the `env.example` file):\n\n    ```text title=\".env\"\n    LOCAL_PRIV_KEY=\"INSERT_LOCAL_PRIVATE_KEY\"\n    AH_PRIV_KEY=\"INSERT_AH_PRIVATE_KEY\"\n    ```\n\n    Ensure to replace `\"INSERT_LOCAL_PRIVATE_KEY\"` with a private key available in the local environment (you can get them from this [file](https://github.com/paritytech/hardhat-polkadot/blob/main/packages/hardhat-polkadot-node/src/constants.ts#L22){target=\\_blank}). And `\"INSERT_AH_PRIVATE_KEY\"` with the account's private key you want to use to deploy the contracts. You can get this by exporting the private key from your wallet (e.g., MetaMask).\n\n    !!!warning\n        Keep your private key safe, and never share it with anyone. If it is compromised, your funds can be stolen.\n\n5. Compile the contracts:\n\n    ```bash\n    npx hardhat compile\n    ```\n\nIf the compilation is successful, you should see the following output:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat compile</span>\n  <span data-ty>Compiling 12 Solidity files</span>\n  <span data-ty>Successfully compiled 12 Solidity files</span>\n</div>\n\nAfter running the above command, you should see the compiled contracts in the `artifacts-pvm` directory. This directory contains the ABI and bytecode of your contracts."}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 3, "depth": 2, "title": "Understanding Uniswap V2 Architecture", "anchor": "understanding-uniswap-v2-architecture", "start_char": 3690, "end_char": 6042, "estimated_token_count": 527, "token_estimator": "heuristic-v1", "text": "## Understanding Uniswap V2 Architecture\n\nBefore interacting with the contracts, it's essential to understand the core architecture that powers Uniswap V2. This model forms the basis of nearly every modern DEX implementation and operates under automated market making, token pair liquidity pools, and deterministic pricing principles.\n\nAt the heart of Uniswap V2 lies a simple but powerful system composed of two major smart contracts:\n\n- **Factory contract**: The factory acts as a registry and creator of new trading pairs. When two ERC-20 tokens are to be traded, the Factory contract is responsible for generating a new Pair contract that will manage that specific token pair’s liquidity pool. It keeps track of all deployed pairs and ensures uniqueness—no duplicate pools can exist for the same token combination.\n- **Pair contract**: Each pair contract is a decentralized liquidity pool that holds reserves of two ERC-20 tokens. These contracts implement the core logic of the AMM, maintaining a constant product invariant (x \\* y = k) to facilitate swaps and price determination. Users can contribute tokens to these pools in return for LP (liquidity provider) tokens, which represent their proportional share of the reserves.\n\nThis minimal architecture enables Uniswap to be highly modular, trustless, and extensible. By distributing responsibilities across these components, developers, and users can engage with the protocol in a composable and predictable manner, making it an ideal foundation for DEX functionality across ecosystems, including Polkadot Hub.\n\nThe project scaffolding is as follows:\n\n```bash\nuniswap-V2-polkadot\n├── bin/\n├── contracts/\n│   ├── interfaces/\n│   │   ├── IERC20.sol\n│   │   ├── IUniswapV2Callee.sol\n│   │   ├── IUniswapV2ERC20.sol\n│   │   ├── IUniswapV2Factory.sol\n│   │   └── IUniswapV2Pair.sol\n│   ├── libraries/\n│   │   ├── Math.sol\n│   │   ├── SafeMath.sol\n│   │   └── UQ112x112.sol\n│   ├── test/\n│   │   └── ERC20.sol\n│   ├── UniswapV2ERC20.sol\n│   ├── UniswapV2Factory.sol\n│   └── UniswapV2Pair.sol\n├── ignition/\n├── scripts/\n│   └── deploy.js\n├── node_modules/\n├── test/\n│   ├── shared/\n│   │   ├── fixtures.js\n│   │   └── utilities.js\n│   ├── UniswapV2ERC20.js\n│   ├── UniswapV2Factory.js\n│   └── UniswapV2Pair.js\n├── .env.example\n├── .gitignore\n├── hardhat.config.js\n├── package.json\n└── README.md\n```"}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 4, "depth": 2, "title": "Test the Contracts", "anchor": "test-the-contracts", "start_char": 6042, "end_char": 8640, "estimated_token_count": 788, "token_estimator": "heuristic-v1", "text": "## Test the Contracts\n\nYou can run the provided test suite to ensure the contracts are working as expected. The tests cover various scenarios, including creating pairs, adding liquidity, and executing swaps.\n\nTo test it locally, you can run the following commands:\n\n1. Spawn a local node for testing:\n\n    ```bash\n    npx hardhat node\n    ```\n\n    This command will spawn a local Substrate node along with the ETH-RPC adapter. The node will be available at `ws://127.0.0.1:8000` and the ETH-RPC adapter at `http://localhost:8545`.\n\n2. In a new terminal, run the tests:\n\n    ```bash\n    npx hardhat test --network localNode\n    ```\n\nThe result should look like this:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat test --network localNode</span>\n  <span data-ty>Compiling 12 Solidity files</span>\n  <span data-ty>Successfully compiled 12 Solidity files</span>\n  <span data-ty></span>\n  <span data-ty>UniswapV2ERC20</span>\n  <span data-ty> ✔ name, symbol, decimals, totalSupply, balanceOf, DOMAIN_SEPARATOR, PERMIT_TYPEHASH (44ms)</span>\n  <span data-ty> ✔ approve (5128ms)</span>\n  <span data-ty> ✔ transfer (5133ms)</span>\n  <span data-ty> ✔ transfer:fail</span>\n  <span data-ty> ✔ transferFrom (6270ms)</span>\n  <span data-ty> ✔ transferFrom:max (6306ms)</span>\n  <span data-ty></span>\n  <span data-ty>UniswapV2Factory</span>\n  <span data-ty> ✔ feeTo, feeToSetter, allPairsLength</span>\n  <span data-ty> ✔ createPair (176ms)</span>\n  <span data-ty> ✔ createPair:reverse (1224ms)</span>\n  <span data-ty> ✔ setFeeTo (1138ms)</span>\n  <span data-ty> ✔ setFeeToSetter (1125ms)</span>\n  <span data-ty></span>\n  <span data-ty>UniswapV2Pair</span>\n  <span data-ty> ✔ mint (11425ms)</span>\n  <span data-ty> ✔ getInputPrice:0 (12590ms)</span>\n  <span data-ty> ✔ getInputPrice:1 (17600ms)</span>\n  <span data-ty> ✔ getInputPrice:2 (17618ms)</span>\n  <span data-ty> ✔ getInputPrice:3 (17704ms)</span>\n  <span data-ty> ✔ getInputPrice:4 (17649ms)</span>\n  <span data-ty> ✔ getInputPrice:5 (17594ms)</span>\n  <span data-ty> ✔ getInputPrice:6 (13643ms)</span>\n  <span data-ty> ✔ optimistic:0 (17647ms)</span>\n  <span data-ty> ✔ optimistic:1 (17946ms)</span>\n  <span data-ty> ✔ optimistic:2 (17657ms)</span>\n  <span data-ty> ✔ optimistic:3 (21625ms)</span>\n  <span data-ty> ✔ swap:token0 (12665ms)</span>\n  <span data-ty> ✔ swap:token1 (17631ms)</span>\n  <span data-ty> ✔ burn (17690ms)</span>\n  <span data-ty> ✔ feeTo:off (23900ms)</span>\n  <span data-ty> ✔ feeTo:on (24991ms)</span>\n  <span data-ty></span>\n  <span data-ty>28 passing (12m)</span>\n</div>"}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 5, "depth": 2, "title": "Deploy the Contracts", "anchor": "deploy-the-contracts", "start_char": 8640, "end_char": 10383, "estimated_token_count": 379, "token_estimator": "heuristic-v1", "text": "## Deploy the Contracts\n\nAfter successfully testing the contracts, you can deploy them to the local node or Polkadot Hub. The deployment script is located in the `scripts` directory and is named `deploy.js`. This script deploys the `Factory` and `Pair` contracts to the network.\n\nTo deploy the contracts, run the following command:\n\n```bash\nnpx hardhat run scripts/deploy.js --network localNode\n```\n\nThis command deploys the contracts to your local blockchain for development and testing. If you want to deploy to Polkadot Hub, you can use the following command:\n\n```bash\nnpx hardhat run scripts/deploy.js --network passetHub\n```\n\nThe command above deploys to the actual Polkadot TestNet. It requires PAS test tokens, persists on the network, and operates under real network conditions.\n\nThe deployment script will output the addresses of the deployed contracts. Save these addresses, as you will need them to interact with the contracts. For example, the output should look like this:\n\n<div id=\"termynal\" data-termynal>\n  <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat run scripts/deploy.js --network localNode</span>\n  <span data-ty>Successfully compiled 12 Solidity files</span>\n  <span data-ty>Deploying contracts using 0xf24FF3a9CF04c71Dbc94D0b566f7A27B94566cac</span>\n  <span data-ty>Deploying UniswapV2ERC20...</span>\n  <span data-ty>ETH deployed to : 0x7acc1aC65892CF3547b1b0590066FB93199b430D</span>\n  <span data-ty>Deploying UniswapV2Factory...</span>\n  <span data-ty>Factory deployed to : 0x85b108660f47caDfAB9e0503104C08C1c96e0DA9</span>\n  <span data-ty>Deploying UniswapV2Pair with JsonRpcProvider workaround...</span>\n  <span data-ty>Pair deployed to : 0xF0e46847c8bFD122C4b5EEE1D4494FF7C5FC5104</span>\n</div>"}
{"page_id": "tutorials-smart-contracts-demo-aplications-deploying-uniswap-v2", "page_title": "Deploying Uniswap V2 on Polkadot", "index": 6, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 10383, "end_char": 11288, "estimated_token_count": 152, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nThis tutorial guided you through deploying Uniswap V2 contracts to Polkadot Hub. This implementation brings the powerful AMM architecture to the Polkadot ecosystem, laying the foundation for the decentralized trading of ERC-20 token pairs.\n\nBy following this guide, you've gained practical experience with:\n\n- Setting up a Hardhat project for deploying to Polkadot Hub.\n- Understanding the Uniswap V2 architecture.\n- Testing Uniswap V2 contracts in a local environment.\n- Deploying contracts to both local and testnet environments.\n\nTo build on this foundation, you could extend this project by implementing functionality to create liquidity pools, execute token swaps, and build a user interface for interacting with your deployment.\n\nThis knowledge can be leveraged to build more complex DeFi applications or to integrate Uniswap V2 functionality into your existing projects on Polkadot."}
{"page_id": "tutorials-smart-contracts-deploy-erc20", "page_title": "Deploy an ERC-20 to Polkadot Hub", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 206, "end_char": 858, "estimated_token_count": 159, "token_estimator": "heuristic-v1", "text": "## Introduction\n\n[ERC-20](https://eips.ethereum.org/EIPS/eip-20){target=\\_blank} tokens are fungible tokens commonly used for creating cryptocurrencies, governance tokens, and staking mechanisms. Polkadot Hub enables easy token deployment with Ethereum-compatible smart contracts via PolkaVM.\n\nThis tutorial covers deploying an ERC-20 contract on the Polkadot Hub TestNet using [Polkadot Remix IDE](https://remix.polkadot.io){target=\\_blank}, a web-based development tool. [OpenZeppelin's ERC-20 contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0/contracts/token/ERC20){target=\\_blank} are used for security and compliance."}
{"page_id": "tutorials-smart-contracts-deploy-erc20", "page_title": "Deploy an ERC-20 to Polkadot Hub", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 858, "end_char": 1469, "estimated_token_count": 160, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore starting, make sure you have:\n\n- [MetaMask](https://metamask.io/){target=\\_blank} installed and connected to Polkadot Hub. For detailed instructions, see the [Connect Your Wallet](/develop/smart-contracts/wallets){target=\\_blank} section.\n- A funded account with some PAS tokens (you can get them from the [Polkadot Faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}). To learn how to get test tokens, check out the [Test Tokens](/develop/smart-contracts/connect-to-polkadot#test-tokens){target=\\_blank} section.\n- Basic understanding of Solidity and fungible tokens."}
{"page_id": "tutorials-smart-contracts-deploy-erc20", "page_title": "Deploy an ERC-20 to Polkadot Hub", "index": 2, "depth": 2, "title": "Create the ERC-20 Contract", "anchor": "create-the-erc-20-contract", "start_char": 1469, "end_char": 4897, "estimated_token_count": 815, "token_estimator": "heuristic-v1", "text": "## Create the ERC-20 Contract\n\nTo create the ERC-20 contract, you can follow the steps below:\n\n1. Navigate to the [Polkadot Remix IDE](https://remix.polkadot.io){target=\\_blank}.\n2. Click in the **Create new file** button under the **contracts** folder, and name your contract as `MyToken.sol`.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-1.webp)\n\n3. Now, paste the following ERC-20 contract code into the editor:\n\n    ```solidity title=\"MyToken.sol\"\n    // SPDX-License-Identifier: MIT\n    // Compatible with OpenZeppelin Contracts ^5.0.0\n    pragma solidity ^0.8.22;\n\n    import {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n    import {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n    contract MyToken is ERC20, Ownable {\n        constructor(address initialOwner)\n            ERC20(\"MyToken\", \"MTK\")\n            Ownable(initialOwner)\n        {}\n\n        function mint(address to, uint256 amount) public onlyOwner {\n            _mint(to, amount);\n        }\n    }\n    ```\n\n    The key components of the code above are:\n\n    - Contract imports:\n\n        - **[`ERC20.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0/contracts/token/ERC20/ERC20.sol){target=\\_blank}**: The base contract for fungible tokens, implementing core functionality like transfers, approvals, and balance tracking.\n        - **[`Ownable.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0/contracts/access/Ownable.sol){target=\\_blank}**: Provides basic authorization control, ensuring only the contract owner can mint new tokens.\n    \n    - Constructor parameters:\n\n        - **`initialOwner`**: Sets the address that will have administrative rights over the contract.\n        - **`\"MyToken\"`**: The full name of your token.\n        - **`\"MTK\"`**: The symbol representing your token in wallets and exchanges.\n\n    - Key functions:\n\n        - **`mint(address to, uint256 amount)`**: Allows the contract owner to create new tokens for any address. The amount should include 18 decimals (e.g., 1 token = 1000000000000000000).\n        - Inherited [Standard ERC-20](https://ethereum.org/en/developers/docs/standards/tokens/erc-20/){target=\\_blank} functions:\n            - **`transfer(address recipient, uint256 amount)`**: Sends a specified amount of tokens to another address.\n            - **`approve(address spender, uint256 amount)`**: Grants permission for another address to spend a specific number of tokens on behalf of the token owner.\n            - **`transferFrom(address sender, address recipient, uint256 amount)`**: Transfers tokens from one address to another, if previously approved.\n            - **`balanceOf(address account)`**: Returns the token balance of a specific address.\n            - **`allowance(address owner, address spender)`**: Checks how many tokens an address is allowed to spend on behalf of another address.\n\n    !!! tip\n        Use the [OpenZeppelin Contracts Wizard](https://wizard.openzeppelin.com/){target=\\_blank} to quickly generate customized smart contracts. Simply configure your contract, copy the generated code, and paste it into Polkadot Remix IDE for deployment. Below is an example of an ERC-20 token contract created with it:\n\n        ![Screenshot of the OpenZeppelin Contracts Wizard showing an ERC-20 contract configuration.](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-2.webp)"}
{"page_id": "tutorials-smart-contracts-deploy-erc20", "page_title": "Deploy an ERC-20 to Polkadot Hub", "index": 3, "depth": 2, "title": "Compile the Contract", "anchor": "compile-the-contract", "start_char": 4897, "end_char": 5722, "estimated_token_count": 192, "token_estimator": "heuristic-v1", "text": "## Compile the Contract\n\nThe compilation transforms your Solidity source code into bytecode that can be deployed on the blockchain. During this process, the compiler checks your contract for syntax errors, ensures type safety, and generates the machine-readable instructions needed for blockchain execution. To compile your contract, follow the instructions below:\n\n1. Select the **Solidity Compiler** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-3.webp)\n\n2. Click the **Compile MyToken.sol** button.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-4.webp)\n\n3. If the compilation succeeded, you'll see a green checkmark indicating success in the **Solidity Compiler** icon.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-5.webp)"}
{"page_id": "tutorials-smart-contracts-deploy-erc20", "page_title": "Deploy an ERC-20 to Polkadot Hub", "index": 4, "depth": 2, "title": "Deploy the Contract", "anchor": "deploy-the-contract", "start_char": 5722, "end_char": 7281, "estimated_token_count": 375, "token_estimator": "heuristic-v1", "text": "## Deploy the Contract\n\nDeployment is the process of publishing your compiled smart contract to the blockchain, making it permanently available for interaction. During deployment, you'll create a new instance of your contract on the blockchain, which involves:\n\n1. Select the **Deploy & Run Transactions** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-6.webp)\n\n2. Configure the deployment settings.\n    1. From the **ENVIRONMENT** dropdown, select **Injected Provider - Talisman** (check the [Deploying Contracts](/develop/smart-contracts/dev-environments/remix/#deploying-contracts){target=\\_blank} section of the Remix IDE guide for more details).\n    2. From the **ACCOUNT** dropdown, select the account you want to use for the deploy.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-7.webp)\n\n3. Configure the contract parameters:\n\n    1. Enter the address that will own the deployed token contract.\n    2. Click the **Deploy** button to initiate the deployment.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-8.webp)\n\n4. **Talisman will pop up**: Review the transaction details. Click **Approve** to deploy your contract.\n\n     ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-9.webp){: .browser-extension}\n\n    If the deployment process succeeded, you will see the transaction details in the terminal, including the contract address and deployment transaction hash:\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-10.webp)"}
{"page_id": "tutorials-smart-contracts-deploy-erc20", "page_title": "Deploy an ERC-20 to Polkadot Hub", "index": 5, "depth": 2, "title": "Interact with Your ERC-20 Contract", "anchor": "interact-with-your-erc-20-contract", "start_char": 7281, "end_char": 8740, "estimated_token_count": 355, "token_estimator": "heuristic-v1", "text": "## Interact with Your ERC-20 Contract\n\nOnce deployed, you can interact with your contract through Remix:\n\n1. Find your contract under **Deployed/Unpinned Contracts**, and click it to expand the available methods.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-11.webp)\n\n2. To mint new tokens:\n\n    1. Click in the contract to expand its associated methods.\n    2. Expand the **mint** function.\n    3. Enter:\n        - The recipient address.\n        - The amount (remember to add 18 zeros for 1 whole token).\n    4. Click **Transact**.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-12.webp)\n\n3. Click **Approve** to confirm the transaction in the Talisman popup.\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-13.webp){: .browser-extension}\n\n    If the transaction succeeds, you will see the following output in the terminal:\n\n    ![](/images/tutorials/smart-contracts/deploy-erc20/deploy-erc20-14.webp)\n\nOther common functions you can use:\n\n- **`balanceOf(address)`**: Check token balance of any address.\n- **`transfer(address to, uint256 amount)`**: Send tokens to another address.\n- **`approve(address spender, uint256 amount)`**: Allow another address to spend your tokens.\n\nFeel free to explore and interact with the contract's other functions using the same approach - selecting the method, providing any required parameters, and confirming the transaction through Talisman when needed."}
{"page_id": "tutorials-smart-contracts-deploy-nft", "page_title": "Deploy an NFT to Polkadot Hub", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 203, "end_char": 925, "estimated_token_count": 165, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nNon-Fungible Tokens (NFTs) represent unique digital assets commonly used for digital art, collectibles, gaming, and identity verification. Polkadot Hub supports Ethereum-compatible smart contracts through PolkaVM, enabling straightforward NFT deployment.\n\nThis tutorial guides you through deploying an [ERC-721](https://eips.ethereum.org/EIPS/eip-721){target=\\_blank} NFT contract on the Polkadot Hub TestNet using the [Polkadot Remix IDE](https://remix.polkadot.io){target=\\_blank}, a web-based development environment. To ensure security and standard compliance, it uses [OpenZeppelin's NFT contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v5.4.0){target=\\_blank} implementation."}
{"page_id": "tutorials-smart-contracts-deploy-nft", "page_title": "Deploy an NFT to Polkadot Hub", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 925, "end_char": 1683, "estimated_token_count": 198, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore starting, make sure you have:\n\n- [Talisman](https://talisman.xyz/){target=\\_blank} installed and connected to the Polkadot Hub TestNet. Check the [Connect to Polkadot](/develop/smart-contracts/connect-to-polkadot/){target=\\_blank} guide for more information.\n- A funded account with some PAS tokens (you can get them from the [Faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank}, noting that the faucet imposes a daily token limit, which may require multiple requests to obtain sufficient funds for testing).\n- Basic understanding of Solidity and NFTs, see the [Solidity Basics](https://soliditylang.org/){target=\\_blank} and the [NFT Overview](https://ethereum.org/en/nft/){target=\\_blank} guides for more details."}
{"page_id": "tutorials-smart-contracts-deploy-nft", "page_title": "Deploy an NFT to Polkadot Hub", "index": 2, "depth": 2, "title": "Create the NFT Contract", "anchor": "create-the-nft-contract", "start_char": 1683, "end_char": 5729, "estimated_token_count": 937, "token_estimator": "heuristic-v1", "text": "## Create the NFT Contract\n\nTo create the NFT contract, you can follow the steps below:\n\n1. Navigate to the [Polkadot Remix IDE](https://remix.polkadot.io/){target=\\_blank}.\n2. Click in the **Create new file** button under the **contracts** folder, and name your contract as `MyNFT.sol`.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-1.webp)\n\n3. Now, paste the following NFT contract code into the editor.\n\n    ```solidity title=\"MyNFT.sol\"\n    // SPDX-License-Identifier: MIT\n    // Compatible with OpenZeppelin Contracts ^5.0.0\n    pragma solidity ^0.8.22;\n\n    import {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n    import {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n    contract MyToken is ERC721, Ownable {\n        uint256 private _nextTokenId;\n\n        constructor(address initialOwner)\n            ERC721(\"MyToken\", \"MTK\")\n            Ownable(initialOwner)\n        {}\n\n        function safeMint(address to) public onlyOwner {\n            uint256 tokenId = _nextTokenId++;\n            _safeMint(to, tokenId);\n        }\n    }\n    ```\n\n    The key components of the code above are:\n\n    - Contract imports:\n\n        - **[`ERC721.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/token/ERC721/ERC721.sol){target=\\_blank}**: The base contract for non-fungible tokens, implementing core NFT functionality like transfers and approvals.\n        - **[`Ownable.sol`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/access/Ownable.sol){target=\\_blank}**: Provides basic authorization control, ensuring only the contract owner can mint new tokens.\n    \n    - Constructor parameters:\n\n        - **`initialOwner`**: Sets the address that will have administrative rights over the contract.\n        - **`\"MyToken\"`**: The full name of your NFT collection.\n        - **`\"MTK\"`**: The symbol representing your token in wallets and marketplaces.\n\n    - Key functions:\n\n        - **[`_safeMint(to, tokenId)`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/token/ERC721/ERC721.sol#L304){target=\\_blank}**: An internal function from `ERC721` that safely mints new tokens. It includes checks to ensure the recipient can handle `ERC721` tokens, with the `_nextTokenId` mechanism automatically generating unique sequential token IDs and the `onlyOwner` modifier restricting minting rights to the contract owner.\n        - Inherited [Standard ERC721](https://ethereum.org/en/developers/docs/standards/tokens/erc-721/){target=\\_blank} functions provide a standardized set of methods that enable interoperability across different platforms, wallets, and marketplaces, ensuring that your NFT can be easily transferred, traded, and managed by any system that supports the `ERC721` standard:\n            - **`transferFrom(address from, address to, uint256 tokenId)`**: Transfers a specific NFT from one address to another.\n            - **`safeTransferFrom(address from, address to, uint256 tokenId)`**: Safely transfers an NFT, including additional checks to prevent loss.\n            - **`approve(address to, uint256 tokenId)`**: Grants permission for another address to transfer a specific NFT.\n            - **`setApprovalForAll(address operator, bool approved)`**: Allows an address to manage all of the owner's NFTs.\n            - **`balanceOf(address owner)`**: Returns the number of NFTs owned by a specific address.\n            - **`ownerOf(uint256 tokenId)`**: Returns the current owner of a specific NFT.\n\n    !!! tip\n        Use the [OpenZeppelin Contracts Wizard](https://wizard.openzeppelin.com/){target=\\_blank} to generate customized smart contracts quickly. Simply configure your contract, copy the generated code, and paste it into Polkadot Remix IDE for deployment. Below is an example of an ERC-721 token contract created with it:\n\n        ![Screenshot of the OpenZeppelin Contracts Wizard showing an ERC-721 contract configuration.](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-2.webp)"}
{"page_id": "tutorials-smart-contracts-deploy-nft", "page_title": "Deploy an NFT to Polkadot Hub", "index": 3, "depth": 2, "title": "Compile the Contract", "anchor": "compile-the-contract", "start_char": 5729, "end_char": 6502, "estimated_token_count": 184, "token_estimator": "heuristic-v1", "text": "## Compile the Contract\n\nCompilation is a stage that converts your Solidity source code into bytecode suitable for deployment on the blockchain. Throughout this process, the compiler examines your contract for syntax errors, verifies type safety, and produces machine-readable instructions for execution on the blockchain.\n\n1. Select the **Solidity Compiler** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-3.webp)\n\n2. Click in the **Compile MyNFT.sol** button.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-4.webp)\n\n3. If the compilation succeeded, you can see a green checkmark indicating success in the **Solidity Compiler** icon.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-5.webp)"}
{"page_id": "tutorials-smart-contracts-deploy-nft", "page_title": "Deploy an NFT to Polkadot Hub", "index": 4, "depth": 2, "title": "Deploy the Contract", "anchor": "deploy-the-contract", "start_char": 6502, "end_char": 8381, "estimated_token_count": 445, "token_estimator": "heuristic-v1", "text": "## Deploy the Contract\n\nDeployment is the process of uploading your compiled smart contract to the blockchain, allowing for interaction. During deployment, you will instantiate your contract on the blockchain, which involves:\n\n1. Select the **Deploy & Run Transactions** plugin from the left panel.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-6.webp)\n\n2. Configure the deployment settings:\n\n    1. From the **ENVIRONMENT** dropdown, select **Injected Provider - Talisman** (check the [Deploying Contracts](/develop/smart-contracts/dev-environments/remix/#deploying-contracts){target=\\_blank} section of the Remix IDE guide for more details).\n    2. From the **ACCOUNT** dropdown, select the account you want to use for the deploy.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-7.webp)\n\n3. Configure the contract parameters:\n\n    1. Enter the address that will own the deployed NFT.\n    2. Click the **Deploy** button to initiate the deployment.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-8.webp)\n\n4. **Talisman will pop up**: Review the transaction details. Click **Approve** to deploy your contract.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-9.webp){: .browser-extension}\n\n    Deploying this contract requires paying gas fees in PAS tokens on the Polkadot Hub TestNet. Ensure your Talisman account is funded with sufficient PAS tokens from the faucet before confirming the transaction, check the [Test Tokens](/develop/smart-contracts/connect-to-polkadot/#test-tokens){target=\\_blank} section for more information. Gas fees cover the computational resources needed to deploy and execute the smart contract on the blockchain.\n\n    If the deployment process succeeded, you will see the following output in the terminal:\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-10.webp)"}
{"page_id": "tutorials-smart-contracts-deploy-nft", "page_title": "Deploy an NFT to Polkadot Hub", "index": 5, "depth": 2, "title": "Interact with Your NFT Contract", "anchor": "interact-with-your-nft-contract", "start_char": 8381, "end_char": 9623, "estimated_token_count": 291, "token_estimator": "heuristic-v1", "text": "## Interact with Your NFT Contract\n\nOnce deployed, you can interact with your contract through Remix:\n\n1. Find your contract under **Deployed/Unpinned Contracts**, and click it to expand the available methods for the contract.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-11.webp)\n\n2. To mint an NFT:\n\n    1. Click on the contract to expand its associated methods.\n    2. Expand the **safeMint** function.\n    3. Enter the recipient address.\n    4. Click **Transact**.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-12.webp)\n\n3. Click **Approve** to confirm the transaction in the Talisman popup.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-13.webp){: .browser-extension}\n\n    If the transaction is successful, the terminal will display the following output, which details the information about the transaction, including the transaction hash, the block number, the associated logs, and so on.\n\n    ![](/images/tutorials/smart-contracts/deploy-nft/deploy-nft-14.webp)\n\nFeel free to explore and interact with the contract's other functions using the same approach - selecting the method, providing any required parameters, and confirming the transaction through Talisman when needed."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "page_title": "Create a Smart Contract", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 197, "end_char": 815, "estimated_token_count": 123, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nCreating [smart contracts](/develop/smart-contracts/overview/){target=\\_blank} is fundamental to blockchain development. While many frameworks and tools are available, understanding how to write a contract from scratch with just a text editor is essential knowledge.\n\nThis tutorial will guide you through creating a basic smart contract that can be used with other tutorials for deployment and integration on Polkadot Hub. To understand how smart contracts work in Polkadot Hub, check the [Smart Contract Basics](/polkadot-protocol/smart-contract-basics/){target=\\_blank} guide for more information."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "page_title": "Create a Smart Contract", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 815, "end_char": 1267, "estimated_token_count": 119, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore starting, make sure you have:\n\n- A text editor of your choice ([VS Code](https://code.visualstudio.com/){target=\\_blank}, [Sublime Text](https://www.sublimetext.com/){target=\\_blank}, etc.).\n- Basic understanding of programming concepts.\n- Familiarity with the Solidity programming language syntax. For further references, check the official [Solidity documentation](https://docs.soliditylang.org/en/latest/){target=\\_blank}."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "page_title": "Create a Smart Contract", "index": 2, "depth": 2, "title": "Understanding Smart Contract Structure", "anchor": "understanding-smart-contract-structure", "start_char": 1267, "end_char": 2249, "estimated_token_count": 216, "token_estimator": "heuristic-v1", "text": "## Understanding Smart Contract Structure\n\nLet's explore these components before building the contract:\n\n- **[SPDX license identifier](https://docs.soliditylang.org/en/v0.6.8/layout-of-source-files.html){target=\\_blank}**: A standardized way to declare the license under which your code is released. This helps with legal compliance and is required by the Solidity compiler to avoid warnings.\n- **Pragma directive**: Specifies which version of Solidity compiler should be used for your contract.\n- **Contract declaration**: Similar to a class in object-oriented programming, it defines the boundaries of your smart contract.\n- **State variables**: Data stored directly in the contract that persists between function calls. These represent the contract's \"state\" on the blockchain.\n- **Functions**: Executable code that can read or modify the contract's state variables.\n- **Events**: Notification mechanisms that applications can subscribe to in order to track blockchain changes."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "page_title": "Create a Smart Contract", "index": 3, "depth": 2, "title": "Create the Smart Contract", "anchor": "create-the-smart-contract", "start_char": 2249, "end_char": 5735, "estimated_token_count": 680, "token_estimator": "heuristic-v1", "text": "## Create the Smart Contract\n\nIn this section, you'll build a simple storage contract step by step. This basic Storage contract is a great starting point for beginners. It introduces key concepts like state variables, functions, and events in a simple way, demonstrating how data is stored and updated on the blockchain. Later, you'll explore each component in more detail to understand what's happening behind the scenes.\n\nThis contract will:\n\n- Store a number.\n- Allow updating the stored number.\n- Emit an event when the number changes.\n\nTo build the smart contract, follow the steps below:\n\n1. Create a new file named `Storage.sol`.\n\n2. Add the SPDX license identifier at the top of the file:\n\n    ```solidity\n    // SPDX-License-Identifier: MIT\n    ```\n\n    This line tells users and tools which license governs your code. The [MIT license](https://opensource.org/license/mit){target=\\_blank} is commonly used for open-source projects. The Solidity compiler requires this line to avoid licensing-related warnings.\n\n3. Specify the Solidity version:\n\n    ```solidity\n    pragma solidity ^0.8.28;\n    ```\n\n    The caret `^` means \"this version or any compatible newer version.\" This helps ensure your contract compiles correctly with the intended compiler features.\n\n4. Create the contract structure:\n\n    ```solidity\n    contract Storage {\n        // Contract code will go here\n    }\n    ```\n\n    This defines a contract named \"Storage\", similar to how you would define a class in other programming languages.\n\n5. Add the state variables and event:\n\n    ```solidity\n    contract Storage {\n        // State variable to store a number\n        uint256 private number;\n        \n        // Event to notify when the number changes\n        event NumberChanged(uint256 newNumber);\n    }\n    ```\n\n    Here, you're defining:\n\n    - A state variable named `number` of type `uint256` (unsigned integer with 256 bits), which is marked as `private` so it can only be accessed via functions within this contract.\n    - An event named `NumberChanged` that will be triggered whenever the number changes. The event includes the new value as data.\n\n6. Add the getter and setter functions:\n\n    ```solidity\n    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.28;\n\n    contract Storage {\n        // State variable to store our number\n        uint256 private number;\n\n        // Event to notify when the number changes\n        event NumberChanged(uint256 newNumber);\n\n        // Function to store a new number\n        function store(uint256 newNumber) public {\n            number = newNumber;\n            emit NumberChanged(newNumber);\n        }\n\n        // Function to retrieve the stored number\n        function retrieve() public view returns (uint256) {\n            return number;\n        }\n    }\n    ```\n\n??? code \"Complete Storage.sol contract\"\n\n    ```solidity title=\"Storage.sol\"\n    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.28;\n\n    contract Storage {\n        // State variable to store our number\n        uint256 private number;\n\n        // Event to notify when the number changes\n        event NumberChanged(uint256 newNumber);\n\n        // Function to store a new number\n        function store(uint256 newNumber) public {\n            number = newNumber;\n            emit NumberChanged(newNumber);\n        }\n\n        // Function to retrieve the stored number\n        function retrieve() public view returns (uint256) {\n            return number;\n        }\n    }\n    ```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "page_title": "Create a Smart Contract", "index": 4, "depth": 2, "title": "Understanding the Code", "anchor": "understanding-the-code", "start_char": 5735, "end_char": 8302, "estimated_token_count": 524, "token_estimator": "heuristic-v1", "text": "## Understanding the Code\n\nLet's break down the key components of the contract:\n\n- **State Variable**\n\n    - **`uint256 private number`**: A private variable that can only be accessed through the contract's functions.\n    - The `private` keyword prevents direct access from other contracts, but it's important to note that while other contracts cannot read this variable directly, the data itself is still visible on the blockchain and can be read by external tools or applications that interact with the blockchain. \"Private\" in Solidity doesn't mean the data is encrypted or truly hidden.\n    - State variables in Solidity are permanent storage on the blockchain, making them different from variables in traditional programming. Every change to a state variable requires a transaction and costs gas (the fee paid for blockchain operations).\n\n- **Event**\n\n    - **`event NumberChanged(uint256 newNumber)`**: Emitted when the stored number changes.\n    - When triggered, events write data to the blockchain's log, which can be efficiently queried by applications.\n    - Unlike state variables, events cannot be read by smart contracts, only by external applications.\n    - Events are much more gas-efficient than storing data when you only need to notify external systems of changes.\n\n- **Functions**\n\n    - **`store(uint256 newNumber)`**: Updates the stored number and emits an event.\n        - This function changes the state of the contract and requires a transaction to execute.\n        - The `emit` keyword is used to trigger the defined event.\n\n    - **`retrieve()`**: Returns the current stored number.\n        - The `view` keyword indicates that this function only reads data and doesn't modify the contract's state.\n        - View functions don't require a transaction and don't cost gas when called externally.\n\n    For those new to Solidity, this naming pattern (getter/setter functions) is a common design pattern. Instead of directly accessing state variables, the convention is to use functions to control access and add additional logic if needed.\n\nThis basic contract serves as a foundation for learning smart contract development. Real-world contracts often require additional security considerations, more complex logic, and thorough testing before deployment.\n\nFor more detailed information about Solidity types, functions, and best practices, refer to the [Solidity documentation](https://docs.soliditylang.org/en/latest/){target=\\_blank} or this [beginner's guide to Solidity](https://www.tutorialspoint.com/solidity/index.htm){target=\\_blank}."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-contracts", "page_title": "Create a Smart Contract", "index": 5, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 8302, "end_char": 8670, "estimated_token_count": 98, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge tutorial\">Tutorial</span> __Test and Deploy with Hardhat__\n\n    ---\n\n    Learn how to test and deploy the smart contract you created by using Hardhat.\n\n    [:octicons-arrow-right-24: Get Started](/tutorials/smart-contracts/launch-your-first-project/test-and-deploy-with-hardhat/)\n\n</div>"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 202, "end_char": 1019, "estimated_token_count": 167, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nDecentralized applications (dApps) have become a cornerstone of the Web3 ecosystem, allowing developers to create applications that interact directly with blockchain networks. Polkadot Hub, a blockchain that supports smart contract functionality, provides an excellent platform for deploying and interacting with dApps.\n\nIn this tutorial, you'll build a complete dApp that interacts with a smart contract deployed on the Polkadot Hub TestNet. It will use [Ethers.js](/develop/smart-contracts/libraries/ethers-js){target=\\_blank} to interact with the blockchain and [Next.js](https://nextjs.org/){target=\\_blank} as the frontend framework. By the end of this tutorial, you'll have a functional dApp that allows users to connect their wallets, read data from the blockchain, and execute transactions."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 1019, "end_char": 1479, "estimated_token_count": 111, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore you begin, make sure you have:\n\n- [Node.js](https://nodejs.org/en){target=\\_blank} v16 or newer installed on your machine.\n- A crypto wallet (like MetaMask) with some test tokens. For further information, check the [Connect to Polkadot](/develop/smart-contracts/connect-to-polkadot){target=\\_blank} guide.\n- Basic understanding of React and JavaScript.\n- Familiarity with blockchain concepts and Solidity (helpful but not mandatory)."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 2, "depth": 2, "title": "Project Overview", "anchor": "project-overview", "start_char": 1479, "end_char": 2676, "estimated_token_count": 301, "token_estimator": "heuristic-v1", "text": "## Project Overview\n\nThe dApp will interact with a simple Storage contract. For a step-by-step guide on creating it, refer to the [Create Contracts](/tutorials/smart-contracts/launch-your-first-project/create-contracts){target=\\_blank} tutorial. This contract allows:\n\n- Reading a stored number from the blockchain.\n- Updating the stored number with a new value.\n\nThe contract has already been deployed to the Polkadot Hub TestNet for testing purposes: `0x58053f0e8ede1a47a1af53e43368cd04ddcaf66f`. If you want to deploy your own, follow the [Deploying Contracts](/develop/smart-contracts/dev-environments/remix/#deploying-contracts){target=\\_blank} section.\n\nHere's a simplified view of what you'll be building:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-ethers-js/create-dapp-ethers-js-1.webp)\n\nThe general structure of the project should end up as follows:\n\n```bash\nethers-dapp\n├── abis\n│   └── Storage.json\n└── app\n    ├── components\n    │   ├── ReadContract.js\n    │   ├── WalletConnect.js\n    │   └── WriteContract.js\n    ├── favicon.ico\n    ├── globals.css\n    ├── layout.js\n    ├── page.js\n    └── utils\n        ├── contract.js\n        └── ethers.js\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 3, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 2676, "end_char": 2923, "estimated_token_count": 77, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nLet's start by creating a new Next.js project:\n\n```bash\nnpx create-next-app ethers-dapp --js --eslint --tailwind --app --yes\ncd ethers-dapp\n```\n\nNext, install the needed dependencies:\n\n```bash\nnpm install ethers@6.13.5\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 4, "depth": 2, "title": "Connect to Polkadot Hub", "anchor": "connect-to-polkadot-hub", "start_char": 2923, "end_char": 4631, "estimated_token_count": 417, "token_estimator": "heuristic-v1", "text": "## Connect to Polkadot Hub\n\nTo interact with the Polkadot Hub, you need to set up an [Ethers.js Provider](/develop/smart-contracts/libraries/ethers-js/#set-up-the-ethersjs-provider){target=\\_blank} that connects to the blockchain. In this example, you will interact with the Polkadot Hub TestNet, so you can experiment safely. Start by creating a new file called `utils/ethers.js` and add the following code:\n\n```javascript title=\"app/utils/ethers.js\"\nimport { JsonRpcProvider } from 'ethers';\n\nexport const PASSET_HUB_CONFIG = {\n  name: 'Passet Hub',\n  rpc: 'https://testnet-passet-hub-eth-rpc.polkadot.io/', // Passet Hub testnet RPC\n  chainId: 420420422, // Passet Hub testnet chainId\n  blockExplorer: 'https://blockscout-passet-hub.parity-testnet.parity.io/',\n};\n\nexport const getProvider = () => {\n  return new JsonRpcProvider(PASSET_HUB_CONFIG.rpc, {\n    chainId: PASSET_HUB_CONFIG.chainId,\n    name: PASSET_HUB_CONFIG.name,\n  });\n};\n\n// Helper to get a signer from a provider\nexport const getSigner = async (provider) => {\n  if (window.ethereum) {\n    await window.ethereum.request({ method: 'eth_requestAccounts' });\n    const ethersProvider = new ethers.BrowserProvider(window.ethereum);\n    return ethersProvider.getSigner();\n  }\n  throw new Error('No Ethereum browser provider detected');\n};\n```\n\nThis file establishes a connection to the Polkadot Hub TestNet and provides helper functions for obtaining a [Provider](https://docs.ethers.org/v5/api/providers/provider/){target=_blank} and [Signer](https://docs.ethers.org/v5/api/signer/){target=_blank}. The provider allows you to read data from the blockchain, while the signer enables users to send transactions and modify the blockchain state."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 5, "depth": 2, "title": "Set Up the Smart Contract Interface", "anchor": "set-up-the-smart-contract-interface", "start_char": 4631, "end_char": 6548, "estimated_token_count": 403, "token_estimator": "heuristic-v1", "text": "## Set Up the Smart Contract Interface\n\nFor this dApp, you'll use a simple Storage contract already deployed. So, you need to create an interface to interact with it. First, ensure to create a folder called `abis` at the root of your project, create a file `Storage.json`, and paste the corresponding ABI (Application Binary Interface) of the Storage contract. You can copy and paste the following:\n\n???+ code \"Storage.sol ABI\"\n\n    ```json title=\"abis/Storage.json\"\n    [\n        {\n            \"inputs\": [\n                {\n                    \"internalType\": \"uint256\",\n                    \"name\": \"_newNumber\",\n                    \"type\": \"uint256\"\n                }\n            ],\n            \"name\": \"setNumber\",\n            \"outputs\": [],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [],\n            \"name\": \"storedNumber\",\n            \"outputs\": [\n                {\n                    \"internalType\": \"uint256\",\n                    \"name\": \"\",\n                    \"type\": \"uint256\"\n                }\n            ],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        }\n    ]\n    ```\n\nNow, create a file called `app/utils/contract.js`:\n\n```javascript title=\"app/utils/contract.js\"\nimport { Contract } from 'ethers';\nimport { getProvider } from './ethers';\nimport StorageABI from '../../abis/Storage.json';\n\nexport const CONTRACT_ADDRESS = '0x58053f0e8ede1a47a1af53e43368cd04ddcaf66f';\n\nexport const CONTRACT_ABI = StorageABI;\n\nexport const getContract = () => {\n  const provider = getProvider();\n  return new Contract(CONTRACT_ADDRESS, CONTRACT_ABI, provider);\n};\n\nexport const getSignedContract = async (signer) => {\n  return new Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);\n};\n```\n\nThis file defines the contract address, ABI, and functions to create instances of the contract for reading and writing."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 6, "depth": 2, "title": "Create the Wallet Connection Component", "anchor": "create-the-wallet-connection-component", "start_char": 6548, "end_char": 12876, "estimated_token_count": 1445, "token_estimator": "heuristic-v1", "text": "## Create the Wallet Connection Component\n\nNext, let's create a component to handle wallet connections. Create a new file called `app/components/WalletConnect.js`:\n\n```javascript title=\"app/components/WalletConnect.js\"\n'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { PASSET_HUB_CONFIG } from '../utils/ethers';\n\nconst WalletConnect = ({ onConnect }) => {\n  const [account, setAccount] = useState(null);\n  const [chainId, setChainId] = useState(null);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Check if user already has an authorized wallet connection\n    const checkConnection = async () => {\n      if (window.ethereum) {\n        try {\n          // eth_accounts doesn't trigger the wallet popup\n          const accounts = await window.ethereum.request({\n            method: 'eth_accounts',\n          });\n          if (accounts.length > 0) {\n            setAccount(accounts[0]);\n            const chainIdHex = await window.ethereum.request({\n              method: 'eth_chainId',\n            });\n            setChainId(parseInt(chainIdHex, 16));\n          }\n        } catch (err) {\n          console.error('Error checking connection:', err);\n          setError('Failed to check wallet connection');\n        }\n      }\n    };\n\n    checkConnection();\n\n    if (window.ethereum) {\n      // Setup wallet event listeners\n      window.ethereum.on('accountsChanged', (accounts) => {\n        setAccount(accounts[0] || null);\n        if (accounts[0] && onConnect) onConnect(accounts[0]);\n      });\n\n      window.ethereum.on('chainChanged', (chainIdHex) => {\n        setChainId(parseInt(chainIdHex, 16));\n      });\n    }\n\n    return () => {\n      // Cleanup event listeners\n      if (window.ethereum) {\n        window.ethereum.removeListener('accountsChanged', () => {});\n        window.ethereum.removeListener('chainChanged', () => {});\n      }\n    };\n  }, [onConnect]);\n\n  const connectWallet = async () => {\n    if (!window.ethereum) {\n      setError(\n        'MetaMask not detected! Please install MetaMask to use this dApp.'\n      );\n      return;\n    }\n\n    try {\n      // eth_requestAccounts triggers the wallet popup\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts',\n      });\n      setAccount(accounts[0]);\n\n      const chainIdHex = await window.ethereum.request({\n        method: 'eth_chainId',\n      });\n      const currentChainId = parseInt(chainIdHex, 16);\n      setChainId(currentChainId);\n\n      // Prompt user to switch networks if needed\n      if (currentChainId !== PASSET_HUB_CONFIG.chainId) {\n        await switchNetwork();\n      }\n\n      if (onConnect) onConnect(accounts[0]);\n    } catch (err) {\n      console.error('Error connecting to wallet:', err);\n      setError('Failed to connect wallet');\n    }\n  };\n\n  const switchNetwork = async () => {\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: `0x${PASSET_HUB_CONFIG.chainId.toString(16)}` }],\n      });\n    } catch (switchError) {\n      // Error 4902 means the chain hasn't been added to MetaMask\n      if (switchError.code === 4902) {\n        try {\n          await window.ethereum.request({\n            method: 'wallet_addEthereumChain',\n            params: [\n              {\n                chainId: `0x${PASSET_HUB_CONFIG.chainId.toString(16)}`,\n                chainName: PASSET_HUB_CONFIG.name,\n                rpcUrls: [PASSET_HUB_CONFIG.rpc],\n                blockExplorerUrls: [PASSET_HUB_CONFIG.blockExplorer],\n              },\n            ],\n          });\n        } catch (addError) {\n          setError('Failed to add network to wallet');\n        }\n      } else {\n        setError('Failed to switch network');\n      }\n    }\n  };\n\n  // UI-only disconnection - MetaMask doesn't support programmatic disconnection\n  const disconnectWallet = () => {\n    setAccount(null);\n  };\n\n  return (\n    <div className=\"border border-pink-500 rounded-lg p-4 shadow-md bg-white text-pink-500 max-w-sm mx-auto\">\n      {error && <p className=\"text-red-500 text-sm mb-2\">{error}</p>}\n\n      {!account ? (\n        <button\n          onClick={connectWallet}\n          className=\"w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg transition\"\n        >\n          Connect Wallet\n        </button>\n      ) : (\n        <div className=\"flex flex-col items-center\">\n          <span className=\"text-sm font-mono bg-pink-100 px-2 py-1 rounded-md text-pink-700\">\n            {`${account.substring(0, 6)}...${account.substring(38)}`}\n          </span>\n          <button\n            onClick={disconnectWallet}\n            className=\"mt-3 w-full bg-gray-200 hover:bg-gray-300 text-pink-500 py-2 px-4 rounded-lg transition\"\n          >\n            Disconnect\n          </button>\n          {chainId !== PASSET_HUB_CONFIG.chainId && (\n            <button\n              onClick={switchNetwork}\n              className=\"mt-3 w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition\"\n            >\n              Switch to Passet Hub\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default WalletConnect;\n```\n\nThis component handles connecting to the wallet, switching networks if necessary, and keeping track of the connected account. \n\nTo integrate this component to your dApp, you need to overwrite the existing boilerplate in `app/page.js` with the following code:\n\n```javascript title=\"app/page.js\"\n\nimport { useState } from 'react';\n\nimport WalletConnect from './components/WalletConnect';\nexport default function Home() {\n  const [account, setAccount] = useState(null);\n\n  const handleConnect = (connectedAccount) => {\n    setAccount(connectedAccount);\n  };\n\n  return (\n    <section className=\"min-h-screen bg-white text-black flex flex-col justify-center items-center gap-4 py-10\">\n      <h1 className=\"text-2xl font-semibold text-center\">\n        Ethers.js dApp - Passet Hub Smart Contracts\n      </h1>\n      <WalletConnect onConnect={handleConnect} />\n</section>\n  );\n}\n```\n\nIn your terminal, you can launch your project by running:\n\n```bash\nnpm run dev\n```\n\nAnd you will see the following:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-ethers-js/create-dapp-ethers-js-2.webp)"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 7, "depth": 2, "title": "Read Data from the Blockchain", "anchor": "read-data-from-the-blockchain", "start_char": 12876, "end_char": 16092, "estimated_token_count": 805, "token_estimator": "heuristic-v1", "text": "## Read Data from the Blockchain\n\nNow, let's create a component to read data from the contract. Create a file called `app/components/ReadContract.js`:\n\n```javascript title=\"app/components/ReadContract.js\"\n'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { getContract } from '../utils/contract';\n\nconst ReadContract = () => {\n  const [storedNumber, setStoredNumber] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Function to read data from the blockchain\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const contract = getContract();\n        // Call the smart contract's storedNumber function\n        const number = await contract.storedNumber();\n        setStoredNumber(number.toString());\n        setError(null);\n      } catch (err) {\n        console.error('Error fetching stored number:', err);\n        setError('Failed to fetch data from the contract');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Poll for updates every 10 seconds to keep UI in sync with blockchain\n    const interval = setInterval(fetchData, 10000);\n\n    // Clean up interval on component unmount\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div className=\"border border-pink-500 rounded-lg p-4 shadow-md bg-white text-pink-500 max-w-sm mx-auto\">\n      <h2 className=\"text-lg font-bold text-center mb-4\">Contract Data</h2>\n      {loading ? (\n        <div className=\"flex justify-center my-4\">\n          <div className=\"w-6 h-6 border-4 border-pink-500 border-t-transparent rounded-full animate-spin\"></div>\n        </div>\n      ) : error ? (\n        <p className=\"text-red-500 text-center\">{error}</p>\n      ) : (\n        <div className=\"text-center\">\n          <p className=\"text-sm font-mono bg-pink-100 px-2 py-1 rounded-md text-pink-700\">\n            <strong>Stored Number:</strong> {storedNumber}\n          </p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default ReadContract;\n```\n\nThis component reads the `storedNumber` value from the contract and displays it to the user. It also sets up a polling interval to refresh the data periodically.\n\nTo see this change in your dApp, you need to integrate this component into the `app/page.js` file:\n\n```javascript title=\"app/page.js\"\n\nimport { useState } from 'react';\n\nimport WalletConnect from './components/WalletConnect';\nimport ReadContract from './components/ReadContract';\nexport default function Home() {\n  const [account, setAccount] = useState(null);\n\n  const handleConnect = (connectedAccount) => {\n    setAccount(connectedAccount);\n  };\n\n  return (\n    <section className=\"min-h-screen bg-white text-black flex flex-col justify-center items-center gap-4 py-10\">\n      <h1 className=\"text-2xl font-semibold text-center\">\n        Ethers.js dApp - Passet Hub Smart Contracts\n      </h1>\n      <WalletConnect onConnect={handleConnect} />\n      <ReadContract />\n</section>\n  );\n}\n```\n\nYour dApp will automatically be updated to the following:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-ethers-js/create-dapp-ethers-js-3.webp)"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 8, "depth": 2, "title": "Write Data to the Blockchain", "anchor": "write-data-to-the-blockchain", "start_char": 16092, "end_char": 21164, "estimated_token_count": 1229, "token_estimator": "heuristic-v1", "text": "## Write Data to the Blockchain\n\nFinally, let's create a component that allows users to update the stored number. Create a file called `app/components/WriteContract.js`:\n\n```javascript title=\"app/components/WriteContract.js\"\n'use client';\n\nimport { useState } from 'react';\nimport { getSignedContract } from '../utils/contract';\nimport { ethers } from 'ethers';\n\nconst WriteContract = ({ account }) => {\n  const [newNumber, setNewNumber] = useState('');\n  const [status, setStatus] = useState({ type: null, message: '' });\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n\n    // Validation checks\n    if (!account) {\n      setStatus({ type: 'error', message: 'Please connect your wallet first' });\n      return;\n    }\n\n    if (!newNumber || isNaN(Number(newNumber))) {\n      setStatus({ type: 'error', message: 'Please enter a valid number' });\n      return;\n    }\n\n    try {\n      setIsSubmitting(true);\n      setStatus({ type: 'info', message: 'Initiating transaction...' });\n\n      // Get a signer from the connected wallet\n      const provider = new ethers.BrowserProvider(window.ethereum);\n      const signer = await provider.getSigner();\n      const contract = await getSignedContract(signer);\n\n      // Send transaction to blockchain and wait for user confirmation in wallet\n      setStatus({\n        type: 'info',\n        message: 'Please confirm the transaction in your wallet...',\n      });\n\n      // Call the contract's setNumber function\n      const tx = await contract.setNumber(newNumber);\n\n      // Wait for transaction to be mined\n      setStatus({\n        type: 'info',\n        message: 'Transaction submitted. Waiting for confirmation...',\n      });\n      const receipt = await tx.wait();\n\n      setStatus({\n        type: 'success',\n        message: `Transaction confirmed! Transaction hash: ${receipt.hash}`,\n      });\n      setNewNumber('');\n    } catch (err) {\n      console.error('Error updating number:', err);\n\n      // Error code 4001 is MetaMask's code for user rejection\n      if (err.code === 4001) {\n        setStatus({ type: 'error', message: 'Transaction rejected by user.' });\n      } else {\n        setStatus({\n          type: 'error',\n          message: `Error: ${err.message || 'Failed to send transaction'}`,\n        });\n      }\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <div className=\"border border-pink-500 rounded-lg p-4 shadow-md bg-white text-pink-500 max-w-sm mx-auto space-y-4\">\n      <h2 className=\"text-lg font-bold\">Update Stored Number</h2>\n      {status.message && (\n        <div\n          className={`p-2 rounded-md break-words h-fit text-sm ${\n            status.type === 'error'\n              ? 'bg-red-100 text-red-500'\n              : 'bg-green-100 text-green-700'\n          }`}\n        >\n          {status.message}\n        </div>\n      )}\n      <form onSubmit={handleSubmit} className=\"space-y-4\">\n        <input\n          type=\"number\"\n          placeholder=\"New Number\"\n          value={newNumber}\n          onChange={(e) => setNewNumber(e.target.value)}\n          disabled={isSubmitting || !account}\n          className=\"w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-pink-400\"\n        />\n        <button\n          type=\"submit\"\n          disabled={isSubmitting || !account}\n          className=\"w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-300\"\n        >\n          {isSubmitting ? 'Updating...' : 'Update'}\n        </button>\n      </form>\n      {!account && (\n        <p className=\"text-sm text-gray-500\">\n          Connect your wallet to update the stored number.\n        </p>\n      )}\n    </div>\n  );\n};\n\nexport default WriteContract;\n```\n\nThis component allows users to input a new number and send a transaction to update the value stored in the contract. When the transaction is successful, users will see the stored value update in the `ReadContract` component after the transaction is confirmed.\n\nUpdate the `app/page.js` file to integrate all components:\n\n```javascript title=\"app/page.js\"\n'use client';\n\nimport { useState } from 'react';\n\nimport WalletConnect from './components/WalletConnect';\nimport ReadContract from './components/ReadContract';\nimport WriteContract from './components/WriteContract';\n\nexport default function Home() {\n  const [account, setAccount] = useState(null);\n\n  const handleConnect = (connectedAccount) => {\n    setAccount(connectedAccount);\n  };\n\n  return (\n    <section className=\"min-h-screen bg-white text-black flex flex-col justify-center items-center gap-4 py-10\">\n      <h1 className=\"text-2xl font-semibold text-center\">\n        Ethers.js dApp - Passet Hub Smart Contracts\n      </h1>\n      <WalletConnect onConnect={handleConnect} />\n      <ReadContract />\n      <WriteContract account={account} />\n    </section>\n  );\n}\n```\n\nThe completed UI will display:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-ethers-js/create-dapp-ethers-js-4.webp)"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-ethers-js", "page_title": "Create a dApp With Ethers.js", "index": 9, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 21164, "end_char": 21978, "estimated_token_count": 171, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nCongratulations! You've built a complete dApp that interacts with a smart contract on the Polkadot Hub TestNet using Ethers.js and Next.js. Your application can now:\n\n- Connect to a user's wallet.\n- Read data from a smart contract.\n- Send transactions to update the contract state.\n\nThese fundamental skills provide the foundation for building more complex dApps on Polkadot Hub. With these building blocks, you can extend your application to interact with more sophisticated smart contracts and create more advanced user interfaces.\n\nTo get started right away with a working example, you can clone the repository and navigate to the implementation:\n\n```\ngit clone https://github.com/polkadot-developers/polkavm-storage-contract-dapps.git -b v0.0.2\ncd polkavm-storage-contract-dapps/ethers-dapp\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 0, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 890, "end_char": 1375, "estimated_token_count": 115, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore getting started, ensure you have the following:\n\n- [Node.js](https://nodejs.org/en){target=\\_blank} v16 or later installed on your system.\n- A crypto wallet (such as MetaMask) funded with test tokens. Refer to the [Connect to Polkadot](/develop/smart-contracts/connect-to-polkadot){target=\\_blank} guide for more details.\n- A basic understanding of React and JavaScript.\n- Some familiarity with blockchain fundamentals and Solidity (useful but not required)."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 1, "depth": 2, "title": "Project Overview", "anchor": "project-overview", "start_char": 1375, "end_char": 2276, "estimated_token_count": 235, "token_estimator": "heuristic-v1", "text": "## Project Overview\n\nThis dApp will interact with a basic Storage contract. Refer to the [Create Contracts](/tutorials/smart-contracts/launch-your-first-project/create-contracts){target=\\_blank} tutorial for a step-by-step guide on creating this contract. The contract allows:\n\n- Retrieving a stored number from the blockchain.\n- Updating the stored number with a new value.\n\n\nBelow is a high-level overview of what you'll be building:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-viem/create-dapp-viem-1.webp)\n\nYour project directory will be organized as follows:\n\n```bash\nviem-dapp\n├── abis\n│   └── Storage.json\n└── app\n    ├── components\n    │   ├── ReadContract.tsx\n    │   ├── WalletConnect.tsx\n    │   └── WriteContract.tsx\n    ├── favicon.ico\n    ├── globals.css\n    ├── layout.tsx\n    ├── page.tsx\n    └── utils\n        ├── contract.ts\n        └── viem.ts\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 2, "depth": 2, "title": "Set Up the Project", "anchor": "set-up-the-project", "start_char": 2276, "end_char": 2423, "estimated_token_count": 49, "token_estimator": "heuristic-v1", "text": "## Set Up the Project\n\nCreate a new Next.js project:\n\n```bash\nnpx create-next-app viem-dapp --ts --eslint --tailwind --app --yes\ncd viem-dapp\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 3, "depth": 2, "title": "Install Dependencies", "anchor": "install-dependencies", "start_char": 2423, "end_char": 2567, "estimated_token_count": 38, "token_estimator": "heuristic-v1", "text": "## Install Dependencies\n\nInstall viem and related packages:\n\n```bash\nnpm install viem@2.23.6\nnpm install --save-dev typescript @types/node\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 4, "depth": 2, "title": "Connect to Polkadot Hub", "anchor": "connect-to-polkadot-hub", "start_char": 2567, "end_char": 4571, "estimated_token_count": 491, "token_estimator": "heuristic-v1", "text": "## Connect to Polkadot Hub\n\nTo interact with Polkadot Hub, you need to set up a [Public Client](https://viem.sh/docs/clients/public#public-client){target=\\_blank} that connects to the blockchain. In this example, you will interact with the Polkadot Hub TestNet, so you can experiment safely. Start by creating a new file called `utils/viem.ts` and add the following code:\n\n```typescript title=\"viem.ts\"\nimport { createPublicClient, http, createWalletClient, custom } from 'viem'\nimport 'viem/window';\n\n\nconst transport = http('https://testnet-passet-hub-eth-rpc.polkadot.io')\n\n// Configure the Passet Hub chain\nexport const passetHub = {\n  id: 420420422,\n  name: 'Passet Hub',\n  network: 'passet-hub',\n  nativeCurrency: {\n    decimals: 18,\n    name: 'PAS',\n    symbol: 'PAS',\n  },\n  rpcUrls: {\n    default: {\n      http: ['https://testnet-passet-hub-eth-rpc.polkadot.io'],\n    },\n  },\n} as const\n\n// Create a public client for reading data\nexport const publicClient = createPublicClient({\n  chain: passetHub,\n  transport\n})\n\n// Create a wallet client for signing transactions\nexport const getWalletClient = async () => {\n  if (typeof window !== 'undefined' && window.ethereum) {\n    const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' });\n    return createWalletClient({\n      chain: passetHub,\n      transport: custom(window.ethereum),\n      account,\n    });\n  }\n  throw new Error('No Ethereum browser provider detected');\n};\n```\n\nThis file initializes a viem client, providing helper functions for obtaining a Public Client and a [Wallet Client](https://viem.sh/docs/clients/wallet#wallet-client){target=\\_blank}. The Public Client enables reading blockchain data, while the Wallet Client allows users to sign and send transactions. Also, note that by importing `'viem/window'` the global `window.ethereum` will be typed as an `EIP1193Provider`, check the [`window` Polyfill](https://viem.sh/docs/typescript#window-polyfill){target=\\_blank} reference for more information."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 5, "depth": 2, "title": "Set Up the Smart Contract Interface", "anchor": "set-up-the-smart-contract-interface", "start_char": 4571, "end_char": 7083, "estimated_token_count": 522, "token_estimator": "heuristic-v1", "text": "## Set Up the Smart Contract Interface\n\nFor this dApp, you'll use a simple [Storage contract](/tutorials/smart-contracts/launch-your-first-project/create-contracts){target=\\_blank} that's already deployed in the Polkadot Hub TestNet: `0x58053f0e8ede1a47a1af53e43368cd04ddcaf66f`. To interact with it, you need to define the contract interface.\n\nCreate a folder called `abis` at the root of your project, then create a file named `Storage.json` and paste the corresponding ABI (Application Binary Interface) of the Storage contract. You can copy and paste the following:\n\n??? code \"Storage.sol ABI\"\n    ```json title=\"Storage.json\"\n    [\n        {\n            \"inputs\": [\n                {\n                    \"internalType\": \"uint256\",\n                    \"name\": \"_newNumber\",\n                    \"type\": \"uint256\"\n                }\n            ],\n            \"name\": \"setNumber\",\n            \"outputs\": [],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [],\n            \"name\": \"storedNumber\",\n            \"outputs\": [\n                {\n                    \"internalType\": \"uint256\",\n                    \"name\": \"\",\n                    \"type\": \"uint256\"\n                }\n            ],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        }\n    ]\n    ```\n\nNext, create a file called `utils/contract.ts`:\n\n```typescript title=\"contract.ts\"\nimport { getContract } from 'viem';\nimport { publicClient, getWalletClient } from './viem';\nimport StorageABI from '../../abis/Storage.json';\n\nexport const CONTRACT_ADDRESS = '0x58053f0e8ede1a47a1af53e43368cd04ddcaf66f';\nexport const CONTRACT_ABI = StorageABI;\n\n// Create a function to get a contract instance for reading\nexport const getContractInstance = () => {\n  return getContract({\n    address: CONTRACT_ADDRESS,\n    abi: CONTRACT_ABI,\n    client: publicClient,\n  });\n};\n\n// Create a function to get a contract instance with a signer for writing\nexport const getSignedContract = async () => {\n  const walletClient = await getWalletClient();\n  return getContract({\n    address: CONTRACT_ADDRESS,\n    abi: CONTRACT_ABI,\n    client: walletClient,\n  });\n};\n```\n\nThis file defines the contract address, ABI, and functions to create a viem [contract instance](https://viem.sh/docs/contract/getContract#contract-instances){target=\\_blank} for reading and writing operations. viem's contract utilities ensure a more efficient and type-safe interaction with smart contracts."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 6, "depth": 2, "title": "Create the Wallet Connection Component", "anchor": "create-the-wallet-connection-component", "start_char": 7083, "end_char": 14170, "estimated_token_count": 1627, "token_estimator": "heuristic-v1", "text": "## Create the Wallet Connection Component\n\nNow, let's create a component to handle wallet connections. Create a new file called `components/WalletConnect.tsx`:\n\n```typescript title=\"WalletConnect.tsx\"\n\"use client\";\n\nimport React, { useState, useEffect } from \"react\";\nimport { passetHub } from \"../utils/viem\";\n\ninterface WalletConnectProps {\n  onConnect: (account: string) => void;\n}\n\nconst WalletConnect: React.FC<WalletConnectProps> = ({ onConnect }) => {\n  const [account, setAccount] = useState<string | null>(null);\n  const [chainId, setChainId] = useState<number | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    // Check if user already has an authorized wallet connection\n    const checkConnection = async () => {\n      if (typeof window !== 'undefined' && window.ethereum) {\n        try {\n          // eth_accounts doesn't trigger the wallet popup\n          const accounts = await window.ethereum.request({\n            method: 'eth_accounts',\n          }) as string[];\n          \n          if (accounts.length > 0) {\n            setAccount(accounts[0]);\n            const chainIdHex = await window.ethereum.request({\n              method: 'eth_chainId',\n            }) as string;\n            setChainId(parseInt(chainIdHex, 16));\n            onConnect(accounts[0]);\n          }\n        } catch (err) {\n          console.error('Error checking connection:', err);\n          setError('Failed to check wallet connection');\n        }\n      }\n    };\n\n    checkConnection();\n\n    if (typeof window !== 'undefined' && window.ethereum) {\n      // Setup wallet event listeners\n      window.ethereum.on('accountsChanged', (accounts: string[]) => {\n        setAccount(accounts[0] || null);\n        if (accounts[0]) onConnect(accounts[0]);\n      });\n\n      window.ethereum.on('chainChanged', (chainIdHex: string) => {\n        setChainId(parseInt(chainIdHex, 16));\n      });\n    }\n\n    return () => {\n      // Cleanup event listeners\n      if (typeof window !== 'undefined' && window.ethereum) {\n        window.ethereum.removeListener('accountsChanged', () => {});\n        window.ethereum.removeListener('chainChanged', () => {});\n      }\n    };\n  }, [onConnect]);\n\n  const connectWallet = async () => {\n    if (typeof window === 'undefined' || !window.ethereum) {\n      setError(\n        'MetaMask not detected! Please install MetaMask to use this dApp.'\n      );\n      return;\n    }\n\n    try {\n      // eth_requestAccounts triggers the wallet popup\n      const accounts = await window.ethereum.request({\n        method: 'eth_requestAccounts',\n      }) as string[];\n      \n      setAccount(accounts[0]);\n\n      const chainIdHex = await window.ethereum.request({\n        method: 'eth_chainId',\n      }) as string;\n      \n      const currentChainId = parseInt(chainIdHex, 16);\n      setChainId(currentChainId);\n\n      // Prompt user to switch networks if needed\n      if (currentChainId !== passetHub.id) {\n        await switchNetwork();\n      }\n\n      onConnect(accounts[0]);\n    } catch (err) {\n      console.error('Error connecting to wallet:', err);\n      setError('Failed to connect wallet');\n    }\n  };\n\n  const switchNetwork = async () => {\n    console.log('Switch network')\n    try {\n      await window.ethereum.request({\n        method: 'wallet_switchEthereumChain',\n        params: [{ chainId: `0x${passetHub.id.toString(16)}` }],\n      });\n    } catch (switchError: any) {\n      // Error 4902 means the chain hasn't been added to MetaMask\n      if (switchError.code === 4902) {\n        try {\n          await window.ethereum.request({\n            method: 'wallet_addEthereumChain',\n            params: [\n              {\n                chainId: `0x${passetHub.id.toString(16)}`,\n                chainName: passetHub.name,\n                rpcUrls: [passetHub.rpcUrls.default.http[0]],\n                nativeCurrency: {\n                  name: passetHub.nativeCurrency.name,\n                  symbol: passetHub.nativeCurrency.symbol,\n                  decimals: passetHub.nativeCurrency.decimals,\n                },\n              },\n            ],\n          });\n        } catch (addError) {\n          setError('Failed to add network to wallet');\n        }\n      } else {\n        setError('Failed to switch network');\n      }\n    }\n  };\n\n  // UI-only disconnection - MetaMask doesn't support programmatic disconnection\n  const disconnectWallet = () => {\n    setAccount(null);\n  };\n\n  return (\n    <div className=\"border border-pink-500 rounded-lg p-4 shadow-md bg-white text-pink-500 max-w-sm mx-auto\">\n      {error && <p className=\"text-red-500 text-sm mb-2\">{error}</p>}\n\n      {!account ? (\n        <button\n          onClick={connectWallet}\n          className=\"w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg transition\"\n        >\n          Connect Wallet\n        </button>\n      ) : (\n        <div className=\"flex flex-col items-center\">\n          <span className=\"text-sm font-mono bg-pink-100 px-2 py-1 rounded-md text-pink-700\">\n            {`${account.substring(0, 6)}...${account.substring(38)}`}\n          </span>\n          <button\n            onClick={disconnectWallet}\n            className=\"mt-3 w-full bg-gray-200 hover:bg-gray-300 text-pink-500 py-2 px-4 rounded-lg transition\"\n          >\n            Disconnect\n          </button>\n          {chainId !== passetHub.id && (\n            <button\n              onClick={switchNetwork}\n              className=\"mt-3 w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition\"\n            >\n              Switch to Passet Hub\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default WalletConnect;\n```\n\nThis component handles connecting to the wallet, switching networks if necessary, and keeping track of the connected account. It provides a button for users to connect their wallet and displays the connected account address once connected.\n\nTo use this component in your dApp, replace the existing boilerplate in `app/page.tsx` with the following code:\n\n```typescript title=\"page.tsx\"\n\nimport { useState } from \"react\";\nimport WalletConnect from \"./components/WalletConnect\";\nexport default function Home() {\n  const [account, setAccount] = useState<string | null>(null);\n\n  const handleConnect = (connectedAccount: string) => {\n    setAccount(connectedAccount);\n  };\n\n  return (\n    <section className=\"min-h-screen bg-white text-black flex flex-col justify-center items-center gap-4 py-10\">\n      <h1 className=\"text-2xl font-semibold text-center\">\n        Viem dApp - Passet Hub Smart Contracts\n      </h1>\n      <WalletConnect onConnect={handleConnect} />\n</section>\n  );\n}\n```\n\nNow you're ready to run your dApp. From your project directory, execute:\n\n```bash\nnpm run dev\n```\n\nNavigate to `http://localhost:3000` in your browser, and you should see your dApp with the wallet connection button, the stored number display, and the form to update the number.\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-viem/create-dapp-viem-2.webp)"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 7, "depth": 2, "title": "Create the Read Contract Component", "anchor": "create-the-read-contract-component", "start_char": 14170, "end_char": 17647, "estimated_token_count": 854, "token_estimator": "heuristic-v1", "text": "## Create the Read Contract Component\n\nNow, let's create a component to read data from the contract. Create a file called `components/ReadContract.tsx`:\n\n```typescript title=\"ReadContract.tsx\"\n'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { publicClient } from '../utils/viem';\nimport { CONTRACT_ADDRESS, CONTRACT_ABI } from '../utils/contract';\n\nconst ReadContract: React.FC = () => {\n  const [storedNumber, setStoredNumber] = useState<string | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    // Function to read data from the blockchain\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        // Call the smart contract's storedNumber function\n        const number = await publicClient.readContract({\n            address: CONTRACT_ADDRESS,\n            abi: CONTRACT_ABI,\n            functionName: 'storedNumber',\n            args: [],\n          }) as bigint;\n\n        setStoredNumber(number.toString());\n        setError(null);\n      } catch (err) {\n        console.error('Error fetching stored number:', err);\n        setError('Failed to fetch data from the contract');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n\n    // Poll for updates every 10 seconds to keep UI in sync with blockchain\n    const interval = setInterval(fetchData, 10000);\n\n    // Clean up interval on component unmount\n    return () => clearInterval(interval);\n  }, []);\n\n  return (\n    <div className=\"border border-pink-500 rounded-lg p-4 shadow-md bg-white text-pink-500 max-w-sm mx-auto\">\n      <h2 className=\"text-lg font-bold text-center mb-4\">Contract Data</h2>\n      {loading ? (\n        <div className=\"flex justify-center my-4\">\n          <div className=\"w-6 h-6 border-4 border-pink-500 border-t-transparent rounded-full animate-spin\"></div>\n        </div>\n      ) : error ? (\n        <p className=\"text-red-500 text-center\">{error}</p>\n      ) : (\n        <div className=\"text-center\">\n          <p className=\"text-sm font-mono bg-pink-100 px-2 py-1 rounded-md text-pink-700\">\n            <strong>Stored Number:</strong> {storedNumber}\n          </p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default ReadContract;\n```\n\nThis component reads the `storedNumber` value from the contract and displays it to the user. It also sets up a polling interval to refresh the data periodically, ensuring that the UI stays in sync with the blockchain state.\n\nTo reflect this change in your dApp, incorporate this component into the `app/page.tsx` file.\n\n```typescript title=\"page.tsx\"\n\nimport { useState } from \"react\";\nimport WalletConnect from \"./components/WalletConnect\";\nimport ReadContract from \"./components/ReadContract\";\nexport default function Home() {\n  const [account, setAccount] = useState<string | null>(null);\n\n  const handleConnect = (connectedAccount: string) => {\n    setAccount(connectedAccount);\n  };\n\n  return (\n    <section className=\"min-h-screen bg-white text-black flex flex-col justify-center items-center gap-4 py-10\">\n      <h1 className=\"text-2xl font-semibold text-center\">\n        Viem dApp - Passet Hub Smart Contracts\n      </h1>\n      <WalletConnect onConnect={handleConnect} />\n      <ReadContract />\n</section>\n  );\n}\n```\n\nAnd you will see in your browser:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-viem/create-dapp-viem-3.webp)"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 8, "depth": 2, "title": "Create the Write Contract Component", "anchor": "create-the-write-contract-component", "start_char": 17647, "end_char": 25635, "estimated_token_count": 1808, "token_estimator": "heuristic-v1", "text": "## Create the Write Contract Component\n\nFinally, let's create a component that allows users to update the stored number. Create a file called `components/WriteContract.tsx`:\n\n```typescript title=\"WriteContract.tsx\"\n\"use client\";\n\nimport React, { useState, useEffect } from \"react\";\nimport { publicClient, getWalletClient } from \"../utils/viem\";\nimport { CONTRACT_ADDRESS, CONTRACT_ABI } from \"../utils/contract\";\n\ninterface WriteContractProps {\n  account: string | null;\n}\n\nconst WriteContract: React.FC<WriteContractProps> = ({ account }) => {\n  const [newNumber, setNewNumber] = useState<string>(\"\");\n  const [status, setStatus] = useState<{\n    type: string | null;\n    message: string;\n  }>({\n    type: null,\n    message: \"\",\n  });\n  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);\n  const [isCorrectNetwork, setIsCorrectNetwork] = useState<boolean>(true);\n\n  // Check if the account is on the correct network\n  useEffect(() => {\n    const checkNetwork = async () => {\n      if (!account) return;\n\n      try {\n        // Get the chainId from the public client\n        const chainId = await publicClient.getChainId();\n\n        // Get the user's current chainId from their wallet\n        const walletClient = await getWalletClient();\n        if (!walletClient) return;\n\n        const walletChainId = await walletClient.getChainId();\n\n        // Check if they match\n        setIsCorrectNetwork(chainId === walletChainId);\n      } catch (err) {\n        console.error(\"Error checking network:\", err);\n        setIsCorrectNetwork(false);\n      }\n    };\n\n    checkNetwork();\n  }, [account]);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    // Validation checks\n    if (!account) {\n      setStatus({ type: \"error\", message: \"Please connect your wallet first\" });\n      return;\n    }\n\n    if (!isCorrectNetwork) {\n      setStatus({\n        type: \"error\",\n        message: \"Please switch to the correct network in your wallet\",\n      });\n      return;\n    }\n\n    if (!newNumber || isNaN(Number(newNumber))) {\n      setStatus({ type: \"error\", message: \"Please enter a valid number\" });\n      return;\n    }\n\n    try {\n      setIsSubmitting(true);\n      setStatus({ type: \"info\", message: \"Initiating transaction...\" });\n\n      // Get wallet client for transaction signing\n      const walletClient = await getWalletClient();\n\n      if (!walletClient) {\n        setStatus({ type: \"error\", message: \"Wallet client not available\" });\n        return;\n      }\n\n      // Check if account matches\n      if (\n        walletClient.account?.address.toLowerCase() !== account.toLowerCase()\n      ) {\n        setStatus({\n          type: \"error\",\n          message:\n            \"Connected wallet account doesn't match the selected account\",\n        });\n        return;\n      }\n\n      // Prepare transaction and wait for user confirmation in wallet\n      setStatus({\n        type: \"info\",\n        message: \"Please confirm the transaction in your wallet...\",\n      });\n\n      // Simulate the contract call first\n      console.log('newNumber', newNumber);\n      const { request } = await publicClient.simulateContract({\n        address: CONTRACT_ADDRESS,\n        abi: CONTRACT_ABI,\n        functionName: \"setNumber\",\n        args: [BigInt(newNumber)],\n        account: walletClient.account,\n      });\n\n      // Send the transaction with wallet client\n      const hash = await walletClient.writeContract(request);\n\n      // Wait for transaction to be mined\n      setStatus({\n        type: \"info\",\n        message: \"Transaction submitted. Waiting for confirmation...\",\n      });\n\n      const receipt = await publicClient.waitForTransactionReceipt({\n        hash,\n      });\n\n      setStatus({\n        type: \"success\",\n        message: `Transaction confirmed! Transaction hash: ${receipt.transactionHash}`,\n      });\n\n      setNewNumber(\"\");\n    } catch (err: any) {\n      console.error(\"Error updating number:\", err);\n\n      // Handle specific errors\n      if (err.code === 4001) {\n        // User rejected transaction\n        setStatus({ type: \"error\", message: \"Transaction rejected by user.\" });\n      } else if (err.message?.includes(\"Account not found\")) {\n        // Account not found on the network\n        setStatus({\n          type: \"error\",\n          message:\n            \"Account not found on current network. Please check your wallet is connected to the correct network.\",\n        });\n      } else if (err.message?.includes(\"JSON is not a valid request object\")) {\n        // JSON error - specific to your current issue\n        setStatus({\n          type: \"error\",\n          message:\n            \"Invalid request format. Please try again or contact support.\",\n        });\n      } else {\n        // Other errors\n        setStatus({\n          type: \"error\",\n          message: `Error: ${err.message || \"Failed to send transaction\"}`,\n        });\n      }\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <div className=\"border border-pink-500 rounded-lg p-4 shadow-md bg-white text-pink-500 max-w-sm mx-auto space-y-4\">\n      <h2 className=\"text-lg font-bold\">Update Stored Number</h2>\n\n      {!isCorrectNetwork && account && (\n        <div className=\"p-2 rounded-md bg-yellow-100 text-yellow-700 text-sm\">\n          ⚠️ You are not connected to the correct network. Please switch\n          networks in your wallet.\n        </div>\n      )}\n\n      {status.message && (\n        <div\n          className={`p-2 rounded-md break-words h-fit text-sm ${\n            status.type === \"error\"\n              ? \"bg-red-100 text-red-500\"\n              : status.type === \"success\"\n              ? \"bg-green-100 text-green-700\"\n              : \"bg-blue-100 text-blue-700\"\n          }`}\n        >\n          {status.message}\n        </div>\n      )}\n\n      <form onSubmit={handleSubmit} className=\"space-y-4\">\n        <input\n          type=\"number\"\n          placeholder=\"New Number\"\n          value={newNumber}\n          onChange={(e) => setNewNumber(e.target.value)}\n          disabled={isSubmitting || !account}\n          className=\"w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-pink-400\"\n        />\n        <button\n          type=\"submit\"\n          disabled={\n            isSubmitting || !account || (!isCorrectNetwork && !!account)\n          }\n          className=\"w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg transition disabled:bg-gray-300\"\n        >\n          {isSubmitting ? \"Updating...\" : \"Update\"}\n        </button>\n      </form>\n\n      {!account && (\n        <p className=\"text-sm text-gray-500\">\n          Connect your wallet to update the stored number.\n        </p>\n      )}\n    </div>\n  );\n};\n\nexport default WriteContract;\n```\n\nThis component allows users to input a new number and send a transaction to update the value stored in the contract. It provides appropriate feedback during each step of the transaction process and handles error scenarios.\n\nUpdate the `app/page.tsx` file to integrate all components:\n\n```typescript title=\"page.tsx\"\n\"use client\";\n\nimport { useState } from \"react\";\nimport WalletConnect from \"./components/WalletConnect\";\nimport ReadContract from \"./components/ReadContract\";\nimport WriteContract from \"./components/WriteContract\";\n\nexport default function Home() {\n  const [account, setAccount] = useState<string | null>(null);\n\n  const handleConnect = (connectedAccount: string) => {\n    setAccount(connectedAccount);\n  };\n\n  return (\n    <section className=\"min-h-screen bg-white text-black flex flex-col justify-center items-center gap-4 py-10\">\n      <h1 className=\"text-2xl font-semibold text-center\">\n        Viem dApp - Passet Hub Smart Contracts\n      </h1>\n      <WalletConnect onConnect={handleConnect} />\n      <ReadContract />\n      <WriteContract account={account} />\n    </section>\n  );\n}\n```\nAfter that, you will see:\n\n![](/images/tutorials/smart-contracts/launch-your-first-project/create-dapp-viem/create-dapp-viem-4.webp)"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 9, "depth": 2, "title": "How It Works", "anchor": "how-it-works", "start_char": 25635, "end_char": 26779, "estimated_token_count": 217, "token_estimator": "heuristic-v1", "text": "## How It Works\n\nLet's examine how the dApp interacts with the blockchain:\n\n1. Wallet connection: \n\n    - The `WalletConnect` component uses the browser's Ethereum provider (MetaMask) to connect to the user's wallet.\n    - It handles network switching to ensure the user is connected to the Polkadot Hub TestNet.\n    - Once connected, it provides the user's account address to the parent component.\n\n2. Reading data:\n\n    - The `ReadContract` component uses viem's `readContract` function to call the `storedNumber` view function.\n    - It periodically polls for updates to keep the UI in sync with the blockchain state.\n    - The component displays a loading indicator while fetching data and handles error states.\n\n3. Writing data:\n\n    - The `WriteContract` component uses viem's `writeContract` function to send a transaction to the `setNumber` function.\n    - It ensures the wallet is connected before allowing a transaction.\n    - The component shows detailed feedback during transaction submission and confirmation.\n    - After a successful transaction, the value displayed in the `ReadContract` component will update on the next poll."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 10, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 26779, "end_char": 27636, "estimated_token_count": 175, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nCongratulations! You've successfully built a fully functional dApp that interacts with a smart contract on Polkadot Hub using viem and Next.js. Your application can now:\n\n- Connect to a user's wallet and handle network switching.\n- Read data from a smart contract and keep it updated.\n- Write data to the blockchain through transactions.\n\nThese fundamental skills provide the foundation for building more complex dApps on Polkadot Hub. With this knowledge, you can extend your application to interact with more sophisticated smart contracts and create advanced user interfaces.\n\nTo get started right away with a working example, you can clone the repository and navigate to the implementation:\n\n```\ngit clone https://github.com/polkadot-developers/polkavm-storage-contract-dapps.git -b v0.0.2\ncd polkavm-storage-contract-dapps/viem-dapp\n```"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-create-dapp-viem", "page_title": "Create a dApp With Viem", "index": 11, "depth": 2, "title": "Where to Go Next", "anchor": "where-to-go-next", "start_char": 27636, "end_char": 27950, "estimated_token_count": 81, "token_estimator": "heuristic-v1", "text": "## Where to Go Next\n\n<div class=\"grid cards\" markdown>\n\n-   <span class=\"badge guide\">Guide</span> __Create a dApp with Wagmi__\n\n    ---\n\n    Learn how to build a decentralized application by using the Wagmi framework.\n\n    [:octicons-arrow-right-24: Get Started](/develop/smart-contracts/libraries/wagmi)\n\n</div>"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 0, "depth": 2, "title": "Introduction", "anchor": "introduction", "start_char": 202, "end_char": 841, "estimated_token_count": 136, "token_estimator": "heuristic-v1", "text": "## Introduction\n\nAfter creating a smart contract, the next crucial steps are testing and deployment. Proper testing ensures your contract behaves as expected, while deployment makes your contract available on the blockchain. This tutorial will guide you through using Hardhat, a popular development environment, to test and deploy the `Storage.sol` contract you created in the [Create a Smart Contract](/tutorials/smart-contracts/launch-your-first-project/create-contracts/){target=\\_blank} tutorial. For more information about Hardhat usage, check the [Hardhat guide](/develop/smart-contracts/dev-environments/hardhat/){target=\\_blank}."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 1, "depth": 2, "title": "Prerequisites", "anchor": "prerequisites", "start_char": 841, "end_char": 1367, "estimated_token_count": 147, "token_estimator": "heuristic-v1", "text": "## Prerequisites\n\nBefore starting, make sure you have:\n\n- The [`Storage.sol` contract](/tutorials/smart-contracts/launch-your-first-project/create-contracts/#create-the-smart-contract){target=\\_blank} created in the previous tutorial.\n- [Node.js](https://nodejs.org/){target=\\_blank} (v16.0.0 or later) and npm installed.\n- Basic understanding of JavaScript for writing tests.\n- Some PAS test tokens to cover transaction fees (obtained from the [Polkadot faucet](https://faucet.polkadot.io/?parachain=1111){target=\\_blank})."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 2, "depth": 2, "title": "Setting Up the Development Environment", "anchor": "setting-up-the-development-environment", "start_char": 1367, "end_char": 4508, "estimated_token_count": 706, "token_estimator": "heuristic-v1", "text": "## Setting Up the Development Environment\n\nLet's start by setting up Hardhat for your Storage contract project:\n\n1. Create a new directory for your project and navigate into it:\n\n    ```bash\n    mkdir storage-hardhat\n    cd storage-hardhat\n    ```\n\n2. Initialize a new npm project:\n\n    ```bash\n    npm init -y\n    ```\n\n3. Install `hardhat-polkadot` and all required plugins:\n\n    ```bash\n    npm install --save-dev @parity/hardhat-polkadot@0.1.9 solc@0.8.28\n    ```\n\n    For dependencies compatibility, ensure to install the `@nomicfoundation/hardhat-toolbox` dependency with the `--force` flag:\n\n    ```bash\n    npm install --force @nomicfoundation/hardhat-toolbox \n    ```\n\n5. Initialize a Hardhat project:\n\n    ```bash\n    npx hardhat-polkadot init\n    ```\n\n    Select **Create an empty hardhat.config.js** when prompted.\n\n6. Configure Hardhat by updating the `hardhat.config.js` file:\n\n    ```javascript title=\"hardhat.config.js\"\n    require(\"@nomicfoundation/hardhat-toolbox\");\n\n    require(\"@parity/hardhat-polkadot\");\n\n    const { vars } = require(\"hardhat/config\");\n\n    /** @type import('hardhat/config').HardhatUserConfig */\n    module.exports = {\n      solidity: \"0.8.28\",\n      resolc: {\n        compilerSource: \"npm\",\n      },\n      networks: {\n        hardhat: {\n          polkavm: true,\n          nodeConfig: {\n            nodeBinaryPath: 'INSERT_PATH_TO_SUBSTRATE_NODE',\n            rpcPort: 8000,\n            dev: true,\n          },\n          adapterConfig: {\n            adapterBinaryPath: 'INSERT_PATH_TO_ETH_RPC_ADAPTER',\n            dev: true,\n          },\n        },\n        localNode: {\n          polkavm: true,\n          url: `http://127.0.0.1:8545`,\n        },\n        passetHub: {\n          polkavm: true,\n          url: 'https://testnet-passet-hub-eth-rpc.polkadot.io',\n          accounts: [vars.get(\"PRIVATE_KEY\")],\n        },\n      },\n    };\n    ```\n\n    Ensure that `INSERT_PATH_TO_SUBSTRATE_NODE` and `INSERT_PATH_TO_ETH_RPC_ADAPTER` are replaced with the proper paths to the compiled binaries. \n\n    If you need to build these binaries, follow the [Installation](/develop/smart-contracts/local-development-node#install-the-substrate-node-and-eth-rpc-adapter){target=\\_blank} section on the Local Development Node page.\n\n    The configuration also defines two network settings: \n\n    - **`localNode`**: Runs a PolkaVM instance on `http://127.0.0.1:8545` for local development and testing.\n    - **`passetHub`**: Connects to the the Polkadot Hub TestNet network using a predefined RPC URL and a private key stored in environment variables.\n\n7. Export your private key and save it in your Hardhat environment:\n\n    ```bash\n    npx hardhat vars set PRIVATE_KEY \"INSERT_PRIVATE_KEY\"\n    ```\n\n    Replace `INSERT_PRIVATE_KEY` with your actual private key. \n    \n    For further details on private key exportation, refer to the article [How to export an account's private key](https://support.metamask.io/configure/accounts/how-to-export-an-accounts-private-key/){target=\\_blank}.\n\n    !!! warning\n        Keep your private key safe, and never share it with anyone. If it is compromised, your funds can be stolen."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 3, "depth": 2, "title": "Adding the Smart Contract", "anchor": "adding-the-smart-contract", "start_char": 4508, "end_char": 5883, "estimated_token_count": 293, "token_estimator": "heuristic-v1", "text": "## Adding the Smart Contract\n\n1. Create a new folder called `contracts` and create a `Storage.sol` file. Add the contract code from the previous tutorial:\n\n    ```solidity title=\"Storage.sol\"\n    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.28;\n\n    contract Storage {\n        // State variable to store our number\n        uint256 private number;\n\n        // Event to notify when the number changes\n        event NumberChanged(uint256 newNumber);\n\n        // Function to store a new number\n        function store(uint256 newNumber) public {\n            number = newNumber;\n            emit NumberChanged(newNumber);\n        }\n\n        // Function to retrieve the stored number\n        function retrieve() public view returns (uint256) {\n            return number;\n        }\n    }\n    ```\n\n2. Compile the contract:\n\n    ```bash\n    npx hardhat compile\n    ```\n\n3. If successful, you will see the following output in your terminal:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat compile</span>\n      <span data-ty>Compiling 1 Solidity file</span>\n      <span data-ty>Successfully compiled 1 Solidity file</span>\n    </div>\n\nAfter compilation, the `artifacts-pvm` and `cache-pvm` folders, containing the metadata and binary files of your compiled contract, will be created in the root of your project."}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 4, "depth": 2, "title": "Writing Tests", "anchor": "writing-tests", "start_char": 5883, "end_char": 12369, "estimated_token_count": 1364, "token_estimator": "heuristic-v1", "text": "## Writing Tests\n\nTesting is a critical part of smart contract development. Hardhat makes it easy to write tests in JavaScript using frameworks like [Mocha](https://mochajs.org/){target=\\_blank} and [Chai](https://www.chaijs.com/){target=\\_blank}.\n\n1. Create a folder for testing called `test`. Inside that directory, create a file named `Storage.js` and add the following code:\n\n    ```javascript title=\"Storage.js\" \n\n        // Add your logic here\n    });\n    });\n    ```\n\n    The `beforeEach` hook ensures stateless contract execution by redeploying a fresh instance of the Storage contract before each test case. This approach guarantees that each test starts with a clean and independent contract state by using `ethers.getSigners()` to obtain test accounts and `ethers.getContractFactory('Storage').deploy()` to create a new contract instance.\n\n    Now, you can add custom unit tests to check your contract functionality. Some example tests are available below:\n\n    1. **Initial state verification**: Ensures that the contract starts with a default value of zero, which is a fundamental expectation for the `Storage.sol` contract.\n\n        ```javascript title=\"Storage.js\"\n        it('Should return 0 initially', async function () {\n              expect(await storage.retrieve()).to.equal(0);\n            });\n        ```\n\n        Explanation:\n\n        - Checks the initial state of the contract.\n        - Verifies that a newly deployed contract has a default value of 0.\n        - Confirms the `retrieve()` method works correctly for a new contract.\n\n    2. **Value storage test**: Validate the core functionality of storing and retrieving a value in the contract.\n\n        ```javascript title=\"Storage.js\"\n        it('Should update when store is called', async function () {\n              const testValue = 42;\n              // Store a value\n              await storage.store(testValue);\n              // Check if the value was updated\n              expect(await storage.retrieve()).to.equal(testValue);\n            });\n        ```\n\n        Explanation:\n\n        - Demonstrates the ability to store a specific value.\n        - Checks that the stored value can be retrieved correctly.\n        - Verifies the basic write and read functionality of the contract.\n\n    3. **Event emission verification**: Confirm that the contract emits the correct event when storing a value, which is crucial for off-chain tracking.\n\n        ```javascript title=\"Storage.js\"\n        it('Should emit an event when storing a value', async function () {\n              const testValue = 100;\n              // Check if the NumberChanged event is emitted with the correct value\n              await expect(storage.store(testValue))\n                .to.emit(storage, 'NumberChanged')\n                .withArgs(testValue);\n            });\n        ```\n\n        Explanation:\n\n        - Ensures the `NumberChanged` event is emitted during storage.\n        - Verifies that the event contains the correct stored value.\n        - Validates the contract's event logging mechanism.\n\n    4. **Sequential value storage test**: Check the contract's ability to store multiple values sequentially and maintain the most recent value.\n\n        ```javascript title=\"Storage.js\"\n        it('Should allow storing sequentially increasing values', async function () {\n              const values = [10, 20, 30, 40];\n\n              for (const value of values) {\n                await storage.store(value);\n                expect(await storage.retrieve()).to.equal(value);\n              }\n            });\n        ```\n\n        Explanation:\n\n        - Verifies that multiple values can be stored in sequence.\n        - Confirms that each new store operation updates the contract's state.\n        - Demonstrates the contract's ability always to reflect the most recently stored value.\n\n    The complete `test/Storage.js` should look like this:\n\n    ???--- code \"View complete script\"\n        ```javascript title=\"Storage.js\"\n        const { expect } = require('chai');\n        const { ethers } = require('hardhat');\n\n        describe('Storage', function () {\n          let storage;\n          let owner;\n          let addr1;\n\n          beforeEach(async function () {\n            // Get signers\n            [owner, addr1] = await ethers.getSigners();\n\n            // Deploy the Storage contract\n            const Storage = await ethers.getContractFactory('Storage');\n            storage = await Storage.deploy();\n            await storage.waitForDeployment();\n          });\n\n          describe('Basic functionality', function () {\n            it('Should return 0 initially', async function () {\n              expect(await storage.retrieve()).to.equal(0);\n            });\n\n            it('Should update when store is called', async function () {\n              const testValue = 42;\n              // Store a value\n              await storage.store(testValue);\n              // Check if the value was updated\n              expect(await storage.retrieve()).to.equal(testValue);\n            });\n\n            it('Should emit an event when storing a value', async function () {\n              const testValue = 100;\n              // Check if the NumberChanged event is emitted with the correct value\n              await expect(storage.store(testValue))\n                .to.emit(storage, 'NumberChanged')\n                .withArgs(testValue);\n            });\n\n            it('Should allow storing sequentially increasing values', async function () {\n              const values = [10, 20, 30, 40];\n\n              for (const value of values) {\n                await storage.store(value);\n                expect(await storage.retrieve()).to.equal(value);\n              }\n            });\n          });\n        });\n        ```\n\n2. Run the tests:\n\n    ```bash\n    npx hardhat test\n    ```\n\n3. After running the above command, you will see the output showing that all tests have passed:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat test</span>\n      <span data-ty>Storage</span>\n      <span data-ty>Basic functionality</span>\n      <span data-ty> ✔ Should return 0 initially</span>\n      <span data-ty> ✔ Should update when store is called (1126ms)</span>\n      <span data-ty> ✔ Should emit an event when storing a value (1131ms)</span>\n      <span data-ty> ✔ Should allow storing sequentially increasing values (12477ms)</span>\n      <span data-ty>4 passing (31s) </span>\n    </div>"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 5, "depth": 2, "title": "Deploying with Ignition", "anchor": "deploying-with-ignition", "start_char": 12369, "end_char": 15589, "estimated_token_count": 786, "token_estimator": "heuristic-v1", "text": "## Deploying with Ignition\n\n[Hardhat's Ignition](https://hardhat.org/ignition/docs/getting-started#overview){target=\\_blank} is a deployment system designed to make deployments predictable and manageable. Let's create a deployment script:\n\n1. Create a new folder called`ignition/modules`. Add a new file named `StorageModule.js` with the following logic:\n\n    ```javascript title=\"StorageModule.js\"\n    const { buildModule } = require('@nomicfoundation/hardhat-ignition/modules');\n\n    module.exports = buildModule('StorageModule', (m) => {\n      const storage = m.contract('Storage');\n\n      return { storage };\n    });\n    ```\n\n2. Deploy to the local network:\n\n    1. First, start a local node:\n\n        ```bash\n        npx hardhat node\n        ```\n\n    2. Then, in a new terminal window, deploy the contract:\n\n        ```bash\n        npx hardhat ignition deploy ./ignition/modules/StorageModule.js --network localNode\n        ```\n\n    3. If successful, output similar to the following will display in your terminal:\n\n        <div id=\"termynal\" data-termynal>\n          <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat ignition deploy ./ignition/modules/Storage.js --network localNode</span>\n          <span data-ty>✔ Confirm deploy to network localNode (420420422)? … yes</span>\n          <span data-ty></span>\n          <span data-ty>Hardhat Ignition 🚀</span>\n          <span data-ty></span>\n          <span data-ty>Deploying [ StorageModule ]</span>\n          <span data-ty></span>\n          <span data-ty>Batch #1</span>\n          <span data-ty> Executed StorageModule#Storage</span>\n          <span data-ty></span>\n          <span data-ty>[ StorageModule ] successfully deployed 🚀</span>\n          <span data-ty></span>\n          <span data-ty>Deployed Addresses</span>\n          <span data-ty></span>\n          <span data-ty>StorageModule#Storage - 0xc01Ee7f10EA4aF4673cFff62710E1D7792aBa8f3</span>\n        </div>\n\n3. Deploy to the Polkadot Hub TestNet:\n\n    1. Make sure your account has enough PAS tokens for gas fees, then run:\n\n        ```bash\n        npx hardhat ignition deploy ./ignition/modules/StorageModule.js --network passetHub\n        ```\n\n    2. After deployment, you'll see the contract address in the console output. Save this address for future interactions.\n\n        <div id=\"termynal\" data-termynal>\n          <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat ignition deploy ./ignition/modules/Storage.js --network passetHub</span>\n          <span data-ty>✔ Confirm deploy to network localNode (420420422)? … yes</span>\n          <span data-ty></span>\n          <span data-ty>Hardhat Ignition 🚀</span>\n          <span data-ty></span>\n          <span data-ty>Deploying [ StorageModule ]</span>\n          <span data-ty></span>\n          <span data-ty>Batch #1</span>\n          <span data-ty> Executed StorageModule#Storage</span>\n          <span data-ty></span>\n          <span data-ty>[ StorageModule ] successfully deployed 🚀</span>\n          <span data-ty></span>\n          <span data-ty>Deployed Addresses</span>\n          <span data-ty></span>\n          <span data-ty>StorageModule#Storage - 0xE8693cE64b294E26765573398C7Ca5C700E9C85c</span>\n        </div>"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 6, "depth": 2, "title": "Interacting with Your Deployed Contract", "anchor": "interacting-with-your-deployed-contract", "start_char": 15589, "end_char": 17543, "estimated_token_count": 460, "token_estimator": "heuristic-v1", "text": "## Interacting with Your Deployed Contract\n\nTo interact with your deployed contract:\n\n1. Create a new folder named `scripts` and add the `interact.js` with the following content:\n\n    ```javascript title=\"interact.js\"\n    const hre = require('hardhat');\n\n    async function main() {\n      // Replace with your deployed contract address\n      const contractAddress = 'INSERT_DEPLOYED_CONTRACT_ADDRESS';\n\n      // Get the contract instance\n      const Storage = await hre.ethers.getContractFactory('Storage');\n      const storage = await Storage.attach(contractAddress);\n\n      // Get current value\n      const currentValue = await storage.retrieve();\n      console.log('Current stored value:', currentValue.toString());\n\n      // Store a new value\n      const newValue = 42;\n      console.log(`Storing new value: ${newValue}...`);\n      const tx = await storage.store(newValue);\n\n      // Wait for transaction to be mined\n      await tx.wait();\n      console.log('Transaction confirmed');\n\n      // Get updated value\n      const updatedValue = await storage.retrieve();\n      console.log('Updated stored value:', updatedValue.toString());\n    }\n\n    main()\n      .then(() => process.exit(0))\n      .catch((error) => {\n        console.error(error);\n        process.exit(1);\n      });\n    ```\n\n    Ensure that `INSERT_DEPLOYED_CONTRACT_ADDRESS` is replaced with the value obtained in the previous step.\n\n2. Run the interaction script:\n\n    ```bash\n    npx hardhat run scripts/interact.js --network passetHub\n    ```\n\n3. If successful, the terminal will show the following output:\n\n    <div id=\"termynal\" data-termynal>\n      <span data-ty=\"input\"><span class=\"file-path\"></span>npx hardhat run scripts/interact.js --network passetHub</span>\n      <span data-ty>Current stored value: 0</span>\n      <span data-ty>Storing new value: 42...</span>\n      <span data-ty>Transaction confirmed</span>\n      <span data-ty>Updated stored value: 42</span>\n    </div>"}
{"page_id": "tutorials-smart-contracts-launch-your-first-project-test-and-deploy-with-hardhat", "page_title": "Test and Deploy with Hardhat", "index": 7, "depth": 2, "title": "Conclusion", "anchor": "conclusion", "start_char": 17543, "end_char": 18148, "estimated_token_count": 122, "token_estimator": "heuristic-v1", "text": "## Conclusion\n\nCongratulations! You've successfully set up a Hardhat development environment, written comprehensive tests for your Storage contract, and deployed it to local and Polkadot Hub TestNet networks. This tutorial covered essential steps in smart contract development, including configuration, testing, deployment, and interaction.\n\nTo get started with a working example right away, you can clone the repository and navigate to the project directory:\n\n```bash\ngit clone https://github.com/polkadot-developers/polkavm-hardhat-examples.git -b v0.0.8\ncd polkavm-hardhat-examples/storage-hardhat\n```"}
